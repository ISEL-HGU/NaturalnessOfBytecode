Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" ) , Flowable . concat ( Flowable . just ( "one" ) , Flowable . < String > error ( new TestException ( ) ) ) ) . toFlowable ( ) ; verifyError ( flowable ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . concat ( Flowable . just ( "one" ) , Flowable . < String > error ( new TestException ( ) ) ) , Flowable . concat ( Flowable . just ( "one" ) , Flowable . < String > error ( new TestException ( ) ) ) ) . toFlowable ( ) ; verifyError ( flowable ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . < String > empty ( ) , Flowable . just ( "one" , "two" , "three" ) ) . toFlowable ( ) ; verifyResult ( flowable , false ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" ) , Flowable . < String > empty ( ) ) . toFlowable ( ) ; verifyResult ( flowable , false ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . < String > empty ( ) , Flowable . < String > empty ( ) ) . toFlowable ( ) ; verifyResult ( flowable , true ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . just ( "one" ) , Flowable . just ( "one" ) , new BiPredicate < String , String > ( ) @ Override public boolean test ( String t1 , String t2 ) throw new TestException ( ) ; ) . toFlowable ( ) ; verifyError ( flowable ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" ) , Flowable . just ( "one" , "two" , "three" ) ) ; verifyResult ( single , true ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" ) , Flowable . just ( "one" , "two" , "three" , "four" ) ) ; verifyResult ( single , false ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" , "four" ) , Flowable . just ( "one" , "two" , "three" ) ) ; verifyResult ( single , false ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . concat ( Flowable . just ( "one" ) , Flowable . < String > error ( new TestException ( ) ) ) , Flowable . just ( "one" , "two" , "three" ) ) ; verifyError ( single ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" ) , Flowable . concat ( Flowable . just ( "one" ) , Flowable . < String > error ( new TestException ( ) ) ) ) ; verifyError ( single ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . concat ( Flowable . just ( "one" ) , Flowable . < String > error ( new TestException ( ) ) ) , Flowable . concat ( Flowable . just ( "one" ) , Flowable . < String > error ( new TestException ( ) ) ) ) ; verifyError ( single ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . < String > empty ( ) , Flowable . just ( "one" , "two" , "three" ) ) ; verifyResult ( single , false ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" ) , Flowable . < String > empty ( ) ) ; verifyResult ( single , false ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . < String > empty ( ) , Flowable . < String > empty ( ) ) ; verifyResult ( single , true ) ; 
Single < Boolean > single = Flowable . sequenceEqual ( Flowable . just ( "one" ) , Flowable . just ( "one" ) , new BiPredicate < String , String > ( ) @ Override public boolean test ( String t1 , String t2 ) throw new TestException ( ) ; ) ; verifyError ( single ) ; 
Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( isA ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable . sequenceEqual ( Flowable . range ( 1 , 20 ) , Flowable . range ( 1 , 20 ) , 2 ) . test ( ) . assertResult ( true ) ; 
TestHelper . checkDisposed ( Flowable . sequenceEqual ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) ) ; 
Flowable . sequenceEqual ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( false ) ; 
Flowable . sequenceEqual ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) . toFlowable ( ) . test ( ) . assertResult ( false ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestObserver < Boolean > to = Flowable . sequenceEqual ( Flowable . never ( ) , pp ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Boolean > ts = Flowable . sequenceEqual ( Flowable . never ( ) , pp ) . toFlowable ( ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertEmpty ( ) ; 
TestHelper . checkDisposed ( Flowable . sequenceEqual ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) . toFlowable ( ) ) ; 
Flowable . sequenceEqual ( Flowable . range ( 1 , 20 ) , Flowable . range ( 1 , 20 ) , 2 ) . toFlowable ( ) . test ( ) . assertResult ( true ) ; 
Flowable < Integer > source = Flowable . range ( 1 , Flowable . bufferSize ( ) * 4 ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable . sequenceEqual ( source , source ) . toFlowable ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( true ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 10 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) ; Flowable . sequenceEqual ( source , Flowable . range ( 1 , 10 ) . hide ( ) ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; Flowable . sequenceEqual ( Flowable . range ( 1 , 10 ) . hide ( ) , source ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable < Object > neverNever = new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Boolean > ts = new TestSubscriber < > ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; boolean swap = ( i & 1 ) == 0 ; Flowable . sequenceEqual ( swap ? pp : neverNever , swap ? neverNever : pp ) . toFlowable ( ) . subscribe ( ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertEmpty ( ) ; 
Flowable . sequenceEqual ( Flowable . never ( ) , new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; , 8 ) . toFlowable ( ) . test ( ) . assertFailure ( MissingBackpressureException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . sequenceEqual ( Flowable . never ( ) , new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "First" ) ) ; s . onError ( new TestException ( "Second" ) ) ; , 8 ) . toFlowable ( ) . to ( TestHelper . < Boolean > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < Integer > source = Flowable . range ( 1 , Flowable . bufferSize ( ) * 4 ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable . sequenceEqual ( source , source ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( true ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 10 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) ; Flowable . sequenceEqual ( source , Flowable . range ( 1 , 10 ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; Flowable . sequenceEqual ( Flowable . range ( 1 , 10 ) . hide ( ) , source ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable < Object > neverNever = new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestObserver < Boolean > to = new TestObserver < > ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; boolean swap = ( i & 1 ) == 0 ; Flowable . sequenceEqual ( swap ? pp : neverNever , swap ? neverNever : pp ) . subscribe ( to ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
Flowable . sequenceEqual ( Flowable . never ( ) , new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; , 8 ) . test ( ) . assertFailure ( MissingBackpressureException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . sequenceEqual ( Flowable . never ( ) , new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "First" ) ) ; s . onError ( new TestException ( "Second" ) ) ; , 8 ) . to ( TestHelper . < Boolean > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Single < Boolean > > ( ) @ Override public Single < Boolean > apply ( Flowable < Integer > upstream ) return Flowable . sequenceEqual ( Flowable . just ( 1 ) . hide ( ) , upstream ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Boolean > > ( ) @ Override public Flowable < Boolean > apply ( Flowable < Integer > upstream ) return Flowable . sequenceEqual ( Flowable . just ( 1 ) . hide ( ) , upstream ) . toFlowable ( ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Single < Boolean > > ( ) @ Override public Single < Boolean > apply ( Flowable < Integer > upstream ) return Flowable . sequenceEqual ( upstream , Flowable . just ( 1 ) . hide ( ) ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Boolean > > ( ) @ Override public Flowable < Boolean > apply ( Flowable < Integer > upstream ) return Flowable . sequenceEqual ( upstream , Flowable . just ( 1 ) . hide ( ) ) . toFlowable ( ) ; ) ; 
Flowable . sequenceEqual ( TestHelper . rejectFlowableFusion ( ) , Flowable . never ( ) ) . test ( ) . assertEmpty ( ) ; 
Flowable . sequenceEqual ( TestHelper . rejectFlowableFusion ( ) , Flowable . never ( ) ) . toFlowable ( ) . test ( ) . assertEmpty ( ) ; 
Flowable . sequenceEqual ( Flowable . fromCallable ( ( ) -> 1 ) , Flowable . just ( 1 ) ) . test ( ) . assertResult ( true ) ; 
int subCount = 3 ; final CountDownLatch upperLatch = new CountDownLatch ( subCount ) ; final CountDownLatch lowerLatch = new CountDownLatch ( subCount ) ; final CountDownLatch onNextLatch = new CountDownLatch ( subCount ) ; final AtomicInteger upperCount = new AtomicInteger ( ) ; final AtomicInteger lowerCount = new AtomicInteger ( ) ; Flowable < Long > longs = Flowable . interval ( 50 , TimeUnit . MILLISECONDS ) . doOnCancel ( new Action ( ) @ Override public void run ( ) upperLatch . countDown ( ) ; upperCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Long > ( ) @ Override public void accept ( Long aLong ) onNextLatch . countDown ( ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) lowerLatch . countDown ( ) ; lowerCount . incrementAndGet ( ) ; ) ; List < Disposable > subscriptions = new ArrayList < > ( ) ; List < TestSubscriber < Long > > subscribers = new ArrayList < > ( ) ; for ( int i = 0 ; i < subCount ; ++ i ) TestSubscriber < Long > subscriber = new TestSubscriber < > ( ) ; subscriptions . add ( Disposable . fromSubscription ( subscriber ) ) ; longs . subscribe ( subscriber ) ; subscribers . add ( subscriber ) ; onNextLatch . await ( ) ; for ( int i = 0 ; i < subCount ; ++ i ) subscriptions . get ( i ) . dispose ( ) ; upperLatch . await ( ) ; lowerLatch . await ( ) ; assertEquals ( String . format ( "There should exactly %d un-subscription events for upper stream" , subCount ) , subCount , upperCount . get ( ) ) ; assertEquals ( String . format ( "There should exactly %d un-subscription events for lower stream" , subCount ) , subCount , lowerCount . get ( ) ) ; 
int subCount = 3 ; final CountDownLatch upperLatch = new CountDownLatch ( 1 ) ; final CountDownLatch lowerLatch = new CountDownLatch ( 1 ) ; final CountDownLatch onNextLatch = new CountDownLatch ( subCount ) ; final AtomicInteger upperCount = new AtomicInteger ( ) ; final AtomicInteger lowerCount = new AtomicInteger ( ) ; Flowable < Long > longs = Flowable . interval ( 50 , TimeUnit . MILLISECONDS ) . doOnCancel ( new Action ( ) @ Override public void run ( ) upperLatch . countDown ( ) ; upperCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Long > ( ) @ Override public void accept ( Long aLong ) onNextLatch . countDown ( ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) lowerLatch . countDown ( ) ; lowerCount . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) ; List < Disposable > subscriptions = new ArrayList < > ( ) ; List < TestSubscriber < Long > > subscribers = new ArrayList < > ( ) ; for ( int i = 0 ; i < subCount ; ++ i ) TestSubscriber < Long > subscriber = new TestSubscriber < > ( ) ; longs . subscribe ( subscriber ) ; subscriptions . add ( Disposable . fromSubscription ( subscriber ) ) ; subscribers . add ( subscriber ) ; onNextLatch . await ( ) ; for ( int i = 0 ; i < subCount ; ++ i ) subscriptions . get ( i ) . dispose ( ) ; upperLatch . await ( ) ; lowerLatch . await ( ) ; assertEquals ( "There should exactly 1 un-subscription events for upper stream" , 1 , upperCount . get ( ) ) ; assertEquals ( "There should exactly 1 un-subscription events for lower stream" , 1 , lowerCount . get ( ) ) ; 
final AtomicInteger cancelCalled = new AtomicInteger ( ) ; final BehaviorProcessor < Integer > p = BehaviorProcessor . create ( ) ; p . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception cancelCalled . incrementAndGet ( ) ; p . onNext ( 2 ) ; ) . firstOrError ( ) . subscribe ( ) . dispose ( ) ; assertEquals ( 1 , cancelCalled . get ( ) ) ; 
int bufferSize = 3 ; final AtomicInteger droppedCount = new AtomicInteger ( 0 ) ; Action incrementOnDrop = new Action ( ) @ Override public void run ( ) throws Exception droppedCount . incrementAndGet ( ) ; ; TestSubscriber < Long > ts = createTestSubscriber ( ) ; Flowable . fromPublisher ( send500ValuesAndComplete . onBackpressureBuffer ( bufferSize , incrementOnDrop , DROP_OLDEST ) ) . subscribe ( ts ) ; ts . request ( 10 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( bufferSize , ts . values ( ) . size ( ) ) ; ts . assertNoErrors ( ) ; assertEquals ( 497 , ts . values ( ) . get ( 0 ) . intValue ( ) ) ; assertEquals ( 498 , ts . values ( ) . get ( 1 ) . intValue ( ) ) ; assertEquals ( 499 , ts . values ( ) . get ( 2 ) . intValue ( ) ) ; assertEquals ( droppedCount . get ( ) , 500 - bufferSize ) ; 
return new TestSubscriber < > ( new DefaultSubscriber < Long > ( ) @ Override protected void onStart ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long t ) , 0L ) ; 
int bufferSize = 3 ; final AtomicInteger droppedCount = new AtomicInteger ( 0 ) ; Action incrementOnDrop = new Action ( ) @ Override public void run ( ) throws Exception droppedCount . incrementAndGet ( ) ; ; TestSubscriber < Long > ts = createTestSubscriber ( ) ; Flowable . fromPublisher ( send500ValuesAndComplete . onBackpressureBuffer ( bufferSize , incrementOnDrop , DROP_LATEST ) ) . subscribe ( ts ) ; ts . request ( 10 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( bufferSize , ts . values ( ) . size ( ) ) ; ts . assertNoErrors ( ) ; assertEquals ( 0 , ts . values ( ) . get ( 0 ) . intValue ( ) ) ; assertEquals ( 1 , ts . values ( ) . get ( 1 ) . intValue ( ) ) ; assertEquals ( 499 , ts . values ( ) . get ( 2 ) . intValue ( ) ) ; assertEquals ( droppedCount . get ( ) , 500 - bufferSize ) ; 
Flowable . empty ( ) . onBackpressureBuffer ( - 1 , EMPTY_ACTION , DROP_OLDEST ) ; 
Flowable . empty ( ) . onBackpressureBuffer ( 0 , EMPTY_ACTION , DROP_OLDEST ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . onBackpressureBuffer ( 16 , Functions . EMPTY_ACTION , BackpressureOverflowStrategy . ERROR ) ) ; 
Flowable . error ( new TestException ( ) ) . onBackpressureBuffer ( 16 , Functions . EMPTY_ACTION , BackpressureOverflowStrategy . ERROR ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 20 ) . onBackpressureBuffer ( 8 , Functions . EMPTY_ACTION , BackpressureOverflowStrategy . ERROR ) . test ( 0L ) . assertFailure ( MissingBackpressureException . class ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . onBackpressureBuffer ( 8 , Functions . EMPTY_ACTION , BackpressureOverflowStrategy . ERROR ) ; , false , 1 , 1 , 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . onBackpressureBuffer ( 8 , Functions . EMPTY_ACTION , BackpressureOverflowStrategy . ERROR ) ; ) ; 
Flowable . range ( 1 , 20 ) . onBackpressureBuffer ( 8 , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; , BackpressureOverflowStrategy . DROP_OLDEST ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
TestHelper . assertBadRequestReported ( Flowable . just ( 1 ) . onBackpressureBuffer ( 16 , Functions . EMPTY_ACTION , BackpressureOverflowStrategy . ERROR ) ) ; 
Flowable . empty ( ) . onBackpressureBuffer ( 16 , Functions . EMPTY_ACTION , BackpressureOverflowStrategy . ERROR ) . test ( 0L ) . assertResult ( ) ; 
Flowable . just ( 1 ) . onBackpressureBuffer ( 16 , Functions . EMPTY_ACTION , BackpressureOverflowStrategy . ERROR ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 5 ) . onBackpressureBuffer ( 1 , null , BackpressureOverflowStrategy . DROP_OLDEST ) . test ( 0L ) . assertEmpty ( ) ; 
Flowable . range ( 1 , 5 ) . onBackpressureBuffer ( 10 , null , BackpressureOverflowStrategy . DROP_OLDEST ) . takeUntil ( v -> true ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 10 ) . assertResult ( 1 ) ; 
Flowable < String > w = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Flowable < List < String > > flowable = w . toList ( ) . toFlowable ( ) ; Subscriber < List < String > > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( "one" , "two" , "three" ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Flowable < List < String > > flowable = w . toList ( ) . toFlowable ( ) ; Subscriber < List < String > > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( "one" , "two" , "three" ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Flowable < List < String > > flowable = w . toList ( ) . toFlowable ( ) ; Subscriber < List < String > > subscriber1 = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber1 ) ; Subscriber < List < String > > subscriber2 = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber2 ) ; List < String > expected = Arrays . asList ( "one" , "two" , "three" ) ; verify ( subscriber1 , times ( 1 ) ) . onNext ( expected ) ; verify ( subscriber1 , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber2 , times ( 1 ) ) . onNext ( expected ) ; verify ( subscriber2 , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > f = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; List < String > actual = f . toList ( ) . toFlowable ( ) . blockingFirst ( ) ; Assert . assertEquals ( Arrays . asList ( "one" , "two" , "three" ) , actual ) ; 
Flowable < List < Integer > > w = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . toList ( ) . toFlowable ( ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( 0L ) ; w . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . assertValue ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; ts . request ( 1 ) ; ts . assertValue ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . range ( 1 , 10 ) . toList ( 4 ) . toFlowable ( ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) ; 
Flowable < String > w = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Single < List < String > > single = w . toList ( ) ; SingleObserver < List < String > > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( Arrays . asList ( "one" , "two" , "three" ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > w = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Single < List < String > > single = w . toList ( ) ; SingleObserver < List < String > > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( Arrays . asList ( "one" , "two" , "three" ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > w = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Single < List < String > > single = w . toList ( ) ; SingleObserver < List < String > > o1 = TestHelper . mockSingleObserver ( ) ; single . subscribe ( o1 ) ; SingleObserver < List < String > > o2 = TestHelper . mockSingleObserver ( ) ; single . subscribe ( o2 ) ; List < String > expected = Arrays . asList ( "one" , "two" , "three" ) ; verify ( o1 , times ( 1 ) ) . onSuccess ( expected ) ; verify ( o1 , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o2 , times ( 1 ) ) . onSuccess ( expected ) ; verify ( o2 , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > f = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; List < String > actual = f . toList ( ) . blockingGet ( ) ; Assert . assertEquals ( Arrays . asList ( "one" , "two" , "three" ) , actual ) ; 
try cb . await ( ) ; catch ( InterruptedException ex ) ex . printStackTrace ( ) ; catch ( BrokenBarrierException ex ) ex . printStackTrace ( ) ; 
Flowable . range ( 1 , 10 ) . toList ( 4 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . toList ( ) . toFlowable ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . toList ( ) ) ; 
Flowable . error ( new TestException ( ) ) . toList ( ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . toList ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception return null ; ) . toFlowable ( ) . to ( TestHelper . < Collection < Integer > > testConsumer ( ) ) . assertFailure ( NullPointerException . class ) . assertErrorMessage ( ExceptionHelper . nullWarning ( "The collectionSupplier returned a null Collection." ) ) ; 
Flowable . just ( 1 ) . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception return null ; ) . to ( TestHelper . < Collection < Integer > > testConsumer ( ) ) . assertFailure ( NullPointerException . class ) . assertErrorMessage ( ExceptionHelper . nullWarning ( "The collectionSupplier returned a null Collection." ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestObserver < List < Integer > > to = pp . toList ( ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < List < Integer > > ts = pp . toList ( ) . toFlowable ( ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < List < Integer > > ts = pp . toList ( ) . toFlowable ( ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . values ( ) . size ( ) != 0 ) ts . assertValue ( Arrays . asList ( 1 ) ) . assertNoErrors ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < List < Object > > > ( ) @ Override public Flowable < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . toList ( ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Object > , Single < List < Object > > > ( ) @ Override public Single < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . toList ( ) ; ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Timed < Integer > > m = source . timestamp ( scheduler ) ; m . subscribe ( subscriber ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 1 , 0 , TimeUnit . MILLISECONDS ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 2 , 100 , TimeUnit . MILLISECONDS ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 3 , 200 , TimeUnit . MILLISECONDS ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Timed < Integer > > m = source . timestamp ( scheduler ) ; m . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 1 , 0 , TimeUnit . MILLISECONDS ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 2 , 0 , TimeUnit . MILLISECONDS ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 3 , 200 , TimeUnit . MILLISECONDS ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler v ) throws Exception return scheduler ; ) ; try Flowable . range ( 1 , 5 ) . timestamp ( ) . map ( new Function < Timed < Integer > , Long > ( ) @ Override public Long apply ( Timed < Integer > v ) throws Exception return v . time ( ) ; ) . test ( ) . assertResult ( 0L , 0L , 0L , 0L , 0L ) ; finally RxJavaPlugins . reset ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler v ) throws Exception return scheduler ; ) ; try Flowable . range ( 1 , 5 ) . timestamp ( TimeUnit . SECONDS ) . map ( new Function < Timed < Integer > , Long > ( ) @ Override public Long apply ( Timed < Integer > v ) throws Exception return v . time ( ) ; ) . test ( ) . assertResult ( 0L , 0L , 0L , 0L , 0L ) ; finally RxJavaPlugins . reset ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . skip ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onNext ( 4 ) ; inOrder . verify ( subscriber ) . onNext ( 5 ) ; inOrder . verify ( subscriber ) . onNext ( 6 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . skip ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . skip ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . skip ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; source . onError ( new TestException ( ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onNext ( 4 ) ; inOrder . verify ( subscriber ) . onNext ( 5 ) ; inOrder . verify ( subscriber ) . onNext ( 6 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable . just ( 1 ) . skip ( 1 , TimeUnit . MINUTES ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
Flowable . just ( 1 ) . doAfterNext ( afterNext ) . subscribeWith ( ts ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Flowable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . subscribeWith ( ts ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 ) , values ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . doAfterNext ( afterNext ) . subscribeWith ( ts ) . assertFailure ( TestException . class ) ; assertTrue ( values . isEmpty ( ) ) ; 
Flowable . < Integer > empty ( ) . doAfterNext ( afterNext ) . subscribeWith ( ts ) . assertResult ( ) ; assertTrue ( values . isEmpty ( ) ) ; 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . subscribe ( ts0 ) ; ts0 . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . subscribe ( ts0 ) ; ts0 . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . doAfterNext ( afterNext ) . subscribe ( ts0 ) ; ts0 . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
Flowable . just ( 1 ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( ts ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Flowable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( ts ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 ) , values ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( ts ) . assertFailure ( TestException . class ) ; assertTrue ( values . isEmpty ( ) ) ; 
Flowable . < Integer > empty ( ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( ts ) . assertResult ( ) ; assertTrue ( values . isEmpty ( ) ) ; 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts0 ) ; ts0 . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts0 ) ; ts0 . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts0 ) ; ts0 . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
Flowable . just ( 1 , 2 ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Flowable . just ( 1 , 2 ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Flowable . just ( 1 , 2 ) . hide ( ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; singleObserver = TestHelper . mockSingleObserver ( ) ; 
Flowable < Integer > result = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sum ) . toFlowable ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 + 2 + 3 + 4 + 5 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > result = Flowable . concat ( Flowable . just ( 1 , 2 , 3 , 4 , 5 ) , Flowable . < Integer > error ( new TestException ( ) ) ) . reduce ( 0 , sum ) . toFlowable ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
BiFunction < Integer , Integer , Integer > sumErr = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throw new TestException ( ) ; ; Flowable < Integer > result = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sumErr ) . toFlowable ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Function < Integer , Integer > error = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new TestException ( ) ; ; Flowable < Integer > result = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sum ) . toFlowable ( ) . map ( error ) ; result . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Flowable < Integer > reduced = source . reduce ( 0 , sum ) . toFlowable ( ) ; Integer r = reduced . blockingFirst ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Single < Integer > result = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sum ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( singleObserver ) ; verify ( singleObserver ) . onSuccess ( 1 + 2 + 3 + 4 + 5 ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Single < Integer > result = Flowable . concat ( Flowable . just ( 1 , 2 , 3 , 4 , 5 ) , Flowable . < Integer > error ( new TestException ( ) ) ) . reduce ( 0 , sum ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( any ( ) ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
BiFunction < Integer , Integer , Integer > sumErr = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throw new TestException ( ) ; ; Single < Integer > result = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sumErr ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( any ( ) ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Function < Integer , Integer > error = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new TestException ( ) ; ; Single < Integer > result = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sum ) . map ( error ) ; result . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( any ( ) ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Maybe < Integer > reduced = source . reduce ( sum ) ; Integer r = reduced . blockingGet ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Single < Integer > reduced = source . reduce ( 0 , sum ) ; Integer r = reduced . blockingGet ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . < Integer > fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( "Source" ) ) ; s . onComplete ( ) ; ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception throw new TestException ( "Reducer" ) ; ) . toFlowable ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Reducer" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Source" ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriber < Integer > ts = Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . toFlowable ( ) . test ( ) ; ts . assertEmpty ( ) ; ts . cancel ( ) ; ts . assertEmpty ( ) ; 
Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Flowable < Integer > reduced = source . reduce ( sum ) . toFlowable ( ) ; Integer r = reduced . blockingFirst ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; assertSame ( source , ( ( ( HasUpstreamPublisher < ? > ) source . reduce ( sum ) ) ) . source ( ) ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 2 ) . reduce ( sum ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToMaybe ( new Function < Flowable < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Flowable < Integer > f ) throws Exception return f . reduce ( sum ) ; ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . reduce ( sum ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . reduce ( sum ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . < Integer > empty ( ) . reduce ( sum ) . test ( ) . assertResult ( ) ; 
Flowable . < Integer > empty ( ) . reduce ( sum ) . toFlowable ( ) . test ( ) . assertResult ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . reduce ( sum ) ; , false , 1 , 1 , 1 ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . reduce ( sum ) . toFlowable ( ) ; , false , 1 , 1 , 1 ) ; 
Flowable . just ( 1 , 2 ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable . range ( 0 , 10 ) . flatMap ( new Function < Integer , Publisher < String > > ( ) @ Override public Publisher < String > apply ( final Integer x ) throws Exception return Flowable . range ( 0 , 2 ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer y ) throws Exception return blockingOp ( x , y ) ; ) . subscribeOn ( Schedulers . io ( ) ) . reduce ( new BiFunction < String , String , String > ( ) @ Override public String apply ( String l , String r ) throws Exception return l + "_" + r ; ) . doOnSuccess ( new Consumer < String > ( ) @ Override public void accept ( String s ) throws Exception count . incrementAndGet ( ) ; System . out . println ( "Completed with " + s ) ; ) . toFlowable ( ) ; ) . blockingLast ( ) ; assertEquals ( 10 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable . range ( 0 , 10 ) . flatMap ( new Function < Integer , Publisher < String > > ( ) @ Override public Publisher < String > apply ( final Integer x ) throws Exception return Flowable . range ( 0 , 2 ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer y ) throws Exception return blockingOp ( x , y ) ; ) . subscribeOn ( Schedulers . io ( ) ) . reduce ( new BiFunction < String , String , String > ( ) @ Override public String apply ( String l , String r ) throws Exception return l + "_" + r ; ) . toFlowable ( ) . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String s ) throws Exception count . incrementAndGet ( ) ; System . out . println ( "Completed with " + s ) ; ) ; ) . blockingLast ( ) ; assertEquals ( 10 , count . get ( ) ) ; 
try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return "x" + x + "y" + y ; 
TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Integer > , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Flowable < Integer > f ) throws Exception return f . reduce ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a ; ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . < Integer > create ( ) . reduce ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a ; ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . reduce ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a ; ) . test ( ) . assertResult ( 0 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . reduce ( ( a , b ) -> a ) . toFlowable ( ) ) ; 
w = TestHelper . mockSubscriber ( ) ; 
Flowable < String > src = Flowable . empty ( ) ; src . distinct ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > src = Flowable . empty ( ) ; src . distinct ( TO_UPPER_WITH_EXCEPTION ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" , "c" , "c" , "b" , "b" , "a" , "e" ) ; src . distinct ( ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "e" ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > src = Flowable . just ( "a" , "B" , "c" , "C" , "c" , "B" , "b" , "a" , "E" ) ; src . distinct ( TO_UPPER_WITH_EXCEPTION ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "B" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "E" ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable . error ( new TestException ( ) ) . distinct ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . just ( 1 , 1 , 2 , 1 , 3 , 2 , 4 , 5 , 4 ) . distinct ( ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . distinct ( ) . subscribe ( ts ) ; TestHelper . emit ( up , 1 , 1 , 2 , 1 , 3 , 2 , 4 , 5 , 4 ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . just ( 1 , 1 , 2 , 1 , 3 , 2 , 4 , 5 , 4 ) . distinct ( ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) QueueSubscription < ? > qs = ( QueueSubscription < ? > ) s ; assertFalse ( qs . isEmpty ( ) ) ; qs . clear ( ) ; assertTrue ( qs . isEmpty ( ) ) ; @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Flowable . just ( 1 ) . distinct ( Functions . identity ( ) , new Supplier < Collection < Object > > ( ) @ Override public Collection < Object > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . distinct ( Functions . identity ( ) , new Supplier < Collection < Object > > ( ) @ Override public Collection < Object > get ( ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( NullPointerException . class ) . assertErrorMessage ( ExceptionHelper . nullWarning ( "The collectionSupplier returned a null Collection." ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . distinct ( ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . just ( 1 ) . doOnLifecycle ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception throw new TestException ( ) ; , Functions . EMPTY_LONG_CONSUMER , Functions . EMPTY_ACTION ) . test ( ) . assertFailure ( TestException . class ) ; 
final int [ ] calls = 0 , 0 ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . doOnLifecycle ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception calls [ 0 ] ++ ; , Functions . EMPTY_LONG_CONSUMER , new Action ( ) @ Override public void run ( ) throws Exception calls [ 1 ] ++ ; ) ; ) ; assertEquals ( 2 , calls [ 0 ] ) ; assertEquals ( 0 , calls [ 1 ] ) ; 
final int [ ] calls = 0 , 0 ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . doOnLifecycle ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception calls [ 0 ] ++ ; , Functions . EMPTY_LONG_CONSUMER , new Action ( ) @ Override public void run ( ) throws Exception calls [ 1 ] ++ ; ) ) ; assertEquals ( 1 , calls [ 0 ] ) ; assertEquals ( 1 , calls [ 1 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . doOnLifecycle ( Functions . emptyConsumer ( ) , new LongConsumer ( ) @ Override public void accept ( long v ) throws Exception throw new TestException ( ) ; , Functions . EMPTY_ACTION ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . doOnLifecycle ( Functions . emptyConsumer ( ) , Functions . EMPTY_LONG_CONSUMER , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final BooleanSubscription bs = new BooleanSubscription ( ) ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( bs ) ; s . onError ( new TestException ( "Second" ) ) ; s . onComplete ( ) ; . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception throw new TestException ( "First" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( bs . isCancelled ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
concat2Strings = new BiFunction < String , String , String > ( ) @ Override public String apply ( String t1 , String t2 ) return t1 + "-" + t2 ; ; s1 = PublishProcessor . create ( ) ; s2 = PublishProcessor . create ( ) ; zipped = Flowable . zip ( s1 , s2 , concat2Strings ) ; subscriber = TestHelper . mockSubscriber ( ) ; inOrder = inOrder ( subscriber ) ; zipped . subscribe ( subscriber ) ; 
Function < Object [ ] , String > zipr = Functions . toFunction ( getConcatStringIntegerIntArrayZipr ( ) ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; @ SuppressWarnings ( "rawtypes" ) Collection ws = java . util . Collections . singleton ( Flowable . just ( "one" , "two" ) ) ; Flowable < String > w = Flowable . zip ( ws , zipr ) ; w . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; 
Subscriber < String > w = TestHelper . mockSubscriber ( ) ; TestFlowable w1 = new TestFlowable ( ) ; TestFlowable w2 = new TestFlowable ( ) ; TestFlowable w3 = new TestFlowable ( ) ; Flowable < String > zipW = Flowable . zip ( Flowable . unsafeCreate ( w1 ) , Flowable . unsafeCreate ( w2 ) , Flowable . unsafeCreate ( w3 ) , getConcat3StringsZipr ( ) ) ; zipW . subscribe ( w ) ; w1 . subscriber . onNext ( "1a" ) ; w1 . subscriber . onComplete ( ) ; w2 . subscriber . onNext ( "2a" ) ; w2 . subscriber . onNext ( "2b" ) ; w2 . subscriber . onComplete ( ) ; w3 . subscriber . onNext ( "3a" ) ; w3 . subscriber . onNext ( "3b" ) ; w3 . subscriber . onNext ( "3c" ) ; w3 . subscriber . onNext ( "3d" ) ; w3 . subscriber . onComplete ( ) ; InOrder io = inOrder ( w ) ; io . verify ( w ) . onNext ( "1a2a3a" ) ; io . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Subscriber < String > w = TestHelper . mockSubscriber ( ) ; TestFlowable w1 = new TestFlowable ( ) ; TestFlowable w2 = new TestFlowable ( ) ; TestFlowable w3 = new TestFlowable ( ) ; Flowable < String > zipW = Flowable . zip ( Flowable . unsafeCreate ( w1 ) , Flowable . unsafeCreate ( w2 ) , Flowable . unsafeCreate ( w3 ) , getConcat3StringsZipr ( ) ) ; zipW . subscribe ( w ) ; w1 . subscriber . onNext ( "1a" ) ; w1 . subscriber . onNext ( "1b" ) ; w1 . subscriber . onNext ( "1c" ) ; w1 . subscriber . onNext ( "1d" ) ; w1 . subscriber . onComplete ( ) ; w2 . subscriber . onNext ( "2a" ) ; w2 . subscriber . onNext ( "2b" ) ; w2 . subscriber . onComplete ( ) ; w3 . subscriber . onNext ( "3a" ) ; w3 . subscriber . onComplete ( ) ; InOrder io = inOrder ( w ) ; io . verify ( w ) . onNext ( "1a2a3a" ) ; io . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
return "" + t1 + t2 ; 
return "" + t1 + t2 + t3 ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; PublishProcessor < String > r2 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . zip ( r1 , r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "world" ) ; InOrder inOrder = inOrder ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "helloworld" ) ; r1 . onNext ( "hello " ) ; r2 . onNext ( "again" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "hello again" ) ; r1 . onComplete ( ) ; r2 . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; PublishProcessor < String > r2 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . zip ( r1 , r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "world" ) ; r2 . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "helloworld" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; r1 . onNext ( "hi" ) ; r1 . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > r2 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . zip ( r1 , r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( 1 ) ; r2 . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "hello1" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; r1 . onNext ( "hi" ) ; r1 . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > r2 = PublishProcessor . create ( ) ; PublishProcessor < List < Integer > > r3 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . zip ( r1 , r2 , r3 , zipr3 ) . subscribe ( subscriber ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( 2 ) ; r3 . onNext ( Arrays . asList ( 5 , 6 , 7 ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "hello2[5, 6, 7]" ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; PublishProcessor < String > r2 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . zip ( r1 , r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one" ) ; r1 . onNext ( "two" ) ; r1 . onNext ( "three" ) ; r2 . onNext ( "A" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "oneA" ) ; r1 . onNext ( "four" ) ; r1 . onComplete ( ) ; r2 . onNext ( "B" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "twoB" ) ; r2 . onNext ( "C" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "threeC" ) ; r2 . onNext ( "D" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "fourD" ) ; r2 . onNext ( "E" ) ; verify ( subscriber , never ( ) ) . onNext ( "E" ) ; r2 . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; PublishProcessor < String > r2 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . zip ( r1 , r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "world" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "helloworld" ) ; r1 . onError ( new RuntimeException ( "" ) ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "again" ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 0 ) ) . onNext ( "helloagain" ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; PublishProcessor < String > r2 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; Flowable . zip ( r1 , r2 , zipr2 ) . subscribe ( ts ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "world" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "helloworld" ) ; ts . cancel ( ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "again" ) ; verify ( subscriber , times ( 0 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 0 ) ) . onNext ( "helloagain" ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; PublishProcessor < String > r2 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . zip ( r1 , r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one" ) ; r1 . onNext ( "two" ) ; r1 . onComplete ( ) ; r2 . onNext ( "A" ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "oneA" ) ; r2 . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; 
BiFunction < String , Integer , String > zipr = getConcatStringIntegerZipr ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > w = Flowable . zip ( Flowable . just ( "one" , "two" ) , Flowable . just ( 2 , 3 , 4 ) , zipr ) ; w . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one2" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two3" ) ; verify ( subscriber , never ( ) ) . onNext ( "4" ) ; 
Function3 < String , Integer , int [ ] , String > zipr = getConcatStringIntegerIntArrayZipr ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > w = Flowable . zip ( Flowable . just ( "one" , "two" ) , Flowable . just ( 2 ) , Flowable . just ( new int [ ] 4 , 5 , 6 ) , zipr ) ; w . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one2[4, 5, 6]" ) ; verify ( subscriber , never ( ) ) . onNext ( "two" ) ; 
BiFunction < Integer , Integer , Integer > zipr = getDivideZipr ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < Integer > w = Flowable . zip ( Flowable . just ( 10 , 20 , 30 ) , Flowable . just ( 0 , 1 , 2 ) , zipr ) ; w . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < String > oA = PublishProcessor . create ( ) ; PublishProcessor < String > oB = PublishProcessor . create ( ) ; Subscriber < String > obs = TestHelper . mockSubscriber ( ) ; Flowable < String > f = Flowable . zip ( oA , oB , getConcat2Strings ( ) ) ; f . subscribe ( obs ) ; InOrder io = inOrder ( obs ) ; oA . onNext ( "a1" ) ; io . verify ( obs , never ( ) ) . onNext ( anyString ( ) ) ; oB . onNext ( "b1" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a1-b1" ) ; oB . onNext ( "b2" ) ; io . verify ( obs , never ( ) ) . onNext ( anyString ( ) ) ; oA . onNext ( "a2" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a2-b2" ) ; oA . onNext ( "a3" ) ; oA . onNext ( "a4" ) ; oA . onNext ( "a5" ) ; oA . onComplete ( ) ; oB . onNext ( "b3" ) ; oB . onNext ( "b4" ) ; oB . onNext ( "b5" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a3-b3" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a4-b4" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a5-b5" ) ; io . verify ( obs , times ( 1 ) ) . onComplete ( ) ; oB . onNext ( "b6" ) ; oB . onNext ( "b7" ) ; oB . onNext ( "b8" ) ; oB . onNext ( "b9" ) ; io . verifyNoMoreInteractions ( ) ; 
PublishProcessor < String > oA = PublishProcessor . create ( ) ; PublishProcessor < String > oB = PublishProcessor . create ( ) ; Subscriber < String > obs = TestHelper . mockSubscriber ( ) ; Flowable < String > f = Flowable . zip ( oA , oB , getConcat2Strings ( ) ) ; f . subscribe ( obs ) ; InOrder io = inOrder ( obs ) ; oA . onNext ( "a1" ) ; io . verify ( obs , never ( ) ) . onNext ( anyString ( ) ) ; oB . onNext ( "b1" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a1-b1" ) ; oB . onNext ( "b2" ) ; io . verify ( obs , never ( ) ) . onNext ( anyString ( ) ) ; oA . onNext ( "a2" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a2-b2" ) ; oA . onNext ( "a3" ) ; oA . onNext ( "a4" ) ; oA . onNext ( "a5" ) ; oA . onError ( new RuntimeException ( "forced failure" ) ) ; io . verify ( obs , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; oB . onNext ( "b3" ) ; oB . onNext ( "b4" ) ; oB . onNext ( "b5" ) ; oB . onNext ( "b6" ) ; oB . onNext ( "b7" ) ; oB . onNext ( "b8" ) ; oB . onNext ( "b9" ) ; io . verifyNoMoreInteractions ( ) ; 
return new BiFunction < String , String , String > ( ) @ Override public String apply ( String t1 , String t2 ) return t1 + "-" + t2 ; ; 
BiFunction < Integer , Integer , Integer > zipr = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 / i2 ; ; return zipr ; 
Function3 < String , String , String , String > zipr = new Function3 < String , String , String , String > ( ) @ Override public String apply ( String a1 , String a2 , String a3 ) if ( a1 == null ) a1 = "" ; if ( a2 == null ) a2 = "" ; if ( a3 == null ) a3 = "" ; return a1 + a2 + a3 ; ; return zipr ; 
BiFunction < String , Integer , String > zipr = new BiFunction < String , Integer , String > ( ) @ Override public String apply ( String s , Integer i ) return getStringValue ( s ) + getStringValue ( i ) ; ; return zipr ; 
Function3 < String , Integer , int [ ] , String > zipr = new Function3 < String , Integer , int [ ] , String > ( ) @ Override public String apply ( String s , Integer i , int [ ] iArray ) return getStringValue ( s ) + getStringValue ( i ) + getStringValue ( iArray ) ; ; return zipr ; 
if ( o == null ) return "" ; else if ( o instanceof int [ ] ) return Arrays . toString ( ( int [ ] ) o ) ; else return String . valueOf ( o ) ; 
this . subscriber = subscriber ; subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s1 . onComplete ( ) ; s2 . onNext ( "1" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a-1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b-2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; s1 . onNext ( "a" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a-1" ) ; s1 . onNext ( "b" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b-2" ) ; s1 . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; s2 . onComplete ( ) ; s1 . onNext ( "a" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a-1" ) ; s1 . onNext ( "b" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b-2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s2 . onNext ( "1" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a-1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b-2" ) ; s2 . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "a" ) ; s1 . onError ( new RuntimeException ( "Forced failure" ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; s2 . onNext ( "b" ) ; s1 . onNext ( "1" ) ; s1 . onNext ( "2" ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s2 . onError ( new RuntimeException ( "Forced failure" ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 1 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return a + b ; ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) subscriber . onComplete ( ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onNext ( Integer args ) subscriber . onNext ( args ) ; ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < String > os = OBSERVABLE_OF_5_INTEGERS . zipWith ( OBSERVABLE_OF_5_INTEGERS , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer a , Integer b ) return a + "-" + b ; ) ; final ArrayList < String > list = new ArrayList < > ( ) ; os . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) System . out . println ( s ) ; list . add ( s ) ; ) ; assertEquals ( 5 , list . size ( ) ) ; assertEquals ( "1-1" , list . get ( 0 ) ) ; assertEquals ( "2-2" , list . get ( 1 ) ) ; assertEquals ( "5-5" , list . get ( 4 ) ) ; 
Flowable < String > os = ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS ( new CountDownLatch ( 1 ) ) . onBackpressureBuffer ( ) . zipWith ( ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS ( new CountDownLatch ( 1 ) ) . onBackpressureBuffer ( ) , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer a , Integer b ) return a + "-" + b ; ) . take ( 5 ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; os . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 5 , ts . values ( ) . size ( ) ) ; assertEquals ( "1-1" , ts . values ( ) . get ( 0 ) ) ; assertEquals ( "2-2" , ts . values ( ) . get ( 1 ) ) ; assertEquals ( "5-5" , ts . values ( ) . get ( 4 ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final CountDownLatch infiniteFlowable = new CountDownLatch ( 1 ) ; Flowable < String > os = OBSERVABLE_OF_5_INTEGERS . zipWith ( ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS ( infiniteFlowable ) , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer a , Integer b ) return a + "-" + b ; ) ; final ArrayList < String > list = new ArrayList < > ( ) ; os . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String s ) System . out . println ( s ) ; list . add ( s ) ; ) ; latch . await ( 1000 , TimeUnit . MILLISECONDS ) ; if ( ! infiniteFlowable . await ( 2000 , TimeUnit . MILLISECONDS ) ) throw new RuntimeException ( "didn't unsubscribe" ) ; assertEquals ( 5 , list . size ( ) ) ; assertEquals ( "1-1" , list . get ( 0 ) ) ; assertEquals ( "2-2" , list . get ( 1 ) ) ; assertEquals ( "5-5" , list . get ( 4 ) ) ; 
if ( notification . isOnError ( ) ) return "OnError" ; if ( notification . isOnNext ( ) ) return "OnNext" ; return "OnComplete" ; 
if ( notification . isOnNext ( ) ) return String . valueOf ( notification . getValue ( ) ) ; return "null" ; 
Flowable < Notification < Integer > > oi = Flowable . just ( 1 , 2 , 3 ) . materialize ( ) ; Flowable < Notification < String > > os = Flowable . just ( "a" , "b" , "c" ) . materialize ( ) ; Flowable < String > f = Flowable . zip ( oi , os , new BiFunction < Notification < Integer > , Notification < String > , String > ( ) @ Override public String apply ( Notification < Integer > t1 , Notification < String > t2 ) return kind ( t1 ) + "_" + value ( t1 ) + "-" + kind ( t2 ) + "_" + value ( t2 ) ; ) ; final ArrayList < String > list = new ArrayList < > ( ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) System . out . println ( s ) ; list . add ( s ) ; ) ; assertEquals ( 4 , list . size ( ) ) ; assertEquals ( "OnNext_1-OnNext_a" , list . get ( 0 ) ) ; assertEquals ( "OnNext_2-OnNext_b" , list . get ( 1 ) ) ; assertEquals ( "OnNext_3-OnNext_c" , list . get ( 2 ) ) ; assertEquals ( "OnComplete_null-OnComplete_null" , list . get ( 3 ) ) ; 
Flowable < String > f = Flowable . zip ( Flowable . < Integer > empty ( ) , Flowable . < String > empty ( ) , new BiFunction < Integer , String , String > ( ) @ Override public String apply ( Integer t1 , String t2 ) return t1 + "-" + t2 ; ) ; final ArrayList < String > list = new ArrayList < > ( ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) System . out . println ( s ) ; list . add ( s ) ; ) ; assertEquals ( 0 , list . size ( ) ) ; 
final Object invoked = new Object ( ) ; Collection < Flowable < Object > > observables = Collections . emptyList ( ) ; Flowable < Object > f = Flowable . zip ( observables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( final Object [ ] args ) assertEquals ( "No argument should have been passed" , 0 , args . length ) ; return invoked ; ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; f . subscribe ( ts ) ; ts . awaitDone ( 200 , TimeUnit . MILLISECONDS ) ; ts . assertNoValues ( ) ; 
final Object invoked = new Object ( ) ; Collection < Flowable < Object > > observables = Collections . emptyList ( ) ; Flowable < Object > f = Flowable . zip ( observables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( final Object [ ] args ) assertEquals ( "No argument should have been passed" , 0 , args . length ) ; return invoked ; ) ; f . blockingLast ( ) ; 
AtomicInteger generatedA = new AtomicInteger ( ) ; AtomicInteger generatedB = new AtomicInteger ( ) ; Flowable < Integer > f1 = createInfiniteFlowable ( generatedA ) ; Flowable < Integer > f2 = createInfiniteFlowable ( generatedB ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . zip ( f1 , f2 , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer t1 , Integer t2 ) return t1 + "-" + t2 ; ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; assertTrue ( generatedA . get ( ) < ( Flowable . bufferSize ( ) * 3 ) ) ; assertTrue ( generatedB . get ( ) < ( Flowable . bufferSize ( ) * 3 ) ) ; 
AtomicInteger generatedA = new AtomicInteger ( ) ; AtomicInteger generatedB = new AtomicInteger ( ) ; Flowable < Integer > f1 = createInfiniteFlowable ( generatedA ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable < Integer > f2 = createInfiniteFlowable ( generatedB ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . zip ( f1 , f2 , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer t1 , Integer t2 ) return t1 + "-" + t2 ; ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; assertTrue ( generatedA . get ( ) < ( Flowable . bufferSize ( ) * 3 ) ) ; assertTrue ( generatedB . get ( ) < ( Flowable . bufferSize ( ) * 3 ) ) ; 
AtomicInteger generatedA = new AtomicInteger ( ) ; AtomicInteger generatedB = new AtomicInteger ( ) ; Flowable < Integer > f1 = createInfiniteFlowable ( generatedA ) . take ( Flowable . bufferSize ( ) * 2 ) ; Flowable < Integer > f2 = createInfiniteFlowable ( generatedB ) . take ( Flowable . bufferSize ( ) * 2 ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . zip ( f1 , f2 , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer t1 , Integer t2 ) return t1 + "-" + t2 ; ) . observeOn ( Schedulers . computation ( ) ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; System . out . println ( "Generated => A: " + generatedA . get ( ) + " B: " + generatedB . get ( ) ) ; assertTrue ( generatedA . get ( ) < ( Flowable . bufferSize ( ) * 3 ) ) ; assertTrue ( generatedB . get ( ) < ( Flowable . bufferSize ( ) * 3 ) ) ; 
AtomicInteger generatedA = new AtomicInteger ( ) ; AtomicInteger generatedB = new AtomicInteger ( ) ; Flowable < Integer > f1 = createInfiniteFlowable ( generatedA ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable < Integer > f2 = createInfiniteFlowable ( generatedB ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . zip ( f1 , f2 , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer t1 , Integer t2 ) return t1 + "-" + t2 ; ) . observeOn ( Schedulers . computation ( ) ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; System . out . println ( "Generated => A: " + generatedA . get ( ) + " B: " + generatedB . get ( ) ) ; assertTrue ( generatedA . get ( ) < ( Flowable . bufferSize ( ) * 4 ) ) ; assertTrue ( generatedB . get ( ) < ( Flowable . bufferSize ( ) * 4 ) ) ; 
AtomicInteger generatedA = new AtomicInteger ( ) ; AtomicInteger generatedB = new AtomicInteger ( ) ; Flowable < Integer > f1 = createInfiniteFlowable ( generatedA ) ; Flowable < Integer > f2 = createInfiniteFlowable ( generatedB ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . zip ( f1 , f2 , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer t1 , Integer t2 ) return t1 + "-" + t2 ; ) . observeOn ( Schedulers . computation ( ) ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; System . out . println ( "Generated => A: " + generatedA . get ( ) + " B: " + generatedB . get ( ) ) ; assertTrue ( generatedA . get ( ) < ( Flowable . bufferSize ( ) * 4 ) ) ; assertTrue ( generatedB . get ( ) < ( Flowable . bufferSize ( ) * 4 ) ) ; 
Flowable < Integer > flowable = Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) @ Override public Integer next ( ) return generated . getAndIncrement ( ) ; @ Override public boolean hasNext ( ) return true ; ; ) ; return flowable ; 
return Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) BooleanSubscription bs = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs ) ; for ( int i = 1 ; i <= 5 ; i ++ ) if ( bs . isCancelled ( ) ) break ; numEmitted . incrementAndGet ( ) ; subscriber . onNext ( i ) ; Thread . yield ( ) ; subscriber . onComplete ( ) ; ) ; 
BooleanSubscription bs = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs ) ; for ( int i = 1 ; i <= 5 ; i ++ ) if ( bs . isCancelled ( ) ) break ; numEmitted . incrementAndGet ( ) ; subscriber . onNext ( i ) ; Thread . yield ( ) ; subscriber . onComplete ( ) ; 
return Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) final BooleanSubscription bs = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) System . out . println ( "-------> subscribe to infinite sequence" ) ; System . out . println ( "Starting thread: " + Thread . currentThread ( ) ) ; int i = 1 ; while ( ! bs . isCancelled ( ) ) subscriber . onNext ( i ++ ) ; Thread . yield ( ) ; subscriber . onComplete ( ) ; latch . countDown ( ) ; System . out . println ( "Ending thread: " + Thread . currentThread ( ) ) ; ) ; t . start ( ) ; ) ; 
Flowable < Integer > zip1 = Flowable . zip ( Flowable . range ( 0 , 1026 ) , Flowable . range ( 0 , 1026 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 + i2 ; ) ; Flowable < Integer > zip2 = Flowable . zip ( zip1 , Flowable . range ( 0 , 1026 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 + i2 ; ) ; List < Integer > expected = new ArrayList < > ( ) ; for ( int i = 0 ; i < 1026 ; i ++ ) expected . add ( i * 3 ) ; assertEquals ( expected , zip2 . toList ( ) . blockingGet ( ) ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 2 ) . zipWith ( Flowable . range ( 1 , 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + 10 * t2 ; ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; request ( 5 ) ; ; source . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValues ( 11 , 22 ) ; 
long startTime = System . currentTimeMillis ( ) ; Flowable < Integer > src = Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; int i = 0 ; while ( System . currentTimeMillis ( ) - startTime < 9000 && i ++ < 100000 ) int value = Flowable . zip ( src , src , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 * 10 ; ) . blockingSingle ( 0 ) ; Assert . assertEquals ( 11 , value ) ; 
Flowable < Integer > src = Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 1L ) ; Flowable . zip ( src , src , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 * 10 ; ) . subscribe ( ts ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertValue ( 11 ) ; 
Flowable source = Flowable . just ( 1 ) ; for ( int i = 2 ; i < 10 ; i ++ ) Class < ? > [ ] types = new Class [ i + 1 ] ; Arrays . fill ( types , Publisher . class ) ; types [ i ] = i == 2 ? BiFunction . class : Class . forName ( "io.reactivex.rxjava3.functions.Function" + i ) ; Method m = Flowable . class . getMethod ( "zip" , types ) ; Object [ ] params = new Object [ i + 1 ] ; Arrays . fill ( params , source ) ; params [ i ] = ArgsToString . INSTANCE ; StringBuilder b = new StringBuilder ( ) ; for ( int j = 0 ; j < i ; j ++ ) b . append ( '1' ) ; ( ( Flowable ) m . invoke ( null , params ) ) . test ( ) . assertResult ( b . toString ( ) ) ; for ( int j = 0 ; j < params . length ; j ++ ) Object [ ] params0 = params . clone ( ) ; params0 [ j ] = null ; try m . invoke ( null , params0 ) ; fail ( "Should have thrown @ " + m ) ; catch ( InvocationTargetException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof NullPointerException ) ; if ( j < i ) assertEquals ( "source" + ( j + 1 ) + " is null" , ex . getCause ( ) . getMessage ( ) ) ; else assertEquals ( "zipper is null" , ex . getCause ( ) . getMessage ( ) ) ; 
return "" + t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 ; 
return "" + t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 ; 
return "" + t1 + t2 + t3 + t4 + t5 + t6 + t7 ; 
return "" + t1 + t2 + t3 + t4 + t5 + t6 ; 
return "" + t1 + t2 + t3 + t4 + t5 ; 
return "" + t1 + t2 + t3 + t4 ; 
return "" + t1 ; 
Flowable < Integer > error1 = Flowable . error ( new TestException ( "One" ) ) ; Flowable < Integer > source1 = Flowable . range ( 1 , 3 ) . concatWith ( error1 ) ; Flowable < Integer > error2 = Flowable . error ( new TestException ( "Two" ) ) ; Flowable < Integer > source2 = Flowable . range ( 1 , 2 ) . concatWith ( error2 ) ; TestSubscriberEx < Object > ts = Flowable . zip ( source1 , source2 , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return "" + a + b ; , true ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class , "11" , "22" ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "One" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Two" ) ; assertEquals ( 2 , errors . size ( ) ) ; 
Flowable < Integer > error1 = Flowable . error ( new TestException ( "One" ) ) ; Flowable < Integer > source1 = Flowable . range ( 1 , 3 ) . concatWith ( error1 ) ; Flowable < Integer > error2 = Flowable . error ( new TestException ( "Two" ) ) ; Flowable < Integer > source2 = Flowable . range ( 1 , 2 ) . concatWith ( error2 ) ; TestSubscriberEx < Object > ts = Flowable . zip ( source1 , source2 , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return "" + a + b ; , true , 1 ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class , "11" , "22" ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "One" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Two" ) ; assertEquals ( 2 , errors . size ( ) ) ; 
Flowable . zip ( Flowable . range ( 1 , 9 ) , Flowable . range ( 21 , 9 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return "" + a + b ; , false , 2 ) . takeLast ( 1 ) . test ( ) . assertResult ( "929" ) ; 
assertSame ( Flowable . empty ( ) , Flowable . zipArray ( Functions . < Object [ ] > identity ( ) , false , 16 ) ) ; 
Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return "" + a + b ; ) . test ( ) . assertResult ( "12" ) ; 
Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception return "" + a + b + c ; ) . test ( ) . assertResult ( "123" ) ; 
Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) , new Function4 < Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d ) throws Exception return "" + a + b + c + d ; ) . test ( ) . assertResult ( "1234" ) ; 
Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) , Flowable . just ( 5 ) , new Function5 < Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e ) throws Exception return "" + a + b + c + d + e ; ) . test ( ) . assertResult ( "12345" ) ; 
Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) , Flowable . just ( 5 ) , Flowable . just ( 6 ) , new Function6 < Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f ) throws Exception return "" + a + b + c + d + e + f ; ) . test ( ) . assertResult ( "123456" ) ; 
Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) , Flowable . just ( 5 ) , Flowable . just ( 6 ) , Flowable . just ( 7 ) , new Function7 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g ) throws Exception return "" + a + b + c + d + e + f + g ; ) . test ( ) . assertResult ( "1234567" ) ; 
Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) , Flowable . just ( 5 ) , Flowable . just ( 6 ) , Flowable . just ( 7 ) , Flowable . just ( 8 ) , new Function8 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g , Integer h ) throws Exception return "" + a + b + c + d + e + f + g + h ; ) . test ( ) . assertResult ( "12345678" ) ; 
Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) , Flowable . just ( 5 ) , Flowable . just ( 6 ) , Flowable . just ( 7 ) , Flowable . just ( 8 ) , Flowable . just ( 9 ) , new Function9 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g , Integer h , Integer i ) throws Exception return "" + a + b + c + d + e + f + g + h + i ; ) . test ( ) . assertResult ( "123456789" ) ; 
@ SuppressWarnings ( "unchecked" ) Flowable < Integer > [ ] arr = new Flowable [ 10 ] ; Arrays . fill ( arr , Flowable . just ( 1 ) ) ; Flowable . zip ( Arrays . asList ( arr ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertResult ( "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]" ) ; 
TestHelper . checkDisposed ( Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . zip ( Flowable . just ( 1 ) , Flowable . just ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try PublishProcessor < Object > pp = PublishProcessor . create ( ) ; @ SuppressWarnings ( "rawtypes" ) final Subscriber [ ] sub = null ; TestSubscriberEx < Object > ts = Flowable . zip ( pp , new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) sub [ 0 ] = s ; , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . to ( TestHelper . < Object > testConsumer ( ) ) ; pp . onError ( new TestException ( "First" ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" ) ; sub [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; TestSubscriberEx < Object > ts = Flowable . zip ( pp1 , pp2 , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; , true ) . to ( TestHelper . < Object > testConsumer ( ) ) ; pp1 . onError ( new TestException ( "First" ) ) ; pp2 . onComplete ( ) ; ts . assertFailureAndMessage ( TestException . class , "First" ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; TestSubscriberEx < Object > ts = Flowable . zip ( pp1 , pp2 , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . to ( TestHelper . < Object > testSubscriber ( 0L ) ) ; pp1 . onError ( new TestException ( "First" ) ) ; pp2 . onComplete ( ) ; ts . assertFailureAndMessage ( TestException . class , "First" ) ; 
Flowable . zip ( Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) , Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . zip ( Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) , Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . zip ( Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) , Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
Flowable . zip ( Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) , Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) TestSubscriber < List < Object > > ts = Flowable . zip ( Flowable . just ( 1 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return Thread . currentThread ( ) . getName ( ) . substring ( 0 , 4 ) ; ) , Flowable . just ( 1 ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return Thread . currentThread ( ) . getName ( ) . substring ( 0 , 4 ) ; ) , new BiFunction < Object , Object , List < Object > > ( ) @ Override public List < Object > apply ( Object t1 , Object t2 ) throws Exception return Arrays . asList ( t1 , t2 ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) ; List < Object > list = ts . values ( ) . get ( 0 ) ; assertTrue ( list . toString ( ) , list . contains ( "RxSi" ) ) ; assertTrue ( list . toString ( ) , list . contains ( "RxCo" ) ) ; 
throw new UnsupportedOperationException ( ) ; 
throw new UnsupportedOperationException ( ) ; 
throw new TestException ( ) ; 
return false ; 
$EMPTY$
$EMPTY$
Flowable . zip ( new ThrowingQueueSubscription ( ) , Flowable . just ( 1 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . zip ( new ThrowingQueueSubscription ( ) , Flowable . just ( 1 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( 0 ) . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . zip ( Flowable . range ( 1 , 2 ) , Flowable . range ( 3 , 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . subscribe ( ts ) ; ts . assertResult ( 4 ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; List < Flowable < ? > > flowableList = new ArrayList < > ( ) ; flowableList . add ( Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception throw new TestException ( ) ; , BackpressureStrategy . MISSING ) ) ; flowableList . add ( Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception counter . getAndIncrement ( ) ; , BackpressureStrategy . MISSING ) ) ; Flowable . zip ( flowableList , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return a ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , counter . get ( ) ) ; 
Publisher < Integer > source = new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) Flowable . just ( 1 ) . subscribe ( subscriber ) ; ; Flowable . zip ( Arrays . asList ( source , source ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] t ) throws Throwable return 2 ; ) . test ( ) . assertResult ( 2 ) ; 
Flowable . zip ( Flowable . range ( 1 , 5 ) , Flowable . just ( 1 ) . < Integer > map ( v -> throw new TestException ( ) ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) , ( a , b ) -> a + b , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . zip ( Flowable . range ( 1 , 5 ) , Flowable . just ( 1 ) . < Integer > map ( v -> throw new TestException ( ) ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) , ( a , b ) -> a + b , true ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
return observables . flatMapSingle ( new Function < Flowable < T > , SingleSource < List < T > > > ( ) @ Override public SingleSource < List < T > > apply ( Flowable < T > w ) throws Throwable return w . toList ( ) ; ) . toList ( ) . blockingGet ( ) ; 
Flowable < String > subject = Flowable . just ( "one" , "two" , "three" , "four" , "five" ) ; Flowable < Flowable < String > > windowed = subject . window ( 3 ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( 2 , windows . size ( ) ) ; assertEquals ( list ( "one" , "two" , "three" ) , windows . get ( 0 ) ) ; assertEquals ( list ( "four" , "five" ) , windows . get ( 1 ) ) ; 
Flowable < String > subject = Flowable . just ( "one" , "two" , "three" , "four" , "five" ) ; Flowable < Flowable < String > > windowed = subject . window ( 3 , 3 ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( 2 , windows . size ( ) ) ; assertEquals ( list ( "one" , "two" , "three" ) , windows . get ( 0 ) ) ; assertEquals ( list ( "four" , "five" ) , windows . get ( 1 ) ) ; 
Flowable < String > subject = Flowable . fromArray ( new String [ ] "zero" , "one" , "two" , "three" , "four" , "five" ) ; Flowable < Flowable < String > > windowed = subject . window ( 3 , 1 ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( 6 , windows . size ( ) ) ; assertEquals ( list ( "zero" , "one" , "two" ) , windows . get ( 0 ) ) ; assertEquals ( list ( "one" , "two" , "three" ) , windows . get ( 1 ) ) ; assertEquals ( list ( "two" , "three" , "four" ) , windows . get ( 2 ) ) ; assertEquals ( list ( "three" , "four" , "five" ) , windows . get ( 3 ) ) ; assertEquals ( list ( "four" , "five" ) , windows . get ( 4 ) ) ; assertEquals ( list ( "five" ) , windows . get ( 5 ) ) ; 
Flowable < String > subject = Flowable . just ( "one" , "two" , "three" , "four" , "five" ) ; Flowable < Flowable < String > > windowed = subject . window ( 2 , 3 ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( 2 , windows . size ( ) ) ; assertEquals ( list ( "one" , "two" ) , windows . get ( 0 ) ) ; assertEquals ( list ( "four" , "five" ) , windows . get ( 1 ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . merge ( Flowable . range ( 1 , 10000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . window ( 5 ) . take ( 2 ) ) . subscribe ( ts ) ; ts . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertEquals ( 10 , count . get ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . merge ( Flowable . range ( 1 , 100000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . observeOn ( Schedulers . computation ( ) ) . window ( 5 ) . take ( 2 ) ) . subscribe ( ts ) ; ts . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertTrue ( count . get ( ) < 100000 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . merge ( Flowable . range ( 1 , 10000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . window ( 5 , 4 ) . take ( 2 ) ) . subscribe ( ts ) ; ts . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 5 , 6 , 7 , 8 , 9 ) ; assertEquals ( 9 , count . get ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . merge ( Flowable . range ( 1 , 100000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . observeOn ( Schedulers . computation ( ) ) . window ( 5 , 4 ) . take ( 2 ) , 128 ) . subscribe ( ts ) ; ts . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 5 , 6 , 7 , 8 , 9 ) ; 
Flowable < Flowable < Integer > > source = Flowable . range ( 1 , 10 ) . window ( 3 ) ; final List < Integer > list = new ArrayList < > ( ) ; final Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; source . subscribe ( new DefaultSubscriber < Flowable < Integer > > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onNext ( Flowable < Integer > t ) t . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) list . add ( t ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , list ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
return Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) BooleanSubscription bs = new BooleanSubscription ( ) ; s . onSubscribe ( bs ) ; while ( ! bs . isCancelled ( ) ) for ( int i = 0 ; i < Math . random ( ) * 20 ; i ++ ) s . onNext ( i ) ; try Thread . sleep ( ( long ) ( Math . random ( ) * 200 ) ) ; catch ( Exception e ) System . out . println ( "Hot done." ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final int indicator = 999999999 ; hotStream ( ) . window ( 10 ) . take ( 2 ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > w ) return w . startWithItem ( indicator ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts . assertComplete ( ) ; ts . assertValueCount ( 22 ) ; 
TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( 0L ) ; Flowable . range ( 1 , 5 ) . window ( 2 , 1 ) . map ( new Function < Flowable < Integer > , Flowable < List < Integer > > > ( ) @ Override public Flowable < List < Integer > > apply ( Flowable < Integer > t ) return t . toList ( ) . toFlowable ( ) ; ) . concatMapEager ( new Function < Flowable < List < Integer > > , Publisher < List < Integer > > > ( ) @ Override public Publisher < List < Integer > > apply ( Flowable < List < Integer > > v ) return v ; ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 2 , 3 ) ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 5 ) ; System . out . println ( ts . values ( ) ) ; ts . assertValues ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 2 , 3 ) , Arrays . asList ( 3 , 4 ) , Arrays . asList ( 4 , 5 ) , Arrays . asList ( 5 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . window ( 1 ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . window ( 2 , 1 ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . window ( 1 , 2 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Flowable < Object > > > ( ) @ Override public Flowable < Flowable < Object > > apply ( Flowable < Object > f ) throws Exception return f . window ( 1 ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Flowable < Object > > > ( ) @ Override public Flowable < Flowable < Object > > apply ( Flowable < Object > f ) throws Exception return f . window ( 2 , 1 ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Flowable < Object > > > ( ) @ Override public Flowable < Flowable < Object > > apply ( Flowable < Object > f ) throws Exception return f . window ( 1 , 2 ) ; ) ; 
Flowable . error ( new TestException ( ) ) . window ( 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . window ( 1 , 2 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . window ( 2 , 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
@ SuppressWarnings ( "rawtypes" ) final TestSubscriber [ ] to = null ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . window ( 2 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Exception to [ 0 ] = w . test ( ) ; ) . test ( ) . assertError ( TestException . class ) ; to [ 0 ] . assertFailure ( TestException . class , 1 ) ; 
@ SuppressWarnings ( "rawtypes" ) final TestSubscriber [ ] to = null ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . window ( 2 , 3 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Exception to [ 0 ] = w . test ( ) ; ) . test ( ) . assertError ( TestException . class ) ; to [ 0 ] . assertFailure ( TestException . class , 1 ) ; 
@ SuppressWarnings ( "rawtypes" ) final TestSubscriber [ ] to = null ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . window ( 3 , 2 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Exception to [ 0 ] = w . test ( ) ; ) . test ( ) . assertError ( TestException . class ) ; to [ 0 ] . assertFailure ( TestException . class , 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 10 ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > inner = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 ) . take ( 1 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 5 , 10 ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > inner = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 5 , 10 ) . take ( 1 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 5 , 3 ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > inner = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 5 , 3 ) . take ( 1 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . window ( 1 ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . window ( 1 , 2 ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . window ( 2 , 1 ) ) ; 
Flowable . empty ( ) . window ( 1 , 2 ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . window ( 2 ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . window ( 1 , 2 ) . doOnNext ( w -> w . test ( ) ) . rebatchRequests ( 1 ) . test ( ) . assertComplete ( ) ; 
Flowable . just ( 1 ) . window ( 2 , 3 ) . flatMap ( v -> v ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 10 ) . window ( 2 , 1 ) . doOnNext ( w -> w . test ( ) ) . rebatchRequests ( 1 ) . test ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 10 ) . window ( 2 , 1 ) . takeUntil ( v -> true ) . doOnNext ( w -> w . test ( ) ) . test ( 0L ) . requestMore ( 10 ) . assertComplete ( ) ; 
Flowable . empty ( ) . window ( 2 , 1 ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . window ( 2 , 1 ) . test ( 0L ) . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; AtomicBoolean once = new AtomicBoolean ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 2 , 1 ) . doOnNext ( v -> v . test ( ) ; if ( once . compareAndSet ( false , true ) ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertComplete ( ) ; 
Flowable . range ( 1 , 10 ) . window ( 5 , 1 ) . doOnNext ( w -> w . test ( ) ) . test ( 3 ) . cancel ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( "Subject still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . cancel ( ) ; assertFalse ( "Subject still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 , 15 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( "Subject still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 , 15 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . cancel ( ) ; assertFalse ( "Subject still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 , 5 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( "Subject still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 , 5 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . cancel ( ) ; assertFalse ( "Subject still has subscribers!" , pp . hasSubscribers ( ) ) ; 
TestHelper . checkUtilityClass ( FlowableScalarXMap . class ) ; 
EmptySubscription . error ( new TestException ( ) , s ) ; 
throw new TestException ( ) ; 
EmptySubscription . complete ( s ) ; 
return null ; 
s . onSubscribe ( new ScalarSubscription < > ( s , 1 ) ) ; 
return 1 ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; assertTrue ( FlowableScalarXMap . tryScalarXMapSubscribe ( new CallablePublisher ( ) , ts , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer f ) throws Exception return Flowable . just ( 1 ) ; ) ) ; ts . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; assertTrue ( FlowableScalarXMap . tryScalarXMapSubscribe ( new EmptyCallablePublisher ( ) , ts , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer f ) throws Exception return Flowable . just ( 1 ) ; ) ) ; ts . assertResult ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; assertTrue ( FlowableScalarXMap . tryScalarXMapSubscribe ( new OneCallablePublisher ( ) , ts , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer f ) throws Exception throw new TestException ( ) ; ) ) ; ts . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; assertTrue ( FlowableScalarXMap . tryScalarXMapSubscribe ( new OneCallablePublisher ( ) , ts , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer f ) throws Exception return Flowable . just ( 1 ) ; ) ) ; ts . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; assertTrue ( FlowableScalarXMap . tryScalarXMapSubscribe ( new OneCallablePublisher ( ) , ts , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer f ) throws Exception return Flowable . empty ( ) ; ) ) ; ts . assertResult ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; assertTrue ( FlowableScalarXMap . tryScalarXMapSubscribe ( new OneCallablePublisher ( ) , ts , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer f ) throws Exception return new CallablePublisher ( ) ; ) ) ; ts . assertFailure ( TestException . class ) ; 
FlowableScalarXMap . scalarXMap ( 1 , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
FlowableScalarXMap . scalarXMap ( 1 , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return new CallablePublisher ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ScalarSubscription < Integer > sd = new ScalarSubscription < > ( ts , 1 ) ; ts . onSubscribe ( sd ) ; assertFalse ( sd . isCancelled ( ) ) ; assertTrue ( sd . isEmpty ( ) ) ; sd . request ( 1 ) ; assertFalse ( sd . isCancelled ( ) ) ; assertTrue ( sd . isEmpty ( ) ) ; ts . assertResult ( 1 ) ; try sd . offer ( 1 ) ; fail ( "Should have thrown" ) ; catch ( UnsupportedOperationException ex ) try sd . offer ( 1 , 2 ) ; fail ( "Should have thrown" ) ; catch ( UnsupportedOperationException ex ) 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final ScalarSubscription < Integer > sd = new ScalarSubscription < > ( ts , 1 ) ; ts . onSubscribe ( sd ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) sd . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sd . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
ScalarSubscription < Integer > scalar = new ScalarSubscription < > ( new TestSubscriber < > ( ) , 1 ) ; assertFalse ( scalar . isCancelled ( ) ) ; scalar . cancel ( ) ; assertTrue ( scalar . isCancelled ( ) ) ; 
Flowable . fromCallable ( ( ) -> 1 ) . concatMap ( v -> Flowable . range ( 1 , 5 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . interval ( 1 , TimeUnit . MILLISECONDS , Schedulers . trampoline ( ) ) . take ( 10 ) . test ( ) . assertResult ( 0L , 1L , 2L , 3L , 4L , 5L , 6L , 7L , 8L , 9L ) ; 
TestHelper . assertBadRequestReported ( Flowable . interval ( 1 , TimeUnit . MILLISECONDS , Schedulers . trampoline ( ) ) ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; IntervalSubscriber is = new IntervalSubscriber ( ts ) ; ts . onSubscribe ( is ) ; is . cancel ( ) ; is . run ( ) ; ts . assertEmpty ( ) ; 
return new Function < Integer , Flowable < T > > ( ) @ Override public Flowable < T > apply ( Integer t1 ) return flowable ; ; 
return new Function < T , Flowable < R > > ( ) @ Override public Flowable < R > apply ( T t1 ) return flowable ; ; 
MockitoAnnotations . openMocks ( this ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > m = Flowable . merge ( source1 . groupJoin ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , add2 ) ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; source1 . onNext ( 2 ) ; source1 . onNext ( 4 ) ; source2 . onNext ( 16 ) ; source2 . onNext ( 32 ) ; source2 . onNext ( 64 ) ; source1 . onComplete ( ) ; source2 . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 17 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 18 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 20 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 33 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 34 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 36 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 65 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 66 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 68 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Person > source1 = Flowable . fromIterable ( Arrays . asList ( new Person ( 1 , "Joe" ) , new Person ( 2 , "Mike" ) , new Person ( 3 , "Charlie" ) ) ) ; Flowable < PersonFruit > source2 = Flowable . fromIterable ( Arrays . asList ( new PersonFruit ( 1 , "Strawberry" ) , new PersonFruit ( 1 , "Apple" ) , new PersonFruit ( 3 , "Peach" ) ) ) ; Flowable < PPF > q = source1 . groupJoin ( source2 , just2 ( Flowable . < Object > never ( ) ) , just2 ( Flowable . < Object > never ( ) ) , new BiFunction < Person , Flowable < PersonFruit > , PPF > ( ) @ Override public PPF apply ( Person t1 , Flowable < PersonFruit > t2 ) return new PPF ( t1 , t2 ) ; ) ; q . subscribe ( new FlowableSubscriber < PPF > ( ) @ Override public void onNext ( final PPF ppf ) ppf . fruits . filter ( new Predicate < PersonFruit > ( ) @ Override public boolean test ( PersonFruit t1 ) return ppf . person . id == t1 . personId ; ) . subscribe ( new Consumer < PersonFruit > ( ) @ Override public void accept ( PersonFruit t1 ) subscriber . onNext ( Arrays . asList ( ppf . person . name , t1 . fruit ) ) ; ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; @ Override public void onSubscribe ( Subscription s ) s . request ( Long . MAX_VALUE ) ; ) ; verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( "Joe" , "Strawberry" ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( "Joe" , "Apple" ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( "Charlie" , "Peach" ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Flowable < Integer > > m = source1 . groupJoin ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , add2 ) ; m . subscribe ( subscriber ) ; source2 . onNext ( 1 ) ; source1 . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Flowable < Integer > > m = source1 . groupJoin ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , add2 ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; source2 . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( any ( Flowable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > duration1 = Flowable . < Integer > error ( new RuntimeException ( "Forced failure" ) ) ; Flowable < Flowable < Integer > > m = source1 . groupJoin ( source2 , just ( duration1 ) , just ( Flowable . never ( ) ) , add2 ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > duration1 = Flowable . < Integer > error ( new RuntimeException ( "Forced failure" ) ) ; Flowable < Flowable < Integer > > m = source1 . groupJoin ( source2 , just ( Flowable . never ( ) ) , just ( duration1 ) , add2 ) ; m . subscribe ( subscriber ) ; source2 . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > fail = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) throw new RuntimeException ( "Forced failure" ) ; ; Flowable < Flowable < Integer > > m = source1 . groupJoin ( source2 , fail , just ( Flowable . never ( ) ) , add2 ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > fail = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) throw new RuntimeException ( "Forced failure" ) ; ; Flowable < Flowable < Integer > > m = source1 . groupJoin ( source2 , just ( Flowable . never ( ) ) , fail , add2 ) ; m . subscribe ( subscriber ) ; source2 . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; BiFunction < Integer , Flowable < Integer > , Integer > fail = new BiFunction < Integer , Flowable < Integer > , Integer > ( ) @ Override public Integer apply ( Integer t1 , Flowable < Integer > t2 ) throw new RuntimeException ( "Forced failure" ) ; ; Flowable < Integer > m = source1 . groupJoin ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , fail ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; source2 . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . groupJoin ( Flowable . just ( 2 ) , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer left ) throws Exception return Flowable . never ( ) ; , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer right ) throws Exception return Flowable . never ( ) ; , new BiFunction < Integer , Flowable < Integer > , Object > ( ) @ Override public Object apply ( Integer r , Flowable < Integer > l ) throws Exception return l ; ) ) ; 
Flowable . just ( 1 ) . groupJoin ( Flowable . just ( 2 ) , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer left ) throws Exception return Flowable . empty ( ) ; , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer right ) throws Exception return Flowable . never ( ) ; , new BiFunction < Integer , Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer r , Flowable < Integer > l ) throws Exception return l ; ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . groupJoin ( Flowable . just ( 2 ) , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer left ) throws Exception return Flowable . error ( new TestException ( ) ) ; , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer right ) throws Exception return Flowable . never ( ) ; , new BiFunction < Integer , Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer r , Flowable < Integer > l ) throws Exception return l ; ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . groupJoin ( Flowable . just ( 2 ) , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer left ) throws Exception return Flowable . never ( ) ; , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer right ) throws Exception return Flowable . empty ( ) ; , new BiFunction < Integer , Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer r , Flowable < Integer > l ) throws Exception return l ; ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertResult ( 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . groupJoin ( Flowable . just ( 2 ) , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer left ) throws Exception return Flowable . never ( ) ; , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer right ) throws Exception return Flowable . error ( new TestException ( ) ) ; , new BiFunction < Integer , Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer r , Flowable < Integer > l ) throws Exception return l ; ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriberEx < Flowable < Integer > > ts = Flowable . just ( 1 ) . groupJoin ( Flowable . just ( 2 ) . concatWith ( Flowable . < Integer > never ( ) ) , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer left ) throws Exception return pp1 ; , new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer right ) throws Exception return pp2 ; , new BiFunction < Integer , Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer r , Flowable < Integer > l ) throws Exception return l ; ) . to ( TestHelper . < Flowable < Integer > > testConsumer ( ) ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertError ( Throwable . class ) . assertSubscribed ( ) . assertNotComplete ( ) . assertValueCount ( 1 ) ; Throwable exc = ts . errors ( ) . get ( 0 ) ; if ( exc instanceof CompositeException ) List < Throwable > es = TestHelper . compositeList ( exc ) ; TestHelper . assertError ( es , 0 , TestException . class ) ; TestHelper . assertError ( es , 1 , TestException . class ) ; else ts . assertError ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriberEx < Object > ts = pp1 . groupJoin ( pp2 , new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object left ) throws Exception return Flowable . never ( ) ; , new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object right ) throws Exception return Flowable . never ( ) ; , new BiFunction < Object , Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object r , Flowable < Object > l ) throws Exception return l ; ) . flatMap ( Functions . < Flowable < Object > > identity ( ) ) . to ( TestHelper . < Object > testConsumer ( ) ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertError ( Throwable . class ) . assertSubscribed ( ) . assertNotComplete ( ) . assertNoValues ( ) ; Throwable exc = ts . errors ( ) . get ( 0 ) ; if ( exc instanceof CompositeException ) List < Throwable > es = TestHelper . compositeList ( exc ) ; TestHelper . assertError ( es , 0 , TestException . class ) ; TestHelper . assertError ( es , 1 , TestException . class ) ; else ts . assertError ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Object > ts = pp1 . groupJoin ( pp2 , new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object left ) throws Exception return Flowable . never ( ) ; , new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object right ) throws Exception return Flowable . never ( ) ; , new BiFunction < Object , Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object r , Flowable < Object > l ) throws Exception return l ; ) . flatMap ( Functions . < Flowable < Object > > identity ( ) ) . test ( ) ; pp2 . onNext ( 2 ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; pp2 . onComplete ( ) ; ts . assertResult ( 2 ) ; 
JoinSupport js = mock ( JoinSupport . class ) ; LeftRightSubscriber o = new LeftRightSubscriber ( js , false ) ; assertFalse ( o . isDisposed ( ) ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; o . dispose ( ) ; assertTrue ( o . isDisposed ( ) ) ; verify ( js ) . innerValue ( false , 1 ) ; verify ( js ) . innerValue ( false , 2 ) ; 
JoinSupport js = mock ( JoinSupport . class ) ; LeftRightEndSubscriber o = new LeftRightEndSubscriber ( js , false , 0 ) ; assertFalse ( o . isDisposed ( ) ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; assertTrue ( o . isDisposed ( ) ) ; verify ( js ) . innerClose ( false , o ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; pp1 . groupJoin ( pp2 , v -> Flowable . never ( ) , v -> Flowable . never ( ) , ( a , b ) -> a ) . doOnNext ( v -> ts . cancel ( ) ; ) . subscribe ( ts ) ; pp2 . onNext ( 1 ) ; pp1 . onNext ( 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; pp1 . groupJoin ( pp2 , v -> Flowable . never ( ) , v -> Flowable . never ( ) , ( a , b ) -> a ) . doOnNext ( v -> if ( v == 1 ) pp2 . onNext ( 2 ) ; pp1 . onComplete ( ) ; pp2 . onComplete ( ) ; ) . subscribe ( ts ) ; pp2 . onNext ( 1 ) ; pp1 . onNext ( 1 ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . groupJoin ( Flowable . never ( ) , v -> Flowable . never ( ) , v -> Flowable . never ( ) , ( a , b ) -> a ) ) ; 
Flowable . just ( 1 ) . groupJoin ( Flowable . never ( ) , v -> BehaviorProcessor . createDefault ( 1 ) , v -> Flowable . never ( ) , ( a , b ) -> a ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; 
Flowable < Integer > f = Flowable . just ( 1 ) ; assertSame ( f , ( ( HasUpstreamPublisher < Integer > ) f . map ( Functions . < Integer > identity ( ) ) ) . source ( ) ) ; 
Flowable < String > w = Flowable . empty ( ) ; Flowable < String > take = w . takeLast ( 2 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; take . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . just ( "one" , "two" , "three" ) ; Flowable < String > take = w . takeLast ( 2 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; take . subscribe ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . just ( "one" ) ; Flowable < String > take = w . takeLast ( 10 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; take . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . just ( "one" ) ; Flowable < String > take = w . takeLast ( 0 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; take . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable . just ( "one" ) . takeLast ( - 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100000 ) . takeLast ( 1 ) . observeOn ( Schedulers . newThread ( ) ) . map ( newSlowProcessor ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertValue ( 100000 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100000 ) . takeLast ( Flowable . bufferSize ( ) * 4 ) . observeOn ( Schedulers . newThread ( ) ) . map ( newSlowProcessor ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , ts . values ( ) . size ( ) ) ; 
return new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer i ) if ( c ++ < 100 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return i ; ; 
assertEquals ( 0 , Flowable . empty ( ) . count ( ) . toFlowable ( ) . filter ( new Predicate < Long > ( ) @ Override public boolean test ( Long v ) return false ; ) . toList ( ) . blockingGet ( ) . size ( ) ) ; 
Flowable . range ( 0 , 100000 ) . takeLast ( 100000 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( Long . MAX_VALUE ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer integer ) request ( Long . MAX_VALUE ) ; ) ; 
Flowable . range ( 0 , 100000 ) . takeLast ( 100000 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer integer ) request ( 1 ) ; ) ; 
Flowable . range ( 0 , 100000 ) . takeLast ( 100000 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer integer ) request ( Long . MAX_VALUE ) ; ) ; 
Flowable . range ( 0 , 100000 ) . takeLast ( 100000 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( Long . MAX_VALUE ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer integer ) request ( 1 ) ; ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable . range ( 0 , 100000 ) . takeLast ( 100000 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( Long . MAX_VALUE ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer integer ) count . incrementAndGet ( ) ; cancel ( ) ; ) ; assertEquals ( 1 , count . get ( ) ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 100 ) . takeLast ( 50 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 2 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) list . add ( t ) ; request ( Long . MAX_VALUE - 1 ) ; ) ; assertEquals ( 50 , list . size ( ) ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 10 ) . takeLast ( 5 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . takeLast ( 5 ) ; ) ; 
Flowable . error ( new TestException ( ) ) . takeLast ( 5 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 10 ) . takeLast ( 5 ) . take ( 2 ) . test ( ) . assertResult ( 6 , 7 ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . takeLast ( 2 ) ) ; 
Flowable . never ( ) . takeLast ( 2 ) . subscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onNext ( @ NonNull Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( @ NonNull Subscription s ) s . cancel ( ) ; s . request ( 1 ) ; ) ; 
Flowable . empty ( ) . takeLast ( 2 ) . test ( 0L ) . assertResult ( ) ; 
Flowable . range ( 1 , 4 ) . takeLast ( 3 ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 2 , 3 ) . requestMore ( 2 ) . assertResult ( 2 , 3 , 4 ) ; 
Flowable . just ( "one" ) . takeLast ( - 1 , 1 , TimeUnit . SECONDS ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Object > source = PublishProcessor . create ( ) ; Flowable < Object > result = source . takeLast ( 1000 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Object > source = PublishProcessor . create ( ) ; Flowable < Object > result = source . takeLast ( 1000 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 1250 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Object > source = PublishProcessor . create ( ) ; Flowable < Object > result = source . takeLast ( 2 , 1000 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Object > source = PublishProcessor . create ( ) ; Flowable < Object > result = source . takeLast ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onError ( new TestException ( ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Object > source = PublishProcessor . create ( ) ; Flowable < Object > result = source . takeLast ( 0 , 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . takeLast ( 1000 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; pp . onNext ( 2 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; pp . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; pp . onNext ( 4 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; pp . onComplete ( ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValue ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; ts . request ( 1 ) ; ts . assertValues ( 3 , 4 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
Flowable . just ( 1 , 2 ) . takeLast ( 1 , 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( 2 ) ; 
Flowable . just ( 1 , 2 ) . takeLast ( 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . just ( 1 , 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . takeLast ( 1 , TimeUnit . MINUTES , true ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Flowable . just ( 1 , 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . takeLast ( 1 , TimeUnit . MINUTES , Schedulers . io ( ) , true ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . takeLast ( 1 , TimeUnit . MINUTES ) ) ; 
Observable . range ( 1 , 1000 ) . takeLast ( 1 , TimeUnit . DAYS ) . take ( 500 ) . observeOn ( Schedulers . single ( ) , true , 1 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . takeLast ( 1 , TimeUnit . DAYS ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Flowable . empty ( ) . takeLast ( 1 , TimeUnit . DAYS , true ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . takeLast ( 1 , TimeUnit . SECONDS ) ; ) ; 
TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) . takeLast ( 1 , TimeUnit . SECONDS ) ) ; 
TimesteppingScheduler scheduler = new TimesteppingScheduler ( ) ; scheduler . stepEnabled = false ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . takeLast ( 2 , TimeUnit . SECONDS , scheduler ) . test ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onNext ( 3 ) ; pp . onNext ( 4 ) ; scheduler . stepEnabled = true ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 3 , 4 ) ; 
Supplier < Object > func = mock ( Supplier . class ) ; when ( func . get ( ) ) . thenReturn ( new Object ( ) ) ; Flowable < Object > fromSupplierFlowable = Flowable . fromSupplier ( func ) ; verifyNoInteractions ( func ) ; fromSupplierFlowable . subscribe ( ) ; verify ( func ) . get ( ) ; 
Supplier < String > func = mock ( Supplier . class ) ; when ( func . get ( ) ) . thenReturn ( "test_value" ) ; Flowable < String > fromSupplierFlowable = Flowable . fromSupplier ( func ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; fromSupplierFlowable . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( "test_value" ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Supplier < Object > func = mock ( Supplier . class ) ; Throwable throwable = new IllegalStateException ( "Test exception" ) ; when ( func . get ( ) ) . thenThrow ( throwable ) ; Flowable < Object > fromSupplierFlowable = Flowable . fromSupplier ( func ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; fromSupplierFlowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( throwable ) ; 
Supplier < String > func = mock ( Supplier . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . get ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Flowable < String > fromSupplierFlowable = Flowable . fromSupplier ( func ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > outer = new TestSubscriber < > ( subscriber ) ; fromSupplierFlowable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . cancel ( ) ; funcLatch . countDown ( ) ; verify ( func ) . get ( ) ; verify ( subscriber ) . onSubscribe ( any ( Subscription . class ) ) ; verifyNoMoreInteractions ( subscriber ) ; 
final Exception checkedException = new Exception ( "test exception" ) ; Flowable < Object > fromSupplierFlowable = Flowable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw checkedException ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; fromSupplierFlowable . subscribe ( subscriber ) ; verify ( subscriber ) . onSubscribe ( any ( Subscription . class ) ) ; verify ( subscriber ) . onError ( checkedException ) ; verifyNoMoreInteractions ( subscriber ) ; 
final int [ ] calls = 0 ; Flowable . just ( 1 ) . flatMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return ++ calls [ 0 ] ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Flowable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return ++ calls [ 0 ] ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
Flowable . just ( 1 ) . flatMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return null ; ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return null ; ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception ts . cancel ( ) ; throw new TestException ( ) ; ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . toFlowable ( BackpressureStrategy . MISSING ) ) ; 
Observable . error ( new TestException ( ) ) . toFlowable ( BackpressureStrategy . MISSING ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( BackpressureStrategy mode : BackpressureStrategy . values ( ) ) Flowable . fromObservable ( Observable . range ( 1 , 5 ) , mode ) . test ( ) . withTag ( "mode: " + mode ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
stringSubscriber = TestHelper . mockSubscriber ( ) ; for ( Thread t : Thread . getAllStackTraces ( ) . keySet ( ) ) if ( t . getName ( ) . startsWith ( "RxNewThread" ) ) count ++ ; 
try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; for ( Thread t : Thread . getAllStackTraces ( ) . keySet ( ) ) if ( t . getName ( ) . startsWith ( "RxNewThread" ) ) -- count ; if ( count != 0 ) throw new IllegalStateException ( "NewThread leak!" ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; Flowable < Flowable < String > > flowableOfFlowables = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( f1 ) ; subscriber . onNext ( f2 ) ; subscriber . onComplete ( ) ; ) ; Flowable < String > m = Flowable . merge ( flowableOfFlowables ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( f1 ) ; subscriber . onNext ( f2 ) ; subscriber . onComplete ( ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; Flowable < String > m = Flowable . merge ( f1 , f2 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; List < Flowable < String > > listOfFlowables = new ArrayList < > ( ) ; listOfFlowables . add ( f1 ) ; listOfFlowables . add ( f2 ) ; Flowable < String > m = Flowable . merge ( listOfFlowables ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; 
final AtomicBoolean unsubscribed = new AtomicBoolean ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Flowable < Flowable < Long > > source = Flowable . unsafeCreate ( new Publisher < Flowable < Long > > ( ) @ Override public void subscribe ( final Subscriber < ? super Flowable < Long > > subscriber ) final Subscription s = new Subscription ( ) @ Override public void request ( long n ) @ Override public void cancel ( ) System . out . println ( "*** unsubscribed" ) ; unsubscribed . set ( true ) ; ; subscriber . onSubscribe ( s ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) while ( ! unsubscribed . get ( ) ) subscriber . onNext ( Flowable . just ( 1L , 2L ) ) ; System . out . println ( "Done looping after unsubscribe: " + unsubscribed . get ( ) ) ; subscriber . onComplete ( ) ; latch . countDown ( ) ; ) . start ( ) ; ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . merge ( source ) . take ( 6 ) . blockingForEach ( new Consumer < Long > ( ) @ Override public void accept ( Long v ) System . out . println ( "Value: " + v ) ; int c = count . incrementAndGet ( ) ; if ( c > 6 ) fail ( "Should be only 6" ) ; ) ; latch . await ( 1000 , TimeUnit . MILLISECONDS ) ; System . out . println ( "unsubscribed: " + unsubscribed . get ( ) ) ; assertTrue ( unsubscribed . get ( ) ) ; 
final Subscription s = new Subscription ( ) @ Override public void request ( long n ) @ Override public void cancel ( ) System . out . println ( "*** unsubscribed" ) ; unsubscribed . set ( true ) ; ; subscriber . onSubscribe ( s ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) while ( ! unsubscribed . get ( ) ) subscriber . onNext ( Flowable . just ( 1L , 2L ) ) ; System . out . println ( "Done looping after unsubscribe: " + unsubscribed . get ( ) ) ; subscriber . onComplete ( ) ; latch . countDown ( ) ; ) . start ( ) ; 
final TestASynchronousFlowable f1 = new TestASynchronousFlowable ( ) ; final TestASynchronousFlowable f2 = new TestASynchronousFlowable ( ) ; Flowable < String > m = Flowable . merge ( Flowable . unsafeCreate ( f1 ) , Flowable . unsafeCreate ( f2 ) ) ; TestSubscriber < String > ts = new TestSubscriber < > ( stringSubscriber ) ; m . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) System . out . println ( "testSynchronizationOfMultipleSequencesLoop > " + i ) ; synchronizationOfMultipleSequences ( ) ; 
final TestASynchronousFlowable f1 = new TestASynchronousFlowable ( ) ; final TestASynchronousFlowable f2 = new TestASynchronousFlowable ( ) ; final CountDownLatch endLatch = new CountDownLatch ( 1 ) ; final AtomicInteger concurrentCounter = new AtomicInteger ( ) ; final AtomicInteger totalCounter = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Flowable < String > m = Flowable . merge ( Flowable . unsafeCreate ( f1 ) , Flowable . unsafeCreate ( f2 ) ) ; m . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) error . set ( e ) ; @ Override public void onNext ( String v ) totalCounter . incrementAndGet ( ) ; concurrentCounter . incrementAndGet ( ) ; try if ( Thread . currentThread ( ) . getName ( ) . equals ( "TestASynchronousFlowable" ) ) endLatch . await ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; throw new RuntimeException ( "failed" , e ) ; finally concurrentCounter . decrementAndGet ( ) ; ) ; f1 . onNextBeingSent . await ( ) ; f2 . onNextBeingSent . await ( ) ; int timeout = 20 ; while ( timeout -- > 0 && concurrentCounter . get ( ) != 1 ) Thread . sleep ( 100 ) ; try if ( error . get ( ) != null ) throw ExceptionHelper . wrapOrThrow ( error . get ( ) ) ; assertEquals ( 1 , concurrentCounter . get ( ) ) ; finally endLatch . countDown ( ) ; try f1 . t . join ( ) ; f2 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertEquals ( 2 , totalCounter . get ( ) ) ; assertEquals ( 0 , concurrentCounter . get ( ) ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestErrorFlowable ( "four" , null , "six" ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestErrorFlowable ( "one" , "two" , "three" ) ) ; Flowable < String > m = Flowable . merge ( f1 , f2 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "two" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "three" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "five" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "six" ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestErrorFlowable ( "one" , "two" , "three" ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestErrorFlowable ( "four" , null , "six" ) ) ; final Flowable < String > f3 = Flowable . unsafeCreate ( new TestErrorFlowable ( "seven" , "eight" , null ) ) ; final Flowable < String > f4 = Flowable . unsafeCreate ( new TestErrorFlowable ( "nine" ) ) ; Flowable < String > m = Flowable . merge ( f1 , f2 , f3 , f4 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "five" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "six" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "seven" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "eight" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "nine" ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "hello" ) ; subscriber . onComplete ( ) ; 
TestScheduler scheduler1 = new TestScheduler ( ) ; AtomicBoolean os1 = new AtomicBoolean ( false ) ; Flowable < Long > f1 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler1 , os1 ) ; TestScheduler scheduler2 = new TestScheduler ( ) ; AtomicBoolean os2 = new AtomicBoolean ( false ) ; Flowable < Long > f2 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler2 , os2 ) ; TestSubscriberEx < Long > ts = new TestSubscriberEx < > ( ) ; Flowable . merge ( f1 , f2 ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; scheduler1 . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; scheduler2 . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ts . assertValues ( 0L , 1L , 2L , 0L , 1L ) ; assertFalse ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; scheduler1 . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; ts . assertValues ( 0L , 1L , 2L , 0L , 1L , 3L , 4L ) ; assertTrue ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; scheduler2 . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; ts . assertValues ( 0L , 1L , 2L , 0L , 1L , 3L , 4L , 2L , 3L , 4L ) ; assertTrue ( os1 . get ( ) ) ; assertTrue ( os2 . get ( ) ) ; ts . assertTerminated ( ) ; 
for ( int i = 0 ; i < 10 ; i ++ ) TestScheduler scheduler1 = new TestScheduler ( ) ; AtomicBoolean os1 = new AtomicBoolean ( false ) ; Flowable < Long > f1 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler1 , os1 ) ; TestScheduler scheduler2 = new TestScheduler ( ) ; AtomicBoolean os2 = new AtomicBoolean ( false ) ; Flowable < Long > f2 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler2 , os2 ) ; TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; Flowable . merge ( f1 , f2 ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; scheduler1 . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; scheduler2 . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ts . assertValues ( 0L , 1L , 2L , 0L , 1L ) ; assertFalse ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; ts . cancel ( ) ; assertTrue ( os1 . get ( ) ) ; assertTrue ( os2 . get ( ) ) ; ts . assertValues ( 0L , 1L , 2L , 0L , 1L ) ; 
return Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( final Subscriber < ? super Long > child ) Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 5 ) . subscribe ( new FlowableSubscriber < Long > ( ) @ Override public void onSubscribe ( final Subscription s ) child . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) s . request ( n ) ; @ Override public void cancel ( ) unsubscribed . set ( true ) ; s . cancel ( ) ; ) ; @ Override public void onNext ( Long t ) child . onNext ( t ) ; @ Override public void onError ( Throwable t ) unsubscribed . set ( true ) ; child . onError ( t ) ; @ Override public void onComplete ( ) unsubscribed . set ( true ) ; child . onComplete ( ) ; ) ; ) ; 
Flowable < Integer > f = Flowable . range ( 1 , 10000 ) . subscribeOn ( Schedulers . newThread ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) Flowable < Integer > merge = Flowable . merge ( f . onBackpressureBuffer ( ) , f . onBackpressureBuffer ( ) , f . onBackpressureBuffer ( ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; merge . subscribe ( ts ) ; ts . awaitDone ( 3 , TimeUnit . SECONDS ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 30000 , onNextEvents . size ( ) ) ; 
Flowable < Integer > f = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > s ) Worker inner = Schedulers . newThread ( ) . createWorker ( ) ; final AsyncSubscription as = new AsyncSubscription ( ) ; as . setSubscription ( new BooleanSubscription ( ) ) ; as . setResource ( inner ) ; s . onSubscribe ( as ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) try for ( int i = 0 ; i < 100 ; i ++ ) s . onNext ( 1 ) ; try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; catch ( Exception e ) s . onError ( e ) ; as . dispose ( ) ; s . onComplete ( ) ; ) ; ) ; for ( int i = 0 ; i < 10 ; i ++ ) Flowable < Integer > merge = Flowable . merge ( f , f , f ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; merge . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertComplete ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 300 , onNextEvents . size ( ) ) ; 
Flowable < Integer > f = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > s ) Worker inner = Schedulers . newThread ( ) . createWorker ( ) ; final AsyncSubscription as = new AsyncSubscription ( ) ; as . setSubscription ( new BooleanSubscription ( ) ) ; as . setResource ( inner ) ; s . onSubscribe ( as ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) try for ( int i = 0 ; i < 10000 ; i ++ ) s . onNext ( i ) ; catch ( Exception e ) s . onError ( e ) ; as . dispose ( ) ; s . onComplete ( ) ; s . onComplete ( ) ; s . onComplete ( ) ; ) ; ) ; for ( int i = 0 ; i < 10 ; i ++ ) Flowable < Integer > merge = Flowable . merge ( f . onBackpressureBuffer ( ) , f . onBackpressureBuffer ( ) , f . onBackpressureBuffer ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; merge . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 30000 , onNextEvents . size ( ) ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Flowable < Integer > f1 = createInfiniteFlowable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; final AtomicInteger generated2 = new AtomicInteger ( ) ; Flowable < Integer > f2 = createInfiniteFlowable ( generated2 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriberEx < Integer > testSubscriber = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) System . err . println ( "testSubscriber received => " + t + "  on thread " + Thread . currentThread ( ) ) ; super . onNext ( t ) ; ; Flowable . merge ( f1 . take ( Flowable . bufferSize ( ) * 2 ) , f2 . take ( Flowable . bufferSize ( ) * 2 ) ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( testSubscriber . errors ( ) . size ( ) > 0 ) testSubscriber . errors ( ) . get ( 0 ) . printStackTrace ( ) ; testSubscriber . assertNoErrors ( ) ; System . err . println ( testSubscriber . values ( ) ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , testSubscriber . values ( ) . size ( ) ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) ) ; System . out . println ( "Generated 2: " + generated2 . get ( ) ) ; assertTrue ( generated1 . get ( ) >= Flowable . bufferSize ( ) * 2 && generated1 . get ( ) <= Flowable . bufferSize ( ) * 4 ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) System . err . flush ( ) ; System . out . println ( "---" ) ; System . out . flush ( ) ; backpressureUpstream2 ( ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Flowable < Integer > f1 = createInfiniteFlowable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriberEx < Integer > testSubscriber = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ; Flowable . merge ( f1 . take ( Flowable . bufferSize ( ) * 2 ) , Flowable . just ( - 99 ) ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 10 , TimeUnit . SECONDS ) ; List < Integer > onNextEvents = testSubscriber . values ( ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) + " / received: " + onNextEvents . size ( ) ) ; System . out . println ( onNextEvents ) ; if ( testSubscriber . errors ( ) . size ( ) > 0 ) testSubscriber . errors ( ) . get ( 0 ) . printStackTrace ( ) ; testSubscriber . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 + 1 , onNextEvents . size ( ) ) ; assertTrue ( generated1 . get ( ) >= Flowable . bufferSize ( ) * 2 && generated1 . get ( ) <= Flowable . bufferSize ( ) * 3 ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Flowable < Integer > f1 = createInfiniteFlowable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; final AtomicInteger generated2 = new AtomicInteger ( ) ; Flowable < Integer > f2 = createInfiniteFlowable ( generated2 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriberEx < Integer > testSubscriber = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t < 100 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; super . onNext ( t ) ; ; Flowable . merge ( f1 . take ( Flowable . bufferSize ( ) * 2 ) , f2 . take ( Flowable . bufferSize ( ) * 2 ) ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 10 , TimeUnit . SECONDS ) ; if ( testSubscriber . errors ( ) . size ( ) > 0 ) testSubscriber . errors ( ) . get ( 0 ) . printStackTrace ( ) ; testSubscriber . assertNoErrors ( ) ; System . err . println ( testSubscriber . values ( ) ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , testSubscriber . values ( ) . size ( ) ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) ) ; System . out . println ( "Generated 2: " + generated2 . get ( ) ) ; assertTrue ( generated1 . get ( ) >= Flowable . bufferSize ( ) * 2 && generated1 . get ( ) <= Flowable . bufferSize ( ) * 4 ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Flowable < Flowable < Integer > > f1 = createInfiniteFlowable ( generated1 ) . map ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return Flowable . just ( t1 ) ; ) ; TestSubscriberEx < Integer > testSubscriber = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t < 100 ) try Thread . sleep ( 2 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; super . onNext ( t ) ; ; Flowable . merge ( f1 ) . observeOn ( Schedulers . computation ( ) ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 10 , TimeUnit . SECONDS ) ; if ( testSubscriber . errors ( ) . size ( ) > 0 ) testSubscriber . errors ( ) . get ( 0 ) . printStackTrace ( ) ; testSubscriber . assertNoErrors ( ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) ) ; System . err . println ( testSubscriber . values ( ) ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , testSubscriber . values ( ) . size ( ) ) ; assertTrue ( generated1 . get ( ) >= Flowable . bufferSize ( ) * 2 && generated1 . get ( ) <= Flowable . bufferSize ( ) * 4 ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Flowable < Flowable < Integer > > f1 = createInfiniteFlowable ( generated1 ) . map ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return Flowable . just ( 1 , 2 , 3 ) ; ) ; TestSubscriberEx < Integer > testSubscriber = new TestSubscriberEx < Integer > ( ) int i ; @ Override public void onNext ( Integer t ) if ( i ++ < 400 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; super . onNext ( t ) ; ; Flowable . merge ( f1 ) . observeOn ( Schedulers . computation ( ) ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 10 , TimeUnit . SECONDS ) ; if ( testSubscriber . errors ( ) . size ( ) > 0 ) testSubscriber . errors ( ) . get ( 0 ) . printStackTrace ( ) ; testSubscriber . assertNoErrors ( ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) ) ; System . err . println ( testSubscriber . values ( ) ) ; System . out . println ( "done1 testBackpressureBothUpstreamAndDownstreamWithRegularFlowables " ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , testSubscriber . values ( ) . size ( ) ) ; System . out . println ( "done2 testBackpressureBothUpstreamAndDownstreamWithRegularFlowables " ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNAsyncStreamsOfN ( 1 , 1 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 1 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNAsyncStreamsOfN ( 1 , 1000 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 1000 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNAsyncStreamsOfN ( 10 , 1000 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 10000 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNAsyncStreamsOfN ( 1000 , 1000 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 1000000 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNAsyncStreamsOfN ( 2000 , 100 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 200000 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNAsyncStreamsOfN ( 100 , 1 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 100 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNSyncStreamsOfN ( 1 , 1 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 1 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNSyncStreamsOfN ( 1 , 1000000 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 1000000 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNSyncStreamsOfN ( 1000 , 1000 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 1000000 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNSyncStreamsOfN ( 10000 , 10 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 100000 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; mergeNSyncStreamsOfN ( 1000000 , 1 ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 1000000 , ts . values ( ) . size ( ) ) ; 
Flowable < Integer > flowable = Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) @ Override public Integer next ( ) return generated . getAndIncrement ( ) ; @ Override public boolean hasNext ( ) return true ; ; ) ; return flowable ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable < Flowable < Integer > > os = Flowable . range ( 1 , 10000 ) . map ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( final Integer i ) return Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; if ( i < 500 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; s . onNext ( i ) ; s . onComplete ( ) ; ) . subscribeOn ( Schedulers . computation ( ) ) . cache ( ) ; ) ; Flowable . merge ( os ) . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 10000 , ts . values ( ) . size ( ) ) ; 
Flowable < Integer > source = Flowable . mergeDelayError ( Flowable . just ( Flowable . range ( 1 , 2 ) ) ) ; TestSubscriberEx < Integer > subscriber = new TestSubscriberEx < > ( 0L ) ; source . subscribe ( subscriber ) ; subscriber . request ( 3 ) ; subscriber . assertValues ( 1 , 2 ) ; subscriber . assertTerminated ( ) ; 
Flowable < Integer > source = Flowable . mergeDelayError ( Flowable . just ( Flowable . just ( 1 ) ) ) ; TestSubscriberEx < Integer > subscriber = new TestSubscriberEx < > ( 0L ) ; source . subscribe ( subscriber ) ; subscriber . request ( 2 ) ; subscriber . assertValue ( 1 ) ; subscriber . assertTerminated ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Long > source = Flowable . mergeDelayError ( Flowable . just ( 1L ) , Flowable . timer ( 1 , TimeUnit . SECONDS , scheduler ) . skip ( 1 ) ) ; TestSubscriberEx < Long > subscriber = new TestSubscriberEx < > ( 0L ) ; source . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; subscriber . assertNoValues ( ) ; subscriber . assertNotComplete ( ) ; subscriber . request ( 1 ) ; subscriber . assertValue ( 1L ) ; subscriber . assertTerminated ( ) ; 
Throwable exception = new Throwable ( ) ; Flowable < Integer > source = Flowable . mergeDelayError ( Flowable . range ( 1 , 2 ) , Flowable . < Integer > error ( exception ) ) ; TestSubscriberEx < Integer > subscriber = new TestSubscriberEx < > ( 0L ) ; source . subscribe ( subscriber ) ; subscriber . request ( 3 ) ; subscriber . assertValues ( 1 , 2 ) ; subscriber . assertTerminated ( ) ; assertEquals ( asList ( exception ) , subscriber . errors ( ) ) ; 
Throwable exception = new Throwable ( ) ; Flowable < Integer > source = Flowable . mergeDelayError ( Flowable . just ( 1 ) , Flowable . < Integer > error ( exception ) ) ; TestSubscriberEx < Integer > subscriber = new TestSubscriberEx < > ( 0L ) ; source . subscribe ( subscriber ) ; subscriber . request ( 2 ) ; subscriber . assertValue ( 1 ) ; subscriber . assertTerminated ( ) ; assertEquals ( asList ( exception ) , subscriber . errors ( ) ) ; 
Flowable < Integer > source = Flowable . merge ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < > ( 1L ) ; source . subscribe ( subscriber ) ; subscriber . assertValue ( 1 ) ; subscriber . request ( 1 ) ; subscriber . assertValues ( 1 , 2 ) ; 
Throwable exception = new Throwable ( ) ; Flowable < Integer > source = Flowable . mergeDelayError ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . < Integer > error ( exception ) ) ; TestSubscriberEx < Integer > subscriber = new TestSubscriberEx < > ( 0L ) ; subscriber . request ( 1 ) ; source . subscribe ( subscriber ) ; subscriber . assertValue ( 1 ) ; assertEquals ( Collections . < Throwable > emptyList ( ) , subscriber . errors ( ) ) ; subscriber . request ( 1 ) ; subscriber . assertValues ( 1 , 2 ) ; assertEquals ( asList ( exception ) , subscriber . errors ( ) ) ; 
Throwable exception = new Throwable ( ) ; Flowable < Integer > source = Flowable . mergeDelayError ( Flowable . range ( 1 , 2 ) , Flowable . range ( 3 , 2 ) , Flowable . < Integer > error ( exception ) ) ; TestSubscriberEx < Integer > subscriber = new TestSubscriberEx < > ( 0L ) ; subscriber . request ( 3 ) ; source . subscribe ( subscriber ) ; subscriber . assertValues ( 1 , 2 , 3 ) ; assertEquals ( Collections . < Throwable > emptyList ( ) , subscriber . errors ( ) ) ; subscriber . request ( 2 ) ; subscriber . assertValues ( 1 , 2 , 3 , 4 ) ; assertEquals ( asList ( exception ) , subscriber . errors ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final ConcurrentLinkedQueue < String > messages = new ConcurrentLinkedQueue < > ( ) ; Flowable . range ( 1 , 2 ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( final Integer number ) return Flowable . range ( 1 , Integer . MAX_VALUE ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) messages . add ( ">>>>>>>> A requested[" + number + "]: " + n ) ; ) . doOnNext ( pauseForMs ( 3 ) ) . onBackpressureBuffer ( ) . subscribeOn ( Schedulers . computation ( ) ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) messages . add ( ">>>>>>>> B requested[" + number + "]: " + n ) ; ) ; ) . take ( Flowable . bufferSize ( ) * 2 + 1 ) . doOnNext ( printCount ( ) ) . doOnComplete ( new Action ( ) @ Override public void run ( ) latch . countDown ( ) ; ) . subscribe ( ) ; boolean a = latch . await ( 10 , TimeUnit . SECONDS ) ; if ( ! a ) for ( String s : messages ) System . out . println ( "DEBUG => " + s ) ; assertTrue ( a ) ; 
Flowable < Integer > f = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) . mergeWith ( Flowable . fromIterable ( Arrays . asList ( 3 , 4 ) ) ) ; final int expectedCount = 4 ; final CountDownLatch latch = new CountDownLatch ( expectedCount ) ; f . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new RuntimeException ( e ) ; @ Override public void onNext ( Integer t ) latch . countDown ( ) ; request ( 2 ) ; request ( Long . MAX_VALUE - 1 ) ; ) ; assertTrue ( latch . await ( 10 , TimeUnit . SECONDS ) ) ; 
return new Consumer < Integer > ( ) long count ; @ Override public void accept ( Integer t1 ) count ++ ; System . out . println ( "count=" + count ) ; ; 
List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) list . add ( i ) ; Flowable < Integer > source = Flowable . fromIterable ( list ) ; source . flatMap ( func ) . subscribe ( ts ) ; if ( ts . values ( ) . size ( ) != 1000 ) System . out . println ( ts . values ( ) ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; ts . assertValueSequence ( list ) ; 
runMerge ( toScalar , new TestSubscriberEx < > ( ) ) ; 
runMerge ( toHiddenScalar , new TestSubscriberEx < > ( ) ) ; 
for ( final int req : new int [ ] 16 , 32 , 64 , 128 , 256 ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( req ) int remaining = req ; @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( -- remaining == 0 ) remaining = req ; request ( req ) ; ; runMerge ( toScalar , ts ) ; 
for ( final int req : new int [ ] 16 , 32 , 64 , 128 , 256 ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( req ) int remaining = req ; @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( -- remaining == 0 ) remaining = req ; request ( req ) ; ; runMerge ( toHiddenScalar , ts ) ; 
try Flowable . merge ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) , - 1 ) ; fail ( "Expected IllegalArgumentException" ) ; catch ( IllegalArgumentException e ) assertEquals ( "maxConcurrency > 0 required but it was -1" , e . getMessage ( ) ) ; 
try Flowable . merge ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) , 0 ) ; fail ( "Expected IllegalArgumentException" ) ; catch ( IllegalArgumentException e ) assertEquals ( "maxConcurrency > 0 required but it was 0" , e . getMessage ( ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . merge ( Flowable . just ( Flowable . just ( 1 ) ) , 5 ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . merge ( Flowable . just ( Flowable . range ( 1 , 5 ) ) , 5 ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; Flowable . mergeArray ( 1 , 128 , new Flowable [ ] pp1 , pp2 ) . subscribe ( ts ) ; assertTrue ( "ps1 has no subscribers?!" , pp1 . hasSubscribers ( ) ) ; assertFalse ( "ps2 has subscribers?!" , pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; assertFalse ( "ps1 has subscribers?!" , pp1 . hasSubscribers ( ) ) ; assertTrue ( "ps2 has no subscribers?!" , pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . just ( 1 ) ) . flatMap ( ( Function ) Functions . identity ( ) ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . range ( 1 , 5 ) ) . flatMap ( ( Function ) Functions . identity ( ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . just ( 1 ) ) . flatMap ( ( Function ) Functions . identity ( ) , 5 ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . range ( 1 , 5 ) ) . flatMap ( ( Function ) Functions . identity ( ) , 5 ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; FlowableFlatMap . MergeSubscriber < Publisher < Integer > , Integer > ms = new FlowableFlatMap . MergeSubscriber < > ( ts , Functions . < Publisher < Integer > > identity ( ) , false , 128 , 128 ) ; ms . onSubscribe ( new BooleanSubscription ( ) ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ms . onNext ( pp ) ; pp . onNext ( 1 ) ; BackpressureHelper . add ( ms . requested , 2 ) ; pp . onNext ( 2 ) ; ms . drain ( ) ; ts . assertValues ( 1 , 2 ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; FlowableFlatMap . MergeSubscriber < Publisher < Integer > , Integer > ms = new FlowableFlatMap . MergeSubscriber < > ( ts , Functions . < Publisher < Integer > > identity ( ) , false , 128 , 128 ) ; ms . onSubscribe ( new BooleanSubscription ( ) ) ; ms . onNext ( Flowable . just ( 1 ) ) ; BackpressureHelper . add ( ms . requested , 2 ) ; ms . onNext ( Flowable . just ( 2 ) ) ; ms . drain ( ) ; ts . assertValues ( 1 , 2 ) ; 
for ( int i = 1 ; i < 100 ; i ++ ) @ SuppressWarnings ( "unchecked" ) Flowable < Integer > [ ] sources = new Flowable [ i ] ; Arrays . fill ( sources , Flowable . just ( 1 ) ) ; Integer [ ] expected = new Integer [ i ] ; for ( int j = 0 ; j < i ; j ++ ) expected [ j ] = 1 ; Flowable . mergeArray ( sources ) . test ( ) . assertResult ( expected ) ; 
Flowable . mergeArray ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable < Integer > source1 = Flowable . error ( new TestException ( "First" ) ) ; Flowable < Integer > source2 = Flowable . error ( new TestException ( "Second" ) ) ; Flowable . merge ( source1 , source2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 ) ; Single < Boolean > single = w . isEmpty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 ) ; Single < Boolean > single = w . isEmpty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . empty ( ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . empty ( ) ; Single < Boolean > single = w . isEmpty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 , 3 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 , 3 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 , 3 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 1 ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . empty ( ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t ) return true ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > f = Flowable . fromArray ( 1 , 3 , 5 , 6 ) ; Single < Boolean > anyEven = f . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i % 2 == 0 ; ) ; assertTrue ( anyEven . blockingGet ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . isEmpty ( ) . flatMapPublisher ( new Function < Boolean , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Boolean t1 ) return Flowable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ; ) ; assertEquals ( ( Object ) 2 , source . blockingFirst ( ) ) ; 
TestObserverEx < Boolean > to = new TestObserverEx < > ( ) ; Flowable . just ( 1 ) . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; to . assertValue ( true ) ; 
TestObserverEx < Boolean > to = new TestObserverEx < > ( ) ; final IllegalArgumentException ex = new IllegalArgumentException ( ) ; Flowable . just ( "Boo!" ) . any ( new Predicate < String > ( ) @ Override public boolean test ( String v ) throw ex ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( ex ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 ) ; Flowable < Boolean > flowable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( false ) ; verify ( subscriber , times ( 1 ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 ) ; Flowable < Boolean > flowable = w . isEmpty ( ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( true ) ; verify ( subscriber , times ( 1 ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 ) ; Flowable < Boolean > flowable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( false ) ; verify ( subscriber , times ( 1 ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 ) ; Single < Boolean > single = w . isEmpty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . empty ( ) ; Flowable < Boolean > flowable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . empty ( ) ; Flowable < Boolean > flowable = w . isEmpty ( ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Boolean > flowable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( false ) ; verify ( subscriber , times ( 1 ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Boolean > flowable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( false ) ; verify ( subscriber , times ( 1 ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Boolean > flowable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 1 ; ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . empty ( ) ; Flowable < Boolean > flowable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t ) return true ; ) . toFlowable ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > f = Flowable . fromArray ( 1 , 3 , 5 , 6 ) ; Flowable < Boolean > anyEven = f . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i % 2 == 0 ; ) . toFlowable ( ) ; assertTrue ( anyEven . blockingFirst ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . isEmpty ( ) . flatMapPublisher ( new Function < Boolean , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Boolean t1 ) return Flowable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ; ) ; assertEquals ( ( Object ) 2 , source . blockingFirst ( ) ) ; 
TestSubscriber < Boolean > ts = new TestSubscriber < > ( 0L ) ; Flowable . just ( 1 ) . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t ) return true ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
TestSubscriberEx < Boolean > ts = new TestSubscriberEx < > ( 1L ) ; Flowable . just ( 1 ) . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; ts . assertValue ( true ) ; 
TestSubscriberEx < Boolean > ts = new TestSubscriberEx < > ( ) ; final IllegalArgumentException ex = new IllegalArgumentException ( ) ; Flowable . just ( "Boo!" ) . any ( new Predicate < String > ( ) @ Override public boolean test ( String v ) throw ex ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( ex ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . any ( Functions . alwaysTrue ( ) ) . toFlowable ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . any ( Functions . alwaysTrue ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Boolean > > ( ) @ Override public Publisher < Boolean > apply ( Flowable < Object > f ) throws Exception return f . any ( Functions . alwaysTrue ( ) ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Object > , Single < Boolean > > ( ) @ Override public Single < Boolean > apply ( Flowable < Object > f ) throws Exception return f . any ( Functions . alwaysTrue ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new IOException ( ) ) ; subscriber . onComplete ( ) ; . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( "Second" ) ) ; subscriber . onComplete ( ) ; . any ( Functions . alwaysTrue ( ) ) . to ( TestHelper . < Boolean > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; subscriber = TestHelper . mockSubscriber ( ) ; 
Flowable < Flowable < String > > source = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 70 , "one" ) ; publishNext ( subscriber , 100 , "two" ) ; publishCompleted ( subscriber , 200 ) ; ) ) ; publishCompleted ( subscriber , 60 ) ; ) ; Flowable < String > sampled = Flowable . switchOnNext ( source ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 350 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 2 ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Flowable < String > > source = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 10 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 0 , "one" ) ; publishNext ( subscriber , 10 , "two" ) ; publishCompleted ( subscriber , 20 ) ; ) ) ; publishNext ( subscriber , 100 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 0 , "three" ) ; publishNext ( subscriber , 10 , "four" ) ; publishCompleted ( subscriber , 20 ) ; ) ) ; publishCompleted ( subscriber , 200 ) ; ) ; Flowable < String > sampled = Flowable . switchOnNext ( source ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 150 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "four" ) ; scheduler . advanceTimeTo ( 250 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Flowable < String > > source = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 60 , "one" ) ; publishNext ( subscriber , 100 , "two" ) ; ) ) ; publishNext ( subscriber , 200 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 0 , "three" ) ; publishNext ( subscriber , 100 , "four" ) ; ) ) ; publishCompleted ( subscriber , 250 ) ; ) ; Flowable < String > sampled = Flowable . switchOnNext ( source ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 125 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 175 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 225 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 350 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Flowable < String > > source = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , "one" ) ; publishNext ( subscriber , 100 , "two" ) ; ) ) ; publishNext ( subscriber , 200 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 0 , "three" ) ; publishNext ( subscriber , 100 , "four" ) ; ) ) ; publishError ( subscriber , 250 , new TestException ( ) ) ; ) ; Flowable < String > sampled = Flowable . switchOnNext ( source ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 125 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 175 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 225 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 350 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Flowable < Flowable < String > > source = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , "one" ) ; publishNext ( subscriber , 100 , "two" ) ; ) ) ; publishNext ( subscriber , 130 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishCompleted ( subscriber , 0 ) ; ) ) ; publishNext ( subscriber , 150 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , "three" ) ; ) ) ; ) ; Flowable < String > sampled = Flowable . switchOnNext ( source ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 125 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 250 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Flowable < String > > source = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , "one" ) ; publishNext ( subscriber , 100 , "two" ) ; ) ) ; publishNext ( subscriber , 130 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishError ( subscriber , 0 , new TestException ( ) ) ; ) ) ; publishNext ( subscriber , 150 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 50 , "three" ) ; ) ) ; ) ; Flowable < String > sampled = Flowable . switchOnNext ( source ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 125 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 250 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Flowable < Flowable < String > > source = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 0 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 10 , "1-one" ) ; publishNext ( subscriber , 20 , "1-two" ) ; publishNext ( subscriber , 30 , "1-three" ) ; publishCompleted ( subscriber , 40 ) ; ) ) ; publishNext ( subscriber , 25 , Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 10 , "2-one" ) ; publishNext ( subscriber , 20 , "2-two" ) ; publishNext ( subscriber , 30 , "2-three" ) ; publishCompleted ( subscriber , 40 ) ; ) ) ; publishCompleted ( subscriber , 30 ) ; ) ; Flowable < String > sampled = Flowable . switchOnNext ( source ) ; sampled . subscribe ( subscriber ) ; scheduler . advanceTimeTo ( 1000 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "1-one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "1-two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "2-one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "2-two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "2-three" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishProcessor < String > o1 = PublishProcessor . create ( ) ; PublishProcessor < String > o2 = PublishProcessor . create ( ) ; PublishProcessor < String > o3 = PublishProcessor . create ( ) ; PublishProcessor < PublishProcessor < String > > o = PublishProcessor . create ( ) ; publishNext ( o , 0 , o1 ) ; publishNext ( o , 5 , o2 ) ; publishNext ( o , 10 , o3 ) ; publishCompleted ( o , 15 ) ; for ( int i = 0 ; i < 10 ; i ++ ) publishNext ( o1 , i * 5 , "a" + ( i + 1 ) ) ; publishNext ( o2 , 5 + i * 5 , "b" + ( i + 1 ) ) ; publishNext ( o3 , 10 + i * 5 , "c" + ( i + 1 ) ) ; publishCompleted ( o1 , 45 ) ; publishCompleted ( o2 , 50 ) ; publishCompleted ( o3 , 55 ) ; final TestSubscriberEx < String > testSubscriber = new TestSubscriberEx < > ( ) ; Flowable . switchOnNext ( o ) . subscribe ( new DefaultSubscriber < String > ( ) private int requested ; @ Override public void onStart ( ) requested = 3 ; request ( 3 ) ; testSubscriber . onSubscribe ( new BooleanSubscription ( ) ) ; @ Override public void onComplete ( ) testSubscriber . onComplete ( ) ; @ Override public void onError ( Throwable e ) testSubscriber . onError ( e ) ; @ Override public void onNext ( String s ) testSubscriber . onNext ( s ) ; requested -- ; if ( requested == 0 ) requested = 3 ; request ( 3 ) ; ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; testSubscriber . assertValues ( "a1" , "b1" , "c1" , "c2" , "c3" , "c4" , "c5" , "c6" , "c7" , "c8" , "c9" , "c10" ) ; testSubscriber . assertNoErrors ( ) ; testSubscriber . assertTerminated ( ) ; 
final AtomicBoolean isUnsubscribed = new AtomicBoolean ( ) ; Flowable . switchOnNext ( Flowable . unsafeCreate ( new Publisher < Flowable < Integer > > ( ) @ Override public void subscribe ( final Subscriber < ? super Flowable < Integer > > subscriber ) BooleanSubscription bs = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs ) ; subscriber . onNext ( Flowable . just ( 1 ) ) ; isUnsubscribed . set ( bs . isCancelled ( ) ) ; ) ) . take ( 1 ) . subscribe ( ) ; assertTrue ( "Switch doesn't propagate 'unsubscribe'" , isUnsubscribed . get ( ) ) ; 
Flowable < String > oneItem = Flowable . just ( "Hello" ) . mergeWith ( Flowable . < String > never ( ) ) ; Flowable < String > src = oneItem . switchMap ( new Function < String , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final String s ) return Flowable . just ( s ) . mergeWith ( Flowable . interval ( 10 , TimeUnit . MILLISECONDS ) . map ( new Function < Long , String > ( ) @ Override public String apply ( Long i ) return s + " " + i ; ) ) . take ( 250 ) ; ) . share ( ) ; TestSubscriberEx < String > ts = new TestSubscriberEx < String > ( ) @ Override public void onNext ( String t ) super . onNext ( t ) ; if ( values ( ) . size ( ) == 250 ) onComplete ( ) ; dispose ( ) ; ; src . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; System . out . println ( "> testIssue2654: " + ts . values ( ) . size ( ) ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; Assert . assertEquals ( 250 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( 0L ) ; Flowable . switchOnNext ( Flowable . interval ( 100 , TimeUnit . MILLISECONDS ) . map ( new Function < Long , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Long t ) return Flowable . just ( 1L , 2L , 3L ) ; ) . take ( 3 ) ) . subscribe ( ts ) ; ts . request ( Long . MAX_VALUE - 100 ) ; ts . request ( 1 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( 0L ) ; Flowable . switchOnNext ( Flowable . interval ( 100 , TimeUnit . MILLISECONDS ) . map ( new Function < Long , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Long t ) return Flowable . fromIterable ( Arrays . asList ( 1L , 2L , 3L ) ) . hide ( ) ; ) . take ( 3 ) ) . subscribe ( ts ) ; ts . request ( Long . MAX_VALUE - 1 ) ; ts . request ( 2 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertTrue ( ts . values ( ) . size ( ) > 0 ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( 0L ) ; Flowable . switchOnNext ( Flowable . interval ( 100 , TimeUnit . MILLISECONDS ) . map ( new Function < Long , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Long t ) return Flowable . fromIterable ( Arrays . asList ( 1L , 2L , 3L ) ) . hide ( ) ; ) . take ( 3 ) ) . subscribe ( ts ) ; ts . request ( 1 ) ; Thread . sleep ( 250 ) ; ts . request ( Long . MAX_VALUE - 1 ) ; ts . request ( Long . MAX_VALUE - 1 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 7 ) ; 
PublishProcessor < Publisher < Integer > > source = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = source . switchMapDelayError ( Functions . < Publisher < Integer > > identity ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ts . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; source . onNext ( Flowable . just ( 1 ) ) ; source . onNext ( Flowable . < Integer > error ( new TestException ( "Forced failure 1" ) ) ) ; source . onNext ( Flowable . just ( 2 , 3 , 4 ) ) ; source . onNext ( Flowable . < Integer > error ( new TestException ( "Forced failure 2" ) ) ) ; source . onNext ( Flowable . just ( 5 ) ) ; source . onError ( new TestException ( "Forced failure 3" ) ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) . assertNotComplete ( ) . assertError ( CompositeException . class ) ; List < Throwable > errors = ExceptionHelper . flatten ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Forced failure 1" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Forced failure 2" ) ; TestHelper . assertError ( errors , 2 , TestException . class , "Forced failure 3" ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 10 ) . hide ( ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) ; Flowable . switchOnNext ( Flowable . just ( source ) . hide ( ) , 2 ) . test ( 1 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , list ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 10 ) . hide ( ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) ; Flowable . switchOnNextDelayError ( Flowable . just ( source ) . hide ( ) ) . test ( 1 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) , list ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 10 ) . hide ( ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) ; Flowable . switchOnNextDelayError ( Flowable . just ( source ) . hide ( ) , 2 ) . test ( 1 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , list ) ; 
PublishProcessor < Flowable < Integer > > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . switchOnNextDelayError ( pp ) . test ( ) ; pp . onNext ( Flowable . just ( 1 ) ) ; pp . onNext ( Flowable . < Integer > error ( new TestException ( ) ) ) ; pp . onNext ( Flowable . range ( 2 , 4 ) ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
PublishProcessor < Flowable < Integer > > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . switchOnNextDelayError ( pp , 2 ) . test ( ) ; pp . onNext ( Flowable . just ( 1 ) ) ; pp . onNext ( Flowable . range ( 2 , 4 ) ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
assertSame ( Flowable . empty ( ) , Flowable . < Object > empty ( ) . switchMapDelayError ( new Function < Object , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , 16 ) ) ; 
Flowable . just ( 0 ) . switchMapDelayError ( new Function < Object , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , 16 ) . test ( ) . assertResult ( 1 ) ; 
assertSame ( Flowable . empty ( ) , Flowable . < Object > empty ( ) . switchMap ( new Function < Object , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , 16 ) ) ; 
Flowable . just ( 0 ) . switchMap ( new Function < Object , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , 16 ) . test ( ) . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( 1 ) . switchMap ( Functions . justFunction ( pp ) ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestHelper . checkDisposed ( Flowable . switchOnNext ( Flowable . just ( Flowable . just ( 1 ) ) . hide ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; pp1 . switchMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return pp2 ; return Flowable . never ( ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onNext ( 2 ) ; ; final TestException ex = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; for ( Throwable e : errors ) assertTrue ( e . toString ( ) , e instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; pp1 . switchMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return pp2 ; return Flowable . never ( ) ; ) . test ( ) ; final TestException ex1 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; final TestException ex2 = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; for ( Throwable e : errors ) assertTrue ( e . toString ( ) , e instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp1 . switchMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . never ( ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Flowable . just ( 1 ) . hide ( ) . switchMap ( new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . switchMap ( Functions . justFunction ( Flowable . never ( ) ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 5 ) . switchMap ( Functions . justFunction ( Flowable . empty ( ) ) ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 5 ) . switchMap ( Functions . justFunction ( Flowable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; pp . onComplete ( ) ; ; Flowable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( pp ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; pp . onError ( new TestException ( ) ) ; ; Flowable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( pp ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
Flowable . switchOnNext ( Flowable . just ( Flowable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . switchOnNextDelayError ( Flowable . just ( Flowable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . fromCallable ( Functions . justCallable ( 1 ) ) . switchMap ( Functions . justFunction ( Flowable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . switchMap ( Functions . justFunction ( Flowable . just ( 1 ) ) ) ; , false , 1 , 1 , 1 ) ; 
Flowable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; ) , 8 ) . test ( 1L ) . assertFailure ( MissingBackpressureException . class , 0 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( pp ) ) . subscribe ( ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
Flowable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( Flowable . just ( 1 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Object > flowableStripBoundary ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
final PublishProcessor < Integer > main = PublishProcessor . create ( ) ; final PublishProcessor < Integer > inner = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = main . switchMap ( Functions . justFunction ( inner ) ) . test ( ) ; assertTrue ( main . hasSubscribers ( ) ) ; main . onNext ( 1 ) ; assertTrue ( inner . hasSubscribers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( inner . hasSubscribers ( ) ) ; ts . assertFailure ( TestException . class ) ; 
String thread = Thread . currentThread ( ) . getName ( ) ; Flowable . range ( 1 , 10000 ) . switchMap ( new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer v ) throws Exception return Flowable . just ( 2 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer w ) throws Exception return Thread . currentThread ( ) . getName ( ) ; ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNever ( thread ) . assertNoErrors ( ) . assertComplete ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Throwable ts . cancel ( ) ; throw new TestException ( ) ; ) . switchMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 2 ) . switchMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . fromIterable ( Arrays . asList ( v * 10 ) ) ; ) . test ( ) . assertResult ( 10 , 20 ) ; 
Flowable . range ( 1 , 2 ) . switchMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . fromIterable ( Arrays . asList ( v * 10 ) ) . hide ( ) ; ) . test ( ) . assertResult ( 10 , 20 ) ; 
Flowable . just ( 1 ) . hide ( ) . switchMap ( v -> Flowable . fromCallable ( ( ) -> 1 ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . withErrorTracking ( errors -> PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Object > ts = pp . switchMap ( v -> if ( v == 1 ) return Flowable . unsafeCreate ( s -> s . onSubscribe ( new BooleanSubscription ( ) ) ; pp . onNext ( 2 ) ; s . onError ( new TestException ( ) ) ; ) ; return Flowable . never ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . switchMap ( v -> Flowable . never ( ) ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . switchMap ( v -> Flowable . never ( ) ) ) ; 
BehaviorProcessor . createDefault ( Flowable . error ( new TestException ( ) ) ) . switchMap ( v -> v ) . test ( ) . assertFailure ( TestException . class ) ; 
BehaviorProcessor . createDefault ( Flowable . empty ( ) . hide ( ) ) . switchMap ( v -> v ) . test ( ) . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = BehaviorProcessor . createDefault ( pp ) . onBackpressureBuffer ( ) . switchMap ( v -> v ) . test ( 1L ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertValuesOnly ( 1 ) ; 
BehaviorProcessor . createDefault ( Flowable . empty ( ) . hide ( ) ) . switchMapDelayError ( v -> v ) . test ( ) . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = BehaviorProcessor . createDefault ( pp ) . onBackpressureBuffer ( ) . switchMapDelayError ( v -> v ) . test ( 1L ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertValuesOnly ( 1 ) ; 
AtomicInteger outer = new AtomicInteger ( ) ; AtomicInteger inner = new AtomicInteger ( ) ; int n = 10_000 ; for ( int i = 0 ; i < n ; i ++ ) Flowable . < Integer > create ( it -> it . onNext ( 0 ) ; , BackpressureStrategy . MISSING ) . switchMap ( v -> createFlowable ( inner ) ) . observeOn ( Schedulers . computation ( ) ) . doFinally ( ( ) -> outer . incrementAndGet ( ) ; ) . take ( 1 ) . blockingSubscribe ( v -> , Throwable :: printStackTrace ) ; Thread . sleep ( 100 ) ; assertEquals ( inner . get ( ) , outer . get ( ) ) ; assertEquals ( n , inner . get ( ) ) ; 
return Flowable . < Integer > unsafeCreate ( s -> SerializedSubscriber < Integer > it = new SerializedSubscriber < > ( s ) ; it . onSubscribe ( new BooleanSubscription ( ) ) ; Schedulers . io ( ) . scheduleDirect ( ( ) -> it . onNext ( 1 ) ; , 0 , TimeUnit . MILLISECONDS ) ; Schedulers . io ( ) . scheduleDirect ( ( ) -> it . onNext ( 2 ) ; , 0 , TimeUnit . MILLISECONDS ) ; ) . doFinally ( ( ) -> inner . incrementAndGet ( ) ; ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 100 ) ; infinite . take ( 500 ) . subscribe ( ts ) ; assertEquals ( 500 , ts . values ( ) . size ( ) ) ; ts . assertNoErrors ( ) ; 
final CountDownLatch l1 = new CountDownLatch ( 100 ) ; final CountDownLatch l2 = new CountDownLatch ( 150 ) ; TestSubscriber < Long > ts = new TestSubscriber < > ( new DefaultSubscriber < Long > ( ) @ Override protected void onStart ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long t ) l1 . countDown ( ) ; l2 . countDown ( ) ; , 0L ) ; ts . request ( 100 ) ; infinite . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureBuffer ( ) . take ( 500 ) . subscribe ( ts ) ; l1 . await ( ) ; assertEquals ( 100 , ts . values ( ) . size ( ) ) ; ts . request ( 50 ) ; l2 . await ( ) ; assertEquals ( 150 , ts . values ( ) . size ( ) ) ; ts . request ( 350 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 500 , ts . values ( ) . size ( ) ) ; ts . assertNoErrors ( ) ; assertEquals ( 0 , ts . values ( ) . get ( 0 ) . intValue ( ) ) ; assertEquals ( 499 , ts . values ( ) . get ( 499 ) . intValue ( ) ) ; 
Flowable . empty ( ) . onBackpressureBuffer ( - 1 ) ; 
Flowable . empty ( ) . onBackpressureBuffer ( 0 ) ; 
final CountDownLatch l1 = new CountDownLatch ( 100 ) ; final CountDownLatch backpressureCallback = new CountDownLatch ( 1 ) ; TestSubscriber < Long > ts = new TestSubscriber < > ( new DefaultSubscriber < Long > ( ) @ Override protected void onStart ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long t ) l1 . countDown ( ) ; , 0L ) ; ts . request ( 100 ) ; infinite . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureBuffer ( 500 , new Action ( ) @ Override public void run ( ) backpressureCallback . countDown ( ) ; ) . subscribe ( ts ) ; l1 . await ( ) ; ts . request ( 50 ) ; assertTrue ( backpressureCallback . await ( 500 , TimeUnit . MILLISECONDS ) ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) ; ts . assertError ( MissingBackpressureException . class ) ; int size = ts . values ( ) . size ( ) ; assertTrue ( size <= 150 ) ; assertEquals ( ( long ) ts . values ( ) . get ( size - 1 ) , size - 1 ) ; 
final AtomicBoolean errorOccurred = new AtomicBoolean ( false ) ; TestSubscriber < Long > ts = TestSubscriber . create ( 0 ) ; infinite . subscribeOn ( Schedulers . computation ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) errorOccurred . set ( true ) ; ) . onBackpressureBuffer ( 1 , THROWS_NON_FATAL ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertFalse ( errorOccurred . get ( ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; Flowable . range ( 1 , 10 ) . onBackpressureBuffer ( 1 ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( MissingBackpressureException . class ) ; ts . assertNotComplete ( ) ; 
Flowable . empty ( ) . onBackpressureBuffer ( - 1 ) ; 
Flowable . empty ( ) . onBackpressureBuffer ( 0 ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . onBackpressureBuffer ( false ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . onBackpressureBuffer ( true ) . test ( 0L ) . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
TestSubscriber < Integer > ts = Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . onBackpressureBuffer ( 16 , true ) . test ( 0L ) . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 10 ) . onBackpressureBuffer ( ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . < Integer > error ( new TestException ( ) ) . onBackpressureBuffer ( ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 1000 * 1000 ) . onBackpressureBuffer ( ) . observeOn ( Schedulers . single ( ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; Thread . sleep ( 100 ) ; ts . request ( 1000 * 1000 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . empty ( ) . onBackpressureBuffer ( true ) . test ( ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . < Integer > never ( ) . onBackpressureBuffer ( ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertEmpty ( ) ; 
for ( int j = 0 ; j < TestHelper . RACE_LONG_LOOPS ; j ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp . onBackpressureBuffer ( 4 , false , true ) . observeOn ( Schedulers . io ( ) ) . map ( Functions . < Integer > identity ( ) ) . observeOn ( Schedulers . single ( ) ) . firstOrError ( ) . test ( ) ; for ( int i = 0 ; pp . hasSubscribers ( ) ; i ++ ) pp . onNext ( i ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( ! errors . isEmpty ( ) ) throw new CompositeException ( errors ) ; to . assertResult ( 0 ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . onBackpressureBuffer ( ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . onBackpressureBuffer ( ) ) ; 
final AtomicReference < Throwable > receivedException = new AtomicReference < > ( ) ; Flowable < String > w = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onError ( new Throwable ( "injected failure" ) ) ; subscriber . onNext ( "two" ) ; subscriber . onNext ( "three" ) ; ) ; Function < Throwable , Flowable < String > > resume = new Function < Throwable , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Throwable t1 ) receivedException . set ( t1 ) ; return Flowable . just ( "twoResume" , "threeResume" ) ; ; Flowable < String > flowable = w . onErrorResumeNext ( resume ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "threeResume" ) ; assertNotNull ( receivedException . get ( ) ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onError ( new Throwable ( "injected failure" ) ) ; subscriber . onNext ( "two" ) ; subscriber . onNext ( "three" ) ; 
final AtomicReference < Throwable > receivedException = new AtomicReference < > ( ) ; Subscription s = mock ( Subscription . class ) ; TestFlowable w = new TestFlowable ( s , "one" ) ; Function < Throwable , Flowable < String > > resume = new Function < Throwable , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Throwable t1 ) receivedException . set ( t1 ) ; return Flowable . just ( "twoResume" , "threeResume" ) ; ; Flowable < String > flowable = Flowable . unsafeCreate ( w ) . onErrorResumeNext ( resume ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; try w . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "threeResume" ) ; assertNotNull ( receivedException . get ( ) ) ; 
Subscription s = mock ( Subscription . class ) ; TestFlowable w = new TestFlowable ( s , "one" ) ; Function < Throwable , Flowable < String > > resume = new Function < Throwable , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Throwable t1 ) throw new RuntimeException ( "exception from function" ) ; ; Flowable < String > flowable = Flowable . unsafeCreate ( w ) . onErrorResumeNext ( resume ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; try w . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 0 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; w = w . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; System . out . println ( "BadMapper:" + s ) ; return s ; ) ; Flowable < String > flowable = w . onErrorResumeNext ( new Function < Throwable , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Throwable t1 ) return Flowable . just ( "twoResume" , "threeResume" ) . subscribeOn ( Schedulers . computation ( ) ) ; ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber , Long . MAX_VALUE ) ; flowable . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "threeResume" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , 100000 ) . onErrorResumeNext ( new Function < Throwable , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Throwable t1 ) return Flowable . just ( 1 ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t1 ) if ( c ++ <= 1 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . onErrorResumeNext ( new Function < Throwable , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Throwable v ) return Flowable . range ( 3 , 2 ) ; ) . subscribe ( ts ) ; ts . request ( 2 ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onError ( new TestException ( "Forced failure" ) ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 3 , 4 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return Flowable . error ( new IOException ( ) ) . onErrorResumeNext ( Functions . justFunction ( f ) ) ; , false , 1 , 1 , 1 ) ; 
PublishProcessor < Integer > src = PublishProcessor . create ( ) ; Flowable < Integer > dst = src . hide ( ) ; assertFalse ( dst instanceof PublishProcessor ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; dst . subscribe ( subscriber ) ; src . onNext ( 1 ) ; src . onComplete ( ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > src = PublishProcessor . create ( ) ; Flowable < Integer > dst = src . hide ( ) ; assertFalse ( dst instanceof PublishProcessor ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; dst . subscribe ( subscriber ) ; src . onError ( new TestException ( ) ) ; verify ( subscriber , never ( ) ) . onNext ( Mockito . < Integer > any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 5 ) . onBackpressureLatest ( ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . onBackpressureLatest ( ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertError ( TestException . class ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 2L ) ; Flowable . range ( 1 , 5 ) . onBackpressureLatest ( ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNotComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureLatest ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; source . onNext ( 1 ) ; ts . request ( 2 ) ; ts . assertValue ( 1 ) ; source . onNext ( 2 ) ; ts . assertValues ( 1 , 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 6 ) ; source . onNext ( 7 ) ; ts . assertValues ( 1 , 2 , 6 , 7 ) ; source . onNext ( 8 ) ; source . onNext ( 9 ) ; source . onComplete ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 6 , 7 , 9 ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( 1L ) final Random rnd = new Random ( ) ; @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( rnd . nextDouble ( ) < 0.001 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException ex ) ex . printStackTrace ( ) ; request ( 1 ) ; ; int m = 100000 ; Flowable . range ( 1 , m ) . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureLatest ( ) . observeOn ( Schedulers . io ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts . assertTerminated ( ) ; int n = ts . values ( ) . size ( ) ; System . out . println ( "testAsynchronousDrop -> " + n ) ; Assert . assertTrue ( "All events received?" , n < m ) ; int previous = 0 ; for ( Integer current : ts . values ( ) ) Assert . assertTrue ( "The sequence must be increasing [current value=" + previous + ", previous value=" + current + "]" , previous <= current ) ; previous = current ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . onBackpressureLatest ( ) ; ) ; 
Flowable . just ( 1 , 2 ) . onBackpressureLatest ( ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . onBackpressureLatest ( ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . onBackpressureLatest ( ) ) ; 
Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 10 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onNext ( s ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception ) . take ( 5 ) . test ( ) . assertResult ( 10 , 10 , 10 , 10 , 10 ) ; 
Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw new TestException ( ) ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onNext ( s ) ; , Functions . emptyConsumer ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception throw new TestException ( ) ; , Functions . emptyConsumer ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onComplete ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onComplete ( ) ; , Functions . emptyConsumer ( ) ) ) ; 
final int [ ] call = 0 ; Flowable . generate ( Functions . justSupplier ( 1 ) , new BiConsumer < Integer , Emitter < Object > > ( ) @ Override public void accept ( Integer s , Emitter < Object > e ) throws Exception try e . onError ( null ) ; catch ( NullPointerException ex ) call [ 0 ] ++ ; , Functions . emptyConsumer ( ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
TestHelper . assertBadRequestReported ( Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onComplete ( ) ; , Functions . emptyConsumer ( ) ) ) ; 
Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onNext ( 1 ) ; , Functions . emptyConsumer ( ) ) . rebatchRequests ( 1 ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onNext ( 1 ) ; , Functions . emptyConsumer ( ) ) . rebatchRequests ( 1 ) . to ( TestHelper . < Object > testSubscriber ( 5L ) ) . assertSubscribed ( ) . assertValues ( 1 , 1 , 1 , 1 , 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
Flowable < Object > source = Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onNext ( 1 ) ; , Functions . emptyConsumer ( ) ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Object > ts = source . test ( 0L ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 500 ; j ++ ) ts . request ( 1 ) ; ; TestHelper . race ( r , r ) ; ts . assertValueCount ( 1000 ) ; 
Flowable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > e ) throws Exception e . onNext ( 1 ) ; e . onNext ( 2 ) ; ) . test ( 1 ) . assertFailure ( IllegalStateException . class , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > e ) throws Exception e . onError ( new TestException ( "First" ) ) ; e . onError ( new TestException ( "Second" ) ) ; ) . test ( 1 ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > e ) throws Exception e . onComplete ( ) ; e . onComplete ( ) ; ) . test ( 1 ) . assertResult ( ) ; 
Flowable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > e ) throws Exception e . onComplete ( ) ; e . onNext ( 1 ) ; ) . test ( ) . assertResult ( ) ; 
Flowable < String > obs = Flowable . just ( "one" , "two" , "three" ) ; Iterator < String > it = obs . blockingIterable ( ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "two" , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "three" , it . next ( ) ) ; assertFalse ( it . hasNext ( ) ) ; 
Flowable < String > obs = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onError ( new TestException ( ) ) ; ) ; Iterator < String > it = obs . blockingIterable ( ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; it . next ( ) ; 
final Counter src = new Counter ( ) ; Flowable < Integer > obs = Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return src ; ) ; Iterator < Integer > it = obs . blockingIterable ( ) . iterator ( ) ; while ( it . hasNext ( ) ) int i = it . next ( ) ; int expected = i - ( i % ( Flowable . bufferSize ( ) - ( Flowable . bufferSize ( ) > > 2 ) ) ) + Flowable . bufferSize ( ) ; expected = Math . min ( expected , Counter . MAX ) ; assertEquals ( expected , src . count ) ; 
return count < MAX ; 
return ++ count ; 
throw new UnsupportedOperationException ( ) ; 
BlockingFlowableIterator < Integer > it = new BlockingFlowableIterator < > ( 128 ) ; it . remove ( ) ; 
BlockingFlowableIterator < Integer > it = new BlockingFlowableIterator < > ( 128 ) ; assertFalse ( it . isDisposed ( ) ) ; it . dispose ( ) ; assertTrue ( it . isDisposed ( ) ) ; 
BlockingFlowableIterator < Integer > it = new BlockingFlowableIterator < > ( 128 ) ; try Thread . currentThread ( ) . interrupt ( ) ; it . hasNext ( ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
BlockingFlowableIterator < Integer > it = new BlockingFlowableIterator < > ( 128 ) ; it . onComplete ( ) ; it . next ( ) ; 
Iterator < Integer > it = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; . blockingIterable ( 1 ) . iterator ( ) ; it . next ( ) ; 
Iterator < Integer > it = PublishProcessor . < Integer > create ( ) . blockingIterable ( ) . iterator ( ) ; ( ( Disposable ) it ) . dispose ( ) ; assertFalse ( it . hasNext ( ) ) ; it . next ( ) ; 
final Iterator < Integer > it = PublishProcessor . < Integer > create ( ) . blockingIterable ( ) . iterator ( ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) ( ( Disposable ) it ) . dispose ( ) ; , 1 , TimeUnit . SECONDS ) ; assertFalse ( it . hasNext ( ) ) ; 
w = TestHelper . mockSubscriber ( ) ; w2 = TestHelper . mockSubscriber ( ) ; 
Flowable < String > src = Flowable . empty ( ) ; src . distinctUntilChanged ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > src = Flowable . empty ( ) ; src . distinctUntilChanged ( TO_UPPER_WITH_EXCEPTION ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" , "c" , "c" , "b" , "b" , "a" , "e" ) ; src . distinctUntilChanged ( ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "e" ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" , "C" , "c" , "B" , "b" , "a" , "e" ) ; src . distinctUntilChanged ( TO_UPPER_WITH_EXCEPTION ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "B" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "e" ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable . fromArray ( 1 , 2 , 2 , 3 , 2 , 4 , 1 , 1 , 2 ) . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) return a . equals ( b ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 2 , 4 , 1 , 2 ) ; 
Flowable . fromArray ( 1 , 2 , 2 , 3 , 2 , 4 , 1 , 1 , 2 ) . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) return a . equals ( b ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 2 , 4 , 1 , 2 ) ; 
Flowable . fromArray ( 1 , 2 , 2 , 3 , 2 , 4 , 1 , 1 , 2 ) . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) return a . equals ( b ) ; ) . to ( TestHelper . < Integer > testSubscriber ( Long . MAX_VALUE , QueueFuseable . ANY , false ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 2 , 4 , 1 , 2 ) ; 
Flowable . fromArray ( 1 , 2 , 2 , 3 , 2 , 4 , 1 , 1 , 2 ) . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) return a . equals ( b ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . to ( TestHelper . < Integer > testSubscriber ( Long . MAX_VALUE , QueueFuseable . ANY , false ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 2 , 4 , 1 , 2 ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "null" , "c" ) ; final AtomicBoolean errorOccurred = new AtomicBoolean ( false ) ; src . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) errorOccurred . set ( true ) ; ) . distinctUntilChanged ( THROWS_NON_FATAL ) . subscribe ( w ) ; Assert . assertFalse ( errorOccurred . get ( ) ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "B" , "A" , "a" , "C" ) ; TestSubscriber < String > ts = TestSubscriber . create ( ) ; source . distinctUntilChanged ( new BiPredicate < String , String > ( ) @ Override public boolean test ( String a , String b ) return a . compareToIgnoreCase ( b ) == 0 ; ) . subscribe ( ts ) ; ts . assertValues ( "a" , "b" , "A" , "C" ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "B" , "A" , "a" , "C" ) ; TestSubscriber < String > ts = TestSubscriber . create ( ) ; source . distinctUntilChanged ( new BiPredicate < String , String > ( ) @ Override public boolean test ( String a , String b ) throw new TestException ( ) ; ) . subscribe ( ts ) ; ts . assertValue ( "a" ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . just ( 1 , 2 , 2 , 3 , 3 , 4 , 5 ) . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) throws Exception return a . equals ( b ) ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) throws Exception return a . equals ( b ) ; ) . subscribe ( ts ) ; TestHelper . emit ( up , 1 , 2 , 2 , 3 , 3 , 4 , 5 ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override public void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Mutable m = new Mutable ( ) ; PublishProcessor < Mutable > pp = PublishProcessor . create ( ) ; TestSubscriber < Mutable > ts = pp . distinctUntilChanged ( new Function < Mutable , Object > ( ) @ Override public Object apply ( Mutable m ) throws Exception return m . value ; ) . test ( ) ; pp . onNext ( m ) ; m . value = 1 ; pp . onNext ( m ) ; pp . onComplete ( ) ; ts . assertResult ( m , m ) ; 
Flowable . just ( 1 , 2 , 1 , 3 , 3 , 4 , 3 , 5 , 5 ) . distinctUntilChanged ( ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . test ( ) . assertResult ( 2 , 4 ) ; 
Flowable . just ( 1 , 2 , 1 , 3 , 3 , 4 , 3 , 5 , 5 ) . hide ( ) . distinctUntilChanged ( ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . test ( ) . assertResult ( 2 , 4 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestSubscriber < Integer > ts = up . hide ( ) . distinctUntilChanged ( ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . test ( ) ; TestHelper . emit ( up , 1 , 2 , 1 , 3 , 3 , 4 , 3 , 5 , 5 ) ; ts . assertResult ( 2 , 4 ) ; 
Flowable . just ( 1 , 2 , 1 , 3 , 3 , 4 , 3 , 5 , 5 ) . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . just ( 1 , 2 , 1 , 3 , 3 , 4 , 3 , 5 , 5 ) . distinctUntilChanged ( ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 2 , 4 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . distinctUntilChanged ( ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; TestHelper . emit ( up , 1 , 2 , 1 , 3 , 3 , 4 , 3 , 5 , 5 ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 2 , 4 ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . distinctUntilChanged ( ) . filter ( Functions . alwaysTrue ( ) ) ; , false , 1 , 1 , 1 ) ; 
for ( int i = 0 ; i < 10 ; i ++ ) try refCountAsyncActual ( ) ; return ; catch ( AssertionError ex ) if ( i == 9 ) throw ex ; Thread . sleep ( ( int ) ( 200 * ( Math . random ( ) * 10 + 1 ) ) ) ; 
final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger nextCount = new AtomicInteger ( ) ; Flowable < Long > r = Flowable . interval ( 0 , 20 , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribeCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Long > ( ) @ Override public void accept ( Long l ) nextCount . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; Disposable d1 = r . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long l ) receivedCount . incrementAndGet ( ) ; ) ; Disposable d2 = r . subscribe ( ) ; try Thread . sleep ( 10 ) ; catch ( InterruptedException e ) for ( ; ; ) int a = nextCount . get ( ) ; int b = receivedCount . get ( ) ; if ( a > 10 && a < 20 && a == b ) break ; if ( a >= 20 ) break ; try Thread . sleep ( 20 ) ; catch ( InterruptedException e ) d2 . dispose ( ) ; d1 . dispose ( ) ; System . out . println ( "onNext: " + nextCount . get ( ) ) ; assertEquals ( nextCount . get ( ) , receivedCount . get ( ) ) ; assertEquals ( 1 , subscribeCount . get ( ) ) ; 
final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger nextCount = new AtomicInteger ( ) ; Flowable < Integer > r = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribeCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer l ) nextCount . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; Disposable d1 = r . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer l ) receivedCount . incrementAndGet ( ) ; ) ; Disposable d2 = r . subscribe ( ) ; try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) d2 . dispose ( ) ; d1 . dispose ( ) ; System . out . println ( "onNext Count: " + nextCount . get ( ) ) ; assertEquals ( nextCount . get ( ) , receivedCount . get ( ) * 2 ) ; assertEquals ( 2 , subscribeCount . get ( ) ) ; 
final AtomicInteger nextCount = new AtomicInteger ( ) ; Flowable < Integer > r = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer l ) System . out . println ( "onNext --------> " + l ) ; nextCount . incrementAndGet ( ) ; ) . take ( 4 ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; r . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer l ) receivedCount . incrementAndGet ( ) ; ) ; System . out . println ( "onNext: " + nextCount . get ( ) ) ; assertEquals ( 4 , receivedCount . get ( ) ) ; assertEquals ( 4 , receivedCount . get ( ) ) ; 
final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger unsubscribeCount = new AtomicInteger ( ) ; Flowable < Long > r = Flowable . interval ( 0 , 1 , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) System . out . println ( "******************************* Subscribe received" ) ; subscribeCount . incrementAndGet ( ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) System . out . println ( "******************************* Unsubscribe received" ) ; unsubscribeCount . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) TestSubscriber < Long > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Long > ts2 = new TestSubscriber < > ( ) ; r . subscribe ( ts1 ) ; r . subscribe ( ts2 ) ; try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) ts1 . cancel ( ) ; ts2 . cancel ( ) ; ts1 . assertNoErrors ( ) ; ts2 . assertNoErrors ( ) ; assertTrue ( ts1 . values ( ) . size ( ) > 0 ) ; assertTrue ( ts2 . values ( ) . size ( ) > 0 ) ; assertEquals ( 10 , subscribeCount . get ( ) ) ; assertEquals ( 10 , unsubscribeCount . get ( ) ) ; 
final CountDownLatch unsubscribeLatch = new CountDownLatch ( 1 ) ; final CountDownLatch subscribeLatch = new CountDownLatch ( 1 ) ; Flowable < Long > f = synchronousInterval ( ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) System . out . println ( "******************************* Subscribe received" ) ; subscribeLatch . countDown ( ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) System . out . println ( "******************************* Unsubscribe received" ) ; unsubscribeLatch . countDown ( ) ; ) ; TestSubscriberEx < Long > s = new TestSubscriberEx < > ( ) ; f . publish ( ) . refCount ( ) . subscribeOn ( Schedulers . newThread ( ) ) . subscribe ( s ) ; System . out . println ( "send unsubscribe" ) ; subscribeLatch . await ( ) ; s . cancel ( ) ; System . out . println ( "DONE sending unsubscribe ... now waiting" ) ; if ( ! unsubscribeLatch . await ( 3000 , TimeUnit . MILLISECONDS ) ) System . out . println ( "Errors: " + s . errors ( ) ) ; if ( s . errors ( ) . size ( ) > 0 ) s . errors ( ) . get ( 0 ) . printStackTrace ( ) ; fail ( "timed out waiting for unsubscribe" ) ; s . assertNoErrors ( ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) connectUnsubscribeRaceCondition ( ) ; 
final AtomicInteger subUnsubCount = new AtomicInteger ( ) ; Flowable < Long > f = synchronousInterval ( ) . doOnCancel ( new Action ( ) @ Override public void run ( ) System . out . println ( "******************************* Unsubscribe received" ) ; subUnsubCount . decrementAndGet ( ) ; ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) System . out . println ( "******************************* SUBSCRIBE received" ) ; subUnsubCount . incrementAndGet ( ) ; ) ; TestSubscriberEx < Long > s = new TestSubscriberEx < > ( ) ; f . publish ( ) . refCount ( ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( s ) ; System . out . println ( "send unsubscribe" ) ; s . cancel ( ) ; Thread . sleep ( 10 ) ; assertEquals ( 0 , subUnsubCount . get ( ) ) ; System . out . println ( "DONE sending unsubscribe ... now waiting" ) ; System . out . println ( "Errors: " + s . errors ( ) ) ; if ( s . errors ( ) . size ( ) > 0 ) s . errors ( ) . get ( 0 ) . printStackTrace ( ) ; s . assertNoErrors ( ) ; 
return Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( Subscriber < ? super Long > subscriber ) final AtomicBoolean cancel = new AtomicBoolean ( ) ; subscriber . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) @ Override public void cancel ( ) cancel . set ( true ) ; ) ; for ( ; ; ) if ( cancel . get ( ) ) break ; try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) subscriber . onNext ( 1L ) ; ) ; 
final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; final AtomicInteger unsubscriptionCount = new AtomicInteger ( ) ; Flowable < Integer > flowable = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriptionCount . incrementAndGet ( ) ; subscriber . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) @ Override public void cancel ( ) unsubscriptionCount . incrementAndGet ( ) ; ) ; ) ; Flowable < Integer > refCounted = flowable . publish ( ) . refCount ( ) ; Disposable first = refCounted . subscribe ( ) ; assertEquals ( 1 , subscriptionCount . get ( ) ) ; Disposable second = refCounted . subscribe ( ) ; assertEquals ( 1 , subscriptionCount . get ( ) ) ; first . dispose ( ) ; assertEquals ( 0 , unsubscriptionCount . get ( ) ) ; second . dispose ( ) ; assertEquals ( 1 , unsubscriptionCount . get ( ) ) ; 
TestScheduler s = new TestScheduler ( ) ; Flowable < Long > interval = Flowable . interval ( 100 , TimeUnit . MILLISECONDS , s ) . publish ( ) . refCount ( ) ; final List < Long > list1 = new ArrayList < > ( ) ; Disposable d1 = interval . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long t1 ) list1 . add ( t1 ) ; ) ; s . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , list1 . size ( ) ) ; assertEquals ( 0L , list1 . get ( 0 ) . longValue ( ) ) ; assertEquals ( 1L , list1 . get ( 1 ) . longValue ( ) ) ; final List < Long > list2 = new ArrayList < > ( ) ; Disposable d2 = interval . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long t1 ) list2 . add ( t1 ) ; ) ; s . advanceTimeBy ( 300 , TimeUnit . MILLISECONDS ) ; assertEquals ( 5 , list1 . size ( ) ) ; assertEquals ( 2L , list1 . get ( 2 ) . longValue ( ) ) ; assertEquals ( 3L , list1 . get ( 3 ) . longValue ( ) ) ; assertEquals ( 4L , list1 . get ( 4 ) . longValue ( ) ) ; assertEquals ( 3 , list2 . size ( ) ) ; assertEquals ( 2L , list2 . get ( 0 ) . longValue ( ) ) ; assertEquals ( 3L , list2 . get ( 1 ) . longValue ( ) ) ; assertEquals ( 4L , list2 . get ( 2 ) . longValue ( ) ) ; d1 . dispose ( ) ; s . advanceTimeBy ( 300 , TimeUnit . MILLISECONDS ) ; assertEquals ( 5 , list1 . size ( ) ) ; assertEquals ( 6 , list2 . size ( ) ) ; assertEquals ( 5L , list2 . get ( 3 ) . longValue ( ) ) ; assertEquals ( 6L , list2 . get ( 4 ) . longValue ( ) ) ; assertEquals ( 7L , list2 . get ( 5 ) . longValue ( ) ) ; d2 . dispose ( ) ; s . advanceTimeBy ( 1000 , TimeUnit . MILLISECONDS ) ; final List < Long > list3 = new ArrayList < > ( ) ; interval . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long t1 ) list3 . add ( t1 ) ; ) ; s . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , list3 . size ( ) ) ; assertEquals ( 0L , list3 . get ( 0 ) . longValue ( ) ) ; assertEquals ( 1L , list3 . get ( 1 ) . longValue ( ) ) ; 
Subscriber < Integer > done = CancelledSubscriber . INSTANCE ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < Integer > result = Flowable . just ( 1 ) . publish ( ) . refCount ( ) ; result . subscribe ( done ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . create ( ) ; Subscriber < Integer > done = CancelledSubscriber . INSTANCE ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; Flowable < Integer > result = source . publish ( ) . refCount ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; result . subscribe ( done ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > f1 = Flowable . just ( 10 ) ; Flowable < Integer > f2 = Flowable . just ( 20 ) ; Flowable < Integer > combined = Flowable . combineLatest ( f1 , f2 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . publish ( ) . refCount ( ) ; TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ) ; combined . subscribe ( ts1 ) ; combined . subscribe ( ts2 ) ; ts1 . assertTerminated ( ) ; ts1 . assertNoErrors ( ) ; ts1 . assertValue ( 30 ) ; ts2 . assertTerminated ( ) ; ts2 . assertNoErrors ( ) ; ts2 . assertValue ( 30 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicInteger intervalSubscribed = new AtomicInteger ( ) ; Flowable < String > interval = Flowable . interval ( 200 , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) System . out . println ( "Subscribing to interval " + intervalSubscribed . incrementAndGet ( ) ) ; ) . flatMap ( new Function < Long , Publisher < String > > ( ) @ Override public Publisher < String > apply ( Long t1 ) return Flowable . defer ( new Supplier < Publisher < String > > ( ) @ Override public Publisher < String > get ( ) return Flowable . < String > error ( new TestException ( "Some exception" ) ) ; ) ; ) . onErrorResumeNext ( new Function < Throwable , Publisher < String > > ( ) @ Override public Publisher < String > apply ( Throwable t1 ) return Flowable . error ( t1 ) ; ) . publish ( ) . refCount ( ) ; interval . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) System . out . println ( "Subscriber 1 onError: " + t1 ) ; ) . retry ( 5 ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) System . out . println ( "Subscriber 1: " + t1 ) ; ) ; Thread . sleep ( 100 ) ; interval . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) System . out . println ( "Subscriber 2 onError: " + t1 ) ; ) . retry ( 5 ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) System . out . println ( "Subscriber 2: " + t1 ) ; ) ; Thread . sleep ( 1300 ) ; System . out . println ( intervalSubscribed . get ( ) ) ; assertEquals ( 6 , intervalSubscribed . get ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
s . cancel ( ) ; 
$EMPTY$
$EMPTY$
$EMPTY$
TestHelper . checkDisposed ( Flowable . just ( 1 ) . publish ( ) . refCount ( ) ) ; 
final int [ ] calls = 0 ; Flowable < Integer > f = new ConnectableFlowable < Integer > ( ) @ Override public void connect ( Consumer < ? super Disposable > connection ) calls [ 0 ] ++ ; @ Override public void reset ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; . refCount ( ) ; f . test ( ) ; f . test ( ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
calls [ 0 ] ++ ; 
$EMPTY$
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; 
Thread . sleep ( 100 ) ; System . gc ( ) ; Thread . sleep ( 100 ) ; long start = ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; source = Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return new byte [ 100 * 1000 * 1000 ] ; ) . replay ( 1 ) . refCount ( ) ; source . subscribe ( ) ; long after = TestHelper . awaitGC ( GC_SLEEP_TIME , 20 , start + 20 * 1000 * 1000 ) ; source = null ; assertTrue ( String . format ( "%,3d -> %,3d%n" , start , after ) , start + 20 * 1000 * 1000 > after ) ; 
Thread . sleep ( 100 ) ; System . gc ( ) ; Thread . sleep ( 100 ) ; long start = ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; source = Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return new byte [ 100 * 1000 * 1000 ] ; ) . concatWith ( Flowable . never ( ) ) . replay ( 1 ) . refCount ( ) ; Disposable d1 = source . subscribe ( ) ; Disposable d2 = source . subscribe ( ) ; d1 . dispose ( ) ; d2 . dispose ( ) ; d1 = null ; d2 = null ; long after = TestHelper . awaitGC ( GC_SLEEP_TIME , 20 , start + 20 * 1000 * 1000 ) ; source = null ; assertTrue ( String . format ( "%,3d -> %,3d%n" , start , after ) , start + 20 * 1000 * 1000 > after ) ; 
System . gc ( ) ; Thread . sleep ( GC_SLEEP_TIME ) ; source = Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new ExceptionData ( new byte [ 100 * 1000 * 1000 ] ) ; ) . publish ( ) . refCount ( ) ; long start = ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; source . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; long after = TestHelper . awaitGC ( GC_SLEEP_TIME , 20 , start + 20 * 1000 * 1000 ) ; source = null ; assertTrue ( String . format ( "%,3d -> %,3d%n" , start , after ) , start + 20 * 1000 * 1000 > after ) ; 
System . gc ( ) ; Thread . sleep ( GC_SLEEP_TIME ) ; long start = ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; source = Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return new byte [ 100 * 1000 * 1000 ] ; ) . concatWith ( Flowable . never ( ) ) . publish ( ) . refCount ( ) ; TestSubscriber < Object > d1 = source . test ( ) ; TestSubscriber < Object > d2 = source . test ( ) ; d1 . cancel ( ) ; d2 . cancel ( ) ; d1 = null ; d2 = null ; long after = TestHelper . awaitGC ( GC_SLEEP_TIME , 20 , start + 20 * 1000 * 1000 ) ; source = null ; assertTrue ( String . format ( "%,3d -> %,3d%n" , start , after ) , start + 20 * 1000 * 1000 > after ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . replay ( ) ; if ( cf instanceof Disposable ) assertTrue ( ( ( Disposable ) cf ) . isDisposed ( ) ) ; Disposable connection = cf . connect ( ) ; assertFalse ( ( ( Disposable ) cf ) . isDisposed ( ) ) ; connection . dispose ( ) ; assertTrue ( ( ( Disposable ) cf ) . isDisposed ( ) ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
$EMPTY$
throw new TestException ( "subscribeActual" ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
throw new TestException ( "dispose" ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; 
throw new TestException ( "connect" ) ; 
$EMPTY$
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BadFlowableSubscribe bo = new BadFlowableSubscribe ( ) ; try bo . refCount ( ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . getCause ( ) instanceof TestException ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
BadFlowableDispose bf = new BadFlowableDispose ( ) ; try bf . refCount ( ) . test ( ) . cancel ( ) ; fail ( "Should have thrown" ) ; catch ( TestException expected ) 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BadFlowableConnect bf = new BadFlowableConnect ( ) ; try bf . refCount ( ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . getCause ( ) instanceof TestException ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
$EMPTY$
if ( ++ count == 1 ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; else throw new TestException ( "subscribeActual" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BadFlowableSubscribe2 bf = new BadFlowableSubscribe2 ( ) ; Flowable < Object > f = bf . refCount ( ) ; f . test ( ) ; try f . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . getCause ( ) instanceof TestException ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
throw new TestException ( "dispose" ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BadFlowableConnect2 bf = new BadFlowableConnect2 ( ) ; try bf . refCount ( ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . getCause ( ) instanceof TestException ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
BehaviorProcessor < Integer > bp = BehaviorProcessor . createDefault ( 1 ) ; Flowable < Integer > f = bp . replay ( 1 ) . refCount ( ) ; f . subscribe ( ) ; final AtomicBoolean interrupted = new AtomicBoolean ( ) ; f . switchMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > emitter ) throws Exception while ( ! emitter . isCancelled ( ) ) Thread . sleep ( 100 ) ; interrupted . set ( true ) ; , BackpressureStrategy . MISSING ) ; ) . takeUntil ( Flowable . timer ( 500 , TimeUnit . MILLISECONDS ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; assertTrue ( interrupted . get ( ) ) ; 
final int [ ] subscriptions = 0 ; Flowable < Integer > source = Flowable . range ( 1 , 5 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception subscriptions [ 0 ] ++ ; ) . publish ( ) . refCount ( 2 ) ; for ( int i = 0 ; i < 3 ; i ++ ) TestSubscriber < Integer > ts1 = source . test ( ) ; ts1 . assertEmpty ( ) ; TestSubscriber < Integer > ts2 = source . test ( ) ; ts1 . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; ts2 . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 3 , subscriptions [ 0 ] ) ; 
final int [ ] subscriptions = 0 ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable < Integer > source = pp . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception subscriptions [ 0 ] ++ ; ) . publish ( ) . refCount ( 500 , TimeUnit . MILLISECONDS ) ; TestSubscriber < Integer > ts1 = source . test ( 0 ) ; assertEquals ( 1 , subscriptions [ 0 ] ) ; ts1 . cancel ( ) ; Thread . sleep ( 100 ) ; ts1 = source . test ( 0 ) ; assertEquals ( 1 , subscriptions [ 0 ] ) ; Thread . sleep ( 500 ) ; assertEquals ( 1 , subscriptions [ 0 ] ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onNext ( 3 ) ; pp . onNext ( 4 ) ; pp . onNext ( 5 ) ; pp . onComplete ( ) ; ts1 . requestMore ( 5 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
final int [ ] subscriptions = 0 ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable < Integer > source = pp . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception subscriptions [ 0 ] ++ ; ) . publish ( ) . refCount ( 1 , 100 , TimeUnit . MILLISECONDS ) ; TestSubscriber < Integer > ts1 = source . test ( 0 ) ; assertEquals ( 1 , subscriptions [ 0 ] ) ; ts1 . cancel ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; Thread . sleep ( 200 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Flowable . < Integer > error ( new IOException ( ) ) . publish ( ) . refCount ( 500 , TimeUnit . MILLISECONDS ) . test ( ) . assertFailure ( IOException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable < Integer > source = pp . publish ( ) . refCount ( 1 ) ; TestSubscriber < Integer > ts1 = source . test ( 0 ) ; assertTrue ( pp . hasSubscribers ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) TestSubscriber < Integer > ts2 = source . test ( ) ; ts1 . cancel ( ) ; ts1 = ts2 ; ts1 . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) final Flowable < Integer > source = Flowable . range ( 1 , 5 ) . replay ( ) . refCount ( 1 ) ; final TestSubscriber < Integer > ts1 = source . test ( 0 ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) source . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 , Schedulers . single ( ) ) ; ts2 . requestMore ( 6 ) . withTag ( "Round: " + i ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
$EMPTY$
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; subscriber . onComplete ( ) ; subscriber . onError ( new TestException ( ) ) ; 
$EMPTY$
return false ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new BadFlowableDoubleOnX ( ) . refCount ( ) . test ( ) . assertResult ( ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new BadFlowableDoubleOnX ( ) . refCount ( 1 ) . test ( ) . assertResult ( ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new BadFlowableDoubleOnX ( ) . refCount ( 5 , TimeUnit . SECONDS , Schedulers . single ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
FlowableRefCount < Object > o = ( FlowableRefCount < Object > ) PublishProcessor . create ( ) . publish ( ) . refCount ( ) ; o . cancel ( null ) ; RefConnection rc = new RefConnection ( o ) ; o . connection = null ; rc . subscriberCount = 0 ; o . timeout ( rc ) ; rc . subscriberCount = 1 ; o . timeout ( rc ) ; o . connection = rc ; o . timeout ( rc ) ; rc . subscriberCount = 0 ; o . timeout ( rc ) ; rc . subscriberCount = 2 ; rc . connected = false ; o . connection = rc ; o . cancel ( rc ) ; rc . subscriberCount = 1 ; rc . connected = false ; o . connection = rc ; o . cancel ( rc ) ; rc . subscriberCount = 2 ; rc . connected = true ; o . connection = rc ; o . cancel ( rc ) ; rc . subscriberCount = 1 ; rc . connected = true ; o . connection = rc ; rc . set ( null ) ; o . cancel ( rc ) ; o . connection = rc ; o . cancel ( new RefConnection ( o ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) Flowable < Integer > flowable = Flowable . just ( 1 ) . replay ( 1 ) . refCount ( ) ; TestSubscriber < Integer > ts1 = flowable . subscribeOn ( Schedulers . io ( ) ) . test ( ) ; TestSubscriber < Integer > ts2 = flowable . subscribeOn ( Schedulers . io ( ) ) . test ( ) ; ts1 . withTag ( "" + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; ts2 . withTag ( "" + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestConnectableFlowable < Object > tcf = new TestConnectableFlowable < > ( ) ; FlowableRefCount < Object > o = ( FlowableRefCount < Object > ) tcf . refCount ( ) ; RefConnection rc = new RefConnection ( o ) ; rc . set ( Disposable . empty ( ) ) ; o . connection = rc ; o . timeout ( rc ) ; assertTrue ( tcf . reset ) ; 
BehaviorProcessor < Integer > processor = BehaviorProcessor . create ( ) ; Flowable < Integer > flowable = processor . replay ( 1 ) . refCount ( ) ; flowable . takeUntil ( Flowable . just ( 1 ) ) . test ( ) ; processor . onNext ( 2 ) ; flowable . take ( 1 ) . test ( ) . assertResult ( 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) Flowable < Integer > flowable = Flowable . just ( 1 ) . publish ( ) . refCount ( ) ; TestSubscriber < Integer > subscriber1 = flowable . subscribeOn ( Schedulers . io ( ) ) . test ( ) ; TestSubscriber < Integer > subscriber2 = flowable . subscribeOn ( Schedulers . io ( ) ) . test ( ) ; subscriber1 . withTag ( "subscriber1 " + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; subscriber2 . withTag ( "subscriber2 " + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . create ( ) ; rp . onNext ( 1 ) ; rp . onComplete ( ) ; Flowable < Integer > shared = rp . share ( ) ; shared . buffer ( shared . debounce ( 5 , TimeUnit . SECONDS ) ) . test ( ) . assertValueCount ( 2 ) ; shared . buffer ( shared . debounce ( 5 , TimeUnit . SECONDS ) ) . test ( ) . assertValueCount ( 2 ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; Single < String > single = Flowable . just ( "Hello World!" ) . single ( "" ) ; single . toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertResult ( "Hello World!" ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; IllegalArgumentException error = new IllegalArgumentException ( "Error" ) ; Single < String > single = Flowable . < String > error ( error ) . single ( "" ) ; single . toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertError ( error ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; Single < String > single = Flowable . just ( "First" , "Second" ) . single ( "" ) ; single . toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertError ( IllegalArgumentException . class ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; Single < String > single = Flowable . < String > empty ( ) . single ( "" ) ; single . toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertResult ( "" ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; Single < String > single = Flowable . just ( "First" , "Second" ) . repeat ( ) . single ( "" ) ; single . toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertError ( IllegalArgumentException . class ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; final AtomicBoolean unsubscribed = new AtomicBoolean ( false ) ; Single < String > single = Flowable . just ( "Hello World!" ) . doOnCancel ( new Action ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; ) . single ( "" ) ; single . toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertComplete ( ) ; Assert . assertFalse ( unsubscribed . get ( ) ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > m = source . skipUntil ( other ) ; m . subscribe ( subscriber ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; other . onNext ( 100 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 4 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > m = source . skipUntil ( Flowable . never ( ) ) ; m . subscribe ( subscriber ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > m = source . skipUntil ( Flowable . empty ( ) ) ; m . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > m = source . skipUntil ( other ) ; m . subscribe ( subscriber ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; other . onNext ( 100 ) ; other . onComplete ( ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 4 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > m = source . skipUntil ( other ) ; m . subscribe ( subscriber ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; other . onNext ( 100 ) ; other . onComplete ( ) ; source . onNext ( 2 ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > m = source . skipUntil ( other ) ; m . subscribe ( subscriber ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; other . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . skipUntil ( PublishProcessor . create ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . skipUntil ( Flowable . never ( ) ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return Flowable . never ( ) . skipUntil ( f ) ; ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
Flowable < String > flowable1 = createFlowable ( new String [ ] "1" , "11" , "111" , "1111" , 2000 , null ) ; Flowable < String > flowable2 = createFlowable ( new String [ ] "2" , "22" , "222" , "2222" , 1000 , null ) ; Flowable < String > flowable3 = createFlowable ( new String [ ] "3" , "33" , "333" , "3333" , 3000 , null ) ; Flowable < String > f = Flowable . ambArray ( flowable1 , flowable2 , flowable3 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; f . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 100000 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "22" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "222" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "2222" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
IOException expectedException = new IOException ( "fake exception" ) ; Flowable < String > flowable1 = createFlowable ( new String [ ] , 2000 , new IOException ( "fake exception" ) ) ; Flowable < String > flowable2 = createFlowable ( new String [ ] "2" , "22" , "222" , "2222" , 1000 , expectedException ) ; Flowable < String > flowable3 = createFlowable ( new String [ ] , 3000 , new IOException ( "fake exception" ) ) ; Flowable < String > f = Flowable . ambArray ( flowable1 , flowable2 , flowable3 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; f . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 100000 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "22" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "222" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "2222" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( expectedException ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < String > flowable1 = createFlowable ( new String [ ] "1" , 2000 , null ) ; Flowable < String > flowable2 = createFlowable ( new String [ ] , 1000 , null ) ; Flowable < String > flowable3 = createFlowable ( new String [ ] "3" , 3000 , null ) ; Flowable < String > f = Flowable . ambArray ( flowable1 , flowable2 , flowable3 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; f . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 100000 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 3 ) ; final AtomicLong requested1 = new AtomicLong ( ) ; final AtomicLong requested2 = new AtomicLong ( ) ; Flowable < Integer > f1 = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) System . out . println ( "1-requested: " + n ) ; requested1 . set ( n ) ; @ Override public void cancel ( ) ) ; ) ; Flowable < Integer > f2 = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) System . out . println ( "2-requested: " + n ) ; requested2 . set ( n ) ; @ Override public void cancel ( ) ) ; ) ; Flowable . ambArray ( f1 , f2 ) . subscribe ( ts ) ; assertEquals ( 3 , requested1 . get ( ) ) ; assertEquals ( 3 , requested2 . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , Flowable . bufferSize ( ) * 2 ) . ambWith ( Flowable . range ( 0 , Flowable . bufferSize ( ) * 2 ) ) . observeOn ( Schedulers . computation ( ) ) . delay ( 1 , TimeUnit . MICROSECONDS ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; 
final AtomicLong count = new AtomicLong ( ) ; Consumer < Subscription > incrementer = new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) count . incrementAndGet ( ) ; ; Flowable < Integer > f1 = Flowable . just ( 1 ) . doOnSubscribe ( incrementer ) . delay ( 100 , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable < Integer > f2 = Flowable . just ( 1 ) . doOnSubscribe ( incrementer ) . delay ( 100 , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . ambArray ( f1 , f2 ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( 2 , count . get ( ) ) ; 
Flowable < Integer > f1 = Flowable . fromArray ( 1 , 2 , 3 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable < Integer > f2 = Flowable . fromArray ( 4 , 5 , 6 ) . delay ( 200 , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 1L ) ; Flowable . ambArray ( f1 , f2 ) . subscribe ( ts ) ; ts . request ( 20 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
int result = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) ) . ambWith ( Flowable . just ( 2 ) ) . blockingSingle ( ) ; assertEquals ( 1 , result ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source3 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . ambArray ( source1 , source2 , source3 ) . subscribe ( ts ) ; assertTrue ( "Source 1 doesn't have subscribers!" , source1 . hasSubscribers ( ) ) ; assertTrue ( "Source 2 doesn't have subscribers!" , source2 . hasSubscribers ( ) ) ; assertTrue ( "Source 3 doesn't have subscribers!" , source3 . hasSubscribers ( ) ) ; source1 . onNext ( 1 ) ; assertTrue ( "Source 1 doesn't have subscribers!" , source1 . hasSubscribers ( ) ) ; assertFalse ( "Source 2 still has subscribers!" , source2 . hasSubscribers ( ) ) ; assertFalse ( "Source 2 still has subscribers!" , source3 . hasSubscribers ( ) ) ; 
TestSubscriber < Long > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Long > ts2 = new TestSubscriber < > ( ) ; Flowable < Long > amb = Flowable . timer ( 100 , TimeUnit . MILLISECONDS ) . ambWith ( Flowable . timer ( 200 , TimeUnit . MILLISECONDS ) ) ; amb . subscribe ( ts1 ) ; amb . subscribe ( ts2 ) ; ts1 . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts2 . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts1 . assertValue ( 0L ) ; ts1 . assertComplete ( ) ; ts1 . assertNoErrors ( ) ; ts2 . assertValue ( 0L ) ; ts2 . assertComplete ( ) ; ts2 . assertNoErrors ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . amb ( Arrays . asList ( pp1 , pp2 ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . amb ( Arrays . asList ( pp1 , pp2 ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; ts . assertValue ( 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
assertSame ( Flowable . empty ( ) , Flowable . ambArray ( ) ) ; 
assertSame ( Flowable . never ( ) , Flowable . ambArray ( Flowable . never ( ) ) ) ; 
TestHelper . checkDisposed ( Flowable . ambArray ( Flowable . never ( ) , Flowable . never ( ) ) ) ; 
Flowable < ? > [ ] a = new Flowable [ 32 ] ; Arrays . fill ( a , Flowable . never ( ) ) ; a [ 31 ] = Flowable . just ( 1 ) ; Flowable . amb ( Arrays . asList ( a ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . amb ( Collections . < Flowable < Integer > > emptyList ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . amb ( Collections . singletonList ( Flowable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = Flowable . ambArray ( pp1 , pp2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertSubscribed ( ) . assertNoErrors ( ) . assertNotComplete ( ) . assertValueCount ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . ambArray ( pp1 , pp2 ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . ambArray ( pp1 , pp2 ) . test ( ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex ) ; ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestHelper . race ( r1 , r2 ) ; finally RxJavaPlugins . reset ( ) ; ts . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; 
Flowable . amb ( Arrays . asList ( Flowable . never ( ) , null , Flowable . never ( ) ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable . amb ( new CrashingMappedIterable < > ( 1 , 100 , 100 , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . never ( ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; Flowable . amb ( new CrashingMappedIterable < > ( 100 , 1 , 100 , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . never ( ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; Flowable . amb ( new CrashingMappedIterable < > ( 100 , 100 , 1 , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . never ( ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Flowable < Integer > error = Flowable . error ( new RuntimeException ( ) ) ; Flowable . just ( 1 ) . ambWith ( error ) . test ( ) . assertValue ( 1 ) . assertComplete ( ) ; 
Flowable < Integer > error = Flowable . error ( new RuntimeException ( ) ) ; Flowable . amb ( Arrays . asList ( Flowable . just ( 1 ) , error ) ) . test ( ) . assertValue ( 1 ) . assertComplete ( ) ; 
Flowable < Integer > error = Flowable . error ( new RuntimeException ( ) ) ; Flowable . ambArray ( Flowable . just ( 1 ) , error ) . test ( ) . assertValue ( 1 ) . assertComplete ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Flowable . ambArray ( Flowable . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Flowable . never ( ) ) . subscribe ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Flowable . ambArray ( Flowable . error ( ex ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Flowable . never ( ) ) . subscribe ( Functions . emptyConsumer ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Flowable . ambArray ( Flowable . empty ( ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Flowable . never ( ) ) . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
Publisher < Integer > source = new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) Flowable . just ( 1 ) . subscribe ( subscriber ) ; ; Flowable . amb ( Arrays . asList ( source , source ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . assertBadRequestReported ( Flowable . amb ( Arrays . asList ( Flowable . never ( ) , Flowable . never ( ) ) ) ) ; 
Flowable . amb ( Arrays . asList ( Flowable . never ( ) , Flowable . never ( ) ) ) . subscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onNext ( @ NonNull Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( @ NonNull Subscription s ) s . cancel ( ) ; s . request ( 1 ) ; ) ; 
FlowableProcessor < String > s = PublishProcessor . create ( ) ; Iterator < String > it = s . blockingMostRecent ( "default" ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "default" , it . next ( ) ) ; assertEquals ( "default" , it . next ( ) ) ; s . onNext ( "one" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; s . onNext ( "two" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "two" , it . next ( ) ) ; assertEquals ( "two" , it . next ( ) ) ; s . onComplete ( ) ; assertFalse ( it . hasNext ( ) ) ; 
FlowableProcessor < String > s = PublishProcessor . create ( ) ; Iterator < String > it = s . blockingMostRecent ( "default" ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "default" , it . next ( ) ) ; assertEquals ( "default" , it . next ( ) ) ; s . onError ( new TestException ( ) ) ; assertTrue ( it . hasNext ( ) ) ; it . next ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Long > source = Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 10 ) ; Iterable < Long > iter = source . blockingMostRecent ( - 1L ) ; for ( int j = 0 ; j < 3 ; j ++ ) Iterator < Long > it = iter . iterator ( ) ; Assert . assertEquals ( Long . valueOf ( - 1 ) , it . next ( ) ) ; for ( int i = 0 ; i < 9 ; i ++ ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertTrue ( it . hasNext ( ) ) ; Assert . assertEquals ( Long . valueOf ( i ) , it . next ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertFalse ( it . hasNext ( ) ) ; 
Iterator < Integer > it = Flowable . < Integer > empty ( ) . blockingMostRecent ( 1 ) . iterator ( ) ; try it . next ( ) ; fail ( "Should have thrown" ) ; catch ( NoSuchElementException ex ) try it . remove ( ) ; fail ( "Should have thrown" ) ; catch ( UnsupportedOperationException ex ) 
o = new Object ( ) ; WeakReference < Object > wr = new WeakReference < > ( o ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . just ( o ) . count ( ) . toFlowable ( ) . onTerminateDetach ( ) . subscribe ( ts ) ; ts . assertValue ( 1L ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; o = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; Assert . assertNull ( "Object retained!" , wr . get ( ) ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . error ( new TestException ( ) ) . onTerminateDetach ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . empty ( ) . onTerminateDetach ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 1000 ) . onTerminateDetach ( ) . subscribe ( ts ) ; ts . assertValueCount ( 1000 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
o = new Object ( ) ; WeakReference < Object > wr = new WeakReference < > ( o ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( 0L ) ; Flowable . just ( o ) . count ( ) . toFlowable ( ) . onTerminateDetach ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1L ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; o = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; Assert . assertNull ( "Object retained!" , wr . get ( ) ) ; 
o = new Object ( ) ; WeakReference < Object > wr = new WeakReference < > ( o ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( 0 ) ; Flowable . just ( o ) . count ( ) . toFlowable ( ) . onTerminateDetach ( ) . subscribe ( ts ) ; ts . cancel ( ) ; o = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; Assert . assertNull ( "Object retained!" , wr . get ( ) ) ; 
final AtomicReference < Subscriber < ? super Object > > subscriber = new AtomicReference < > ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( 0 ) ; Flowable . unsafeCreate ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > t ) subscriber . set ( t ) ; ) . onTerminateDetach ( ) . subscribe ( ts ) ; ts . request ( 2 ) ; new FlowableRange ( 1 , 3 ) . subscribe ( subscriber . get ( ) ) ; ts . assertValues ( 1 , 2 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . onTerminateDetach ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . onTerminateDetach ( ) ; ) ; 
return ( list , number ) -> list . add ( number ) ; return list ; ; 
return ArrayList :: new ; 
TestSubscriberEx < List < Integer > > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 5 ) . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValues ( Collections . singletonList ( 1 ) , Collections . singletonList ( 2 ) , Collections . singletonList ( 3 ) , Collections . singletonList ( 4 ) , Collections . singletonList ( 5 ) ) ; 
TestSubscriberEx < List < Integer > > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Flowable . error ( new TestException ( ) ) ) . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertError ( TestException . class ) ; ts . assertValues ( Collections . singletonList ( 1 ) , Collections . singletonList ( 2 ) , Collections . singletonList ( 3 ) , Collections . singletonList ( 4 ) , Collections . singletonList ( 5 ) ) ; 
TestSubscriberEx < List < Integer > > ts = new TestSubscriberEx < > ( 2L ) ; Flowable . range ( 1 , 5 ) . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValues ( Collections . singletonList ( 1 ) , Collections . singletonList ( 2 ) ) ; ts . assertNotComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureReduce ( ( ) -> 0 , Integer :: sum ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; ts . request ( 1 ) ; ts . assertValuesOnly ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; ts . assertValuesOnly ( 6 ) ; ts . request ( 1 ) ; ts . assertResult ( 6 , 4 ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < List < Integer > > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; source . onNext ( 1 ) ; ts . request ( 2 ) ; ts . assertValues ( Collections . singletonList ( 1 ) ) ; source . onNext ( 2 ) ; ts . assertValues ( Collections . singletonList ( 1 ) , Collections . singletonList ( 2 ) ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; ts . request ( 2 ) ; ts . assertValues ( Collections . singletonList ( 1 ) , Collections . singletonList ( 2 ) , Arrays . asList ( 3 , 4 , 5 , 6 ) ) ; source . onNext ( 7 ) ; ts . assertValues ( Collections . singletonList ( 1 ) , Collections . singletonList ( 2 ) , Arrays . asList ( 3 , 4 , 5 , 6 ) , Collections . singletonList ( 7 ) ) ; source . onNext ( 8 ) ; source . onNext ( 9 ) ; source . onComplete ( ) ; ts . request ( 1 ) ; ts . assertValues ( Collections . singletonList ( 1 ) , Collections . singletonList ( 2 ) , Arrays . asList ( 3 , 4 , 5 , 6 ) , Collections . singletonList ( 7 ) , Arrays . asList ( 8 , 9 ) ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; 
return new TestSubscriberEx < T > ( 1L ) final Random rnd = new Random ( ) ; @ Override public void onNext ( T t ) super . onNext ( t ) ; if ( rnd . nextDouble ( ) < 0.001 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException ex ) ex . printStackTrace ( ) ; request ( 1 ) ; ; 
int previous = 0 ; for ( Integer current : ts . values ( ) ) Assert . assertTrue ( "The sequence must be increasing [current value=" + previous + ", previous value=" + current + "]" , previous <= current ) ; previous = current ; 
TestSubscriberEx < Integer > ts = createDelayedSubscriber ( ) ; int m = 100000 ; Flowable . range ( 1 , m ) . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureReduce ( ( Supplier < List < Integer > > ) Collections :: emptyList , ( list , current ) -> return Collections . singletonList ( current ) ; ) . observeOn ( Schedulers . io ( ) ) . concatMap ( Flowable :: fromIterable ) . subscribe ( ts ) ; ts . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts . assertTerminated ( ) ; assertValuesDropped ( ts , m ) ; assertIncreasingSequence ( ts ) ; 
TestSubscriberEx < Long > ts = createDelayedSubscriber ( ) ; int m = 100000 ; Flowable . rangeLong ( 1 , m ) . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) . observeOn ( Schedulers . io ( ) ) . concatMap ( list -> Flowable . just ( list . stream ( ) . reduce ( Long :: sum ) . orElseThrow ( ( ) -> throw new IllegalArgumentException ( "No value in list" ) ; ) ) ) . subscribe ( ts ) ; ts . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts . assertTerminated ( ) ; assertValuesDropped ( ts , m ) ; long sum = 0 ; for ( Long i : ts . values ( ) ) sum += i ; Assert . assertEquals ( "Wrong sum: " + sum , 5000050000L , sum ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < List < Integer > > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureReduce ( createTestSupplier ( ) , ( BiFunction < List < Integer > , ? super Integer , List < Integer > > ) ( list , number ) -> null ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( ts . errors ( ) , 0 , NullPointerException . class , "The reducer returned a null value" ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < List < Integer > > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureReduce ( ( ) -> null , createTestReducer ( ) ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( ts . errors ( ) , 0 , NullPointerException . class , "The supplier returned a null value" ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < List < Integer > > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureReduce ( createTestSupplier ( ) , ( BiFunction < List < Integer > , ? super Integer , List < Integer > > ) ( l , r ) -> throw new TestException ( "Test exception" ) ; ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( ts . errors ( ) , 0 , TestException . class , "Test exception" ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < List < Integer > > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureReduce ( ( ) -> throw new TestException ( "Test exception" ) ; , createTestReducer ( ) ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( ts . errors ( ) , 0 , TestException . class , "Test exception" ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) ) ; 
Flowable . just ( 1 , 2 ) . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) . take ( 1 ) . test ( ) . assertResult ( Collections . singletonList ( 1 ) ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . onBackpressureReduce ( createTestSupplier ( ) , createTestReducer ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . lift ( new FlowableOperator < Object , Integer > ( ) @ Override public Subscriber < ? super Integer > apply ( Subscriber < ? super Object > subscriber ) throws Exception throw new TestException ( ) ; ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 3 ) . publish ( f -> Flowable . concat ( f . take ( 5 ) , f . takeLast ( 5 ) ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; Flowable . range ( 1 , 6 ) . publish ( f -> Flowable . concat ( f . take ( 5 ) , f . takeLast ( 5 ) ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . request ( 4 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 5 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( f -> Flowable . concat ( f . take ( 5 ) , f . takeLast ( 5 ) ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . cancel ( ) ; Assert . assertFalse ( "Source has subscribers?" , pp . hasSubscribers ( ) ) ; 
try Flowable . < Integer > never ( ) . publish ( Functions . identity ( ) , - 99 ) ; fail ( "Didn't throw IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) Assert . assertEquals ( "prefetch > 0 required but it was -99" , ex . getMessage ( ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( f -> f . take ( 1 ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; Assert . assertFalse ( "Source has subscribers?" , pp . hasSubscribers ( ) ) ; 
final AtomicInteger startCount = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onStart ( ) startCount . incrementAndGet ( ) ; ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( f -> f . take ( 1 ) ) . subscribe ( ts ) ; Assert . assertEquals ( 1 , startCount . get ( ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( f -> f . take ( 1 ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; Assert . assertFalse ( "Source has subscribers?" , pp . hasSubscribers ( ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( Functions . identity ( ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; Assert . assertFalse ( "Source has subscribers?" , pp . hasSubscribers ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0 ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( Functions . identity ( ) ) . subscribe ( ts ) ; for ( int i = 0 ; i < Flowable . bufferSize ( ) * 2 ; i ++ ) pp . onNext ( i ) ; ts . assertNoValues ( ) ; ts . assertError ( MissingBackpressureException . class ) ; ts . assertNotComplete ( ) ; Assert . assertEquals ( "Could not emit value due to lack of requests" , ts . errors ( ) . get ( 0 ) . getMessage ( ) ) ; Assert . assertFalse ( "Source has subscribers?" , pp . hasSubscribers ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0 ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; new FlowablePublishMulticast < > ( pp , Functions . identity ( ) , Flowable . bufferSize ( ) , true ) . subscribe ( ts ) ; for ( int i = 0 ; i < Flowable . bufferSize ( ) * 2 ; i ++ ) pp . onNext ( i ) ; ts . request ( Flowable . bufferSize ( ) ) ; ts . assertValueCount ( Flowable . bufferSize ( ) ) ; ts . assertError ( MissingBackpressureException . class ) ; ts . assertNotComplete ( ) ; Assert . assertEquals ( "Could not emit value due to lack of requests" , ts . errors ( ) . get ( 0 ) . getMessage ( ) ) ; Assert . assertFalse ( "Source has subscribers?" , pp . hasSubscribers ( ) ) ; 
Flowable . empty ( ) . publish ( Functions . identity ( ) ) . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . publish ( v -> Flowable . range ( 1 , 5 ) ) . test ( 0 ) ; assertTrue ( "pp has no Subscribers?!" , pp . hasSubscribers ( ) ) ; ts . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ts . request ( 5 ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertFalse ( "pp has Subscribers?!" , pp . hasSubscribers ( ) ) ; 
TestHelper . checkBadSourceFlowable ( f -> f . publish ( Functions . identity ( ) ) , false , 1 , 1 , 1 ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 9 ; i ++ ) s . onNext ( i ) ; . publish ( Functions . identity ( ) , 8 ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; 
Flowable . error ( new TestException ( ) ) . publish ( f -> f . onErrorResumeWith ( f ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . map ( v -> throw new TestException ( ) ; ) . publish ( Functions . identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
new FlowablePublishMulticast < > ( Flowable . just ( 1 ) . concatWith ( Flowable . error ( new TestException ( ) ) ) , Functions . identity ( ) , 16 , true ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Flowable . < Integer > empty ( ) . publish ( Functions . identity ( ) ) . test ( 0L ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . publish ( Functions . identity ( ) ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cancel ( ) ; onComplete ( ) ; ; pp . publish ( Functions . identity ( ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertResult ( 1 ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . publish ( f -> f . subscribeOn ( Schedulers . single ( ) ) ) ; for ( int i = 0 ; i < 500 ; i ++ ) source . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) . publish ( Functions . identity ( ) ) ; for ( int i = 0 ; i < 500 ; i ++ ) source . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( 0L ) ; Flowable . just ( 1 ) . publish ( f -> Runnable r1 = ( ) -> f . subscribe ( ts1 ) ; Runnable r2 = ( ) -> for ( int j = 0 ; j < 100 ; j ++ ) ts1 . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; return f ; ) . test ( ) . assertResult ( 1 ) ; ts1 . assertResult ( 1 ) ; 
Flowable . range ( 1 , 1000000 ) . publish ( v -> Flowable . mergeArray ( v . filter ( w -> w % 2 == 0 ) , v . filter ( w -> w % 2 != 0 ) ) ) . takeLast ( 1 ) . test ( ) . assertResult ( 1000000 ) ; 
Flowable . range ( 1 , 100000 ) . publish ( v -> Flowable . mergeArray ( v . filter ( w -> w % 2 == 0 ) , v . filter ( w -> w % 2 != 0 ) ) ) . test ( ) . assertValueCount ( 100000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 1000000 ) . hide ( ) . publish ( v -> Flowable . mergeArray ( v . filter ( w -> w % 2 == 0 ) , v . filter ( w -> w % 2 != 0 ) ) ) . takeLast ( 1 ) . test ( ) . assertResult ( 1000000 ) ; 
AtomicBoolean parentUpstreamCancelled = new AtomicBoolean ( false ) ; Flowable . range ( 1 , 10 ) . doOnCancel ( ( ) -> parentUpstreamCancelled . set ( true ) ) . publish ( Functions . identity ( ) ) . test ( ) . awaitDone ( 1 , TimeUnit . SECONDS ) ; assertFalse ( "Unnecessary upstream .cancel() call in FlowablePublishMulticast" , parentUpstreamCancelled . get ( ) ) ; 
AtomicBoolean parentUpstreamCancelled = new AtomicBoolean ( false ) ; Flowable . range ( 1 , 10 ) . doOnCancel ( ( ) -> parentUpstreamCancelled . set ( true ) ) . publish ( v -> Flowable . concat ( v . take ( 1 ) , v . skip ( 5 ) ) ) . test ( ) . awaitDone ( 1 , TimeUnit . SECONDS ) ; assertFalse ( "Unnecessary upstream .cancel() call in FlowablePublishMulticast" , parentUpstreamCancelled . get ( ) ) ; 
AtomicBoolean parentUpstreamCancelled = new AtomicBoolean ( false ) ; Flowable . range ( 1 , 10 ) . doOnCancel ( ( ) -> parentUpstreamCancelled . set ( true ) ) . publish ( Functions . identity ( ) ) . take ( 1 ) . test ( ) . awaitDone ( 1 , TimeUnit . SECONDS ) ; assertTrue ( "Upstream .cancel() not called in FlowablePublishMulticast" , parentUpstreamCancelled . get ( ) ) ; 
Callable < Object > func = mock ( Callable . class ) ; when ( func . call ( ) ) . thenReturn ( new Object ( ) ) ; Flowable < Object > fromCallableFlowable = Flowable . fromCallable ( func ) ; verifyNoInteractions ( func ) ; fromCallableFlowable . subscribe ( ) ; verify ( func ) . call ( ) ; 
Callable < String > func = mock ( Callable . class ) ; when ( func . call ( ) ) . thenReturn ( "test_value" ) ; Flowable < String > fromCallableFlowable = Flowable . fromCallable ( func ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; fromCallableFlowable . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( "test_value" ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Callable < Object > func = mock ( Callable . class ) ; Throwable throwable = new IllegalStateException ( "Test exception" ) ; when ( func . call ( ) ) . thenThrow ( throwable ) ; Flowable < Object > fromCallableFlowable = Flowable . fromCallable ( func ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; fromCallableFlowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( throwable ) ; 
Callable < String > func = mock ( Callable . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . call ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Flowable < String > fromCallableFlowable = Flowable . fromCallable ( func ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > outer = new TestSubscriber < > ( subscriber ) ; fromCallableFlowable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . cancel ( ) ; funcLatch . countDown ( ) ; verify ( func ) . call ( ) ; verify ( subscriber ) . onSubscribe ( any ( Subscription . class ) ) ; verifyNoMoreInteractions ( subscriber ) ; 
final Exception checkedException = new Exception ( "test exception" ) ; Flowable < Object > fromCallableFlowable = Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw checkedException ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; fromCallableFlowable . subscribe ( subscriber ) ; verify ( subscriber ) . onSubscribe ( any ( Subscription . class ) ) ; verify ( subscriber ) . onError ( checkedException ) ; verifyNoMoreInteractions ( subscriber ) ; 
final int [ ] calls = 0 ; Flowable . just ( 1 ) . flatMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return ++ calls [ 0 ] ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Flowable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return ++ calls [ 0 ] ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
Flowable . just ( 1 ) . flatMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return null ; ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception return Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return null ; ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception ts . cancel ( ) ; throw new TestException ( ) ; ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; ConnectableFlowable < String > f = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; subscriber . onNext ( "one" ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) . publish ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; Disposable connection = f . connect ( ) ; try if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; finally connection . dispose ( ) ; 
ConnectableFlowable < Integer > is = Flowable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . publish ( ) ; Flowable < Integer > fast = is . observeOn ( Schedulers . computation ( ) ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "^^^^^^^^^^^^^ completed FAST" ) ; ) ; Flowable < Integer > slow = is . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer i ) if ( c == 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) c ++ ; return i ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "^^^^^^^^^^^^^ completed SLOW" ) ; ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . merge ( fast , slow ) . subscribe ( ts ) ; is . connect ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , ts . values ( ) . size ( ) ) ; 
final AtomicInteger emitted = new AtomicInteger ( ) ; Flowable < Integer > xs = Flowable . range ( 0 , Flowable . bufferSize ( ) * 2 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) emitted . incrementAndGet ( ) ; ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; xs . publish ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > xs ) return xs . takeUntil ( xs . skipWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i <= 3 ; ) ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertValues ( 0 , 1 , 2 , 3 ) ; assertEquals ( 5 , emitted . get ( ) ) ; System . out . println ( ts . values ( ) ) ; 
Flowable < Integer > xs = Flowable . range ( 0 , Flowable . bufferSize ( ) * 2 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ConnectableFlowable < Integer > xsp = xs . publish ( ) ; xsp . takeUntil ( xsp . skipWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i <= 3 ; ) ) . subscribe ( ts ) ; xsp . connect ( ) ; System . out . println ( ts . values ( ) ) ; 
final AtomicInteger sourceEmission = new AtomicInteger ( ) ; final AtomicBoolean sourceUnsubscribed = new AtomicBoolean ( ) ; final Flowable < Integer > source = Flowable . range ( 1 , 100 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) sourceEmission . incrementAndGet ( ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) sourceUnsubscribed . set ( true ) ; ) . share ( ) ; ; final AtomicBoolean child1Unsubscribed = new AtomicBoolean ( ) ; final AtomicBoolean child2Unsubscribed = new AtomicBoolean ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( values ( ) . size ( ) == 2 ) source . doOnCancel ( new Action ( ) @ Override public void run ( ) child2Unsubscribed . set ( true ) ; ) . take ( 5 ) . subscribe ( ts2 ) ; super . onNext ( t ) ; ; source . doOnCancel ( new Action ( ) @ Override public void run ( ) child1Unsubscribed . set ( true ) ; ) . take ( 5 ) . subscribe ( ts1 ) ; ts1 . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts2 . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts1 . assertNoErrors ( ) ; ts2 . assertNoErrors ( ) ; assertTrue ( sourceUnsubscribed . get ( ) ) ; assertTrue ( child1Unsubscribed . get ( ) ) ; assertTrue ( child2Unsubscribed . get ( ) ) ; ts1 . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts2 . assertValues ( 4 , 5 , 6 , 7 , 8 ) ; assertEquals ( 8 , sourceEmission . get ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ConnectableFlowable < Long > cf = Flowable . interval ( 10 , 10 , TimeUnit . MILLISECONDS , scheduler ) . take ( 3 ) . publish ( ) ; cf . connect ( ) ; scheduler . advanceTimeBy ( 15 , TimeUnit . MILLISECONDS ) ; TestSubscriber < Long > subscriber = new TestSubscriber < > ( ) ; cf . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 50 , TimeUnit . MILLISECONDS ) ; subscriber . assertResult ( 0L , 1L , 2L ) ; 
ConnectableFlowable < Integer > source = Flowable . just ( 1 ) . publish ( ) ; TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; source . subscribe ( ts1 ) ; Disposable connection = source . connect ( ) ; ts1 . assertValue ( 1 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertTerminated ( ) ; source . reset ( ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ) ; source . subscribe ( ts2 ) ; Disposable connection2 = source . connect ( ) ; ts2 . assertValue ( 1 ) ; ts2 . assertNoErrors ( ) ; ts2 . assertTerminated ( ) ; System . out . println ( connection ) ; System . out . println ( connection2 ) ; 
FlowablePublish < Integer > source = ( FlowablePublish < Integer > ) Flowable . just ( 1 ) . publish ( ) ; TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; source . subscribe ( ts1 ) ; ts1 . assertNoValues ( ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; source . connect ( ) ; ts1 . assertValue ( 1 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertTerminated ( ) ; assertEquals ( 0 , source . current . get ( ) . subscribers . get ( ) . length ) ; 
ConnectableFlowable < Object > source = Flowable . never ( ) . publish ( ) ; assertNotNull ( source . connect ( ) ) ; assertNotNull ( source . connect ( ) ) ; 
ConnectableFlowable < Object > source = Flowable . never ( ) . publish ( ) ; Disposable connection1 = source . connect ( ) ; Disposable connection2 = source . connect ( ) ; connection1 . dispose ( ) ; Disposable connection3 = source . connect ( ) ; connection2 . dispose ( ) ; assertTrue ( checkPublishDisposed ( connection1 ) ) ; assertTrue ( checkPublishDisposed ( connection2 ) ) ; assertFalse ( checkPublishDisposed ( connection3 ) ) ; 
return ( ( FlowablePublish . PublishConnection < Object > ) d ) . isDisposed ( ) ; 
ConnectableFlowable < Integer > source = Flowable . just ( 1 ) . publish ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; source . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; source . connect ( ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 5 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > t ) t . onSubscribe ( new BooleanSubscription ( ) ) ; calls . getAndIncrement ( ) ; ) ; ConnectableFlowable < Integer > conn = source . publish ( ) ; assertEquals ( 0 , calls . get ( ) ) ; conn . connect ( ) ; conn . connect ( ) ; assertEquals ( 1 , calls . get ( ) ) ; conn . connect ( ) . dispose ( ) ; conn . connect ( ) ; conn . connect ( ) ; assertEquals ( 2 , calls . get ( ) ) ; 
ConnectableFlowable < Integer > cf = Flowable . range ( 0 , 1000 ) . publish ( ) ; Flowable < Integer > obs = cf . observeOn ( Schedulers . computation ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) for ( int j = 1 ; j < 6 ; j ++ ) List < TestSubscriberEx < Integer > > tss = new ArrayList < > ( ) ; for ( int k = 1 ; k < j ; k ++ ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; tss . add ( ts ) ; obs . subscribe ( ts ) ; Disposable connection = cf . connect ( ) ; for ( TestSubscriberEx < Integer > ts : tss ) ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; connection . dispose ( ) ; 
ConnectableFlowable < Integer > cf = Flowable . range ( 0 , 1000 ) . publish ( ) ; Flowable < Integer > obs = cf . observeOn ( ImmediateThinScheduler . INSTANCE ) ; for ( int i = 0 ; i < 1000 ; i ++ ) for ( int j = 1 ; j < 6 ; j ++ ) List < TestSubscriberEx < Integer > > tss = new ArrayList < > ( ) ; for ( int k = 1 ; k < j ; k ++ ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; tss . add ( ts ) ; obs . subscribe ( ts ) ; Disposable connection = cf . connect ( ) ; for ( TestSubscriberEx < Integer > ts : tss ) ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; connection . dispose ( ) ; 
ConnectableFlowable < Integer > cf = Flowable . range ( 0 , 1000 ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . publish ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) for ( int j = 1 ; j < 6 ; j ++ ) List < TestSubscriberEx < Integer > > tss = new ArrayList < > ( ) ; for ( int k = 1 ; k < j ; k ++ ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; tss . add ( ts ) ; cf . subscribe ( ts ) ; Disposable connection = cf . connect ( ) ; for ( TestSubscriberEx < Integer > ts : tss ) ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; connection . dispose ( ) ; 
ConnectableFlowable < Integer > cf = Flowable . range ( 0 , 1000 ) . hide ( ) . publish ( ) ; Flowable < Integer > obs = cf . observeOn ( Schedulers . computation ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) for ( int j = 1 ; j < 6 ; j ++ ) List < TestSubscriberEx < Integer > > tss = new ArrayList < > ( ) ; for ( int k = 1 ; k < j ; k ++ ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; tss . add ( ts ) ; obs . subscribe ( ts ) ; Disposable connection = cf . connect ( ) ; for ( TestSubscriberEx < Integer > ts : tss ) ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; connection . dispose ( ) ; 
Flowable < Integer > f = Flowable . never ( ) ; assertSame ( f , ( ( ( HasUpstreamPublisher < ? > ) f . publish ( ) ) . source ( ) ) ) ; 
ConnectableFlowable < Integer > cf = Flowable . < Integer > empty ( ) . publish ( ) ; try cf . connect ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( ) ; ) ; catch ( TestException ex ) 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . < Integer > empty ( ) . publish ( ) ; final TestSubscriber < Integer > ts = cf . test ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
ConnectableFlowable < Integer > cf = Flowable . < Integer > empty ( ) . publish ( ) ; cf . test ( Long . MAX_VALUE , true ) . assertEmpty ( ) ; 
Flowable < Integer > co = Flowable . < Integer > never ( ) . publish ( ) . autoConnect ( ) ; co . test ( Long . MAX_VALUE , true ) . assertEmpty ( ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . publish ( ) ) ; TestHelper . checkDisposed ( Flowable . never ( ) . publish ( Functions . < Flowable < Object > > identity ( ) ) ) ; 
ConnectableFlowable < Integer > cf = Flowable . < Integer > empty ( ) . publish ( ) ; cf . connect ( ) ; 
ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 2 ) . publish ( ) ; TestSubscriber < Integer > ts = cf . take ( 1 ) . test ( ) ; cf . connect ( ) ; ts . assertResult ( 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . publish ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; pp . onComplete ( ) ; ; cf . subscribe ( ts ) ; cf . connect ( ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final ConnectableFlowable < Integer > cf = pp . publish ( ) ; final TestSubscriber < Integer > ts = cf . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . publish ( ) . autoConnect ( ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ConnectableFlowable < Object > cf = Flowable . error ( new TestException ( ) ) . publish ( ) ; cf . connect ( ) ; cf . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final ConnectableFlowable < Integer > cf = pp . publish ( ) ; final Disposable d = cf . connect ( ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) d . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts ) ; ; TestHelper . race ( r1 , r2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return Flowable . range ( 1 , 2 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Flowable . range ( 1 , 5 ) . publish ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return v . concatWith ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . error ( new TestException ( ) ) . publish ( Functions . < Flowable < Object > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return Flowable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . < Integer > empty ( ) . publish ( ) ; cf . connect ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . test ( ) ; ; TestHelper . race ( r1 , r1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . < Integer > empty ( ) . publish ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . connect ( ) ; ; TestHelper . race ( r1 , r1 ) ; 
Flowable . just ( 1 ) . publish ( new Function < Flowable < Integer > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Integer > v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . publish ( ) . autoConnect ( ) . test ( ) . assertFailure ( TestException . class ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 , 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception if ( v == 2 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . < Integer > flowableStripBoundary ( ) ) . publish ( ) ; TestSubscriber < Integer > ts = cf . take ( 1 ) . test ( ) ; cf . connect ( ) ; ts . assertResult ( 1 ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < Object > ( 1L ) @ Override public void onNext ( Object t ) super . onNext ( t ) ; onComplete ( ) ; cancel ( ) ; ; Flowable < Object > source = Flowable . range ( 1 , 10 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception if ( v == 2 ) throw new TestException ( ) ; return v ; ) . publish ( ) . autoConnect ( ) ; source . subscribe ( ts ) ; ts . assertResult ( 1 ) ; source . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > s ) throws Exception for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; , BackpressureStrategy . MISSING ) . publish ( 8 ) . autoConnect ( ) . test ( 0L ) . requestMore ( 10 ) . assertFailure ( MissingBackpressureException . class , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ; TestHelper . assertError ( errors , 0 , MissingBackpressureException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final Subscriber < ? > [ ] sub = null ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) sub [ 0 ] = s ; . publish ( ) . connect ( ) . dispose ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; sub [ 0 ] . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Disposable > ref = new AtomicReference < > ( ) ; final ConnectableFlowable < Integer > cf = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( ( Disposable ) s ) ; . publish ( ) ; cf . connect ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ref . get ( ) . dispose ( ) ; ; TestHelper . race ( r1 , r1 ) ; 
final AtomicReference < PublishConnection < Integer > > ref = new AtomicReference < > ( ) ; final ConnectableFlowable < Integer > cf = new Flowable < Integer > ( ) @ Override @ SuppressWarnings ( "unchecked" ) protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( ( PublishConnection < Integer > ) s ) ; . publish ( ) ; cf . connect ( ) ; ref . get ( ) . add ( new InnerSubscription < > ( new TestSubscriber < > ( ) , ref . get ( ) ) ) ; ref . get ( ) . remove ( null ) ; 
final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 5 ) . publish ( ) ; cf . connect ( ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; cf . subscribe ( ts1 ) ; ts1 . assertResult ( 1 ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 0 ) ; cf . subscribe ( ts2 ) ; ts2 . assertEmpty ( ) . requestMore ( 4 ) . assertResult ( 2 , 3 , 4 , 5 ) ; 
final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 5 ) . publish ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 0 ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; cf . subscribe ( ts2 ) ; ; cf . subscribe ( ts1 ) ; cf . connect ( ) ; ts1 . assertResult ( 1 ) ; ts2 . assertEmpty ( ) . requestMore ( 4 ) . assertResult ( 2 , 3 , 4 , 5 ) ; 
final AtomicReference < Flowable < Integer > > ref = new AtomicReference < > ( ) ; Flowable . range ( 1 , 5 ) . publish ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > f ) throws Exception ref . set ( f ) ; return Flowable . never ( ) ; ) . test ( ) ; ref . get ( ) . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; ref . get ( ) . test ( 0 ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 3 , 4 ) . requestMore ( 1 ) . assertResult ( 3 , 4 , 5 ) ; 
final AtomicReference < Flowable < Integer > > ref = new AtomicReference < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > f ) throws Exception ref . set ( f ) ; return Flowable . never ( ) ; ) . test ( ) ; TestSubscriber < Integer > ts1 = ref . get ( ) . take ( 2 ) . test ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; ts1 . assertResult ( 1 , 2 ) ; pp . onNext ( 3 ) ; pp . onNext ( 4 ) ; TestSubscriber < Integer > ts2 = ref . get ( ) . test ( 0L ) ; ts2 . assertEmpty ( ) ; ts2 . requestMore ( 2 ) ; ts2 . assertValuesOnly ( 3 , 4 ) ; 
final FlowableTransformer < Integer , Integer > transformer = new FlowableTransformer < Integer , Integer > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > g ) return g . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) ; ; final AtomicInteger calls = new AtomicInteger ( ) ; Flowable . range ( 1 , 5 ) . publish ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( final Flowable < Integer > shared ) throws Exception return shared . take ( 1 ) . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer first ) throws Exception calls . incrementAndGet ( ) ; return transformer . apply ( Flowable . just ( first ) . concatWith ( shared ) ) ; ) ; ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
final FlowableTransformer < Integer , Integer > transformer = new FlowableTransformer < Integer , Integer > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > g ) return g . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) ; ; final AtomicInteger calls = new AtomicInteger ( ) ; Flowable . range ( 1 , 5 ) . hide ( ) . publish ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( final Flowable < Integer > shared ) throws Exception return shared . take ( 1 ) . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer first ) throws Exception calls . incrementAndGet ( ) ; return transformer . apply ( Flowable . just ( first ) . concatWith ( shared ) ) ; ) ; ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
final FlowableTransformer < Integer , Integer > transformer = new FlowableTransformer < Integer , Integer > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > g ) return g . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) ; ; final AtomicInteger calls = new AtomicInteger ( ) ; Flowable . < Integer > empty ( ) . hide ( ) . publish ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( final Flowable < Integer > shared ) throws Exception return shared . take ( 1 ) . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer first ) throws Exception calls . incrementAndGet ( ) ; return transformer . apply ( Flowable . just ( first ) . concatWith ( shared ) ) ; ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , calls . get ( ) ) ; 
final AtomicReference < Flowable < Integer > > ref = new AtomicReference < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . publish ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > f ) throws Exception ref . set ( f ) ; return Flowable . never ( ) ; ) . test ( ) ; ref . get ( ) . subscribe ( new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; onComplete ( ) ; ts . cancel ( ) ; ) ; pp . onNext ( 1 ) ; 
final AtomicReference < Flowable < Integer > > ref = new AtomicReference < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . publish ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > f ) throws Exception ref . set ( f ) ; return Flowable . never ( ) ; ) . test ( ) ; ref . get ( ) . subscribe ( new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; onComplete ( ) ; ts . cancel ( ) ; ) ; pp . onNext ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > ref = new AtomicReference < > ( ) ; pp . publish ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > f ) throws Exception ref . set ( f ) ; return Flowable . never ( ) ; ) . test ( ) ; final TestSubscriber < Integer > ts1 = ref . get ( ) . test ( ) ; TestSubscriber < Integer > ts2 = ref . get ( ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts2 . assertValuesOnly ( 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . publish ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; final AtomicReference < InnerSubscription < Integer > > ref = new AtomicReference < > ( ) ; cf . subscribe ( new FlowableSubscriber < Integer > ( ) @ SuppressWarnings ( "unchecked" ) @ Override public void onSubscribe ( Subscription s ) ts1 . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( ( InnerSubscription < Integer > ) s ) ; @ Override public void onNext ( Integer t ) ts1 . onNext ( t ) ; @ Override public void onError ( Throwable t ) ts1 . onError ( t ) ; @ Override public void onComplete ( ) ts1 . onComplete ( ) ; ) ; TestSubscriber < Integer > ts2 = cf . test ( ) ; cf . connect ( ) ; ref . get ( ) . set ( Long . MIN_VALUE ) ; pp . onNext ( 1 ) ; ts1 . assertEmpty ( ) ; ts2 . assertValuesOnly ( 1 ) ; 
Flowable . range ( 1 , 10000 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) throws Exception String name = Thread . currentThread ( ) . getName ( ) ; if ( name . contains ( "RxSingleScheduler" ) ) return "RxSingleScheduler" ; return name ; ) . share ( ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( "RxSingleScheduler" ) ; 
TestHelper . assertBadRequestReported ( Flowable . range ( 1 , 5 ) . publish ( ) ) ; 
Flowable < Integer > source = Flowable . range ( 0 , 20 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription v ) throws Exception System . out . println ( "Subscribed" ) ; ) . publish ( 10 ) . refCount ( ) ; Flowable < Integer > evenNumbers = source . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) ; Flowable < Integer > oddNumbers = source . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 != 0 ; ) ; final Single < Integer > getNextOdd = oddNumbers . first ( 0 ) ; TestSubscriber < List < Integer > > ts = evenNumbers . concatMap ( new Function < Integer , Publisher < List < Integer > > > ( ) @ Override public Publisher < List < Integer > > apply ( Integer v ) throws Exception return Single . zip ( Single . just ( v ) , getNextOdd , new BiFunction < Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer a , Integer b ) throws Exception return Arrays . asList ( a , b ) ; ) . toFlowable ( ) ; ) . takeWhile ( new Predicate < List < Integer > > ( ) @ Override public boolean test ( List < Integer > v ) throws Exception return v . get ( 0 ) < 20 ; ) . test ( ) ; ts . assertResult ( Arrays . asList ( 0 , 1 ) , Arrays . asList ( 2 , 3 ) , Arrays . asList ( 4 , 5 ) , Arrays . asList ( 6 , 7 ) , Arrays . asList ( 8 , 9 ) , Arrays . asList ( 10 , 11 ) , Arrays . asList ( 12 , 13 ) , Arrays . asList ( 14 , 15 ) , Arrays . asList ( 16 , 17 ) , Arrays . asList ( 18 , 19 ) ) ; 
Flowable < Integer > source = Flowable . range ( 0 , 20 ) . publish ( 10 ) . refCount ( ) ; Flowable < Integer > evenNumbers = source . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) ; Flowable < Integer > oddNumbers = source . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 != 0 ; ) ; final Single < Integer > getNextOdd = oddNumbers . first ( 0 ) ; TestSubscriber < List < Integer > > ts = evenNumbers . concatMap ( new Function < Integer , Publisher < List < Integer > > > ( ) @ Override public Publisher < List < Integer > > apply ( Integer v ) throws Exception return Single . zip ( Single . just ( v ) , getNextOdd , new BiFunction < Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer a , Integer b ) throws Exception return Arrays . asList ( a , b ) ; ) . toFlowable ( ) ; ) . takeWhile ( new Predicate < List < Integer > > ( ) @ Override public boolean test ( List < Integer > v ) throws Exception return v . get ( 0 ) < 20 ; ) . test ( ) ; ts . assertResult ( Arrays . asList ( 0 , 1 ) , Arrays . asList ( 2 , 3 ) , Arrays . asList ( 4 , 5 ) , Arrays . asList ( 6 , 7 ) , Arrays . asList ( 8 , 9 ) , Arrays . asList ( 10 , 11 ) , Arrays . asList ( 12 , 13 ) , Arrays . asList ( 14 , 15 ) , Arrays . asList ( 16 , 17 ) , Arrays . asList ( 18 , 19 ) ) ; 
try new FlowablePublish < > ( Flowable . < Integer > empty ( ) , 128 ) . connect ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable t ) throws Exception throw new TestException ( ) ; ) ; fail ( "Should have thrown" ) ; catch ( TestException expected ) 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = new FlowablePublish < > ( Flowable . < Integer > never ( ) , 128 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cf . connect ( ) ; ; TestHelper . race ( r , r ) ; 
Flowable . range ( 1 , 5 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . publish ( ) . refCount ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . publish ( 1 ) . refCount ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . hide ( ) . publish ( 1 ) . refCount ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . empty ( ) . hide ( ) . publish ( 1 ) . refCount ( ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . publish ( 1 ) . refCount ( ) . test ( ) . assertResult ( ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; . publish ( 1 ) . refCount ( ) . test ( 0 ) . requestMore ( 1 ) . assertFailure ( MissingBackpressureException . class , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "one" ) ) ; s . onError ( new TestException ( "two" ) ) ; . publish ( 1 ) . refCount ( ) . to ( TestHelper . < Integer > testSubscriber ( 0L ) ) . assertFailureAndMessage ( TestException . class , "one" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "two" ) ; assertEquals ( 1 , errors . size ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . publish ( ) ; TestSubscriber < Integer > ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertResult ( 1 ) ; cf . test ( ) . assertResult ( ) ; cf . reset ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertResult ( 1 ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . publish ( ) ; TestSubscriber < Integer > ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertFailure ( TestException . class , 1 ) ; cf . test ( ) . assertFailure ( TestException . class ) ; cf . reset ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertFailure ( TestException . class , 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . publish ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; Disposable d = cf . connect ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; d . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; TestSubscriber < Integer > ts = cf . test ( ) ; cf . connect ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; 
ConnectableFlowable < Object > cf = Flowable . never ( ) . publish ( ) ; cf . connect ( ) ; cf . connect ( d -> throw new TestException ( ) ; ) ; 
ConnectableFlowable < Object > cf = Flowable . never ( ) . publish ( ) ; cf . reset ( ) ; 
ConnectableFlowable < Object > cf = Flowable . never ( ) . publish ( ) ; cf . connect ( ) ; cf . reset ( ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onComplete ( ) super . onComplete ( ) ; ts1 . cancel ( ) ; ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . publish ( ) ; cf . subscribe ( ts2 ) ; cf . subscribe ( ts1 ) ; cf . connect ( ) ; pp . onComplete ( ) ; ts2 . assertResult ( ) ; ts1 . assertEmpty ( ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onError ( Throwable t ) super . onError ( t ) ; ts1 . cancel ( ) ; ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . publish ( ) ; cf . subscribe ( ts2 ) ; cf . subscribe ( ts1 ) ; cf . connect ( ) ; pp . onError ( new TestException ( ) ) ; ts2 . assertFailure ( TestException . class ) ; ts1 . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . publish ( ) ; TestSubscriber < Integer > ts = cf . test ( ) ; Disposable d = cf . connect ( ) ; pp . onNext ( 1 ) ; d . dispose ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 2 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . onNext ( 100 ) ; ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . < Integer > error ( new TestException ( ) ) . concatWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . onNext ( 100 ) ; ) ) . subscribe ( ts ) ; ts . assertFailure ( TestException . class ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Completable . error ( new TestException ( ) ) ) . subscribe ( ts ) ; ts . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . onNext ( 100 ) ; ) ) . take ( 3 ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
CompletableSubject other = CompletableSubject . create ( ) ; TestSubscriber < Object > ts = Flowable . empty ( ) . concatWith ( other ) . test ( ) ; assertTrue ( other . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( other . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) BooleanSubscription bs1 = new BooleanSubscription ( ) ; s . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; s . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertTrue ( bs2 . isCancelled ( ) ) ; s . onComplete ( ) ; . concatWith ( Completable . complete ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > timeout = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return timeout ; ; Flowable < Integer > other = Flowable . fromIterable ( Arrays . asList ( 100 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . timeout ( timeout , timeoutFunc , other ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; timeout . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onNext ( 100 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > source = Flowable . < Integer > never ( ) ; final PublishProcessor < Integer > timeout = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return timeout ; ; Flowable < Integer > other = Flowable . fromIterable ( Arrays . asList ( 100 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . timeout ( timeout , timeoutFunc , other ) . subscribe ( subscriber ) ; timeout . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 100 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > source = Flowable . < Integer > never ( ) ; final PublishProcessor < Integer > timeout = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return timeout ; ; Supplier < Flowable < Integer > > firstTimeoutFunc = new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) throw new TestException ( ) ; ; Flowable < Integer > other = Flowable . fromIterable ( Arrays . asList ( 100 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . timeout ( Flowable . defer ( firstTimeoutFunc ) , timeoutFunc , other ) . subscribe ( subscriber ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > timeout = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; Flowable < Integer > other = Flowable . fromIterable ( Arrays . asList ( 100 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . timeout ( timeout , timeoutFunc , other ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > timeout = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return timeout ; ; Flowable < Integer > other = Flowable . fromIterable ( Arrays . asList ( 100 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . timeout ( Flowable . < Integer > error ( new TestException ( ) ) , timeoutFunc , other ) . subscribe ( subscriber ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > timeout = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return Flowable . < Integer > error ( new TestException ( ) ) ; ; Flowable < Integer > other = Flowable . fromIterable ( Arrays . asList ( 100 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . timeout ( timeout , timeoutFunc , other ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > timeout = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return PublishProcessor . create ( ) ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . timeout ( timeout , timeoutFunc ) . subscribe ( subscriber ) ; timeout . onNext ( 1 ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onError ( isA ( TimeoutException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > timeout = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return timeout ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . timeout ( PublishProcessor . create ( ) , timeoutFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; timeout . onNext ( 1 ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onError ( isA ( TimeoutException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final CountDownLatch observerReceivedTwo = new CountDownLatch ( 1 ) ; final CountDownLatch timeoutEmittedOne = new CountDownLatch ( 1 ) ; final CountDownLatch observerCompleted = new CountDownLatch ( 1 ) ; final CountDownLatch enteredTimeoutOne = new CountDownLatch ( 1 ) ; final AtomicBoolean latchTimeout = new AtomicBoolean ( false ) ; final Function < Integer , Flowable < Integer > > timeoutFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) if ( t1 == 1 ) return Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; enteredTimeoutOne . countDown ( ) ; while ( true ) try if ( ! observerReceivedTwo . await ( 30 , TimeUnit . SECONDS ) ) latchTimeout . set ( true ) ; break ; catch ( InterruptedException e ) subscriber . onNext ( 1 ) ; timeoutEmittedOne . countDown ( ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) ; else return PublishProcessor . create ( ) ; ; final Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; doAnswer ( new Answer < Void > ( ) @ Override public Void answer ( InvocationOnMock invocation ) throws Throwable observerReceivedTwo . countDown ( ) ; return null ; ) . when ( subscriber ) . onNext ( 2 ) ; doAnswer ( new Answer < Void > ( ) @ Override public Void answer ( InvocationOnMock invocation ) throws Throwable observerCompleted . countDown ( ) ; return null ; ) . when ( subscriber ) . onComplete ( ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( subscriber ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) PublishProcessor < Integer > source = PublishProcessor . create ( ) ; source . timeout ( timeoutFunc , Flowable . just ( 3 ) ) . subscribe ( ts ) ; source . onNext ( 1 ) ; try if ( ! enteredTimeoutOne . await ( 30 , TimeUnit . SECONDS ) ) latchTimeout . set ( true ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; source . onNext ( 2 ) ; try if ( ! timeoutEmittedOne . await ( 30 , TimeUnit . SECONDS ) ) latchTimeout . set ( true ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; source . onComplete ( ) ; ) . start ( ) ; if ( ! observerCompleted . await ( 30 , TimeUnit . SECONDS ) ) latchTimeout . set ( true ) ; assertFalse ( "CoundDownLatch timeout" , latchTimeout . get ( ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . timeout ( Functions . justFunction ( Flowable . never ( ) ) ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . timeout ( Functions . justFunction ( Flowable . never ( ) ) , Flowable . never ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . timeout ( Functions . justFunction ( Flowable . never ( ) ) ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . timeout ( Functions . justFunction ( Flowable . never ( ) ) , Flowable . never ( ) ) ; ) ; 
Flowable . empty ( ) . timeout ( Functions . justFunction ( Flowable . never ( ) ) ) . test ( ) . assertResult ( ) ; 
Flowable . error ( new TestException ( ) ) . timeout ( Functions . justFunction ( Flowable . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . timeout ( Functions . justFunction ( Flowable . empty ( ) ) ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertFailure ( TimeoutException . class , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = pp . timeout ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( "Second" ) ) ; subscriber . onComplete ( ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = pp . timeout ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( "Second" ) ) ; subscriber . onComplete ( ) ; ) , Flowable . just ( 2 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . error ( new TestException ( ) ) . timeout ( Functions . justFunction ( Flowable . never ( ) ) , Flowable . never ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onNext ( 3 ) ; subscriber . onComplete ( ) ; subscriber . onError ( new TestException ( "Second" ) ) ; . timeout ( Functions . justFunction ( Flowable . never ( ) ) , Flowable . < Integer > never ( ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . timeout ( Functions . justFunction ( Flowable . never ( ) ) ) . take ( 1 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . timeout ( Functions . justFunction ( Flowable . never ( ) ) , Flowable . just ( 2 ) ) . take ( 1 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Subscriber < ? > [ ] sub = null , null ; final Flowable < Integer > pp2 = new Flowable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; sub [ count ++ ] = s ; ; TestSubscriber < Integer > ts = pp . timeout ( Functions . justFunction ( pp2 ) ) . test ( ) ; pp . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; final Throwable ex = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Subscriber < ? > [ ] sub = null , null ; final Flowable < Integer > pp2 = new Flowable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) assertFalse ( ( ( Disposable ) s ) . isDisposed ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; sub [ count ++ ] = s ; ; TestSubscriber < Integer > ts = pp . timeout ( Functions . justFunction ( pp2 ) , Flowable . < Integer > never ( ) ) . test ( ) ; pp . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; final Throwable ex = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Subscriber < ? > [ ] sub = null , null ; final Flowable < Integer > pp2 = new Flowable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) assertFalse ( ( ( Disposable ) s ) . isDisposed ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; sub [ count ++ ] = s ; ; TestSubscriber < Integer > ts = pp . timeout ( Functions . justFunction ( pp2 ) ) . test ( ) ; pp . onNext ( 0 ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Subscriber < ? > [ ] sub = null , null ; final Flowable < Integer > pp2 = new Flowable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) assertFalse ( ( ( Disposable ) s ) . isDisposed ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; sub [ count ++ ] = s ; ; TestSubscriber < Integer > ts = pp . timeout ( Functions . justFunction ( pp2 ) ) . test ( ) ; pp . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Subscriber < ? > [ ] sub = null , null ; final Flowable < Integer > pp2 = new Flowable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) assertFalse ( ( ( Disposable ) s ) . isDisposed ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; sub [ count ++ ] = s ; ; TestSubscriber < Integer > ts = pp . timeout ( Functions . justFunction ( pp2 ) , Flowable . < Integer > never ( ) ) . test ( ) ; pp . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < Object > timeoutAndFallback = Flowable . never ( ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception counter . incrementAndGet ( ) ; ) ; pp . timeout ( timeoutAndFallback , Functions . justFunction ( timeoutAndFallback ) ) . test ( 1 , true ) . assertEmpty ( ) ; assertEquals ( 0 , counter . get ( ) ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < Object > timeoutAndFallback = Flowable . never ( ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception counter . incrementAndGet ( ) ; ) ; pp . timeout ( timeoutAndFallback , Functions . justFunction ( timeoutAndFallback ) , timeoutAndFallback ) . test ( 1 , true ) . assertEmpty ( ) ; assertEquals ( 0 , counter . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BehaviorProcessor . createDefault ( 1 ) . timeout ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) BooleanSubscription bs1 = new BooleanSubscription ( ) ; s . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; s . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertTrue ( bs2 . isCancelled ( ) ) ; s . onComplete ( ) ; ) ) . test ( ) . assertFailure ( TimeoutException . class , 1 ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TimeoutConsumer consumer = new TimeoutConsumer ( 0 , null ) ; assertFalse ( consumer . isDisposed ( ) ) ; consumer . dispose ( ) ; assertTrue ( consumer . isDisposed ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Integer > flowable = source . defaultIfEmpty ( 10 ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( 10 ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onNext ( 2 ) ; verify ( subscriber ) . onNext ( 3 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > source = Flowable . empty ( ) ; Flowable < Integer > flowable = source . defaultIfEmpty ( 10 ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 10 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; Flowable . < Integer > empty ( ) . defaultIfEmpty ( 1 ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotTerminated ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; Flowable . just ( 1 , 2 , 3 ) . defaultIfEmpty ( 1 ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotTerminated ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
final CountDownLatch scheduled = new CountDownLatch ( 1 ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final CountDownLatch doneLatch = new CountDownLatch ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; scheduled . countDown ( ) ; try try latch . await ( ) ; catch ( InterruptedException e ) subscriber . onComplete ( ) ; catch ( Throwable e ) subscriber . onError ( e ) ; finally doneLatch . countDown ( ) ; ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; scheduled . await ( ) ; ts . cancel ( ) ; latch . countDown ( ) ; doneLatch . await ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new RuntimeException ( "fail" ) ) ; ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 1000 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; 
return new SlowInner ( actual . createWorker ( ) ) ; 
actualInner . dispose ( ) ; 
return actualInner . isDisposed ( ) ; 
return actualInner . schedule ( action , delay , unit ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > sub ) BooleanSubscription bs = new BooleanSubscription ( ) ; sub . onSubscribe ( bs ) ; for ( int i = 1 ; ! bs . isCancelled ( ) ; i ++ ) count . incrementAndGet ( ) ; sub . onNext ( i ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) . take ( 10 ) . subscribe ( ts ) ; ts . awaitDone ( 1000 , TimeUnit . MILLISECONDS ) ; ts . cancel ( ) ; Thread . sleep ( 200 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertEquals ( 10 , count . get ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 10 ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) latch . countDown ( ) ; ) ; ts . request ( 10 ) ; Flowable . range ( 1 , 10000000 ) . subscribeOn ( Schedulers . newThread ( ) ) . take ( 20 ) . subscribe ( ts ) ; latch . await ( ) ; Thread t = ts . lastThread ( ) ; System . out . println ( "First schedule: " + t ) ; assertTrue ( t . getName ( ) . startsWith ( "Rx" ) ) ; ts . request ( 10 ) ; ts . awaitDone ( 20 , TimeUnit . SECONDS ) ; System . out . println ( "After reschedule: " + ts . lastThread ( ) ) ; assertEquals ( t , ts . lastThread ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 , 3 ) . lift ( new FlowableOperator < Integer , Integer > ( ) @ Override public Subscriber < ? super Integer > apply ( final Subscriber < ? super Integer > child ) final AtomicLong requested = new AtomicLong ( ) ; child . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) if ( ! requested . compareAndSet ( 0 , n ) ) child . onError ( new RuntimeException ( "Expected to receive request before onNext but didn't" ) ) ; @ Override public void cancel ( ) ) ; Subscriber < Integer > parent = new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) child . onComplete ( ) ; @ Override public void onError ( Throwable e ) child . onError ( e ) ; @ Override public void onNext ( Integer t ) if ( requested . compareAndSet ( 0 , - 99 ) ) child . onError ( new RuntimeException ( "Got values before requested" ) ) ; ; return parent ; ) . subscribeOn ( Schedulers . newThread ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 20 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
TestScheduler test = new TestScheduler ( ) ; TestSubscriberEx < Integer > ts = Flowable . just ( 1 ) . hide ( ) . subscribeOn ( test ) . to ( TestHelper . < Integer > testConsumer ( true ) ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertSubscribed ( ) . assertNoValues ( ) . assertNotTerminated ( ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Worker w = Schedulers . computation ( ) . createWorker ( ) ; final SubscribeOnSubscriber < Integer > so = new SubscribeOnSubscriber < > ( ts , w , Flowable . < Integer > never ( ) , true ) ; ts . onSubscribe ( so ) ; final BooleanSubscription bs = new BooleanSubscription ( ) ; try Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onSubscribe ( bs ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; finally w . dispose ( ) ; 
TestSubscriber < Object > ts = Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > s ) throws Exception for ( int i = 1 ; i < 1001 ; i ++ ) s . onNext ( i ) ; Thread . sleep ( 1 ) ; s . onComplete ( ) ; , BackpressureStrategy . DROP ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) . test ( ) . awaitDone ( 20 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; int c = ts . values ( ) . size ( ) ; assertTrue ( "" + c , c > Flowable . bufferSize ( ) ) ; 
Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > s ) throws Exception for ( int i = 1 ; i < 1001 ; i ++ ) s . onNext ( i ) ; Thread . sleep ( 1 ) ; s . onComplete ( ) ; , BackpressureStrategy . DROP ) . map ( Functions . identity ( ) ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) . test ( ) . awaitDone ( 20 , TimeUnit . SECONDS ) . assertValueCount ( Flowable . bufferSize ( ) ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestSubscriber < Object > ts = Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > s ) throws Exception for ( int i = 1 ; i < 1001 ; i ++ ) s . onNext ( i ) ; Thread . sleep ( 1 ) ; s . onComplete ( ) ; , BackpressureStrategy . DROP ) . map ( Functions . identity ( ) ) . subscribeOn ( Schedulers . single ( ) , false ) . observeOn ( Schedulers . computation ( ) ) . test ( ) . awaitDone ( 20 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; int c = ts . values ( ) . size ( ) ; assertTrue ( "" + c , c > Flowable . bufferSize ( ) ) ; 
Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > s ) throws Exception for ( int i = 1 ; i < 1001 ; i ++ ) s . onNext ( i ) ; Thread . sleep ( 1 ) ; s . onComplete ( ) ; , BackpressureStrategy . DROP ) . map ( Functions . identity ( ) ) . subscribeOn ( Schedulers . single ( ) , true ) . observeOn ( Schedulers . computation ( ) ) . test ( ) . awaitDone ( 20 , TimeUnit . SECONDS ) . assertValueCount ( Flowable . bufferSize ( ) ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . subscribeOn ( ImmediateThinScheduler . INSTANCE ) ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . mergeWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . onNext ( 100 ) ; ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
Flowable . range ( 1 , 5 ) . mergeWith ( Completable . complete ( ) ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Flowable . range ( 1 , 5 ) . mergeWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . onNext ( 100 ) ; ) ) . subscribe ( ts ) ; ts . assertValue ( 100 ) . requestMore ( 2 ) . assertValues ( 100 , 1 , 2 ) . requestMore ( 2 ) . assertValues ( 100 , 1 , 2 , 3 , 4 ) . requestMore ( 1 ) . assertResult ( 100 , 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . error ( new TestException ( ) ) . mergeWith ( Completable . complete ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . never ( ) . mergeWith ( Completable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , pp . hasSubscribers ( ) ) ; assertFalse ( "other has observers" , cs . hasObservers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , pp . hasSubscribers ( ) ) ; assertFalse ( "other has observers" , cs . hasObservers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . mergeWith ( Completable . complete ( ) . hide ( ) ) ; ) ; 
aAction0 = Mockito . mock ( Action . class ) ; subscriber = TestHelper . mockSubscriber ( ) ; 
input . doAfterTerminate ( aAction0 ) . subscribe ( subscriber ) ; try verify ( aAction0 , times ( 1 ) ) . run ( ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
checkActionCalled ( Flowable . fromArray ( "1" , "2" , "3" ) ) ; 
checkActionCalled ( Flowable . < String > error ( new RuntimeException ( "expected" ) ) ) ; 
try Flowable . empty ( ) . doAfterTerminate ( null ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException expected ) assertEquals ( "onAfterTerminate is null" , expected . getMessage ( ) ) ; 
try Flowable . just ( "value" ) . doAfterTerminate ( null ) ; fail ( ) ; catch ( NullPointerException expected ) 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Action finallyAction = Mockito . mock ( Action . class ) ; doThrow ( new IllegalStateException ( ) ) . when ( finallyAction ) . run ( ) ; TestSubscriber < String > testSubscriber = new TestSubscriber < > ( ) ; Flowable . just ( "value" ) . doAfterTerminate ( finallyAction ) . subscribe ( testSubscriber ) ; testSubscriber . assertValue ( "value" ) ; verify ( finallyAction ) . run ( ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . empty ( ) . takeUntil ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) return true ; ) . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber ) . onComplete ( ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 , 2 ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return false ; ) . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber ) . onComplete ( ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 , 2 ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber , never ( ) ) . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber ) . onComplete ( ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 , 2 , 3 ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 == 2 ; ) . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onNext ( 3 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber ) . onComplete ( ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Predicate < Integer > predicate = new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) throw new TestException ( "Forced failure" ) ; ; Flowable . just ( 1 , 2 , 3 ) . takeUntil ( predicate ) . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber , never ( ) ) . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onNext ( 3 ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . concatWith ( Flowable . just ( 2 ) ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return false ; ) . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber , never ( ) ) . onNext ( 2 ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 5L ) ; Flowable . range ( 1 , 1000 ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return false ; ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNotComplete ( ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; final TestException e = new TestException ( "Forced failure" ) ; Predicate < String > predicate = new Predicate < String > ( ) @ Override public boolean test ( String t ) throw e ; ; Flowable . just ( "abc" ) . takeUntil ( predicate ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . takeUntil ( Functions . alwaysFalse ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . takeUntil ( Functions . alwaysFalse ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . takeUntil ( Functions . alwaysFalse ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
stringSubscriber = TestHelper . mockSubscriber ( ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestErrorFlowable ( "four" , null , "six" ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestErrorFlowable ( "one" , "two" , "three" ) ) ; Flowable < String > m = Flowable . mergeDelayError ( f1 , f2 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "five" ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestErrorFlowable ( "one" , "two" , "three" ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestErrorFlowable ( "four" , null , "six" ) ) ; final Flowable < String > f3 = Flowable . unsafeCreate ( new TestErrorFlowable ( "seven" , "eight" , null ) ) ; final Flowable < String > f4 = Flowable . unsafeCreate ( new TestErrorFlowable ( "nine" ) ) ; Flowable < String > m = Flowable . mergeDelayError ( f1 , f2 , f3 , f4 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( CompositeException . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "five" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "seven" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "eight" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "nine" ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestErrorFlowable ( "one" , "two" , "three" ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestErrorFlowable ( "four" , "five" , "six" ) ) ; final Flowable < String > f3 = Flowable . unsafeCreate ( new TestErrorFlowable ( "seven" , "eight" , null ) ) ; final Flowable < String > f4 = Flowable . unsafeCreate ( new TestErrorFlowable ( "nine" ) ) ; Flowable < String > m = Flowable . mergeDelayError ( f1 , f2 , f3 , f4 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "five" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "six" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "seven" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "eight" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "nine" ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestErrorFlowable ( "one" , "two" , "three" ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestErrorFlowable ( "four" , "five" , "six" ) ) ; final Flowable < String > f3 = Flowable . unsafeCreate ( new TestErrorFlowable ( "seven" , "eight" ) ) ; final Flowable < String > f4 = Flowable . unsafeCreate ( new TestErrorFlowable ( "nine" , null ) ) ; Flowable < String > m = Flowable . mergeDelayError ( f1 , f2 , f3 , f4 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "five" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "six" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "seven" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "eight" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "nine" ) ; 
final TestAsyncErrorFlowable f1 = new TestAsyncErrorFlowable ( "one" , "two" , "three" ) ; final TestAsyncErrorFlowable f2 = new TestAsyncErrorFlowable ( "four" , "five" , "six" ) ; final TestAsyncErrorFlowable f3 = new TestAsyncErrorFlowable ( "seven" , "eight" ) ; final TestAsyncErrorFlowable f4 = new TestAsyncErrorFlowable ( "nine" , null ) ; Flowable < String > m = Flowable . mergeDelayError ( Flowable . unsafeCreate ( f1 ) , Flowable . unsafeCreate ( f2 ) , Flowable . unsafeCreate ( f3 ) , Flowable . unsafeCreate ( f4 ) ) ; m . subscribe ( stringSubscriber ) ; try f1 . t . join ( ) ; f2 . t . join ( ) ; f3 . t . join ( ) ; f4 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "five" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "six" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "seven" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "eight" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "nine" ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestErrorFlowable ( "four" , null , "six" ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestErrorFlowable ( "one" , "two" , null ) ) ; Flowable < String > m = Flowable . mergeDelayError ( f1 , f2 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "three" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringSubscriber , times ( 0 ) ) . onNext ( "five" ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestErrorFlowable ( "four" , null , "six" ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestErrorFlowable ( "one" , "two" , null ) ) ; Flowable < String > m = Flowable . mergeDelayError ( f1 , f2 ) ; CaptureObserver w = new CaptureObserver ( ) ; m . subscribe ( w ) ; assertNotNull ( w . e ) ; int size = ( ( CompositeException ) w . e ) . size ( ) ; if ( size != 2 ) w . e . printStackTrace ( ) ; assertEquals ( 2 , size ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; Flowable < Flowable < String > > flowableOfFlowables = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( f1 ) ; subscriber . onNext ( f2 ) ; subscriber . onComplete ( ) ; ) ; Flowable < String > m = Flowable . mergeDelayError ( flowableOfFlowables ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( f1 ) ; subscriber . onNext ( f2 ) ; subscriber . onComplete ( ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; Flowable < String > m = Flowable . mergeDelayError ( f1 , f2 ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; List < Flowable < String > > listOfFlowables = new ArrayList < > ( ) ; listOfFlowables . add ( f1 ) ; listOfFlowables . add ( f2 ) ; Flowable < String > m = Flowable . mergeDelayError ( Flowable . fromIterable ( listOfFlowables ) ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; 
final TestASynchronousFlowable f1 = new TestASynchronousFlowable ( ) ; final TestASynchronousFlowable f2 = new TestASynchronousFlowable ( ) ; Flowable < String > m = Flowable . mergeDelayError ( Flowable . unsafeCreate ( f1 ) , Flowable . unsafeCreate ( f2 ) ) ; m . subscribe ( stringSubscriber ) ; try f1 . t . join ( ) ; f2 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; 
final Flowable < Flowable < String > > f1 = Flowable . error ( new RuntimeException ( "unit test" ) ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Flowable . mergeDelayError ( f1 ) . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) fail ( "Expected onError path" ) ; @ Override public void onError ( Throwable e ) latch . countDown ( ) ; @ Override public void onNext ( String s ) fail ( "Expected onError path" ) ; ) ; try latch . await ( ) ; catch ( InterruptedException ex ) fail ( "interrupted" ) ; 
fail ( "Expected onError path" ) ; 
latch . countDown ( ) ; 
fail ( "Expected onError path" ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "hello" ) ; subscriber . onComplete ( ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) subscriber . onNext ( "hello" ) ; subscriber . onComplete ( ) ; ) ; t . start ( ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; boolean errorThrown = false ; for ( String s : valuesToReturn ) if ( s == null ) System . out . println ( "throwing exception" ) ; subscriber . onError ( new NullPointerException ( ) ) ; errorThrown = true ; else subscriber . onNext ( s ) ; if ( ! errorThrown ) subscriber . onComplete ( ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) for ( String s : valuesToReturn ) if ( s == null ) System . out . println ( "throwing exception" ) ; try Thread . sleep ( 100 ) ; catch ( Throwable e ) subscriber . onError ( new NullPointerException ( ) ) ; return ; else subscriber . onNext ( s ) ; System . out . println ( "subscription complete" ) ; subscriber . onComplete ( ) ; ) ; t . start ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . mergeDelayError ( Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) . startWithItem ( Flowable . < Integer > error ( new RuntimeException ( ) ) ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 ) ; assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final TestASynchronous1sDelayedFlowable f1 = new TestASynchronous1sDelayedFlowable ( ) ; final TestASynchronous1sDelayedFlowable f2 = new TestASynchronous1sDelayedFlowable ( ) ; Flowable < Flowable < String > > parentFlowable = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > op ) op . onSubscribe ( new BooleanSubscription ( ) ) ; op . onNext ( Flowable . unsafeCreate ( f1 ) ) ; op . onNext ( Flowable . unsafeCreate ( f2 ) ) ; op . onError ( new NullPointerException ( "throwing exception in parent" ) ) ; ) ; stringSubscriber = TestHelper . mockSubscriber ( ) ; TestSubscriberEx < String > ts = new TestSubscriberEx < > ( stringSubscriber ) ; Flowable < String > m = Flowable . mergeDelayError ( parentFlowable ) ; m . subscribe ( ts ) ; System . out . println ( "testErrorInParentFlowableDelayed | " + i ) ; ts . awaitDone ( 2000 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable < Integer > source = Flowable . mergeDelayError ( Flowable . just ( Flowable . just ( 1 ) . hide ( ) , Flowable . < Integer > error ( new TestException ( ) ) ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long t1 ) requests . add ( t1 ) ; ) , 1 ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertTerminated ( ) ; ts . assertError ( TestException . class ) ; assertEquals ( Arrays . asList ( 1L , 1L , 1L ) , requests ) ; 
final Flowable < String > f1 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; final Flowable < String > f2 = Flowable . unsafeCreate ( new TestSynchronousFlowable ( ) ) ; List < Flowable < String > > listOfFlowables = new ArrayList < > ( ) ; listOfFlowables . add ( f1 ) ; listOfFlowables . add ( f2 ) ; Flowable < String > m = Flowable . mergeDelayError ( listOfFlowables ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 2 ) ) . onNext ( "hello" ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; Flowable . mergeDelayError ( Arrays . asList ( pp1 , pp2 ) , 1 ) . subscribe ( ts ) ; assertTrue ( "ps1 has no subscribers?!" , pp1 . hasSubscribers ( ) ) ; assertFalse ( "ps2 has subscribers?!" , pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; assertFalse ( "ps1 has subscribers?!" , pp1 . hasSubscribers ( ) ) ; assertTrue ( "ps2 has no subscribers?!" , pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; Flowable . mergeDelayError ( Arrays . asList ( pp1 , pp2 ) , 1 ) . subscribe ( ts ) ; assertTrue ( "ps1 has no subscribers?!" , pp1 . hasSubscribers ( ) ) ; assertFalse ( "ps2 has subscribers?!" , pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( "ps1 has subscribers?!" , pp1 . hasSubscribers ( ) ) ; assertTrue ( "ps2 has no subscribers?!" , pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onError ( new TestException ( ) ) ; ts . assertValues ( 1 , 2 ) ; ts . assertError ( CompositeException . class ) ; ts . assertNotComplete ( ) ; CompositeException ce = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; assertEquals ( 2 , ce . getExceptions ( ) . size ( ) ) ; 
return source . concatWith ( Flowable . < T > error ( new TestException ( ) ) ) ; 
for ( int i = 1 ; i < 100 ; i ++ ) @ SuppressWarnings ( "unchecked" ) Flowable < Integer > [ ] sources = new Flowable [ i ] ; Arrays . fill ( sources , Flowable . just ( 1 ) ) ; Integer [ ] expected = new Integer [ i ] ; for ( int j = 0 ; j < i ; j ++ ) expected [ j ] = 1 ; Flowable . mergeArrayDelayError ( sources ) . test ( ) . assertResult ( expected ) ; 
Flowable . mergeArrayDelayError ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . mergeDelayError ( Arrays . asList ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Flowable . mergeDelayError ( Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . mergeDelayError ( Flowable . just ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Flowable . mergeDelayError ( Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . mergeDelayError ( Flowable . just ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Flowable . mergeDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . mergeDelayError ( Arrays . asList ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Flowable . mergeDelayError ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Flowable . mergeDelayError ( Flowable . just ( 1 ) , Flowable . just ( 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 3 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; 
Flowable . mergeDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; testScheduler = new TestScheduler ( ) ; processor = PublishProcessor . create ( ) ; flowable = processor . timeInterval ( testScheduler ) ; 
InOrder inOrder = inOrder ( subscriber ) ; flowable . subscribe ( subscriber ) ; testScheduler . advanceTimeBy ( 1000 , TIME_UNIT ) ; processor . onNext ( 1 ) ; testScheduler . advanceTimeBy ( 2000 , TIME_UNIT ) ; processor . onNext ( 2 ) ; testScheduler . advanceTimeBy ( 3000 , TIME_UNIT ) ; processor . onNext ( 3 ) ; processor . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 1 , 1000 , TIME_UNIT ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 2 , 2000 , TIME_UNIT ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( new Timed < > ( 3 , 3000 , TIME_UNIT ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler v ) throws Exception return scheduler ; ) ; try Flowable . range ( 1 , 5 ) . timeInterval ( ) . map ( new Function < Timed < Integer > , Long > ( ) @ Override public Long apply ( Timed < Integer > v ) throws Exception return v . time ( ) ; ) . test ( ) . assertResult ( 0L , 0L , 0L , 0L , 0L ) ; finally RxJavaPlugins . reset ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler v ) throws Exception return scheduler ; ) ; try Flowable . range ( 1 , 5 ) . timeInterval ( TimeUnit . SECONDS ) . map ( new Function < Timed < Integer > , Long > ( ) @ Override public Long apply ( Timed < Integer > v ) throws Exception return v . time ( ) ; ) . test ( ) . assertResult ( 0L , 0L , 0L , 0L , 0L ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . timeInterval ( ) ) ; 
Flowable . error ( new TestException ( ) ) . timeInterval ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Timed < Object > > > ( ) @ Override public Publisher < Timed < Object > > apply ( Flowable < Object > f ) throws Exception return f . timeInterval ( ) ; ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
final List < String > list = new ArrayList < > ( ) ; final List < List < String > > lists = new ArrayList < > ( ) ; Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , "one" , 10 ) ; push ( subscriber , "two" , 90 ) ; push ( subscriber , "three" , 110 ) ; push ( subscriber , "four" , 190 ) ; push ( subscriber , "five" , 210 ) ; complete ( subscriber , 250 ) ; ) ; Flowable < Flowable < String > > windowed = source . window ( 100 , TimeUnit . MILLISECONDS , scheduler , 2 ) ; windowed . subscribe ( observeWindow ( list , lists ) ) ; scheduler . advanceTimeTo ( 95 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , lists . size ( ) ) ; assertEquals ( lists . get ( 0 ) , list ( "one" , "two" ) ) ; scheduler . advanceTimeTo ( 195 , TimeUnit . MILLISECONDS ) ; assertEquals ( 3 , lists . size ( ) ) ; assertTrue ( lists . get ( 1 ) . isEmpty ( ) ) ; assertEquals ( lists . get ( 2 ) , list ( "three" , "four" ) ) ; scheduler . advanceTimeTo ( 300 , TimeUnit . MILLISECONDS ) ; assertEquals ( 5 , lists . size ( ) ) ; assertTrue ( lists . get ( 3 ) . isEmpty ( ) ) ; assertEquals ( lists . get ( 4 ) , list ( "five" ) ) ; 
final List < String > list = new ArrayList < > ( ) ; final List < List < String > > lists = new ArrayList < > ( ) ; Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , "one" , 98 ) ; push ( subscriber , "two" , 99 ) ; push ( subscriber , "three" , 99 ) ; push ( subscriber , "four" , 101 ) ; push ( subscriber , "five" , 102 ) ; complete ( subscriber , 150 ) ; ) ; Flowable < Flowable < String > > windowed = source . window ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; windowed . subscribe ( observeWindow ( list , lists ) ) ; scheduler . advanceTimeTo ( 101 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , lists . size ( ) ) ; assertEquals ( lists . get ( 0 ) , list ( "one" , "two" , "three" ) ) ; scheduler . advanceTimeTo ( 201 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , lists . size ( ) ) ; assertEquals ( lists . get ( 1 ) , list ( "four" , "five" ) ) ; 
return new Consumer < Flowable < T > > ( ) @ Override public void accept ( Flowable < T > stringFlowable ) stringFlowable . subscribe ( new DefaultSubscriber < T > ( ) @ Override public void onComplete ( ) lists . add ( new ArrayList < > ( list ) ) ; list . clear ( ) ; @ Override public void onError ( Throwable e ) Assert . fail ( e . getMessage ( ) ) ; @ Override public void onNext ( T args ) list . add ( args ) ; ) ; ; 
Flowable < Flowable < Integer > > source = Flowable . range ( 1 , 10 ) . window ( 1 , TimeUnit . MINUTES , scheduler , 3 ) ; final List < Integer > list = new ArrayList < > ( ) ; final List < List < Integer > > lists = new ArrayList < > ( ) ; source . subscribe ( observeWindow ( list , lists ) ) ; assertEquals ( 4 , lists . size ( ) ) ; assertEquals ( 3 , lists . get ( 0 ) . size ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , lists . get ( 0 ) ) ; assertEquals ( 3 , lists . get ( 1 ) . size ( ) ) ; assertEquals ( Arrays . asList ( 4 , 5 , 6 ) , lists . get ( 1 ) ) ; assertEquals ( 3 , lists . get ( 2 ) . size ( ) ) ; assertEquals ( Arrays . asList ( 7 , 8 , 9 ) , lists . get ( 2 ) ) ; assertEquals ( 1 , lists . get ( 3 ) . size ( ) ) ; assertEquals ( Arrays . asList ( 10 ) , lists . get ( 3 ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final AtomicInteger wip = new AtomicInteger ( ) ; final int indicator = 999999999 ; FlowableWindowWithSizeTest . hotStream ( ) . window ( 300 , TimeUnit . MILLISECONDS ) . take ( 10 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "Main done!" ) ; ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > w ) return w . startWithItem ( indicator ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "inner done: " + wip . incrementAndGet ( ) ) ; ) ; ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer pv ) System . out . println ( pv ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertComplete ( ) ; Assert . assertTrue ( ts . values ( ) . size ( ) != 0 ) ; 
Flowable . range ( 1 , 10 ) . window ( 1 , 1 , TimeUnit . MINUTES , Schedulers . io ( ) , 2 ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . window ( 1 , TimeUnit . MINUTES , 20 ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . window ( 1 , TimeUnit . MINUTES , 20 , true ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
try Flowable . just ( 1 ) . window ( - 99 , 1 , TimeUnit . SECONDS ) ; fail ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "timespan > 0 required but it was -99" , ex . getMessage ( ) ) ; 
Flowable . just ( 1 ) . window ( 1 , 1 , TimeUnit . MINUTES ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . window ( 1 , 1 , TimeUnit . MINUTES , Schedulers . io ( ) ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . window ( 2 , 1 , TimeUnit . MINUTES , Schedulers . single ( ) ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . window ( 1 , 2 , TimeUnit . MINUTES , Schedulers . single ( ) ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 1 , 2 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 3 ) ; pp . onNext ( 4 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 5 ) ; pp . onNext ( 6 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 7 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 5 , 6 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 2 , 1 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 3 ) ; pp . onNext ( 4 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 5 ) ; pp . onNext ( 6 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 7 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 , 6 , 7 , 7 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 1 , 1 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) ; pp . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 2 , 1 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) ; pp . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 1 , 2 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) ; pp . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 1 , 1 , TimeUnit . SECONDS , scheduler ) . test ( 0L ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertFailure ( MissingBackpressureException . class ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 1 , 2 , TimeUnit . SECONDS , scheduler ) . test ( 0L ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertFailure ( MissingBackpressureException . class ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 2 , 1 , TimeUnit . SECONDS , scheduler ) . test ( 0L ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertFailure ( MissingBackpressureException . class ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 1 , 1 , TimeUnit . SECONDS , scheduler ) . test ( 1L ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ts . assertError ( MissingBackpressureException . class ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 1 , 2 , TimeUnit . SECONDS , scheduler ) . test ( 1L ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ts . assertError ( MissingBackpressureException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > tsInner = new TestSubscriber < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 2 , 1 , TimeUnit . SECONDS , scheduler ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Throwable w . subscribe ( tsInner ) ; ) . test ( 1L ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ts . assertError ( MissingBackpressureException . class ) ; tsInner . assertError ( MissingBackpressureException . class ) ; assertTrue ( errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . window ( 1 , TimeUnit . DAYS , Schedulers . single ( ) ) . onBackpressureDrop ( ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . window ( 2 , 1 , TimeUnit . DAYS , Schedulers . single ( ) ) . onBackpressureDrop ( ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . window ( 1 , 2 , TimeUnit . DAYS , Schedulers . single ( ) ) . onBackpressureDrop ( ) ) ; TestHelper . checkDisposed ( Flowable . never ( ) . window ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , true ) . onBackpressureDrop ( ) ) ; 
Flowable . range ( 1 , 5 ) . window ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , true ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . error ( new TestException ( ) ) . window ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , true ) . to ( TestHelper . < Flowable < Object > > testConsumer ( ) ) . assertSubscribed ( ) . assertError ( TestException . class ) . assertNotComplete ( ) ; 
final AtomicBoolean cancel1 = new AtomicBoolean ( ) ; Flowable . intervalRange ( 1 , 1000 , 1 , 1 , TimeUnit . MILLISECONDS ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception cancel1 . set ( true ) ; ) . window ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , 2 , true ) . flatMap ( Functions . < Flowable < Long > > identity ( ) ) . take ( 500 ) . to ( TestHelper . < Long > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; int timeout = 20 ; while ( timeout -- > 0 && ! cancel1 . get ( ) ) Thread . sleep ( 100 ) ; assertTrue ( "intervalRange was not cancelled!" , cancel1 . get ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( 1 , TimeUnit . MILLISECONDS , scheduler ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return v ; ) . subscribe ( ts ) ; ps . onNext ( 1 ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( 1 , TimeUnit . MILLISECONDS , scheduler , 10 , true ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return v ; ) . subscribe ( ts ) ; ps . onNext ( 1 ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( 1 , TimeUnit . MILLISECONDS , scheduler , 2 , true ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return v ; ) . subscribe ( ts ) ; ps . onNext ( 1 ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( 1 , 2 , TimeUnit . MILLISECONDS , scheduler ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return v ; ) . subscribe ( ts ) ; ps . onNext ( 1 ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 100 ) . test ( ) . assertValueCount ( 1 ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . MILLISECONDS ) ; ts . assertValueCount ( 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; ts . values ( ) . get ( 0 ) . test ( ) . assertResult ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Flowable < Integer > > ts = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , Long . MAX_VALUE , false ) . test ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValueCount ( 21 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Flowable < Integer > > ts = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , Long . MAX_VALUE , true ) . test ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValueCount ( 21 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Flowable < Integer > > ts = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 5 , false ) . test ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValueCount ( 21 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Flowable < Integer > > ts = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 5 , true ) . test ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValueCount ( 21 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Flowable < Integer > > ts = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 2 , true ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValueCount ( 22 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Flowable < Integer > > ts = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 5 , true ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Throwable w . subscribe ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . MILLISECONDS ) ; ps . onNext ( 3 ) ; ps . onNext ( 4 ) ; ps . onNext ( 5 ) ; ps . onNext ( 6 ) ; ts . assertValueCount ( 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Flowable < Object > > > ( ) @ Override public Publisher < Flowable < Object > > apply ( Flowable < Object > f ) throws Exception return f . window ( 1 , TimeUnit . SECONDS , 1 ) . takeLast ( 0 ) ; ) ; 
Flowable . never ( ) . window ( 1 , TimeUnit . SECONDS , 1 ) . test ( 0L ) . assertFailure ( MissingBackpressureException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 1 , TimeUnit . SECONDS , 1 ) . test ( 1L ) ; pp . onNext ( 1 ) ; ts . assertValueCount ( 1 ) . assertError ( MissingBackpressureException . class ) . assertNotComplete ( ) ; 
Flowable . never ( ) . window ( 1 , TimeUnit . SECONDS , 1 ) . test ( 0L , true ) . assertEmpty ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 1 , TimeUnit . MINUTES , 1 ) . subscribeWith ( new TestSubscriber < Flowable < Integer > > ( 2 ) int calls ; @ Override public void onNext ( Flowable < Integer > t ) super . onNext ( t ) ; if ( ++ calls == 2 ) pp . onNext ( 2 ) ; ) ; pp . onNext ( 1 ) ; ts . assertValueCount ( 2 ) . assertError ( MissingBackpressureException . class ) . assertNotComplete ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestScheduler sch = new TestScheduler ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 1 , TimeUnit . MILLISECONDS , sch , 10 ) . test ( 1 ) ; sch . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; ts . assertValueCount ( 1 ) . assertError ( MissingBackpressureException . class ) . assertNotComplete ( ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; pp . window ( 100 , TimeUnit . MILLISECONDS ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) int count ; @ Override public void accept ( Flowable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; pp . onComplete ( ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; pp . window ( 100 , TimeUnit . MILLISECONDS ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) int count ; @ Override public void accept ( Flowable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; pp . window ( 100 , TimeUnit . MILLISECONDS , 10 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) int count ; @ Override public void accept ( Flowable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; pp . onComplete ( ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; pp . window ( 100 , TimeUnit . MILLISECONDS , 10 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) int count ; @ Override public void accept ( Flowable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; pp . window ( 90 , 100 , TimeUnit . MILLISECONDS ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) int count ; @ Override public void accept ( Flowable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; pp . onComplete ( ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; pp . window ( 90 , 100 , TimeUnit . MILLISECONDS ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) int count ; @ Override public void accept ( Flowable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 10 , TimeUnit . MINUTES ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > inner = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 , TimeUnit . MINUTES ) . take ( 1 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 10 , TimeUnit . MINUTES , 100 ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > inner = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 , TimeUnit . MINUTES , 100 ) . take ( 1 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( 10 , 15 , TimeUnit . MINUTES ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > inner = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 10 , 15 , TimeUnit . MINUTES ) . take ( 1 ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . window ( 1 , TimeUnit . SECONDS ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( 1 , TimeUnit . MINUTES , scheduler , 1 ) . test ( ) ; TestHelper . race ( ( ) -> pp . onNext ( 1 ) , ( ) -> ts . cancel ( ) ) ; 
Flowable . range ( 1 , 10000 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) throws Exception String name = Thread . currentThread ( ) . getName ( ) ; if ( name . contains ( "RxSingleScheduler" ) ) return "RxSingleScheduler" ; return name ; ) . concatMap ( new Function < String , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( String v ) throws Exception return Flowable . just ( v ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( "RxSingleScheduler" ) ; 
Flowable < Integer > just = Flowable . just ( 1 ) ; int n = 1000 ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Flowable < Integer > > source = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = source . concatMap ( v -> v , n + 1 , ImmediateThinScheduler . INSTANCE ) . test ( 1L ) ; TestHelper . race ( ( ) -> for ( int j = 0 ; j < n ; j ++ ) source . onNext ( just ) ; , ( ) -> for ( int j = 0 ; j < n ; j ++ ) ts . request ( 1 ) ; ) ; ts . assertValueCount ( n ) ; 
Flowable < Integer > just = Flowable . just ( 1 ) ; int n = 1000 ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Flowable < Integer > > source = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = source . concatMapDelayError ( v -> v , true , n + 1 , ImmediateThinScheduler . INSTANCE ) . test ( 1L ) ; TestHelper . race ( ( ) -> for ( int j = 0 ; j < n ; j ++ ) source . onNext ( just ) ; , ( ) -> for ( int j = 0 ; j < n ; j ++ ) ts . request ( 1 ) ; ) ; ts . assertValueCount ( n ) ; 
Flowable . range ( 1 , 10000 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) throws Exception String name = Thread . currentThread ( ) . getName ( ) ; if ( name . contains ( "RxSingleScheduler" ) ) return "RxSingleScheduler" ; return name ; ) . concatMapDelayError ( new Function < String , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( String v ) throws Exception return Flowable . just ( v ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( "RxSingleScheduler" ) ; 
Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > flowableStripBoundary ( ) ) . concatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > flowableStripBoundary ( ) ) . concatMapDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . range ( 1 , 5 ) . concatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
Flowable . just ( 1 , 2 , 3 , 101 , 102 , 23 , 890 , 120 , 32 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( final Integer integer ) throws Exception return Flowable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception if ( integer >= 100 ) throw new NullPointerException ( "test null exp" ) ; return integer ; ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( CompositeException . class , 1 , 2 , 3 , 23 , 32 ) ; 
Flowable . just ( 1 , 2 , 3 , 101 , 102 , 23 , 890 , 120 , 32 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( final Integer integer ) throws Exception return Flowable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception if ( integer >= 100 ) throw new NullPointerException ( "test null exp" ) ; return integer ; ) ; , false , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( NullPointerException . class , 1 , 2 , 3 ) ; 
TestSubscriber < String > ts = Flowable . just ( 1 ) . concatMap ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) ; , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestSubscriber < String > ts = Flowable . just ( 1 ) . concatMap ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) . hide ( ) ; , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestSubscriber < String > ts = Flowable . just ( 1 ) . concatMapDelayError ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) ; , false , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestSubscriber < String > ts = Flowable . just ( 1 ) . concatMapDelayError ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) . hide ( ) ; , false , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestSubscriber < String > ts = Flowable . just ( 1 ) . concatMapDelayError ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) ; , true , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestSubscriber < String > ts = Flowable . just ( 1 ) . concatMapDelayError ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) . hide ( ) ; , true , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
final ExecutorService executor = Executors . newFixedThreadPool ( 2 ) ; final Scheduler sch = Schedulers . from ( executor ) ; Function < Integer , Flowable < Integer > > func = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) Flowable < Integer > flowable = Flowable . just ( t ) . subscribeOn ( sch ) ; FlowableProcessor < Integer > processor = UnicastProcessor . create ( ) ; flowable . subscribe ( processor ) ; return processor ; ; int n = 5000 ; final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . range ( 1 , n ) . concatMap ( func , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) if ( counter . getAndIncrement ( ) % 100 == 0 ) System . out . print ( "testIssue2890NoStackoverflow -> " ) ; System . out . println ( counter . get ( ) ) ; ; @ Override public void onComplete ( ) executor . shutdown ( ) ; @ Override public void onError ( Throwable e ) executor . shutdown ( ) ; ) ; long awaitTerminationTimeoutMillis = 100_000 ; if ( ! executor . awaitTermination ( awaitTerminationTimeoutMillis , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( "Completed " + counter . get ( ) + "/" + n + " before timed out after " + awaitTerminationTimeoutMillis + " milliseconds." ) ; assertEquals ( n , counter . get ( ) ) ; 
final long durationSeconds = 2 ; final long startTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; ; i ++ ) if ( System . currentTimeMillis ( ) - startTime > TimeUnit . SECONDS . toMillis ( durationSeconds ) ) return ; if ( i % 1000 == 0 ) System . out . println ( "concatMapRangeAsyncLoop > " + i ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 0 , 1000 ) . concatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return Flowable . fromIterable ( Arrays . asList ( t ) ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 2500 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; assertEquals ( 1000 , ts . values ( ) . size ( ) ) ; assertEquals ( ( Integer ) 999 , ts . values ( ) . get ( 999 ) ) ; 
for ( int i = 2 ; i < 10 ; i ++ ) Flowable < Integer > [ ] obs = new Flowable [ i ] ; Arrays . fill ( obs , Flowable . just ( 1 ) ) ; Integer [ ] expected = new Integer [ i ] ; Arrays . fill ( expected , 1 ) ; Method m = Flowable . class . getMethod ( "concatArray" , Publisher [ ] . class ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ( ( Flowable < Integer > ) m . invoke ( null , new Object [ ] obs ) ) . subscribe ( ts ) ; ts . assertValues ( expected ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . just ( 1 ) ) . concatMap ( ( Function ) Functions . identity ( ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . range ( 1 , 5 ) ) . concatMap ( ( Function ) Functions . identity ( ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . just ( 1 ) ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . range ( 1 , 5 ) ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
for ( int i = 2 ; i < 10 ; i ++ ) Object [ ] obs = new Object [ i ] ; Arrays . fill ( obs , 1 ) ; Integer [ ] expected = new Integer [ i ] ; Arrays . fill ( expected , 1 ) ; Method m = Flowable . class . getMethod ( "startWithArray" , Object [ ] . class ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ( ( Flowable < Integer > ) m . invoke ( Flowable . empty ( ) , new Object [ ] obs ) ) . subscribe ( ts ) ; ts . assertValues ( expected ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) . concatMapDelayError ( Functions . < Flowable < Integer > > identity ( ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . just ( 0 ) . concatMapDelayError ( new Function < Object , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , true , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 0 ) . hide ( ) . concatMap ( new Function < Object , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 0 ) . hide ( ) . concatMapDelayError ( new Function < Object , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , false , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Flowable . just ( 2 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( 1L ) . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 2 ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( 1L ) . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Flowable . empty ( ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Flowable . empty ( ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; . concatMap ( Functions . justFunction ( Flowable . just ( 2 ) ) , 8 , ImmediateThinScheduler . INSTANCE ) . test ( 0L ) . assertFailure ( IllegalStateException . class ) ; 
s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Object > f ) throws Exception return f . concatMap ( Functions . justFunction ( Flowable . just ( 2 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Object > f ) throws Exception return f . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 2 ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onError ( new TestException ( "First" ) ) ; ; pp . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onError ( new TestException ( "First" ) ) ; ; pp . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) . hide ( ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Flowable . error ( new TestException ( ) ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Flowable . error ( new TestException ( ) ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) . hide ( ) ) , 2 , ImmediateThinScheduler . INSTANCE ) ; , true , 1 , 1 , 1 ) ; 
@ SuppressWarnings ( "rawtypes" ) final Subscriber [ ] ts0 = null ; TestSubscriberEx < Integer > ts = Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) ts0 [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "First" ) ) ; ) , 2 , ImmediateThinScheduler . INSTANCE ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ts0 [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
@ SuppressWarnings ( "rawtypes" ) final Subscriber [ ] ts0 = null ; TestSubscriberEx < Integer > ts = Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) ts0 [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "First" ) ) ; ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ts0 [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 1 ) . hide ( ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) ; , true , 1 , 1 , 1 ) ; 
Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 1 ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 2 ) . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 2 ) . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 1 ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) ) ; 
Flowable . range ( 1 , 2 ) . concatMapDelayError ( Functions . justFunction ( Flowable . error ( new TestException ( ) ) ) , false , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 2 ) ) , false , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . concatMap ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; source . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . range ( v , 2 ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . assertValues ( 1 , 2 , 2 , 3 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
final Flowable < Integer > inner = Flowable . range ( 1 , 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return inner ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 1 , 2 , 1 , 2 ) ; ts . assertError ( CompositeException . class ) ; ts . assertNotComplete ( ) ; 
final Flowable < Integer > inner = Flowable . range ( 1 , 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return inner ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return null ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( NullPointerException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throw new TestException ( ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return v == 2 ? Flowable . < Integer > empty ( ) : Flowable . range ( 1 , 2 ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return v == 2 ? Flowable . just ( 3 ) : Flowable . range ( 1 , 2 ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; Flowable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . range ( v , 2 ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 3 ) ; ts . assertValues ( 1 , 2 , 2 , 3 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 , 4 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < String > ts = Flowable . range ( 1 , 1000 ) . hide ( ) . observeOn ( Schedulers . computation ( ) ) . concatMap ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) . repeat ( 1000 ) . observeOn ( Schedulers . io ( ) ) ; , 2 , Schedulers . single ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestSubscriber < String > ts = Flowable . range ( 1 , 1000 ) . hide ( ) . observeOn ( Schedulers . computation ( ) ) . concatMapDelayError ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) . repeat ( 1000 ) . observeOn ( Schedulers . io ( ) ) ; , false , 2 , Schedulers . single ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestSubscriber < String > ts = Flowable . range ( 1 , 1000 ) . hide ( ) . observeOn ( Schedulers . computation ( ) ) . concatMapDelayError ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer t ) throws Throwable return Flowable . just ( Thread . currentThread ( ) . getName ( ) ) . repeat ( 1000 ) . observeOn ( Schedulers . io ( ) ) ; , true , 2 , Schedulers . single ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . toString ( ) , ts . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; , false , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; TestHelper . rejectFlowableFusion ( ) . concatMap ( v -> Flowable . never ( ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; TestHelper . rejectFlowableFusion ( ) . concatMapDelayError ( v -> Flowable . never ( ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMap ( v -> Flowable . fromCallable ( ( ) -> ts . cancel ( ) ; return 1 ; ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( v -> Flowable . fromCallable ( ( ) -> ts . cancel ( ) ; return 1 ; ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
ts . cancel ( ) ; return null ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( v -> new EmptyDisposingFlowable ( ts ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
AtomicReference < Subscriber < ? super Integer > > ref = new AtomicReference < > ( ) ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . concatMap ( v -> Flowable . < Integer > fromPublisher ( ref :: set ) , 2 , ImmediateThinScheduler . INSTANCE ) . doOnError ( e -> ref . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; ref . get ( ) . onNext ( 1 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . concatMap ( v -> Flowable . fromCallable ( ( ) -> pp . onError ( new TestException ( ) ) ; return 2 ; ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertFailure ( TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> TestException ex1 = new TestException ( ) ; TestException ex2 = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) AtomicReference < Subscriber < ? super Integer > > ref1 = new AtomicReference < > ( ) ; AtomicReference < Subscriber < ? super Integer > > ref2 = new AtomicReference < > ( ) ; TestSubscriber < Integer > ts = Flowable . < Integer > fromPublisher ( ref1 :: set ) . concatMap ( v -> Flowable . < Integer > fromPublisher ( ref2 :: set ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) ; ref1 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref2 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; TestHelper . race ( ( ) -> ref1 . get ( ) . onError ( ex1 ) , ( ) -> ref2 . get ( ) . onError ( ex2 ) ) ; ts . assertError ( RuntimeException . class ) ; errors . clear ( ) ; ) ; 
int num = 10 ; final AtomicInteger count = new AtomicInteger ( ) ; int value = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) subscriber . onNext ( count . incrementAndGet ( ) ) ; subscriber . onComplete ( ) ; ) . repeat ( ) . subscribeOn ( Schedulers . computation ( ) ) . take ( num ) . blockingLast ( ) ; assertEquals ( num , value ) ; 
Flowable < Integer > xs = Flowable . just ( 1 , 2 ) ; Object [ ] ys = xs . repeat ( ) . subscribeOn ( Schedulers . newThread ( ) ) . take ( 4 ) . toList ( ) . blockingGet ( ) . toArray ( ) ; assertArrayEquals ( new Object [ ] 1 , 2 , 1 , 2 , ys ) ; 
Flowable . just ( 1 ) . repeat ( ) . subscribeOn ( Schedulers . newThread ( ) ) . take ( 100000 ) . blockingLast ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < Integer > oi = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > sub ) sub . onSubscribe ( new BooleanSubscription ( ) ) ; counter . incrementAndGet ( ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onComplete ( ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) ; Object [ ] ys = oi . repeat ( ) . subscribeOn ( Schedulers . newThread ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 ; ) . take ( 4 ) . toList ( ) . blockingGet ( ) . toArray ( ) ; assertEquals ( 2 , counter . get ( ) ) ; assertArrayEquals ( new Object [ ] 1 , 2 , 1 , 2 , ys ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 ) . repeat ( ) . take ( 10 ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 10 ) ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 ) . repeat ( 10 ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 10 ) ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . error ( new TestException ( ) ) . repeat ( 10 ) . subscribe ( subscriber ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 ) . repeat ( 0 ) . subscribe ( subscriber ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 ) . repeat ( 1 ) . subscribe ( subscriber ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > src = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) . take ( 3 ) . repeat ( 3 ) . distinct ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; src . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 ) ; 
final List < Integer > concatBase = new ArrayList < > ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . repeat ( 5 ) . concatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer x ) System . out . println ( "testRepeatRetarget -> " + x ) ; concatBase . add ( x ) ; return Flowable . < Integer > empty ( ) . delay ( 200 , TimeUnit . MILLISECONDS ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; assertEquals ( Arrays . asList ( 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 ) , concatBase ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . repeat ( 5 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValues ( 1 , 1 , 1 , 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . repeatWhen ( ( Function ) new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable f ) return f . take ( 2 ) ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . trampoline ( ) ) . repeatWhen ( ( Function ) new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable f ) return f . take ( 2 ) ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . just ( 1 ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Flowable . just ( 1 ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return true ; ) . test ( 2L , true ) . assertEmpty ( ) ; 
try Flowable . just ( 1 ) . repeat ( - 99 ) ; fail ( "Should have thrown" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "times >= 0 required but it was -99" , ex . getMessage ( ) ) ; 
Flowable . error ( new TestException ( ) ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return true ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return true ; ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
final PublishProcessor < Object > processor = PublishProcessor . create ( ) ; final Disposable disposable = Flowable . just ( "Leak" ) . repeatWhen ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > completions ) throws Exception return completions . switchMap ( new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object ignore ) throws Exception return processor ; ) ; ) . subscribe ( ) ; assertTrue ( processor . hasSubscribers ( ) ) ; disposable . dispose ( ) ; assertFalse ( processor . hasSubscribers ( ) ) ; 
Flowable . error ( new TestException ( ) ) . repeatWhen ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > v ) throws Exception return v . delay ( 10 , TimeUnit . SECONDS ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 3 ) . repeatWhen ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > handler ) throws Exception return handler . take ( 2 ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 1 , 2 , 3 ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . repeat ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; final AtomicInteger times = new AtomicInteger ( ) ; source . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return times . getAndIncrement ( ) == 4 ; ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; final AtomicInteger times = new AtomicInteger ( ) ; source . repeatWhen ( new Function < Flowable < Object > , Flowable < ? > > ( ) @ Override public Flowable < ? > apply ( Flowable < Object > e ) throws Exception return e . takeWhile ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) throws Exception return times . getAndIncrement ( ) < 4 ; ) ; ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > signaller = PublishProcessor . create ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriber < Integer > ts = source . take ( 1 ) . repeatWhen ( new Function < Flowable < Object > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Object > v ) throws Exception return signaller ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) source . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) signaller . offer ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . cancel ( ) ; if ( ! errors . isEmpty ( ) ) for ( Throwable e : errors ) e . printStackTrace ( ) ; fail ( errors + "" ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < Integer > source = Flowable . range ( 0 , 3 ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . retry ( retryTwice ) . subscribe ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > source = Flowable . unsafeCreate ( new Publisher < Integer > ( ) int count ; @ Override public void subscribe ( Subscriber < ? super Integer > t1 ) t1 . onSubscribe ( new BooleanSubscription ( ) ) ; count ++ ; t1 . onNext ( 0 ) ; t1 . onNext ( 1 ) ; if ( count == 1 ) t1 . onError ( new TestException ( ) ) ; return ; t1 . onNext ( 2 ) ; t1 . onNext ( 3 ) ; t1 . onComplete ( ) ; ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . retry ( retryTwice ) . subscribe ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > source = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > t1 ) t1 . onSubscribe ( new BooleanSubscription ( ) ) ; t1 . onNext ( 0 ) ; t1 . onNext ( 1 ) ; t1 . onError ( new TestException ( ) ) ; ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . retry ( retryTwice ) . subscribe ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable < Integer > source = Flowable . unsafeCreate ( new Publisher < Integer > ( ) int count ; @ Override public void subscribe ( Subscriber < ? super Integer > t1 ) t1 . onSubscribe ( new BooleanSubscription ( ) ) ; count ++ ; t1 . onNext ( 0 ) ; t1 . onNext ( 1 ) ; if ( count == 1 ) t1 . onError ( new IOException ( ) ) ; return ; t1 . onNext ( 2 ) ; t1 . onNext ( 3 ) ; t1 . onComplete ( ) ; ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . retry ( retryOnTestException ) . subscribe ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final IOException ioe = new IOException ( ) ; final TestException te = new TestException ( ) ; Flowable < Integer > source = Flowable . unsafeCreate ( new Publisher < Integer > ( ) int count ; @ Override public void subscribe ( Subscriber < ? super Integer > t1 ) t1 . onSubscribe ( new BooleanSubscription ( ) ) ; count ++ ; t1 . onNext ( 0 ) ; t1 . onNext ( 1 ) ; if ( count == 1 ) t1 . onError ( ioe ) ; return ; t1 . onNext ( 2 ) ; t1 . onNext ( 3 ) ; t1 . onError ( te ) ; ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . retry ( retryOnTestException ) . subscribe ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 0 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onError ( te ) ; verify ( subscriber , never ( ) ) . onError ( ioe ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > processor = PublishProcessor . create ( ) ; final AtomicInteger count = new AtomicInteger ( 0 ) ; Disposable sub = processor . retry ( retryTwice ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer n ) count . incrementAndGet ( ) ; ) ; processor . onNext ( 1 ) ; sub . dispose ( ) ; processor . onNext ( 2 ) ; assertEquals ( 1 , count . get ( ) ) ; 
Subscriber < Long > subscriber = TestHelper . mockSubscriber ( ) ; FlowableRetryTest . SlowFlowable so = new FlowableRetryTest . SlowFlowable ( 100 , 0 , "testUnsubscribeAfterError" ) ; Flowable < Long > f = Flowable . unsafeCreate ( so ) . retry ( retry5 ) ; FlowableRetryTest . AsyncSubscriber < Long > async = new FlowableRetryTest . AsyncSubscriber < > ( subscriber ) ; f . subscribe ( async ) ; async . await ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; assertEquals ( "Start 6 threads, retry 5 then fail on 6" , 6 , so . efforts . get ( ) ) ; assertEquals ( "Only 1 active subscription" , 1 , so . maxActive . get ( ) ) ; 
Subscriber < Long > subscriber = TestHelper . mockSubscriber ( ) ; FlowableRetryTest . SlowFlowable so = new FlowableRetryTest . SlowFlowable ( 100 , 10 , "testTimeoutWithRetry" ) ; Flowable < Long > f = Flowable . unsafeCreate ( so ) . timeout ( 80 , TimeUnit . MILLISECONDS ) . retry ( retry5 ) ; FlowableRetryTest . AsyncSubscriber < Long > async = new FlowableRetryTest . AsyncSubscriber < > ( subscriber ) ; f . subscribe ( async ) ; async . await ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; assertEquals ( "Start 6 threads, retry 5 then fail on 6" , 6 , so . efforts . get ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final RuntimeException e = new RuntimeException ( "You shall not pass" ) ; final AtomicInteger c = new AtomicInteger ( ) ; Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) c . incrementAndGet ( ) ; throw e ; ) . retry ( retry5 ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; assertEquals ( 6 , c . get ( ) ) ; assertEquals ( Collections . singletonList ( e ) , ts . errors ( ) ) ; 
final AtomicBoolean throwException = new AtomicBoolean ( true ) ; int value = Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) if ( throwException . compareAndSet ( true , false ) ) throw new TestException ( ) ; return t1 ; ) . retry ( 1 ) . blockingSingle ( ) ; assertEquals ( 1 , value ) ; 
final List < Long > list = new CopyOnWriteArrayList < > ( ) ; final AtomicBoolean isFirst = new AtomicBoolean ( true ) ; Flowable . < Long > just ( 1L , 2L , 3L ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long x ) System . out . println ( "map " + x ) ; if ( x == 2 && isFirst . getAndSet ( false ) ) throw new RuntimeException ( "retryable error" ) ; return x ; ) . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer t1 , Throwable t2 ) return true ; ) . forEach ( new Consumer < Long > ( ) @ Override public void accept ( Long t ) System . out . println ( t ) ; list . add ( t ) ; ) ; assertEquals ( Arrays . asList ( 1L , 1L , 2L , 3L ) , list ) ; 
final List < Long > list = new CopyOnWriteArrayList < > ( ) ; final AtomicBoolean isFirst = new AtomicBoolean ( true ) ; Flowable . < Long > just ( 1L , 2L , 3L ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long x ) System . out . println ( "map " + x ) ; if ( x == 2 && isFirst . getAndSet ( false ) ) throw new RuntimeException ( "retryable error" ) ; return x ; ) . retry ( ) . forEach ( new Consumer < Long > ( ) @ Override public void accept ( Long t ) System . out . println ( t ) ; list . add ( t ) ; ) ; assertEquals ( Arrays . asList ( 1L , 1L , 2L , 3L ) , list ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long t ) requests . add ( t ) ; ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 3L ) ; source . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer t1 , Throwable t2 ) return t1 < 4 ; ) . subscribe ( ts ) ; assertEquals ( Arrays . asList ( 3L , 2L , 1L ) , requests ) ; ts . assertValues ( 1 , 1 , 1 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriberEx < Object > ts = Flowable . error ( new TestException ( "Outer" ) ) . retry ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
Flowable . error ( new TestException ( "Outer" ) ) . retry ( Functions . alwaysFalse ( ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Outer" ) ; 
final TestException ex = new TestException ( ) ; RxJavaPlugins . setErrorHandler ( Functions . emptyConsumer ( ) ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . retry ( Functions . alwaysTrue ( ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertEmpty ( ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriberEx < Object > ts = Flowable . error ( new TestException ( "Outer" ) ) . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer n , Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
RxJavaPlugins . setErrorHandler ( Functions . emptyConsumer ( ) ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . retry ( new BiPredicate < Object , Object > ( ) @ Override public boolean test ( Object t1 , Object t2 ) throws Exception return true ; ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertEmpty ( ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > src = PublishProcessor . create ( ) ; Flowable < Integer > dst = src . hide ( ) ; assertFalse ( dst instanceof PublishProcessor ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; dst . subscribe ( subscriber ) ; src . onNext ( 1 ) ; src . onComplete ( ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > src = PublishProcessor . create ( ) ; Flowable < Integer > dst = src . hide ( ) ; assertFalse ( dst instanceof PublishProcessor ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; dst . subscribe ( subscriber ) ; src . onError ( new TestException ( ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . hide ( ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . hide ( ) ) ; 
Flowable . intervalRange ( 5 , 5 , 50 , 50 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 5L , 6L , 7L , 8L , 9L ) ; 
Flowable . intervalRange ( 1 , 5 , 1 , 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
Flowable . intervalRange ( 1 , 0 , 1 , 1 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
try Flowable . intervalRange ( 1 , - 1 , 1 , 1 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "count >= 0 required but it was -1" , ex . getMessage ( ) ) ; 
Flowable . intervalRange ( Long . MAX_VALUE - 1 , 2 , 1 , 1 , TimeUnit . MILLISECONDS ) ; Flowable . intervalRange ( Long . MIN_VALUE , Long . MAX_VALUE , 1 , 1 , TimeUnit . MILLISECONDS ) ; try Flowable . intervalRange ( Long . MAX_VALUE - 1 , 3 , 1 , 1 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "Overflow! start + count is bigger than Long.MAX_VALUE" , ex . getMessage ( ) ) ; 
TestHelper . checkDisposed ( Flowable . intervalRange ( 1 , 2 , 1 , 1 , TimeUnit . MILLISECONDS ) ) ; 
Flowable . intervalRange ( 1 , 2 , 1 , 1 , TimeUnit . MILLISECONDS ) . test ( 2L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1L , 2L ) ; 
Flowable . intervalRange ( 1 , 3 , 1 , 1 , TimeUnit . MILLISECONDS ) . test ( 2L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( MissingBackpressureException . class , 1L , 2L ) ; 
TestHelper . assertBadRequestReported ( Flowable . intervalRange ( 1 , 3 , 1 , 1 , TimeUnit . MILLISECONDS ) ) ; 
Flowable . intervalRange ( 1 , 2 , 1 , 1 , TimeUnit . MILLISECONDS ) . take ( 1 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1L ) ; 
Flowable . intervalRange ( 0 , 20 , 1 , 1 , TimeUnit . MILLISECONDS , Schedulers . trampoline ( ) ) . take ( 10 ) . test ( ) . assertResult ( 0L , 1L , 2L , 3L , 4L , 5L , 6L , 7L , 8L , 9L ) ; 
Flowable . intervalRange ( 0 , 2 , 1 , 1 , TimeUnit . MILLISECONDS , Schedulers . trampoline ( ) ) . take ( 2 ) . test ( ) . assertResult ( 0L , 1L ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Flowable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Action run = new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ; Flowable . fromAction ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Flowable . fromAction ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Flowable < Object > source = Flowable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; source . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Flowable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final int [ ] counter = 0 ; Flowable < Void > m = Flowable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter [ 0 ] ++ ; ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof Supplier ) ; assertNull ( ( ( Supplier < Void > ) m ) . get ( ) ) ; assertEquals ( 1 , counter [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestSubscriber < Object > ts = Flowable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; ts . cancel ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Action run = mock ( Action . class ) ; Flowable . fromAction ( run ) . test ( 1L , true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . cancel ( ) ; ) . subscribeWith ( ts ) . assertEmpty ( ) ; assertTrue ( ts . isCancelled ( ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Action action = mock ( Action . class ) ; Flowable . fromAction ( action ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Action action = mock ( Action . class ) ; Flowable . fromAction ( action ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
Flowable < String > source = Flowable . empty ( ) ; Flowable < List < String > > buffered = source . buffer ( 3 , 3 ) ; buffered . subscribe ( subscriber ) ; Mockito . verify ( subscriber , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; Mockito . verify ( subscriber , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; Mockito . verify ( subscriber , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onNext ( "two" ) ; subscriber . onNext ( "three" ) ; subscriber . onNext ( "four" ) ; subscriber . onNext ( "five" ) ; ) ; Flowable < List < String > > buffered = source . buffer ( 3 , 1 ) ; buffered . subscribe ( subscriber ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" , "three" ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "two" , "three" , "four" ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "three" , "four" , "five" ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "one" , "two" , "three" , "four" , "five" ) ; Flowable < List < String > > buffered = source . buffer ( 3 , 3 ) ; buffered . subscribe ( subscriber ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" , "three" ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "four" , "five" ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "one" , "two" , "three" , "four" , "five" ) ; Flowable < List < String > > buffered = source . buffer ( 2 , 3 ) ; buffered . subscribe ( subscriber ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "four" , "five" ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , "one" , 10 ) ; push ( subscriber , "two" , 90 ) ; push ( subscriber , "three" , 110 ) ; push ( subscriber , "four" , 190 ) ; push ( subscriber , "five" , 210 ) ; complete ( subscriber , 250 ) ; ) ; Flowable < List < String > > buffered = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler , 2 ) ; buffered . subscribe ( subscriber ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 100 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" ) ) ; scheduler . advanceTimeTo ( 200 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "three" , "four" ) ) ; scheduler . advanceTimeTo ( 300 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "five" ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , "one" , 97 ) ; push ( subscriber , "two" , 98 ) ; push ( subscriber , "three" , 99 ) ; push ( subscriber , "four" , 101 ) ; push ( subscriber , "five" , 102 ) ; complete ( subscriber , 150 ) ; ) ; Flowable < List < String > > buffered = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; buffered . subscribe ( subscriber ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 101 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" , "three" ) ) ; scheduler . advanceTimeTo ( 201 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "four" , "five" ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , "one" , 10 ) ; push ( subscriber , "two" , 60 ) ; push ( subscriber , "three" , 110 ) ; push ( subscriber , "four" , 160 ) ; push ( subscriber , "five" , 210 ) ; complete ( subscriber , 500 ) ; ) ; Flowable < Object > openings = Flowable . unsafeCreate ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , new Object ( ) , 50 ) ; push ( subscriber , new Object ( ) , 200 ) ; complete ( subscriber , 250 ) ; ) ; Function < Object , Flowable < Object > > closer = new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object opening ) return Flowable . unsafeCreate ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , new Object ( ) , 100 ) ; complete ( subscriber , 101 ) ; ) ; ; Flowable < List < String > > buffered = source . buffer ( openings , closer ) ; buffered . subscribe ( subscriber ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 500 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "two" , "three" ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onNext ( list ( "five" ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( subscriber , Mockito . times ( 1 ) ) . onComplete ( ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; LongTimeAction action = new LongTimeAction ( latch ) ; Flowable . just ( 1 ) . buffer ( 10 , TimeUnit . MILLISECONDS , 10 ) . subscribe ( action ) ; latch . await ( ) ; assertFalse ( action . fail ) ; 
try if ( fail ) return ; Thread . sleep ( 200 ) ; catch ( InterruptedException e ) fail = true ; finally latch . countDown ( ) ; 
Flowable < Integer > source = Flowable . never ( ) ; Subscriber < List < Integer > > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( subscriber , 0L ) ; source . buffer ( 100 , 200 , TimeUnit . MILLISECONDS , scheduler ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > pv ) System . out . println ( pv ) ; ) . subscribe ( ts ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; scheduler . advanceTimeBy ( 1001 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 5 ) ) . onNext ( Arrays . < Integer > asList ( ) ) ; ts . cancel ( ) ; scheduler . advanceTimeBy ( 999 , TimeUnit . MILLISECONDS ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; source . buffer ( boundary ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; boundary . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( 1 , 2 , 3 ) ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; boundary . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( 4 , 5 ) ) ; source . onNext ( 6 ) ; boundary . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( 6 ) ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; source . buffer ( boundary ) . subscribe ( subscriber ) ; boundary . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( ) ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; source . buffer ( boundary ) . subscribe ( subscriber ) ; source . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( ) ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = Mockito . inOrder ( subscriber ) ; source . buffer ( boundary ) . subscribe ( subscriber ) ; source . onComplete ( ) ; boundary . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( ) ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . buffer ( boundary ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . buffer ( boundary ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; boundary . onError ( new TestException ( ) ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . repeat ( ) ; Flowable < List < Integer > > result = source . buffer ( 2 ) . take ( 1 ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 1 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . repeat ( ) ; Flowable < List < Integer > > result = source . buffer ( 2 , 3 ) . take ( 1 ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 1 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Long > source = Flowable . interval ( 40 , 40 , TimeUnit . MILLISECONDS , scheduler ) ; Flowable < List < Long > > result = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler ) . take ( 1 ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 0L , 1L ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Long > source = Flowable . interval ( 40 , 40 , TimeUnit . MILLISECONDS , scheduler ) ; Flowable < List < Long > > result = source . buffer ( 100 , 60 , TimeUnit . MILLISECONDS , scheduler ) . take ( 2 ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 0L , 1L ) ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 1L , 2L ) ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Long > boundary = Flowable . interval ( 60 , 60 , TimeUnit . MILLISECONDS , scheduler ) ; Flowable < Long > source = Flowable . interval ( 40 , 40 , TimeUnit . MILLISECONDS , scheduler ) ; Flowable < List < Long > > result = source . buffer ( boundary ) . take ( 2 ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 0L ) ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 1L ) ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Long > start = Flowable . interval ( 61 , 61 , TimeUnit . MILLISECONDS , scheduler ) ; Function < Long , Flowable < Long > > end = new Function < Long , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Long t1 ) return Flowable . interval ( 100 , 100 , TimeUnit . MILLISECONDS , scheduler ) ; ; Flowable < Long > source = Flowable . interval ( 40 , 40 , TimeUnit . MILLISECONDS , scheduler ) ; Flowable < List < Long > > result = source . buffer ( start , end ) . take ( 2 ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . doOnNext ( new Consumer < List < Long > > ( ) @ Override public void accept ( List < Long > pv ) System . out . println ( pv ) ; ) . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 1L , 2L , 3L ) ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 3L , 4L ) ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < List < Integer > > result = source . buffer ( 2 ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 ) ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( Arrays . asList ( 3 ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < List < Integer > > result = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 ) ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( Arrays . asList ( 3 ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable < Long > source = Flowable . interval ( 30 , 30 , TimeUnit . MILLISECONDS , scheduler ) ; Flowable < List < Long > > result = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler , 2 ) . take ( 3 ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 0L , 1L ) ) ; inOrder . verify ( subscriber ) . onNext ( Arrays . asList ( 2L ) ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > start = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > end = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return Flowable . never ( ) ; ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < List < Integer > > result = source . buffer ( start , end ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; start . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; start . onError ( new TestException ( ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
PublishProcessor < Integer > start = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > end = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < List < Integer > > result = source . buffer ( start , end ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; start . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
PublishProcessor < Integer > start = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > end = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return Flowable . error ( new TestException ( ) ) ; ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < List < Integer > > result = source . buffer ( start , end ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; start . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( 3L ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . buffer ( 5 , 5 ) . subscribe ( ts ) ; assertEquals ( 15 , requested . get ( ) ) ; ts . request ( 4 ) ; assertEquals ( 20 , requested . get ( ) ) ; 
$EMPTY$
TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . buffer ( 5 , 5 ) . subscribe ( ts ) ; assertEquals ( Long . MAX_VALUE , requested . get ( ) ) ; 
TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( 3L ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . buffer ( 5 , 2 ) . subscribe ( ts ) ; assertEquals ( 9 , requested . get ( ) ) ; ts . request ( 3 ) ; assertEquals ( 6 , requested . get ( ) ) ; 
TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . buffer ( 5 , 2 ) . subscribe ( ts ) ; assertEquals ( Long . MAX_VALUE , requested . get ( ) ) ; 
TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( Long . MAX_VALUE > > 1 ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . buffer ( 3 , 3 ) . subscribe ( ts ) ; assertEquals ( Long . MAX_VALUE , requested . get ( ) ) ; 
TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( Long . MAX_VALUE > > 1 ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . buffer ( 3 , 2 ) . subscribe ( ts ) ; assertEquals ( Long . MAX_VALUE , requested . get ( ) ) ; 
final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) AtomicBoolean once = new AtomicBoolean ( ) ; @ Override public void request ( long n ) requested . set ( n ) ; if ( once . compareAndSet ( false , true ) ) s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; @ Override public void cancel ( ) ) ; ) . buffer ( 3 , 2 ) . subscribe ( new DefaultSubscriber < List < Integer > > ( ) @ Override public void onStart ( ) request ( Long . MAX_VALUE / 2 - 4 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( List < Integer > t ) request ( Long . MAX_VALUE / 2 ) ; ) ; assertEquals ( Long . MAX_VALUE - 1 , requested . get ( ) ) ; 
final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; ResourceSubscriber < Object > s = new ResourceSubscriber < Object > ( ) @ Override public void onNext ( Object t ) subscriber . onNext ( t ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; cdl . countDown ( ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; cdl . countDown ( ) ; ; Flowable . range ( 1 , 1 ) . delay ( 1 , TimeUnit . SECONDS ) . buffer ( 2 , TimeUnit . SECONDS ) . subscribe ( s ) ; cdl . await ( ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; assertFalse ( s . isDisposed ( ) ) ; 
Flowable < List < Integer > > source = Flowable . range ( 1 , 10 ) . buffer ( 3 , 1 ) ; TestSubscriber < List < Integer > > ts = TestSubscriber . create ( 0L ) ; source . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 7 ) ; ts . assertValues ( Arrays . asList ( 1 , 2 , 3 ) , Arrays . asList ( 2 , 3 , 4 ) , Arrays . asList ( 3 , 4 , 5 ) , Arrays . asList ( 4 , 5 , 6 ) , Arrays . asList ( 5 , 6 , 7 ) , Arrays . asList ( 6 , 7 , 8 ) , Arrays . asList ( 7 , 8 , 9 ) ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( Arrays . asList ( 1 , 2 , 3 ) , Arrays . asList ( 2 , 3 , 4 ) , Arrays . asList ( 3 , 4 , 5 ) , Arrays . asList ( 4 , 5 , 6 ) , Arrays . asList ( 5 , 6 , 7 ) , Arrays . asList ( 6 , 7 , 8 ) , Arrays . asList ( 7 , 8 , 9 ) , Arrays . asList ( 8 , 9 , 10 ) ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( Arrays . asList ( 1 , 2 , 3 ) , Arrays . asList ( 2 , 3 , 4 ) , Arrays . asList ( 3 , 4 , 5 ) , Arrays . asList ( 4 , 5 , 6 ) , Arrays . asList ( 5 , 6 , 7 ) , Arrays . asList ( 6 , 7 , 8 ) , Arrays . asList ( 7 , 8 , 9 ) , Arrays . asList ( 8 , 9 , 10 ) , Arrays . asList ( 9 , 10 ) ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( Arrays . asList ( 1 , 2 , 3 ) , Arrays . asList ( 2 , 3 , 4 ) , Arrays . asList ( 3 , 4 , 5 ) , Arrays . asList ( 4 , 5 , 6 ) , Arrays . asList ( 5 , 6 , 7 ) , Arrays . asList ( 6 , 7 , 8 ) , Arrays . asList ( 7 , 8 , 9 ) , Arrays . asList ( 8 , 9 , 10 ) , Arrays . asList ( 9 , 10 ) , Arrays . asList ( 10 ) ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = TestSubscriber . create ( ) ; pp . buffer ( 2 , 1 , TimeUnit . SECONDS , scheduler ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 4 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onComplete ( ) ; ts . assertValues ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 2 , 3 ) , Arrays . asList ( 3 , 4 ) , Arrays . asList ( 4 ) , Collections . < Integer > emptyList ( ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = TestSubscriber . create ( ) ; pp . buffer ( 2 , 3 , TimeUnit . SECONDS , scheduler ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 4 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onComplete ( ) ; ts . assertValues ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 4 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler t ) return scheduler ; ) ; try PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = TestSubscriber . create ( ) ; pp . buffer ( 2 , 1 , TimeUnit . SECONDS ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 4 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onComplete ( ) ; ts . assertValues ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 2 , 3 ) , Arrays . asList ( 3 , 4 ) , Arrays . asList ( 4 ) , Collections . < Integer > emptyList ( ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; 
RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler t ) return scheduler ; ) ; try PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = TestSubscriber . create ( ) ; pp . buffer ( 2 , 3 , TimeUnit . SECONDS ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 4 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onComplete ( ) ; ts . assertValues ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 4 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 5 ) . buffer ( Flowable . timer ( 1 , TimeUnit . MINUTES ) , 2 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Flowable . just ( 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 ) . buffer ( 3 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception return new HashSet < > ( ) ; ) . test ( ) . assertResult ( set ( 1 , 2 ) , set ( 2 , 3 ) , set ( 4 ) ) ; 
Flowable . just ( 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 ) . buffer ( 3 , 3 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception return new HashSet < > ( ) ; ) . test ( ) . assertResult ( set ( 1 , 2 ) , set ( 2 , 3 ) , set ( 4 ) ) ; 
Flowable . range ( 1 , 5 ) . buffer ( 1 , 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . buffer ( 1 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . buffer ( 2 , 1 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . buffer ( 1 , 2 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . buffer ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , Functions . < Integer > createArrayList ( 16 ) , true ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . buffer ( 1 ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . buffer ( 2 , 1 ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . buffer ( 1 , 2 ) ) ; 
Flowable . < Integer > never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , Integer . MAX_VALUE , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) return null ; else return new ArrayList < > ( ) ; , false ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( NullPointerException . class ) ; 
Flowable . < Integer > never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , 10 , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) return null ; else return new ArrayList < > ( ) ; , false ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( NullPointerException . class ) ; 
Flowable . < Integer > never ( ) . buffer ( 2 , 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) return null ; else return new ArrayList < > ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( NullPointerException . class ) ; 
Flowable . just ( 1 ) . buffer ( 1 , TimeUnit . SECONDS , Schedulers . single ( ) , Integer . MAX_VALUE , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; , false ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . buffer ( 1 , TimeUnit . SECONDS , Schedulers . single ( ) , 10 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; , false ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . buffer ( 2 , 1 , TimeUnit . SECONDS , Schedulers . single ( ) , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . < Integer > never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , Integer . MAX_VALUE , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) throw new TestException ( ) ; else return new ArrayList < > ( ) ; , false ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Flowable . < Integer > never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , 10 , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) throw new TestException ( ) ; else return new ArrayList < > ( ) ; , false ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Flowable . < Integer > never ( ) . buffer ( 2 , 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) throw new TestException ( ) ; else return new ArrayList < > ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . buffer ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , Functions . < Integer > createArrayList ( 16 ) , true ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 3 , 4 ) , Arrays . asList ( 5 ) ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . buffer ( 2 , 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . buffer ( 1 , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; ) . test ( ) . assertFailure ( TestException . class , Arrays . asList ( 1 ) ) ; 
Flowable . range ( 1 , 2 ) . buffer ( 1 , 2 , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 1 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . buffer ( 2 , 1 , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . buffer ( 5 , 1 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , Arrays . asList ( 2 , 3 , 4 , 5 ) , Arrays . asList ( 3 , 4 , 5 ) , Arrays . asList ( 4 , 5 ) , Arrays . asList ( 5 ) ) ; 
Flowable . error ( new TestException ( ) ) . buffer ( 1 , TimeUnit . DAYS ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . buffer ( 1 , 2 , TimeUnit . DAYS ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . buffer ( 2 , 1 , TimeUnit . DAYS ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . empty ( ) . buffer ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Flowable . empty ( ) . buffer ( 1 , 2 , TimeUnit . DAYS ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Flowable . empty ( ) . buffer ( 2 , 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = pp . buffer ( 1 , TimeUnit . MILLISECONDS , scheduler , 1 , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; , true ) . test ( ) ; pp . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; pp . onNext ( 2 ) ; ts . assertFailure ( TestException . class , Arrays . asList ( 1 ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = pp . buffer ( 1 , TimeUnit . MILLISECONDS , scheduler , 1 , Functions . < Integer > createArrayList ( 16 ) , true ) . test ( ) ; pp . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . buffer ( 1 ) ; , false , 1 , 1 , Arrays . asList ( 1 ) ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . buffer ( 1 , 2 ) ; , false , 1 , 1 , Arrays . asList ( 1 ) ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . buffer ( 2 , 1 ) ; , false , 1 , 1 , Arrays . asList ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < List < Object > > > ( ) @ Override public Publisher < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . buffer ( 1 ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < List < Object > > > ( ) @ Override public Publisher < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . buffer ( 1 , 2 ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < List < Object > > > ( ) @ Override public Publisher < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . buffer ( 2 , 1 ) ; ) ; 
TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) . buffer ( 1 ) ) ; TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) . buffer ( 1 , 2 ) ) ; TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) . buffer ( 2 , 1 ) ) ; 
Flowable . error ( new TestException ( ) ) . buffer ( 1 , 2 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . buffer ( 2 , 3 ) . test ( ) . assertResult ( Arrays . asList ( 1 ) ) ; 
Flowable . range ( 1 , 10 ) . buffer ( 2 , 3 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 4 , 5 ) , Arrays . asList ( 7 , 8 ) , Arrays . asList ( 10 ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestScheduler scheduler = new TestScheduler ( ) ; final PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Object > > ts = pp . buffer ( 1 , TimeUnit . SECONDS , scheduler , 5 ) . test ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onNext ( 3 ) ; pp . onNext ( 4 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 5 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; pp . onComplete ( ) ; int items = 0 ; for ( List < Object > o : ts . values ( ) ) items += o . size ( ) ; assertEquals ( "Round: " + i , 5 , items ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . < Integer > empty ( ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) . buffer ( 5 , TimeUnit . SECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( Collections . < Integer > emptyList ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . < Integer > empty ( ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) . buffer ( 5 , 10 , TimeUnit . SECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( Collections . < Integer > emptyList ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . < Integer > empty ( ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) . buffer ( 10 , 5 , TimeUnit . SECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( Collections . < Integer > emptyList ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > openIndicator = PublishProcessor . create ( ) ; PublishProcessor < Integer > closeIndicator = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . test ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( openIndicator . hasSubscribers ( ) ) ; assertFalse ( closeIndicator . hasSubscribers ( ) ) ; openIndicator . onNext ( 1 ) ; assertTrue ( openIndicator . hasSubscribers ( ) ) ; assertTrue ( closeIndicator . hasSubscribers ( ) ) ; source . onComplete ( ) ; ts . assertResult ( Collections . < Integer > emptyList ( ) ) ; assertFalse ( openIndicator . hasSubscribers ( ) ) ; assertFalse ( closeIndicator . hasSubscribers ( ) ) ; 
Flowable . range ( 1 , 50 ) . zipWith ( Flowable . interval ( 5 , TimeUnit . MILLISECONDS ) , new BiFunction < Integer , Long , Integer > ( ) @ Override public Integer apply ( Integer integer , Long aLong ) return integer ; ) . buffer ( Flowable . interval ( 0 , 200 , TimeUnit . MILLISECONDS ) , new Function < Long , Publisher < ? > > ( ) @ Override public Publisher < ? > apply ( Long a ) return Flowable . just ( a ) . delay ( 100 , TimeUnit . MILLISECONDS ) ; ) . to ( TestHelper . < List < Integer > > testConsumer ( ) ) . assertSubscribed ( ) . awaitDone ( 3 , TimeUnit . SECONDS ) . assertComplete ( ) ; 
Flowable . range ( 1 , 50 ) . zipWith ( Flowable . interval ( 5 , TimeUnit . MILLISECONDS ) , new BiFunction < Integer , Long , Integer > ( ) @ Override public Integer apply ( Integer integer , Long aLong ) return integer ; ) . buffer ( Flowable . interval ( 0 , 100 , TimeUnit . MILLISECONDS ) , new Function < Long , Publisher < ? > > ( ) @ Override public Publisher < ? > apply ( Long a ) return Flowable . just ( a ) . delay ( 200 , TimeUnit . MILLISECONDS ) ; ) . to ( TestHelper . < List < Integer > > testConsumer ( ) ) . assertSubscribed ( ) . awaitDone ( 3 , TimeUnit . SECONDS ) . assertComplete ( ) ; 
Flowable . error ( new TestException ( ) ) . buffer ( Flowable . never ( ) , Functions . justFunction ( Flowable . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; s . onSubscribe ( bs1 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; s . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertTrue ( bs2 . isCancelled ( ) ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( ) ) ; . buffer ( Flowable . never ( ) , Functions . justFunction ( Flowable . never ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > openIndicator = PublishProcessor . create ( ) ; PublishProcessor < Integer > closeIndicator = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . test ( ) ; openIndicator . onNext ( 1 ) ; assertTrue ( closeIndicator . hasSubscribers ( ) ) ; openIndicator . onComplete ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( closeIndicator . hasSubscribers ( ) ) ; closeIndicator . onComplete ( ) ; assertFalse ( source . hasSubscribers ( ) ) ; ts . assertResult ( Collections . < Integer > emptyList ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > openIndicator = PublishProcessor . create ( ) ; PublishProcessor < Integer > closeIndicator = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . test ( ) ; openIndicator . onNext ( 1 ) ; assertTrue ( closeIndicator . hasSubscribers ( ) ) ; closeIndicator . onComplete ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( openIndicator . hasSubscribers ( ) ) ; openIndicator . onComplete ( ) ; assertFalse ( source . hasSubscribers ( ) ) ; ts . assertResult ( Collections . < Integer > emptyList ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > openIndicator = PublishProcessor . create ( ) ; PublishProcessor < Integer > closeIndicator = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . take ( 1 ) . test ( 2 ) ; openIndicator . onNext ( 1 ) ; closeIndicator . onComplete ( ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( openIndicator . hasSubscribers ( ) ) ; assertFalse ( closeIndicator . hasSubscribers ( ) ) ; ts . assertResult ( Collections . < Integer > emptyList ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > openIndicator = PublishProcessor . create ( ) ; PublishProcessor < Integer > closeIndicator = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . test ( 0 ) ; source . onComplete ( ) ; assertFalse ( openIndicator . hasSubscribers ( ) ) ; assertFalse ( closeIndicator . hasSubscribers ( ) ) ; ts . assertResult ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > openIndicator = PublishProcessor . create ( ) ; PublishProcessor < Integer > closeIndicator = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . test ( 0 ) ; source . onError ( new TestException ( ) ) ; assertFalse ( openIndicator . hasSubscribers ( ) ) ; assertFalse ( closeIndicator . hasSubscribers ( ) ) ; ts . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . never ( ) . buffer ( new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) assertFalse ( ( ( Disposable ) s ) . isDisposed ( ) ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; s . onSubscribe ( bs1 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; s . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertTrue ( bs2 . isCancelled ( ) ) ; s . onError ( new IOException ( ) ) ; assertTrue ( ( ( Disposable ) s ) . isDisposed ( ) ) ; s . onComplete ( ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( ) ) ; , Functions . justFunction ( Flowable . never ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . never ( ) . buffer ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) , Functions . justFunction ( new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) assertFalse ( ( ( Disposable ) s ) . isDisposed ( ) ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; s . onSubscribe ( bs1 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; s . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertTrue ( bs2 . isCancelled ( ) ) ; s . onError ( new IOException ( ) ) ; assertTrue ( ( ( Disposable ) s ) . isDisposed ( ) ) ; s . onComplete ( ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( ) ) ; ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < List < Object > > > ( ) @ Override public Flowable < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . buffer ( Flowable . never ( ) ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > b = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = pp . buffer ( b , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; ) . test ( ) ; b . onNext ( 1 ) ; ts . assertFailure ( TestException . class ) ; 
Flowable < Integer > pp = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 1 ) ; subscriber . onComplete ( ) ; ; final AtomicReference < Subscriber < ? super Integer > > ref = new AtomicReference < > ( ) ; Flowable < Integer > b = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( subscriber ) ; ; TestSubscriber < List < Integer > > ts = pp . buffer ( b ) . test ( ) ; ref . get ( ) . onNext ( 1 ) ; ts . assertResult ( Collections . < Integer > emptyList ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > b = PublishProcessor . create ( ) ; pp . buffer ( b ) . test ( 0L , true ) . assertEmpty ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertFalse ( b . hasSubscribers ( ) ) ; 
Flowable < Integer > pp = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; Disposable d = ( Disposable ) s ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; ; PublishProcessor < Integer > b = PublishProcessor . create ( ) ; pp . buffer ( b ) . test ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < List < Object > > > ( ) @ Override public Publisher < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . buffer ( 1 , TimeUnit . SECONDS ) ; ) ; 
TestScheduler sch = new TestScheduler ( ) ; TestSubscriber < List < Object > > ts = Flowable . never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , sch ) . test ( 1L , true ) ; sch . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; ts . assertEmpty ( ) ; 
TestScheduler sch = new TestScheduler ( ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; BufferExactUnboundedSubscriber < Integer , List < Integer > > sub = new BufferExactUnboundedSubscriber < > ( ts , Functions . justSupplier ( ( List < Integer > ) new ArrayList < Integer > ( ) ) , 1 , TimeUnit . SECONDS , sch ) ; sub . onSubscribe ( new BooleanSubscription ( ) ) ; assertFalse ( sub . isDisposed ( ) ) ; sub . onError ( new TestException ( ) ) ; sub . onNext ( 1 ) ; sub . onComplete ( ) ; sub . run ( ) ; sub . dispose ( ) ; assertTrue ( sub . isDisposed ( ) ) ; sub . buffer = new ArrayList < > ( ) ; sub . enter ( ) ; sub . onComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < List < Object > > > ( ) @ Override public Publisher < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . buffer ( 2 , 1 , TimeUnit . SECONDS ) ; ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < List < Object > > > ( ) @ Override public Publisher < List < Object > > apply ( Flowable < Object > f ) throws Exception return f . buffer ( 2 , TimeUnit . SECONDS , 10 ) ; ) ; 
TestScheduler sch = new TestScheduler ( ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; BufferSkipBoundedSubscriber < Integer , List < Integer > > sub = new BufferSkipBoundedSubscriber < > ( ts , Functions . justSupplier ( ( List < Integer > ) new ArrayList < Integer > ( ) ) , 1 , 1 , TimeUnit . SECONDS , sch . createWorker ( ) ) ; sub . onSubscribe ( new BooleanSubscription ( ) ) ; sub . enter ( ) ; sub . onComplete ( ) ; sub . cancel ( ) ; sub . run ( ) ; 
TestScheduler sch = new TestScheduler ( ) ; final TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; BufferSkipBoundedSubscriber < Integer , List < Integer > > sub = new BufferSkipBoundedSubscriber < > ( ts , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) ts . cancel ( ) ; return new ArrayList < > ( ) ; , 1 , 1 , TimeUnit . SECONDS , sch . createWorker ( ) ) ; sub . onSubscribe ( new BooleanSubscription ( ) ) ; sub . run ( ) ; assertTrue ( ts . isCancelled ( ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; BufferExactBoundedSubscriber < Integer , List < Integer > > sub = new BufferExactBoundedSubscriber < > ( ts , Functions . justSupplier ( ( List < Integer > ) new ArrayList < Integer > ( ) ) , 1 , TimeUnit . SECONDS , 1 , false , sch . createWorker ( ) ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; sub . onSubscribe ( bs ) ; sub . producerIndex ++ ; sub . run ( ) ; assertFalse ( sub . isDisposed ( ) ) ; sub . enter ( ) ; sub . onComplete ( ) ; assertTrue ( sub . isDisposed ( ) ) ; sub . run ( ) ; 
Flowable . empty ( ) . buffer ( 1 , TimeUnit . SECONDS , Schedulers . computation ( ) , 10 , new Supplier < List < Object > > ( ) @ Override public List < Object > get ( ) throws Exception throw new TestException ( ) ; , false ) . test ( ) . awaitDone ( 1 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . buffer ( 1 ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . buffer ( 1 , 2 ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . buffer ( 2 , 1 ) ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . unsafeCreate ( s -> s . onSubscribe ( new BooleanSubscription ( ) ) ; ts . cancel ( ) ; s . onNext ( 1 ) ; ) . buffer ( 1 , TimeUnit . MINUTES , 2 ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) BehaviorProcessor < Integer > bp = BehaviorProcessor . createDefault ( 1 ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = bp . buffer ( BehaviorProcessor . createDefault ( 0 ) , v -> pp ) . test ( ) ; TestHelper . race ( ( ) -> bp . onComplete ( ) , ( ) -> pp . onComplete ( ) ) ; ts . assertResult ( Arrays . asList ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . buffer ( Flowable . never ( ) , v -> Flowable . never ( ) ) ) ; 
BehaviorProcessor . createDefault ( 1 ) . buffer ( BehaviorProcessor . createDefault ( 2 ) , v -> Flowable . just ( 1 ) ) . takeUntil ( v -> true ) . test ( ) . assertResult ( Arrays . asList ( ) ) ; 
Flowable . empty ( ) . buffer ( Flowable . never ( ) , v -> Flowable . just ( 1 ) ) . take ( 1 ) . test ( ) . assertResult ( ) ; 
BehaviorProcessor . createDefault ( 1 ) . buffer ( BehaviorProcessor . createDefault ( 2 ) , v -> Flowable . just ( 1 ) ) . test ( 1L ) . assertValuesOnly ( Arrays . asList ( ) ) ; 
PublishProcessor < Integer > bp = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; TestSubscriber < List < Integer > > ts = bp . buffer ( pp , v -> Flowable . just ( 1 ) ) . doOnNext ( v -> if ( counter . getAndIncrement ( ) == 0 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; ) . test ( 1L ) ; pp . onNext ( 1 ) ; bp . onNext ( 1 ) ; ts . assertValuesOnly ( Arrays . asList ( ) ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Maybe . < Integer > fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . onNext ( 100 ) ; ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Maybe . just ( 100 ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
Flowable . range ( 1 , 5 ) . concatWith ( Maybe . just ( 100 ) ) . test ( 0 ) . assertEmpty ( ) . requestMore ( 3 ) . assertValues ( 1 , 2 , 3 ) . requestMore ( 2 ) . assertValues ( 1 , 2 , 3 , 4 , 5 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . < Integer > error ( new TestException ( ) ) . concatWith ( Maybe . < Integer > fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . onNext ( 100 ) ; ) ) . subscribe ( ts ) ; ts . assertFailure ( TestException . class ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Maybe . < Integer > error ( new TestException ( ) ) ) . subscribe ( ts ) ; ts . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Maybe . < Integer > fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . onNext ( 100 ) ; ) ) . take ( 3 ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
MaybeSubject < Object > other = MaybeSubject . create ( ) ; TestSubscriber < Object > ts = Flowable . empty ( ) . concatWith ( other ) . test ( ) ; assertTrue ( other . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( other . hasObservers ( ) ) ; 
Flowable . range ( 1 , 5 ) . mergeWith ( Maybe . just ( 100 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
Flowable . range ( 1 , 5 ) . mergeWith ( Maybe . < Integer > empty ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 512 ) . mergeWith ( Maybe . just ( 100 ) ) . test ( ) . assertValueCount ( 513 ) . assertComplete ( ) ; 
Flowable . range ( 1 , 512 ) . mergeWith ( Maybe . just ( 100 ) ) . test ( 513 ) . assertValueCount ( 513 ) . assertComplete ( ) ; 
Flowable . range ( 1 , 5 ) . mergeWith ( Maybe . just ( 100 ) ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
Flowable . range ( 1 , 5 ) . mergeWith ( Maybe . just ( 100 ) ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValues ( 100 , 1 ) . requestMore ( 2 ) . assertValues ( 100 , 1 , 2 , 3 ) . requestMore ( 2 ) . assertResult ( 100 , 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . error ( new TestException ( ) ) . mergeWith ( Maybe . just ( 100 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . never ( ) . mergeWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < 10000 ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onSuccess ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 , 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onNext ( 2 ) ; ) ; pp . onNext ( 1 ) ; cs . onSuccess ( 3 ) ; pp . onNext ( 4 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 3 , 4 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cs . onSuccess ( 2 ) ; ) ; pp . onNext ( 1 ) ; pp . onNext ( 3 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cs . onSuccess ( 2 ) ; ) ; pp . onNext ( 1 ) ; pp . onNext ( 3 ) ; pp . onComplete ( ) ; ts . request ( 2 ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
for ( int i = 0 ; i < 10000 ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < > ( 0 ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cs . onSuccess ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 2 ) ; ; TestHelper . race ( r1 , r2 ) ; pp . onNext ( 2 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Subscriber < ? > > subscriber = new AtomicReference < > ( ) ; TestSubscriber < Integer > ts = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . set ( s ) ; . mergeWith ( Maybe . < Integer > error ( new IOException ( ) ) ) . test ( ) ; subscriber . get ( ) . onError ( new TestException ( ) ) ; ts . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . error ( new IOException ( ) ) . mergeWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < 10000 ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( 0 ) ; pp . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 3 ) ; ; TestHelper . race ( r1 , r2 ) ; cs . onSuccess ( 1 ) ; pp . onComplete ( ) ; ts . assertResult ( 0 , 1 , 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . mergeWith ( Maybe . just ( 1 ) ) ; ) ; 
Flowable . empty ( ) . mergeWith ( Maybe . error ( new TestException ( ) ) ) . test ( 0 ) . assertFailure ( TestException . class ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . take ( 2 ) . subscribeWith ( new TestSubscriber < Integer > ( 2 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cs . onSuccess ( 2 ) ; ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . request ( 2 ) ; ts . assertResult ( 1 , 2 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) for ( int i = 0 ; i < Flowable . bufferSize ( ) - 1 ; i ++ ) pp . onNext ( i + 2 ) ; ) ; cs . onSuccess ( 1 ) ; pp . onComplete ( ) ; ts . request ( 2 ) ; ts . assertValueCount ( Flowable . bufferSize ( ) ) ; ts . assertComplete ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( ms ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , pp . hasSubscribers ( ) ) ; assertFalse ( "other has observers" , ms . hasObservers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( ms ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ms . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , pp . hasSubscribers ( ) ) ; assertFalse ( "other has observers" , ms . hasObservers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . mergeWith ( Maybe . just ( 1 ) . hide ( ) ) ; ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . mergeWith ( ms ) . doOnNext ( v -> if ( v == 1 ) ms . onSuccess ( 6 ) ; ts . cancel ( ) ; ) . subscribe ( ts ) ; ts . assertValuesOnly ( 1 ) ; 
subscribedSubscriber = TestHelper . mockSubscriber ( ) ; sideEffectSubscriber = TestHelper . mockSubscriber ( ) ; 
Flowable < String > base = Flowable . just ( "a" , "b" , "c" ) ; Flowable < String > doOnEach = base . doOnEach ( sideEffectSubscriber ) ; doOnEach . subscribe ( subscribedSubscriber ) ; verify ( subscribedSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onNext ( "a" ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onNext ( "b" ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onNext ( "c" ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onComplete ( ) ; verify ( sideEffectSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( sideEffectSubscriber , times ( 1 ) ) . onNext ( "a" ) ; verify ( sideEffectSubscriber , times ( 1 ) ) . onNext ( "b" ) ; verify ( sideEffectSubscriber , times ( 1 ) ) . onNext ( "c" ) ; verify ( sideEffectSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > base = Flowable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; Flowable < String > errs = base . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; return s ; ) ; Flowable < String > doOnEach = errs . doOnEach ( sideEffectSubscriber ) ; doOnEach . subscribe ( subscribedSubscriber ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscribedSubscriber , never ( ) ) . onNext ( "two" ) ; verify ( subscribedSubscriber , never ( ) ) . onNext ( "three" ) ; verify ( subscribedSubscriber , never ( ) ) . onComplete ( ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( sideEffectSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( sideEffectSubscriber , never ( ) ) . onNext ( "two" ) ; verify ( sideEffectSubscriber , never ( ) ) . onNext ( "three" ) ; verify ( sideEffectSubscriber , never ( ) ) . onComplete ( ) ; verify ( sideEffectSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > base = Flowable . just ( "one" , "two" , "fail" , "three" ) ; Flowable < String > doOnEach = base . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; ) ; doOnEach . subscribe ( subscribedSubscriber ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscribedSubscriber , never ( ) ) . onNext ( "three" ) ; verify ( subscribedSubscriber , never ( ) ) . onComplete ( ) ; verify ( subscribedSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
final int expectedCount = 3 ; final AtomicInteger count = new AtomicInteger ( ) ; for ( int i = 0 ; i < expectedCount ; i ++ ) Flowable . just ( Boolean . TRUE , Boolean . FALSE ) . takeWhile ( new Predicate < Boolean > ( ) @ Override public boolean test ( Boolean value ) return value ; ) . toList ( ) . doOnSuccess ( new Consumer < List < Boolean > > ( ) @ Override public void accept ( List < Boolean > booleans ) count . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( expectedCount , count . get ( ) ) ; 
final int expectedCount = 3 ; final AtomicInteger count = new AtomicInteger ( ) ; for ( int i = 0 ; i < expectedCount ; i ++ ) Flowable . just ( Boolean . TRUE , Boolean . FALSE , Boolean . FALSE ) . takeWhile ( new Predicate < Boolean > ( ) @ Override public boolean test ( Boolean value ) return value ; ) . toList ( ) . doOnSuccess ( new Consumer < List < Boolean > > ( ) @ Override public void accept ( List < Boolean > booleans ) count . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( expectedCount , count . get ( ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; Flowable . error ( new TestException ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throw new TestException ( ) ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( CompositeException . class ) ; CompositeException ex = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; List < Throwable > exceptions = ex . getExceptions ( ) ; assertEquals ( 2 , exceptions . size ( ) ) ; Assert . assertTrue ( exceptions . get ( 0 ) instanceof TestException ) ; Assert . assertTrue ( exceptions . get ( 1 ) instanceof TestException ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ) . doOnNext ( new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( ) ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onComplete ( ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onComplete ( ) ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertFailure ( IOException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ) . doOnNext ( new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) ConditionalSubscriber < ? super Object > cs = ( ConditionalSubscriber < ? super Object > ) s ; cs . onSubscribe ( new BooleanSubscription ( ) ) ; cs . tryOnNext ( 1 ) ; cs . tryOnNext ( 2 ) ; cs . onError ( new IOException ( ) ) ; cs . onComplete ( ) ; ) . doOnNext ( new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( ) ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] call = 0 ; Flowable . just ( 1 ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , call [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onComplete ( ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . fromPublisher ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onComplete ( ) ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( IOException . class ) ; 
TestSubscriberEx < Object > ts = Flowable . error ( new TestException ( "Outer" ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . filter ( Functions . alwaysTrue ( ) ) . to ( TestHelper . testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; Flowable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final int [ ] call = 0 ; Flowable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; Flowable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final int [ ] call = 0 ; Flowable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . subscribe ( ts ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . hide ( ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . doOnEach ( new TestSubscriber < > ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . doOnEach ( new TestSubscriber < > ( ) ) ; ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( "First" ) ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Second" ) ; ) . publish ( ) ; TestSubscriberEx < Integer > ts = cf . to ( TestHelper . < Integer > testConsumer ( ) ) ; cf . connect ( ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , TestException . class , "First" ) ; TestHelper . assertError ( ts , 1 , TestException . class , "Second" ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . compose ( new FlowableTransformer < Integer , Integer > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > v ) return new FlowableDoOnEach < > ( v , new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( "First" ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Second" ) ; , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; ) . publish ( ) ; TestSubscriberEx < Integer > ts = cf . to ( TestHelper . < Integer > testConsumer ( ) ) ; cf . connect ( ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , TestException . class , "First" ) ; TestHelper . assertError ( ts , 1 , TestException . class , "Second" ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( "First" ) ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Second" ) ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Third" ) ; ) . publish ( ) ; TestSubscriberEx < Integer > ts = cf . to ( TestHelper . < Integer > testConsumer ( ) ) ; cf . connect ( ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , TestException . class , "First" ) ; TestHelper . assertError ( ts , 1 , TestException . class , "Second" ) ; TestHelper . assertError ( ts , 2 , TestException . class , "Third" ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( "First" ) ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Second" ) ; ) . filter ( Functions . alwaysTrue ( ) ) . publish ( ) ; TestSubscriberEx < Integer > ts = cf . to ( TestHelper . < Integer > testConsumer ( ) ) ; cf . connect ( ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , TestException . class , "First" ) ; TestHelper . assertError ( ts , 1 , TestException . class , "Second" ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( "First" ) ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Second" ) ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Third" ) ; ) . filter ( Functions . alwaysTrue ( ) ) . publish ( ) ; TestSubscriberEx < Integer > ts = cf . to ( TestHelper . < Integer > testConsumer ( ) ) ; cf . connect ( ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , TestException . class , "First" ) ; TestHelper . assertError ( ts , 1 , TestException . class , "Second" ) ; TestHelper . assertError ( ts , 2 , TestException . class , "Third" ) ; 
ConnectableFlowable < Integer > cf = Flowable . just ( 1 ) . compose ( new FlowableTransformer < Integer , Integer > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > v ) return new FlowableDoOnEach < > ( v , new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( "First" ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Second" ) ; , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; ) . filter ( Functions . alwaysTrue ( ) ) . publish ( ) ; TestSubscriberEx < Integer > ts = cf . to ( TestHelper . < Integer > testConsumer ( ) ) ; cf . connect ( ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , TestException . class , "First" ) ; TestHelper . assertError ( ts , 1 , TestException . class , "Second" ) ; 
calls ++ ; 
Flowable . just ( 1 ) . doFinally ( this ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls ) ; 
Flowable . empty ( ) . doFinally ( this ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls ) ; 
Flowable . error ( new TestException ( ) ) . doFinally ( this ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls ) ; 
Flowable . range ( 1 , 10 ) . doFinally ( this ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . doFinally ( FlowableDoFinallyTest . this ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . doFinally ( FlowableDoFinallyTest . this ) . filter ( Functions . alwaysTrue ( ) ) ; ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . doFinally ( this ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC | QueueFuseable . BOUNDARY ) ; Flowable . range ( 1 , 5 ) . doFinally ( this ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . doFinally ( this ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . doFinally ( this ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
Flowable . just ( 1 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls ) ; 
Flowable . empty ( ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls ) ; 
Flowable . error ( new TestException ( ) ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls ) ; 
Flowable . range ( 1 , 10 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . doFinally ( this ) . compose ( TestHelper . conditional ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . hide ( ) . doFinally ( this ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . hide ( ) . doFinally ( this ) . compose ( TestHelper . conditional ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC | QueueFuseable . BOUNDARY ) ; Flowable . range ( 1 , 5 ) . doFinally ( this ) . compose ( TestHelper . conditional ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . doFinally ( this ) . compose ( TestHelper . conditional ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . doFinally ( this ) . compose ( TestHelper . conditional ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( 1 ) . cancel ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) . cancel ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 5 ) . doFinally ( this ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < Integer > qs = ( QueueSubscription < Integer > ) s ; qs . requestFusion ( QueueFuseable . ANY ) ; assertFalse ( qs . isEmpty ( ) ) ; try assertEquals ( 1 , qs . poll ( ) . intValue ( ) ) ; catch ( Throwable ex ) throw new RuntimeException ( ex ) ; assertFalse ( qs . isEmpty ( ) ) ; qs . clear ( ) ; assertTrue ( qs . isEmpty ( ) ) ; qs . cancel ( ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; assertEquals ( 1 , calls ) ; 
Flowable . range ( 1 , 5 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < Integer > qs = ( QueueSubscription < Integer > ) s ; qs . requestFusion ( QueueFuseable . ANY ) ; assertFalse ( qs . isEmpty ( ) ) ; try assertEquals ( 1 , qs . poll ( ) . intValue ( ) ) ; catch ( Throwable ex ) throw new RuntimeException ( ex ) ; assertFalse ( qs . isEmpty ( ) ) ; qs . clear ( ) ; assertTrue ( qs . isEmpty ( ) ) ; qs . cancel ( ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; assertEquals ( 1 , calls ) ; 
final List < String > list = new ArrayList < > ( ) ; Flowable . error ( new TestException ( ) ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "cancel" ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "finally" ) ; ) . subscribe ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( "onNext" ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( "onError" ) ; , new Action ( ) @ Override public void run ( ) throws Exception list . add ( "onComplete" ) ; ) ; assertEquals ( Arrays . asList ( "onError" , "finally" ) , list ) ; 
final List < String > list = new ArrayList < > ( ) ; Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "cancel" ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "finally" ) ; ) . subscribe ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( "onNext" ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( "onError" ) ; , new Action ( ) @ Override public void run ( ) throws Exception list . add ( "onComplete" ) ; ) ; assertEquals ( Arrays . asList ( "onNext" , "onComplete" , "finally" ) , list ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; TestHelper . rejectFlowableFusion ( ) . doFinally ( ( ) -> ) . subscribeWith ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; TestHelper . rejectFlowableFusion ( ) . doFinally ( ( ) -> ) . compose ( TestHelper . conditional ( ) ) . subscribeWith ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) ; 
Flowable < ? > source = Flowable . just ( 1 , 2 ) ; Flowable < Integer > flowable = source . cast ( Integer . class ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < ? > source = Flowable . just ( 1 , 2 ) ; Flowable < Boolean > flowable = source . cast ( Boolean . class ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( ClassCastException . class ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < String > ts = TestSubscriber . create ( ) ; pp . cast ( String . class ) . subscribe ( ts ) ; Assert . assertTrue ( "Not subscribed?" , pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; Assert . assertFalse ( "Subscribed?" , pp . hasSubscribers ( ) ) ; ts . assertError ( ClassCastException . class ) ; 
Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . just ( 1 , 2 , 3 ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > obs = Flowable . just ( "one" , "null" , "two" , "three" , "four" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; TestSubscriberEx < String > ts = new TestSubscriberEx < > ( subscriber ) ; obs . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 1000 , TimeUnit . MILLISECONDS ) ; if ( ts . errors ( ) . size ( ) > 0 ) for ( Throwable t : ts . errors ( ) ) t . printStackTrace ( ) ; fail ( "failed with exception" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "null" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
System . out . println ( "Main Thread: " + Thread . currentThread ( ) . getName ( ) ) ; Flowable < String > obs = Flowable . just ( "one" , "null" , "two" , "three" , "four" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; final String parentThreadName = Thread . currentThread ( ) . getName ( ) ; final CountDownLatch completedLatch = new CountDownLatch ( 1 ) ; obs = obs . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String s ) String threadName = Thread . currentThread ( ) . getName ( ) ; System . out . println ( "Source ThreadName: " + threadName + "  Expected => " + parentThreadName ) ; assertEquals ( parentThreadName , threadName ) ; ) ; obs . observeOn ( Schedulers . newThread ( ) ) . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) String threadName = Thread . currentThread ( ) . getName ( ) ; boolean correctThreadName = threadName . startsWith ( "RxNewThreadScheduler" ) ; System . out . println ( "ObserveOn ThreadName: " + threadName + "  Correct => " + correctThreadName ) ; assertTrue ( correctThreadName ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) completedLatch . countDown ( ) ; ) . subscribe ( subscriber ) ; if ( ! completedLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out waiting" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 5 ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Scheduler scheduler = ImmediateThinScheduler . INSTANCE ; Flowable < Integer > f = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Integer > f2 = f . observeOn ( scheduler ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; Subscriber < Object > subscriber2 = TestHelper . mockSubscriber ( ) ; InOrder inOrder1 = inOrder ( subscriber1 ) ; InOrder inOrder2 = inOrder ( subscriber2 ) ; f2 . subscribe ( subscriber1 ) ; f2 . subscribe ( subscriber2 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder1 . verifyNoMoreInteractions ( ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 1 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 3 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder2 . verifyNoMoreInteractions ( ) ; 
TestScheduler scheduler1 = new TestScheduler ( ) ; TestScheduler scheduler2 = new TestScheduler ( ) ; Flowable < Integer > f = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Integer > f1 = f . observeOn ( scheduler1 ) ; Flowable < Integer > f2 = f . observeOn ( scheduler2 ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; Subscriber < Object > subscriber2 = TestHelper . mockSubscriber ( ) ; InOrder inOrder1 = inOrder ( subscriber1 ) ; InOrder inOrder2 = inOrder ( subscriber2 ) ; f1 . subscribe ( subscriber1 ) ; f2 . subscribe ( subscriber2 ) ; scheduler1 . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; scheduler2 . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder1 . verifyNoMoreInteractions ( ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 1 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 3 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder2 . verifyNoMoreInteractions ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final int _multiple = 99 ; Flowable . range ( 1 , 100000 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * _multiple ; ) . observeOn ( Schedulers . newThread ( ) ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) assertEquals ( count . incrementAndGet ( ) * _multiple , t1 . intValue ( ) ) ; String name = Thread . currentThread ( ) . getName ( ) ; assertFalse ( "Wrong thread name: " + name , name . startsWith ( "Rx" ) ) ; ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final int _multiple = 99 ; Flowable . range ( 1 , 100000 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * _multiple ; ) . observeOn ( Schedulers . computation ( ) ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) assertEquals ( count . incrementAndGet ( ) * _multiple , t1 . intValue ( ) ) ; String name = Thread . currentThread ( ) . getName ( ) ; assertFalse ( "Wrong thread name: " + name , name . startsWith ( "Rx" ) ) ; ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final int _multiple = 99 ; Flowable . range ( 1 , 10000 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) if ( randomIntFrom0to100 ( ) > 98 ) try Thread . sleep ( 2 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 * _multiple ; ) . observeOn ( Schedulers . computation ( ) ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) assertEquals ( count . incrementAndGet ( ) * _multiple , t1 . intValue ( ) ) ; String name = Thread . currentThread ( ) . getName ( ) ; assertFalse ( "Wrong thread name: " + name , name . startsWith ( "Rx" ) ) ; ) ; 
final CountDownLatch completedLatch = new CountDownLatch ( 1 ) ; final CountDownLatch nextLatch = new CountDownLatch ( 1 ) ; final AtomicLong completeTime = new AtomicLong ( ) ; Flowable . range ( 1 , 2 ) . subscribeOn ( Schedulers . newThread ( ) ) . observeOn ( Schedulers . newThread ( ) ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) System . out . println ( "onComplete" ) ; completeTime . set ( System . nanoTime ( ) ) ; completedLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) try if ( ! nextLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ) throw new RuntimeException ( "it shouldn't have timed out" ) ; catch ( InterruptedException e ) throw new RuntimeException ( "it shouldn't have failed" ) ; ) ; long afterSubscribeTime = System . nanoTime ( ) ; System . out . println ( "After subscribe: " + completedLatch . getCount ( ) ) ; assertEquals ( 1 , completedLatch . getCount ( ) ) ; nextLatch . countDown ( ) ; completedLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ; assertTrue ( completeTime . get ( ) > afterSubscribeTime ) ; System . out . println ( "onComplete nanos after subscribe: " + ( completeTime . get ( ) - afterSubscribeTime ) ) ; 
System . out . println ( "onComplete" ) ; completeTime . set ( System . nanoTime ( ) ) ; completedLatch . countDown ( ) ; 
long x = System . nanoTime ( ) ; x ^= ( x << 21 ) ; x ^= ( x > > > 35 ) ; x ^= ( x << 4 ) ; return Math . abs ( ( int ) x % 100 ) ; 
TestScheduler testScheduler = new TestScheduler ( ) ; Flowable < Integer > source = Flowable . concat ( Flowable . < Integer > error ( new TestException ( ) ) , Flowable . just ( 1 ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . observeOn ( testScheduler ) . subscribe ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( TestException . class ) ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyInt ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; 
final TestScheduler testScheduler = new TestScheduler ( ) ; final Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( subscriber ) ; Flowable . just ( 1 , 2 , 3 ) . observeOn ( testScheduler ) . subscribe ( ts ) ; ts . cancel ( ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; final InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyInt ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Exception . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; 
final AtomicInteger generated = new AtomicInteger ( ) ; Flowable < Integer > flowable = Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) @ Override public Integer next ( ) return generated . getAndIncrement ( ) ; @ Override public boolean hasNext ( ) return true ; ; ) ; TestSubscriber < Integer > testSubscriber = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) System . err . println ( "c t = " + t + " thread " + Thread . currentThread ( ) ) ; super . onNext ( t ) ; try Thread . sleep ( 10 ) ; catch ( InterruptedException e ) ; flowable . observeOn ( Schedulers . newThread ( ) ) . take ( 3 ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 5 , TimeUnit . SECONDS ) ; System . err . println ( testSubscriber . values ( ) ) ; testSubscriber . assertValues ( 0 , 1 , 2 ) ; System . out . println ( "Generated: " + generated . get ( ) ) ; assertTrue ( generated . get ( ) >= 3 && generated . get ( ) <= Flowable . bufferSize ( ) ) ; 
int numForBatches = Flowable . bufferSize ( ) * 3 + 1 ; final AtomicInteger generated = new AtomicInteger ( ) ; Flowable < Integer > flowable = Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) @ Override public Integer next ( ) return generated . getAndIncrement ( ) ; @ Override public boolean hasNext ( ) return true ; ; ) ; TestSubscriber < Integer > testSubscriber = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ; flowable . observeOn ( Schedulers . newThread ( ) ) . take ( numForBatches ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 5 , TimeUnit . SECONDS ) ; System . err . println ( testSubscriber . values ( ) ) ; System . out . println ( "Generated: " + generated . get ( ) ) ; assertTrue ( generated . get ( ) >= numForBatches && generated . get ( ) <= numForBatches + Flowable . bufferSize ( ) ) ; 
final AtomicInteger generated = new AtomicInteger ( ) ; Flowable < Integer > flowable = Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) @ Override public Integer next ( ) return generated . getAndIncrement ( ) ; @ Override public boolean hasNext ( ) return true ; ; ) ; TestSubscriber < Integer > testSubscriber = new TestSubscriber < > ( ) ; flowable . take ( 7 ) . observeOn ( Schedulers . newThread ( ) ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 5 , TimeUnit . SECONDS ) ; testSubscriber . assertValues ( 0 , 1 , 2 , 3 , 4 , 5 , 6 ) ; assertEquals ( 7 , generated . get ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; Flowable < Integer > flowable = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < Flowable . bufferSize ( ) + 10 ; i ++ ) subscriber . onNext ( i ) ; latch . countDown ( ) ; subscriber . onComplete ( ) ; ) ; TestSubscriberEx < Integer > testSubscriber = new TestSubscriberEx < > ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) try latch . await ( 500 , TimeUnit . MILLISECONDS ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; ) ; flowable . observeOn ( Schedulers . newThread ( ) ) . subscribe ( testSubscriber ) ; testSubscriber . awaitDone ( 5 , TimeUnit . SECONDS ) ; List < Throwable > errors = testSubscriber . errors ( ) ; assertEquals ( 1 , errors . size ( ) ) ; System . out . println ( "Errors: " + errors ) ; Throwable t = errors . get ( 0 ) ; if ( t instanceof MissingBackpressureException ) else if ( t . getCause ( ) instanceof MissingBackpressureException ) else fail ( "Expecting MissingBackpressureException" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , 100000 ) . observeOn ( Schedulers . newThread ( ) ) . observeOn ( Schedulers . newThread ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final PublishProcessor < Long > processor = PublishProcessor . create ( ) ; final AtomicLong counter = new AtomicLong ( ) ; TestSubscriberEx < Long > ts = new TestSubscriberEx < > ( new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long t ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) ) ; processor . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; while ( counter . get ( ) < 102400 ) processor . onNext ( counter . get ( ) ) ; counter . incrementAndGet ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; ts . assertError ( MissingBackpressureException . class ) ; List < Long > onNextEvents = ts . values ( ) ; assertTrue ( onNextEvents . isEmpty ( ) || onNextEvents . size ( ) == onNextEvents . get ( onNextEvents . size ( ) - 1 ) + 1 ) ; assertTrue ( onNextEvents . size ( ) < Flowable . bufferSize ( ) ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; Flowable . interval ( 0 , 1 , TimeUnit . MICROSECONDS ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Long , String > ( ) @ Override public String apply ( Long t1 ) System . out . println ( t1 ) ; try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) return t1 + " slow value" ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; System . out . println ( "Errors: " + ts . errors ( ) ) ; assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; assertEquals ( MissingBackpressureException . class , ts . errors ( ) . get ( 0 ) . getClass ( ) ) ; 
Flowable < Long > timer = Flowable . interval ( 0 , 1 , TimeUnit . MICROSECONDS ) . doOnEach ( new Consumer < Notification < Long > > ( ) @ Override public void accept ( Notification < Long > n ) ) . observeOn ( Schedulers . newThread ( ) ) . doOnEach ( new Consumer < Notification < Long > > ( ) @ Override public void accept ( Notification < Long > n ) try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) ) ; TestSubscriberEx < Long > ts = new TestSubscriberEx < > ( ) ; Flowable . combineLatest ( timer , Flowable . < Integer > never ( ) , new BiFunction < Long , Integer , Long > ( ) @ Override public Long apply ( Long t1 , Integer t2 ) return t1 ; ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; assertEquals ( MissingBackpressureException . class , ts . errors ( ) . get ( 0 ) . getClass ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . range ( 1 , 100 ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( new DefaultSubscriber < Integer > ( ) boolean first = true ; @ Override public void onStart ( ) request ( 2 ) ; @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) count . incrementAndGet ( ) ; if ( first ) request ( Long . MAX_VALUE - 1 ) ; request ( Long . MAX_VALUE - 1 ) ; request ( 10 ) ; first = false ; ) ; assertTrue ( latch . await ( 10 , TimeUnit . SECONDS ) ) ; assertEquals ( 100 , count . get ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final List < Long > requests = Collections . synchronizedList ( new ArrayList < > ( ) ) ; Flowable . range ( 1 , 1000000 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) requests . add ( n ) ; ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) cancel ( ) ; latch . countDown ( ) ; ) ; assertTrue ( latch . await ( 10 , TimeUnit . SECONDS ) ) ; assertEquals ( Arrays . asList ( 128L ) , requests ) ; 
TestScheduler s = new TestScheduler ( ) ; Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; source . observeOn ( s , true ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; s . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; s . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 3 ) ; s . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; source . observeOn ( Schedulers . computation ( ) , true ) . subscribe ( ts ) ; ts . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; TestScheduler test = new TestScheduler ( ) ; Flowable . range ( 1 , 10 ) . observeOn ( test ) . subscribe ( ts ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 10 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 10 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; TestScheduler test = new TestScheduler ( ) ; final List < Long > requests = new ArrayList < > ( ) ; Flowable . range ( 1 , 100 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long v ) requests . add ( v ) ; ) . observeOn ( test , false , 16 ) . subscribe ( ts ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . request ( 20 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . request ( 10 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . request ( 50 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . request ( 35 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 100 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; assertEquals ( Arrays . asList ( 16L , 12L , 12L , 12L , 12L , 12L , 12L , 12L , 12L ) , requests ) ; 
for ( int i = 1 ; i <= 1024 ; i = i * 2 ) TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 1 , 1000 * 1000 ) . observeOn ( Schedulers . computation ( ) , false , i ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 1000 * 1000 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
final List < Long > requests = new ArrayList < > ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 50 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long r ) requests . add ( r ) ; ) . rebatchRequests ( 20 ) . subscribe ( ts ) ; ts . assertValueCount ( 50 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; assertEquals ( Arrays . asList ( 20L , 15L , 15L , 15L ) , requests ) ; 
try Flowable . never ( ) . rebatchRequests ( - 99 ) ; fail ( "Didn't throw IAE" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "bufferSize > 0 required but it was -99" , ex . getMessage ( ) ) ; 
Flowable . range ( 1 , 5 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . observeOn ( Schedulers . computation ( ) , true ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( v == 1 ) Thread . sleep ( 100 ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 , 4 ) ; 
Flowable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . take ( 3 ) . take ( 3 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . test ( 0L ) ; ts . cancel ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 , 4 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 , 4 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testSubscriber ( 1L ) ) ; Thread . sleep ( 100 ) ; ts . assertSubscribed ( ) . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . filter ( Functions . alwaysTrue ( ) ) . to ( TestHelper . < Integer > testSubscriber ( 1L ) ) ; Thread . sleep ( 100 ) ; ts . assertSubscribed ( ) . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . observeOn ( Schedulers . single ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onNext ( 3 ) ; up . onNext ( 4 ) ; up . onNext ( 5 ) ; up . onComplete ( ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 , 4 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 , 4 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . map ( Functions . < Integer > identity ( ) ) . observeOn ( Schedulers . single ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 , 4 ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . observeOn ( new TestScheduler ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . observeOn ( new TestScheduler ( ) ) ; ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . observeOn ( new TestScheduler ( ) ) . compose ( TestHelper . conditional ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; TestSubscriber < Integer > ts = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . observeOn ( scheduler ) . test ( ) ; scheduler . triggerActions ( ) ; ts . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestSubscriber < Integer > ts = up . observeOn ( Schedulers . single ( ) ) . test ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestSubscriber < Integer > ts = up . observeOn ( Schedulers . single ( ) ) . test ( ) ; up . onError ( new TestException ( ) ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestSubscriber < Integer > ts = up . observeOn ( Schedulers . single ( ) , true ) . test ( ) ; up . onError ( new TestException ( ) ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . observeOn ( Schedulers . single ( ) ) . subscribe ( ts ) ; up . onError ( new TestException ( ) ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . observeOn ( Schedulers . single ( ) , true ) . subscribe ( ts ) ; up . onError ( new TestException ( ) ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
final UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; up . observeOn ( Schedulers . single ( ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) Subscription upstream ; int count ; @ Override public void onSubscribe ( Subscription s ) this . upstream = s ; ( ( QueueSubscription < ? > ) s ) . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer value ) if ( ++ count == 1 ) up . onNext ( 2 ) ; upstream . cancel ( ) ; cdl . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; up . onNext ( 1 ) ; cdl . await ( ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; @ SuppressWarnings ( "unchecked" ) BaseObserveOnSubscriber < Integer > oo = ( BaseObserveOnSubscriber < Integer > ) subscriber ; oo . sourceMode = QueueFuseable . SYNC ; oo . requested . lazySet ( 1 ) ; oo . queue = new SimpleQueue < Integer > ( ) @ Override public boolean offer ( Integer value ) return false ; @ Override public boolean offer ( Integer v1 , Integer v2 ) return false ; @ Nullable @ Override public Integer poll ( ) throws Exception throw new TestException ( ) ; @ Override public boolean isEmpty ( ) return false ; @ Override public void clear ( ) ; oo . clear ( ) ; oo . trySchedule ( ) ; . observeOn ( Schedulers . single ( ) ) . test ( 0L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; @ SuppressWarnings ( "unchecked" ) BaseObserveOnSubscriber < Integer > oo = ( BaseObserveOnSubscriber < Integer > ) subscriber ; oo . sourceMode = QueueFuseable . SYNC ; oo . requested . lazySet ( 1 ) ; oo . queue = new SimpleQueue < Integer > ( ) @ Override public boolean offer ( Integer value ) return false ; @ Override public boolean offer ( Integer v1 , Integer v2 ) return false ; @ Nullable @ Override public Integer poll ( ) throws Exception throw new TestException ( ) ; @ Override public boolean isEmpty ( ) return false ; @ Override public void clear ( ) ; oo . clear ( ) ; oo . trySchedule ( ) ; . observeOn ( Schedulers . single ( ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( 0L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; @ SuppressWarnings ( "unchecked" ) BaseObserveOnSubscriber < Integer > oo = ( BaseObserveOnSubscriber < Integer > ) subscriber ; oo . sourceMode = QueueFuseable . ASYNC ; oo . requested . lazySet ( 1 ) ; oo . queue = new SimpleQueue < Integer > ( ) @ Override public boolean offer ( Integer value ) return false ; @ Override public boolean offer ( Integer v1 , Integer v2 ) return false ; @ Nullable @ Override public Integer poll ( ) throws Exception throw new TestException ( ) ; @ Override public boolean isEmpty ( ) return false ; @ Override public void clear ( ) ; oo . clear ( ) ; oo . trySchedule ( ) ; . observeOn ( Schedulers . single ( ) ) . test ( 0L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; @ SuppressWarnings ( "unchecked" ) BaseObserveOnSubscriber < Integer > oo = ( BaseObserveOnSubscriber < Integer > ) subscriber ; oo . sourceMode = QueueFuseable . ASYNC ; oo . requested . lazySet ( 1 ) ; oo . queue = new SimpleQueue < Integer > ( ) @ Override public boolean offer ( Integer value ) return false ; @ Override public boolean offer ( Integer v1 , Integer v2 ) return false ; @ Nullable @ Override public Integer poll ( ) throws Exception throw new TestException ( ) ; @ Override public boolean isEmpty ( ) return false ; @ Override public void clear ( ) ; oo . clear ( ) ; oo . trySchedule ( ) ; . observeOn ( Schedulers . single ( ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( 0L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . observeOn ( Schedulers . trampoline ( ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 1000 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . take ( 250 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 250 ) . assertNoErrors ( ) . assertComplete ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 2L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 2 ) cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 3 ) . observeOn ( Schedulers . single ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 2L ) ; Flowable . range ( 1 , 2 ) . observeOn ( Schedulers . single ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 2L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 2 ) cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 3 ) . observeOn ( Schedulers . single ( ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 2L ) ; Flowable . range ( 1 , 2 ) . observeOn ( Schedulers . single ( ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 2L ) ; Flowable . range ( 1 , 2 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
Flowable . just ( 1 ) . hide ( ) . observeOn ( Schedulers . computation ( ) ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . error ( new TestException ( ) ) . observeOn ( Schedulers . computation ( ) ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . error ( new TestException ( ) ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 10 ) . hide ( ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . filter ( Functions . alwaysTrue ( ) ) . test ( 1L ) . assertValue ( 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 100 ) . hide ( ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertValueCount ( 100 ) . assertComplete ( ) . assertNoErrors ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . < Integer > error ( new TestException ( ) ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final TestScheduler scheduler = new TestScheduler ( ) ; Flowable . just ( 1 ) . hide ( ) . observeOn ( scheduler ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) scheduler . triggerActions ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) ; if ( ts . values ( ) . size ( ) != 0 ) ts . assertResult ( 1 ) ; 
Flowable . range ( 1 , 5 ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . filter ( Functions . alwaysTrue ( ) ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
return new TrackingWorker ( ) ; 
disposedCount . getAndIncrement ( ) ; 
return false ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; Flowable . concat ( Flowable . just ( 1 ) . hide ( ) . observeOn ( s ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; Flowable . concat ( Flowable . just ( 1 ) . observeOn ( s ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; up . onComplete ( ) ; Flowable . concat ( up . observeOn ( s ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberFusedCanceling ( ) ; Flowable . just ( 1 ) . hide ( ) . observeOn ( s ) . subscribe ( ts ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; Flowable . concat ( Flowable . just ( 1 ) . hide ( ) . observeOn ( s ) . filter ( Functions . alwaysTrue ( ) ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; Flowable . concat ( Flowable . just ( 1 ) . observeOn ( s ) . filter ( Functions . alwaysTrue ( ) ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; up . onComplete ( ) ; Flowable . concat ( up . observeOn ( s ) . filter ( Functions . alwaysTrue ( ) ) , Flowable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberFusedCanceling ( ) ; Flowable . just ( 1 ) . hide ( ) . observeOn ( s ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
for ( int j = 0 ; j < TestHelper . RACE_LONG_LOOPS ; j ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestObserver < Integer > to = up . hide ( ) . observeOn ( Schedulers . io ( ) ) . observeOn ( Schedulers . single ( ) ) . unsubscribeOn ( Schedulers . computation ( ) ) . firstOrError ( ) . test ( ) ; for ( int i = 0 ; up . hasSubscribers ( ) && i < 10000 ; i ++ ) up . onNext ( i ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( ! errors . isEmpty ( ) ) throw new CompositeException ( errors ) ; to . assertResult ( 0 ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 0 , 500000 ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . map ( Functions . < Integer > identity ( ) ) . sequential ( ) . test ( ) . awaitDone ( 20 , TimeUnit . SECONDS ) . assertValueCount ( 500000 ) . assertComplete ( ) . assertNoErrors ( ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . observeOn ( ImmediateThinScheduler . INSTANCE ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . map ( v -> ts . cancel ( ) ; return v + 1 ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . map ( v -> ts . cancel ( ) ; return v + 1 ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . compose ( TestHelper . conditional ( ) ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
final TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . observeOn ( ImmediateThinScheduler . INSTANCE ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 , 2 ) ; 
final TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . observeOn ( ImmediateThinScheduler . INSTANCE ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 , 2 ) ; 
final TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . observeOn ( ImmediateThinScheduler . INSTANCE ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; ) . compose ( TestHelper . conditional ( ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 , 2 ) ; 
final TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . observeOn ( ImmediateThinScheduler . INSTANCE ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; ) . compose ( TestHelper . conditional ( ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 , 2 ) ; 
Subscriber < String > consumer = TestHelper . mockSubscriber ( ) ; Flowable < String > producer = Flowable . unsafeCreate ( new Publisher < String > ( ) private AtomicInteger count = new AtomicInteger ( 4 ) ; long last = System . currentTimeMillis ( ) ; @ Override public void subscribe ( Subscriber < ? super String > t1 ) t1 . onSubscribe ( new BooleanSubscription ( ) ) ; System . out . println ( count . get ( ) + " @ " + String . valueOf ( last - System . currentTimeMillis ( ) ) ) ; last = System . currentTimeMillis ( ) ; if ( count . getAndDecrement ( ) == 0 ) t1 . onNext ( "hello" ) ; t1 . onComplete ( ) ; else t1 . onError ( new RuntimeException ( ) ) ; ) ; TestSubscriber < String > ts = new TestSubscriber < > ( consumer ) ; producer . retryWhen ( new Function < Flowable < ? extends Throwable > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < ? extends Throwable > attempts ) return attempts . map ( new Function < Throwable , Tuple > ( ) @ Override public Tuple apply ( Throwable n ) return new Tuple ( 1L , n ) ; ) . scan ( new BiFunction < Tuple , Tuple , Tuple > ( ) @ Override public Tuple apply ( Tuple t , Tuple n ) return new Tuple ( t . count + n . count , n . n ) ; ) . flatMap ( new Function < Tuple , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Tuple t ) System . out . println ( "Retry # " + t . count ) ; return t . count > 20 ? Flowable . < Object > error ( t . n ) : Flowable . timer ( t . count * 1L , TimeUnit . MILLISECONDS ) . cast ( Object . class ) ; ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; InOrder inOrder = inOrder ( consumer ) ; inOrder . verify ( consumer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( consumer , times ( 1 ) ) . onNext ( "hello" ) ; inOrder . verify ( consumer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
t1 . onSubscribe ( new BooleanSubscription ( ) ) ; System . out . println ( count . get ( ) + " @ " + String . valueOf ( last - System . currentTimeMillis ( ) ) ) ; last = System . currentTimeMillis ( ) ; if ( count . getAndDecrement ( ) == 0 ) t1 . onNext ( "hello" ) ; t1 . onComplete ( ) ; else t1 . onError ( new RuntimeException ( ) ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; int numRetries = 20 ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( numRetries ) ) ; origin . retry ( ) . subscribe ( new TestSubscriber < > ( subscriber ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( numRetries + 1 ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; int numRetries = 2 ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( numRetries ) ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; origin . retryWhen ( new Function < Flowable < ? extends Throwable > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < ? extends Throwable > t1 ) return t1 . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable t1 ) return 1 ; ) . startWithItem ( 1 ) . cast ( Object . class ) ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) e . printStackTrace ( ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 + numRetries ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; int numRetries = 2 ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( numRetries ) ) ; origin . retryWhen ( new Function < Flowable < ? extends Throwable > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < ? extends Throwable > t1 ) return t1 . map ( new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable t1 ) return 0 ; ) . startWithItem ( 0 ) . cast ( Object . class ) ; ) . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( numRetries + 1 ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( 1 ) ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; origin . retryWhen ( new Function < Flowable < ? extends Throwable > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < ? extends Throwable > t1 ) return Flowable . empty ( ) ; ) . subscribe ( ts ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Exception . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( 2 ) ) ; origin . retryWhen ( new Function < Flowable < ? extends Throwable > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < ? extends Throwable > t1 ) return Flowable . error ( new RuntimeException ( ) ) ; ) . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final AtomicInteger inc = new AtomicInteger ( 0 ) ; Publisher < Integer > onSubscribe = new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; final int emit = inc . incrementAndGet ( ) ; subscriber . onNext ( emit ) ; subscriber . onComplete ( ) ; ; int first = Flowable . unsafeCreate ( onSubscribe ) . retryWhen ( new Function < Flowable < ? extends Throwable > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < ? extends Throwable > attempt ) return attempt . zipWith ( Flowable . just ( 1 ) , new BiFunction < Throwable , Integer , Object > ( ) @ Override public Object apply ( Throwable o , Integer integer ) return 0 ; ) ; ) . blockingFirst ( ) ; assertEquals ( "Observer did not receive the expected output" , 1 , first ) ; assertEquals ( "Subscribe was not called once" , 1 , inc . get ( ) ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; final int emit = inc . incrementAndGet ( ) ; subscriber . onNext ( emit ) ; subscriber . onComplete ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( 1 ) ) ; origin . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; 
int numRetries = 1 ; int numFailures = 2 ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( numFailures ) ) ; origin . retry ( numRetries ) . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 + numRetries ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
int numFailures = 1 ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( numFailures ) ) ; origin . retry ( 3 ) . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 + numFailures ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
int numFailures = 20 ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( numFailures ) ) ; origin . retry ( ) . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 + numFailures ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Consumer < Integer > record = mock ( Consumer . class ) ; InOrder inOrder = inOrder ( record ) ; Consumer < Integer > throwException = mock ( Consumer . class ) ; doThrow ( new RuntimeException ( ) ) . when ( throwException ) . accept ( Mockito . anyInt ( ) ) ; PublishProcessor < Integer > processor = PublishProcessor . create ( ) ; processor . doOnNext ( record ) . doOnNext ( throwException ) . retry ( ) . subscribe ( ) ; inOrder . verifyNoMoreInteractions ( ) ; processor . onNext ( 1 ) ; inOrder . verify ( record ) . accept ( 1 ) ; processor . onNext ( 2 ) ; inOrder . verify ( record ) . accept ( 2 ) ; processor . onNext ( 3 ) ; inOrder . verify ( record ) . accept ( 3 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishProcessor < Integer > processor = PublishProcessor . create ( ) ; final AtomicInteger count = new AtomicInteger ( 0 ) ; Disposable sub = processor . retry ( ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer n ) count . incrementAndGet ( ) ; ) ; processor . onNext ( 1 ) ; sub . dispose ( ) ; processor . onNext ( 2 ) ; assertEquals ( 1 , count . get ( ) ) ; 
final AtomicInteger subsCount = new AtomicInteger ( 0 ) ; Publisher < String > onSubscribe = new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > s ) subsCount . incrementAndGet ( ) ; s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) @ Override public void cancel ( ) subsCount . decrementAndGet ( ) ; ) ; ; Flowable < String > stream = Flowable . unsafeCreate ( onSubscribe ) ; Flowable < String > streamWithRetry = stream . retry ( ) ; Disposable sub = streamWithRetry . subscribe ( ) ; assertEquals ( 1 , subsCount . get ( ) ) ; sub . dispose ( ) ; assertEquals ( 0 , subsCount . get ( ) ) ; streamWithRetry . subscribe ( ) ; assertEquals ( 1 , subsCount . get ( ) ) ; 
final AtomicInteger subsCount = new AtomicInteger ( 0 ) ; final TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Publisher < String > onSubscribe = new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > s ) BooleanSubscription bs = new BooleanSubscription ( ) ; if ( ! bs . isCancelled ( ) ) subsCount . incrementAndGet ( ) ; s . onError ( new RuntimeException ( "failed" ) ) ; bs . cancel ( ) ; else s . onError ( new RuntimeException ( ) ) ; ; Flowable . unsafeCreate ( onSubscribe ) . retry ( 3 ) . subscribe ( ts ) ; assertEquals ( 4 , subsCount . get ( ) ) ; 
final AtomicInteger subsCount = new AtomicInteger ( 0 ) ; final TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Publisher < String > onSubscribe = new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; subsCount . incrementAndGet ( ) ; s . onError ( new RuntimeException ( "failed" ) ) ; ; Flowable . unsafeCreate ( onSubscribe ) . retry ( 1 ) . subscribe ( ts ) ; assertEquals ( 2 , subsCount . get ( ) ) ; 
final AtomicInteger subsCount = new AtomicInteger ( 0 ) ; final TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Publisher < String > onSubscribe = new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; subsCount . incrementAndGet ( ) ; s . onError ( new RuntimeException ( "failed" ) ) ; ; Flowable . unsafeCreate ( onSubscribe ) . retry ( 0 ) . subscribe ( ts ) ; assertEquals ( 1 , subsCount . get ( ) ) ; 
try latch . await ( ) ; catch ( InterruptedException e ) fail ( "Test interrupted" ) ; 
target . onComplete ( ) ; latch . countDown ( ) ; 
target . onError ( t ) ; latch . countDown ( ) ; 
Subscriber < Long > subscriber = TestHelper . mockSubscriber ( ) ; SlowFlowable so = new SlowFlowable ( 100 , 0 , "testUnsubscribeAfterError" ) ; Flowable < Long > f = Flowable . unsafeCreate ( so ) . retry ( 5 ) ; AsyncSubscriber < Long > async = new AsyncSubscriber < > ( subscriber ) ; f . subscribe ( async ) ; async . await ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; assertEquals ( "Start 6 threads, retry 5 then fail on 6" , 6 , so . efforts . get ( ) ) ; assertEquals ( "Only 1 active subscription" , 1 , so . maxActive . get ( ) ) ; 
Subscriber < Long > subscriber = TestHelper . mockSubscriber ( ) ; SlowFlowable sf = new SlowFlowable ( 100 , 10 , "testTimeoutWithRetry" ) ; Flowable < Long > f = Flowable . unsafeCreate ( sf ) . timeout ( 80 , TimeUnit . MILLISECONDS ) . retry ( 5 ) ; AsyncSubscriber < Long > async = new AsyncSubscriber < > ( subscriber ) ; f . subscribe ( async ) ; async . await ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; assertEquals ( "Start 6 threads, retry 5 then fail on 6" , 6 , sf . efforts . get ( ) ) ; 
final int NUM_LOOPS = 1 ; for ( int j = 0 ; j < NUM_LOOPS ; j ++ ) final int numRetries = Flowable . bufferSize ( ) * 2 ; for ( int i = 0 ; i < 400 ; i ++ ) Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( numRetries ) ) ; TestSubscriberEx < String > ts = new TestSubscriberEx < > ( subscriber ) ; origin . retry ( ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( numRetries + 1 ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final int NUM_LOOPS = 1 ; final int numRetries = Flowable . bufferSize ( ) * 2 ; int ncpu = Runtime . getRuntime ( ) . availableProcessors ( ) ; ExecutorService exec = Executors . newFixedThreadPool ( Math . max ( ncpu / 2 , 2 ) ) ; try for ( int r = 0 ; r < NUM_LOOPS ; r ++ ) if ( r % 10 == 0 ) System . out . println ( "testRetryWithBackpressureParallelLoop -> " + r ) ; final AtomicInteger timeouts = new AtomicInteger ( ) ; final Map < Integer , List < String > > data = new ConcurrentHashMap < > ( ) ; int m = 5000 ; final CountDownLatch cdl = new CountDownLatch ( m ) ; for ( int i = 0 ; i < m ; i ++ ) final int j = i ; exec . execute ( new Runnable ( ) @ Override public void run ( ) final AtomicInteger nexts = new AtomicInteger ( ) ; try Flowable < String > origin = Flowable . unsafeCreate ( new FuncWithErrors ( numRetries ) ) ; TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; origin . retry ( ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 2500 , TimeUnit . MILLISECONDS ) ; List < String > onNextEvents = new ArrayList < > ( ts . values ( ) ) ; if ( onNextEvents . size ( ) != numRetries + 2 ) for ( Throwable t : ts . errors ( ) ) onNextEvents . add ( t . toString ( ) ) ; for ( long err = ts . completions ( ) ; err != 0 ; err -- ) onNextEvents . add ( "onComplete" ) ; data . put ( j , onNextEvents ) ; catch ( Throwable t ) timeouts . incrementAndGet ( ) ; System . out . println ( j + " | " + cdl . getCount ( ) + " !!! " + nexts . get ( ) ) ; cdl . countDown ( ) ; ) ; cdl . await ( ) ; assertEquals ( 0 , timeouts . get ( ) ) ; if ( data . size ( ) > 0 ) fail ( "Data content mismatch: " + allSequenceFrequency ( data ) ) ; finally exec . shutdown ( ) ; 
StringBuilder b = new StringBuilder ( ) ; for ( Map . Entry < Integer , List < T > > e : its . entrySet ( ) ) if ( b . length ( ) > 0 ) b . append ( ", " ) ; b . append ( e . getKey ( ) ) . append ( "={" ) ; b . append ( sequenceFrequency ( e . getValue ( ) ) ) ; b . append ( "}" ) ; return b ; 
StringBuilder sb = new StringBuilder ( ) ; Object prev = null ; int cnt = 0 ; for ( Object curr : it ) if ( sb . length ( ) > 0 ) if ( ! curr . equals ( prev ) ) if ( cnt > 1 ) sb . append ( " x " ) . append ( cnt ) ; cnt = 1 ; sb . append ( ", " ) ; sb . append ( curr ) ; else cnt ++ ; else sb . append ( curr ) ; cnt ++ ; prev = curr ; if ( cnt > 1 ) sb . append ( " x " ) . append ( cnt ) ; return sb ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; final int NUM_MSG = 1034 ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable < String > origin = Flowable . range ( 0 , NUM_MSG ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "msg: " + count . incrementAndGet ( ) ; ) ; origin . retry ( ) . groupBy ( new Function < String , String > ( ) @ Override public String apply ( String t1 ) return t1 ; ) . flatMap ( new Function < GroupedFlowable < String , String > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( GroupedFlowable < String , String > t1 ) return t1 . take ( 1 ) ; , NUM_MSG ) . subscribe ( new TestSubscriber < > ( subscriber ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( NUM_MSG ) ) . onNext ( any ( java . lang . String . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; final int NUM_MSG = 1034 ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable < String > origin = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < NUM_MSG ; i ++ ) subscriber . onNext ( "msg:" + count . incrementAndGet ( ) ) ; subscriber . onComplete ( ) ; ) ; origin . retry ( ) . groupBy ( new Function < String , String > ( ) @ Override public String apply ( String t1 ) return t1 ; ) . flatMap ( new Function < GroupedFlowable < String , String > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( GroupedFlowable < String , String > t1 ) return t1 . take ( 1 ) ; ) . subscribe ( new TestSubscriber < > ( subscriber ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( NUM_MSG ) ) . onNext ( any ( java . lang . String . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . retryWhen ( ( Function ) new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable f ) return f . take ( 2 ) ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . subscribeOn ( Schedulers . trampoline ( ) ) . retryWhen ( ( Function ) new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable f ) return f . take ( 2 ) ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . retry ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable v ) throws Exception return true ; ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
try Flowable . just ( 1 ) . retry ( - 99 , new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return true ; ) ; fail ( "Should have thrown" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "times >= 0 required but it was -99" , ex . getMessage ( ) ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . retryUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
final PublishProcessor < Object > processor = PublishProcessor . create ( ) ; final Disposable disposable = Flowable . error ( new RuntimeException ( "Leak" ) ) . retryWhen ( new Function < Flowable < Throwable > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Throwable > errors ) throws Exception return errors . switchMap ( new Function < Throwable , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Throwable ignore ) throws Exception return processor ; ) ; ) . subscribe ( ) ; assertTrue ( processor . hasSubscribers ( ) ) ; disposable . dispose ( ) ; assertFalse ( processor . hasSubscribers ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . defer ( new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) throws Exception if ( times . getAndIncrement ( ) < 4 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( 1 ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retry ( 5 ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . defer ( new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) throws Exception if ( times . getAndIncrement ( ) < 4 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( 1 ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retry ( 5 , Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . defer ( new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) throws Exception if ( times . getAndIncrement ( ) < 4 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( 1 ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer a , Throwable b ) throws Exception return a < 5 ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . defer ( new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) throws Exception if ( times . getAndIncrement ( ) < 4 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( 1 ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retryUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . defer ( new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) throws Exception if ( times . get ( ) < 4 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( 1 ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retryWhen ( new Function < Flowable < Throwable > , Flowable < ? > > ( ) @ Override public Flowable < ? > apply ( Flowable < Throwable > e ) throws Exception return e . takeWhile ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) throws Exception return times . getAndIncrement ( ) < 4 ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . < Integer > error ( new TestException ( ) ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retryWhen ( new Function < Flowable < Throwable > , Flowable < ? > > ( ) @ Override public Flowable < ? > apply ( Flowable < Throwable > e ) throws Exception return e . takeWhile ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) throws Exception return times . getAndIncrement ( ) < 4 ; ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , counter . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; final TestException error = new TestException ( ) ; try final PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > signaller = PublishProcessor . create ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriber < Integer > ts = source . take ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw error ; ) . retryWhen ( new Function < Flowable < Throwable > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Throwable > v ) throws Exception return signaller ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) source . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) signaller . offer ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . cancel ( ) ; if ( ! errors . isEmpty ( ) ) for ( Throwable e : errors ) e . printStackTrace ( ) ; fail ( errors + "" ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . ignoreElement ( ) . toMaybe ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . ignoreElement ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > v ) throws Exception return v . ignoreElement ( ) . toMaybe ( ) ; ) ; 
TestHelper . checkDisposed ( Maybe . sequenceEqual ( Maybe . just ( 1 ) , Maybe . just ( 1 ) ) ) ; 
Maybe . sequenceEqual ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . doOnSuccess ( Functions . emptyConsumer ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > m ) throws Exception return m . doOnSuccess ( Functions . emptyConsumer ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; final Throwable [ ] err = null ; try TestObserverEx < Integer > to = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onError ( new TestException ( "Second" ) ) ; . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception err [ 0 ] = e ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; assertTrue ( "" + err , err [ 0 ] instanceof TestException ) ; assertEquals ( "First" , err [ 0 ] . getMessage ( ) ) ; to . assertFailureAndMessage ( TestException . class , "First" ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] compl = 0 ; TestObserver < Integer > to = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onComplete ( ) ; . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception compl [ 0 ] ++ ; ) . test ( ) ; assertEquals ( 1 , compl [ 0 ] ) ; to . assertResult ( ) ; 
TestObserverEx < Object > to = Maybe . error ( new TestException ( "Main" ) ) . doOnError ( new Consumer < Object > ( ) @ Override public void accept ( Object t ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) ; to . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Main" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Maybe . just ( 1 ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Maybe . switchOnNext ( Flowable . range ( 1 , 10 ) . map ( v -> if ( v % 2 == 0 ) return Maybe . just ( v ) ; return Maybe . empty ( ) ; ) ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
Maybe . switchOnNextDelayError ( Flowable . range ( 1 , 10 ) . map ( v -> if ( v % 2 == 0 ) return Maybe . just ( v ) ; return Maybe . empty ( ) ; ) ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
PublishProcessor < Maybe < Integer > > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Maybe . switchOnNext ( pp ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; MaybeSubject < Integer > ms1 = MaybeSubject . create ( ) ; MaybeSubject < Integer > ms2 = MaybeSubject . create ( ) ; pp . onNext ( ms1 ) ; assertTrue ( ms1 . hasObservers ( ) ) ; pp . onNext ( ms2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; pp . onComplete ( ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onSuccess ( 1 ) ; ts . assertResult ( 1 ) ; 
PublishProcessor < Maybe < Integer > > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Maybe . switchOnNextDelayError ( pp ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; MaybeSubject < Integer > ms1 = MaybeSubject . create ( ) ; MaybeSubject < Integer > ms2 = MaybeSubject . create ( ) ; pp . onNext ( ms1 ) ; assertTrue ( ms1 . hasObservers ( ) ) ; pp . onNext ( ms2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class ) ; 
MaybeCallbackObserver < Object > mo = new MaybeCallbackObserver < > ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION ) ; Disposable d = Disposable . empty ( ) ; mo . onSubscribe ( d ) ; assertFalse ( mo . isDisposed ( ) ) ; mo . dispose ( ) ; assertTrue ( mo . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try MaybeCallbackObserver < Object > mo = new MaybeCallbackObserver < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception throw new TestException ( ) ; , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION ) ; mo . onSubscribe ( Disposable . empty ( ) ) ; mo . onSuccess ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try MaybeCallbackObserver < Object > mo = new MaybeCallbackObserver < > ( Functions . emptyConsumer ( ) , new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception throw new TestException ( "Inner" ) ; , Functions . EMPTY_ACTION ) ; mo . onSubscribe ( Disposable . empty ( ) ) ; mo . onError ( new TestException ( "Outer" ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "Inner" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try MaybeCallbackObserver < Object > mo = new MaybeCallbackObserver < > ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) ; mo . onSubscribe ( Disposable . empty ( ) ) ; mo . onComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
MaybeCallbackObserver < Integer > o = new MaybeCallbackObserver < > ( Functions . < Integer > emptyConsumer ( ) , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; assertFalse ( o . hasCustomOnError ( ) ) ; 
MaybeCallbackObserver < Integer > o = new MaybeCallbackObserver < > ( Functions . < Integer > emptyConsumer ( ) , Functions . < Throwable > emptyConsumer ( ) , Functions . EMPTY_ACTION ) ; assertTrue ( o . hasCustomOnError ( ) ) ; 
Maybe . just ( 1 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Maybe . error ( new TestException ( ) ) . delay ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . delay ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Integer > to = Maybe . just ( 1 ) . delay ( 100 , TimeUnit . MILLISECONDS , scheduler ) . test ( ) ; to . dispose ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp . singleElement ( ) . delay ( 100 , TimeUnit . MILLISECONDS ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . delay ( 100 , TimeUnit . MILLISECONDS ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Maybe < Object > f ) throws Exception return f . delay ( 100 , TimeUnit . MILLISECONDS ) ; ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < Integer > observer = Maybe . just ( 1 ) . delay ( 5 , TimeUnit . SECONDS , scheduler , true ) . test ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; observer . assertNoValues ( ) ; scheduler . advanceTimeTo ( 5 , TimeUnit . SECONDS ) ; observer . assertValue ( 1 ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < ? > observer = Maybe . error ( new TestException ( ) ) . delay ( 5 , TimeUnit . SECONDS , scheduler , true ) . test ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; observer . assertNoErrors ( ) ; scheduler . advanceTimeTo ( 5 , TimeUnit . SECONDS ) ; observer . assertError ( TestException . class ) ; 
Maybe . just ( 1 ) . timeInterval ( ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . empty ( ) . timeInterval ( ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . timeInterval ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . timeInterval ( TimeUnit . SECONDS ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . timeInterval ( Schedulers . single ( ) ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . timeInterval ( TimeUnit . SECONDS , Schedulers . single ( ) ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( m -> m . timeInterval ( ) ) ; 
TestHelper . checkDisposed ( MaybeSubject . create ( ) . timeInterval ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Timed < Integer > > to = ms . timeInterval ( scheduler ) . test ( ) ; scheduler . advanceTimeBy ( 1000 , TimeUnit . MILLISECONDS ) ; ms . onSuccess ( 1 ) ; to . assertResult ( new Timed < > ( 1 , 1000L , TimeUnit . MILLISECONDS ) ) ; 
List < Maybe < Integer > > ms = new ArrayList < > ( ) ; for ( int i = 0 ; i < 32 ; i ++ ) ms . add ( Maybe . < Integer > never ( ) ) ; ms . add ( Maybe . just ( 1 ) ) ; Maybe . amb ( ms ) . test ( ) . assertResult ( 1 ) ; 
Maybe . amb ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) ) . test ( ) . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp0 . singleElement ( ) , pp1 . singleElement ( ) ) ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp0 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserver < Integer > to = Maybe . ambArray ( new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; observer . onSuccess ( 2 ) ; observer . onComplete ( ) ; , Maybe . < Integer > never ( ) ) . test ( ) ; to . dispose ( ) ; to . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe . ambArray ( Maybe . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Maybe . never ( ) ) . subscribe ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe . ambArray ( Maybe . error ( ex ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Maybe . never ( ) ) . subscribe ( Functions . emptyConsumer ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe . ambArray ( Maybe . empty ( ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Maybe . never ( ) ) . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Subject < Integer > ps = ReplaySubject . create ( ) ; ps . onNext ( 1 ) ; final Maybe < Integer > source = Maybe . ambArray ( ps . singleElement ( ) , Maybe . < Integer > never ( ) , Maybe . < Integer > never ( ) , null ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertError ( errors , 0 , NullPointerException . class ) ; finally RxJavaPlugins . reset ( ) ; 
MaybeSource < Integer > source = new MaybeSource < Integer > ( ) @ Override public void subscribe ( MaybeObserver < ? super Integer > observer ) Maybe . just ( 1 ) . subscribe ( observer ) ; ; Maybe . amb ( Arrays . asList ( source , source ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . zip ( Arrays . asList ( Maybe . error ( new TestException ( ) ) , Maybe . just ( 1 ) ) , addString ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . zip ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . < Integer > error ( new TestException ( ) ) ) , addString ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Object > to = Maybe . zip ( Arrays . asList ( pp . singleElement ( ) , pp . singleElement ( ) ) , addString ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Maybe . zip ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . zip ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; TestObserver < Object > to = Maybe . zip ( Arrays . asList ( pp0 . singleElement ( ) , pp1 . singleElement ( ) , pp0 . singleElement ( ) ) , addString ) . test ( ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp0 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final TestObserver < Object > to = Maybe . zip ( Arrays . asList ( pp0 . singleElement ( ) , pp1 . singleElement ( ) ) , addString ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp0 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Maybe . zip ( new CrashingMappedIterable < > ( 1 , 100 , 100 , new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) , addString ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Maybe . zip ( new CrashingMappedIterable < > ( 100 , 20 , 100 , new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) , addString ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
Maybe . zip ( new CrashingMappedIterable < > ( 100 , 100 , 5 , new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) , addString ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Maybe . zip ( Arrays . asList ( null , Maybe . just ( 1 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingGet ( ) ; 
Maybe . zip ( Arrays . asList ( Maybe . just ( 1 ) , null ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingGet ( ) ; 
Maybe . zipArray ( Functions . justFunction ( null ) , Maybe . just ( 1 ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The zipper returned a null value" ) ; 
MaybeSource < Integer > source = new MaybeSource < Integer > ( ) @ Override public void subscribe ( MaybeObserver < ? super Integer > observer ) Maybe . just ( 1 ) . subscribe ( observer ) ; ; Maybe . zip ( Arrays . asList ( source , source ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] t ) throws Throwable return 2 ; ) . test ( ) . assertResult ( 2 ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . concatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Maybe < Integer > v ) throws Exception return v . concatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; ) ; ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . concatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . < Integer > empty ( ) . concatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . concatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . concatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe < Integer > m = Maybe . just ( 1 ) ; Single < Integer > s = m . toSingle ( ) ; assertTrue ( s . getClass ( ) . toString ( ) , s instanceof HasUpstreamMaybeSource ) ; assertSame ( m , ( ( ( HasUpstreamMaybeSource < ? > ) s ) . source ( ) ) ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . toSingle ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToSingle ( new Function < Maybe < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Maybe < Object > m ) throws Exception return m . toSingle ( ) ; ) ; 
Maybe . just ( 1 ) . blockingSubscribe ( ) ; 
Maybe . just ( 1 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( ) ; 
Maybe . empty ( ) . blockingSubscribe ( ) ; 
Maybe . empty ( ) . delay ( 100 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( ) ; 
TestHelper . withErrorTracking ( errors -> Maybe . error ( new TestException ( ) ) . blockingSubscribe ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Maybe . error ( new TestException ( ) ) . delay ( 100 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) . blockingSubscribe ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Maybe . just ( 1 ) . blockingSubscribe ( success ) ; verify ( success ) . accept ( 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Maybe . just ( 1 ) . delay ( 50 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( success ) ; verify ( success ) . accept ( 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Maybe . < Integer > empty ( ) . blockingSubscribe ( success ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Maybe . < Integer > empty ( ) . delay ( 50 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( success ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; doThrow ( new TestException ( ) ) . when ( success ) . accept ( any ( ) ) ; Maybe . just ( 1 ) . blockingSubscribe ( success ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success ) . accept ( 1 ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . blockingSubscribe ( success ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) . blockingSubscribe ( success ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Maybe . just ( 1 ) . blockingSubscribe ( success , consumer ) ; verify ( success ) . accept ( 1 ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Maybe . just ( 1 ) . delay ( 50 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( success , consumer ) ; verify ( success ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Maybe . < Integer > empty ( ) . blockingSubscribe ( success , consumer ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Maybe . < Integer > empty ( ) . delay ( 50 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( success , consumer ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; doThrow ( new TestException ( ) ) . when ( success ) . accept ( any ( ) ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Maybe . just ( 1 ) . blockingSubscribe ( success , consumer ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . blockingSubscribe ( success , consumer ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) . blockingSubscribe ( success , consumer ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . accept ( any ( ) ) ; Maybe . < Integer > error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) . blockingSubscribe ( success , consumer ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Action action = mock ( Action . class ) ; Maybe . just ( 1 ) . blockingSubscribe ( success , consumer , action ) ; verify ( success ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( Throwable . class ) ) ; verify ( action , never ( ) ) . run ( ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Action action = mock ( Action . class ) ; Maybe . < Integer > empty ( ) . blockingSubscribe ( success , consumer , action ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( Throwable . class ) ) ; verify ( action ) . run ( ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Action action = mock ( Action . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . blockingSubscribe ( success , consumer , action ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; verify ( action , never ( ) ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Action action = mock ( Action . class ) ; doThrow ( new TestException ( ) ) . when ( action ) . run ( ) ; Maybe . < Integer > empty ( ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) . blockingSubscribe ( success , consumer , action ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; verify ( action ) . run ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Action onDispose = mock ( Action . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Action action = mock ( Action . class ) ; Thread . currentThread ( ) . interrupt ( ) ; Maybe . < Integer > never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( success , consumer , action ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( onDispose ) . run ( ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( action , never ( ) ) . run ( ) ; verify ( consumer ) . accept ( any ( InterruptedException . class ) ) ; ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Maybe . just ( 1 ) . blockingSubscribe ( to ) ; to . assertResult ( 1 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Maybe . just ( 1 ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) . blockingSubscribe ( to ) ; to . assertResult ( 1 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Maybe . < Integer > empty ( ) . blockingSubscribe ( to ) ; to . assertResult ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Maybe . < Integer > empty ( ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) . blockingSubscribe ( to ) ; to . assertResult ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Maybe . error ( new TestException ( ) ) . blockingSubscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Maybe . error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) . blockingSubscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
Action onDispose = mock ( Action . class ) ; TestObserver < Object > to = new TestObserver < > ( ) ; to . dispose ( ) ; Maybe . never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( to ) ; to . assertEmpty ( ) ; verify ( onDispose ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> Action onDispose = mock ( Action . class ) ; TestObserver < Object > to = new TestObserver < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; Maybe . never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( to ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( onDispose ) . run ( ) ; to . assertFailure ( InterruptedException . class ) ; ) ; 
final AtomicBoolean atomicBoolean = new AtomicBoolean ( ) ; Maybe . just ( 1 ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) atomicBoolean . set ( true ) ; ) . test ( ) . assertResult ( 1 ) ; assertTrue ( atomicBoolean . get ( ) ) ; 
final AtomicBoolean atomicBoolean = new AtomicBoolean ( ) ; Maybe . error ( new TestException ( ) ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) atomicBoolean . set ( true ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( atomicBoolean . get ( ) ) ; 
final AtomicBoolean atomicBoolean = new AtomicBoolean ( ) ; Maybe . empty ( ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) atomicBoolean . set ( true ) ; ) . test ( ) . assertResult ( ) ; assertTrue ( atomicBoolean . get ( ) ) ; 
Maybe . just ( 1 ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Object > to = Maybe . error ( new TestException ( "Outer" ) ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) throw new TestException ( "Inner" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
Maybe . empty ( ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . just ( 1 ) . delay ( pp ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . just ( 1 ) . delay ( pp ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onComplete ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = Maybe . just ( 1 ) . delay ( pp ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onError ( new TestException ( "Other" ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertFailureAndMessage ( TestException . class , "Other" ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . < Integer > empty ( ) . delay ( pp ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . < Integer > empty ( ) . delay ( pp ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onComplete ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = Maybe . < Integer > empty ( ) . delay ( pp ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onError ( new TestException ( "Other" ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertFailureAndMessage ( TestException . class , "Other" ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = Maybe . < Integer > error ( new TestException ( "Main" ) ) . delay ( pp ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertFailureAndMessage ( TestException . class , "Main" ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = Maybe . < Integer > error ( new TestException ( "Main" ) ) . delay ( pp ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onComplete ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertFailureAndMessage ( TestException . class , "Main" ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = Maybe . < Integer > error ( new TestException ( "Main" ) ) . delay ( pp ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onError ( new TestException ( "Other" ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertFailure ( CompositeException . class ) ; List < Throwable > list = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; assertEquals ( 2 , list . size ( ) ) ; TestHelper . assertError ( list , 0 , TestException . class , "Main" ) ; TestHelper . assertError ( list , 1 , TestException . class , "Other" ) ; 
TestHelper . checkDisposed ( Completable . complete ( ) . andThen ( Maybe . just ( 1 ) ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletableToMaybe ( new Function < Completable , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Completable c ) throws Exception return c . andThen ( Maybe . just ( 1 ) ) ; ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . delay ( Flowable . just ( 1 ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Maybe < Integer > c ) throws Exception return c . delay ( Flowable . never ( ) ) ; ) ; 
Maybe . just ( 1 ) . delay ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) ) ; 
Maybe . just ( 1 ) . startWith ( Completable . complete ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . empty ( ) . startWith ( Completable . complete ( ) ) . test ( ) . assertResult ( ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Completable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Maybe . just ( 1 ) . startWith ( Single . just ( 2 ) ) . test ( ) . assertResult ( 2 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Single . just ( 2 ) ) . test ( ) . assertResult ( 2 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Maybe . just ( 1 ) . startWith ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 2 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 2 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Maybe . just ( 1 ) . startWith ( Observable . just ( 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Observable . just ( 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Runnable run2 = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Observable . fromRunnable ( run2 ) ) . test ( ) . assertResult ( ) ; verify ( run ) . run ( ) ; verify ( run2 ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Observable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Maybe . just ( 1 ) . startWith ( Flowable . just ( 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Flowable . just ( 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Runnable run2 = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Flowable . fromRunnable ( run2 ) ) . test ( ) . assertResult ( ) ; verify ( run ) . run ( ) ; verify ( run2 ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . startWith ( Flowable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) MaybeObserver < Integer > consumer = mock ( MaybeObserver . class ) ; Maybe . just ( 1 ) . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onSuccess ( 1 ) ; order . verifyNoMoreInteractions ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) MaybeObserver < Integer > consumer = mock ( MaybeObserver . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onError ( any ( TestException . class ) ) ; order . verifyNoMoreInteractions ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) MaybeObserver < Integer > consumer = mock ( MaybeObserver . class ) ; Maybe . < Integer > empty ( ) . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onComplete ( ) ; order . verifyNoMoreInteractions ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) MaybeObserver < Integer > consumer = mock ( MaybeObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onSubscribe ( any ( ) ) ; Disposable d = Disposable . empty ( ) ; new Maybe < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( d ) ; observer . onSuccess ( 1 ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verifyNoMoreInteractions ( ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , IOException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) MaybeObserver < Integer > consumer = mock ( MaybeObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onSuccess ( any ( ) ) ; new Maybe < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onSuccess ( 1 ) ; order . verifyNoMoreInteractions ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) MaybeObserver < Integer > consumer = mock ( MaybeObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onError ( any ( ) ) ; new Maybe < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new IOException ( ) ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onError ( any ( IOException . class ) ) ; order . verifyNoMoreInteractions ( ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; CompositeException compositeException = ( CompositeException ) errors . get ( 0 ) ; TestHelper . assertError ( compositeException . getExceptions ( ) , 0 , IOException . class ) ; TestHelper . assertError ( compositeException . getExceptions ( ) , 1 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) MaybeObserver < Integer > consumer = mock ( MaybeObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onComplete ( ) ; new Maybe < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onComplete ( ) ; order . verifyNoMoreInteractions ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Maybe . fromSingle ( Single . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . fromSingle ( Single . error ( new UnsupportedOperationException ( ) ) ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
Single < Integer > c = Single . never ( ) ; assertSame ( c , ( ( HasUpstreamSingleSource < ? > ) Maybe . fromSingle ( c ) ) . source ( ) ) ; 
TestHelper . checkDisposed ( Maybe . fromSingle ( PublishProcessor . create ( ) . singleOrError ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToMaybe ( new Function < Single < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Single < Object > v ) throws Exception return Maybe . fromSingle ( v ) ; ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Maybe . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Supplier < Object > supplier = new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ; Maybe . fromSupplier ( supplier ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Maybe . fromSupplier ( supplier ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Maybe < Object > completable = Maybe . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; completable . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Maybe . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final int [ ] counter = 0 ; Maybe < Integer > m = Maybe . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception counter [ 0 ] ++ ; return 0 ; ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof Supplier ) ; assertEquals ( 0 , ( ( Supplier < Void > ) m ) . get ( ) ) ; assertEquals ( 1 , counter [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Integer > to = Maybe . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; return 1 ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Supplier < String > func = mock ( Supplier . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . get ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Maybe < String > fromSupplierObservable = Maybe . fromSupplier ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; TestObserver < String > outer = new TestObserver < > ( observer ) ; fromSupplierObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . dispose ( ) ; funcLatch . countDown ( ) ; verify ( func ) . get ( ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verifyNoMoreInteractions ( observer ) ; 
Maybe . fromSupplier ( ( ) -> 1 ) . test ( ) . assertResult ( 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Supplier < Integer > supplier = mock ( Supplier . class ) ; Maybe . fromSupplier ( supplier ) . test ( true ) . assertEmpty ( ) ; verify ( supplier , never ( ) ) . get ( ) ; 
Maybe < Integer > source = Maybe . just ( 1 ) ; assertSame ( source , ( ( HasUpstreamMaybeSource < Integer > ) source . map ( Functions . < Integer > identity ( ) ) ) . source ( ) ) ; 
FutureTask < Integer > ft = new FutureTask < > ( Functions . justCallable ( 1 ) ) ; Maybe . fromFuture ( ft ) . test ( true ) . assertEmpty ( ) ; 
FutureTask < Integer > ft = new FutureTask < > ( Functions . justCallable ( 1 ) ) ; Maybe . fromFuture ( ft , 1 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
FutureTask < Integer > ft = new FutureTask < > ( Functions . justCallable ( 1 ) ) ; ft . run ( ) ; Maybe . fromFuture ( ft , 1 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
FutureTask < Integer > ft = new FutureTask < > ( Functions . justCallable ( 1 ) ) ; Thread . currentThread ( ) . interrupt ( ) ; Maybe . fromFuture ( ft , 1 , TimeUnit . MILLISECONDS ) . test ( ) . assertFailure ( InterruptedException . class ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; FutureTask < Object > ft = new FutureTask < > ( new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; , null ) ; Schedulers . single ( ) . scheduleDirect ( ft , 100 , TimeUnit . MILLISECONDS ) ; Maybe . fromFuture ( ft ) . subscribeWith ( to ) . assertEmpty ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; FutureTask < Object > ft = new FutureTask < > ( new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; throw new TestException ( ) ; , null ) ; Schedulers . single ( ) . scheduleDirect ( ft , 100 , TimeUnit . MILLISECONDS ) ; Maybe . fromFuture ( ft ) . subscribeWith ( to ) . assertEmpty ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
FutureTask < Object > ft = new FutureTask < > ( new Runnable ( ) @ Override public void run ( ) , null ) ; Schedulers . single ( ) . scheduleDirect ( ft , 100 , TimeUnit . MILLISECONDS ) ; Maybe . fromFuture ( ft ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) ) ; 
Maybe . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe . just ( 1 ) . doAfterSuccess ( afterSuccess ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . doAfterSuccess ( afterSuccess ) . subscribeWith ( to ) . assertFailure ( TestException . class ) ; assertTrue ( values . isEmpty ( ) ) ; 
Maybe . < Integer > empty ( ) . doAfterSuccess ( afterSuccess ) . subscribeWith ( to ) . assertResult ( ) ; assertTrue ( values . isEmpty ( ) ) ; 
Maybe . just ( 1 ) . doAfterSuccess ( afterSuccess ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . doAfterSuccess ( afterSuccess ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertFailure ( TestException . class ) ; assertTrue ( values . isEmpty ( ) ) ; 
Maybe . < Integer > empty ( ) . doAfterSuccess ( afterSuccess ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertResult ( ) ; assertTrue ( values . isEmpty ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Maybe . just ( 1 ) . doAfterSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . singleElement ( ) . doAfterSuccess ( afterSuccess ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Maybe < Integer > m ) throws Exception return m . doAfterSuccess ( afterSuccess ) ; ) ; 
Maybe . concat ( Flowable . just ( Maybe . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . concat ( Flowable . fromCallable ( new Callable < Maybe < Integer > > ( ) @ Override public Maybe < Integer > call ( ) throws Exception return Maybe . just ( 1 ) ; ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . fromCompletable ( Completable . complete ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . fromCompletable ( Completable . error ( new UnsupportedOperationException ( ) ) ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
Completable c = Completable . complete ( ) ; assertSame ( c , ( ( HasUpstreamCompletableSource ) Maybe . fromCompletable ( c ) ) . source ( ) ) ; 
TestHelper . checkDisposed ( Maybe . fromCompletable ( PublishProcessor . create ( ) . ignoreElements ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletableToMaybe ( new Function < Completable , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Completable v ) throws Exception return Maybe . fromCompletable ( v ) ; ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) ) ; 
Maybe . just ( 1 ) . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw new TestException ( ) ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . just ( 1 ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . error ( new TestException ( ) ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . empty ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) . assertResult ( ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . error ( new TestException ( ) ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . empty ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) . test ( ) . assertResult ( ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception throw new TestException ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception throw new TestException ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception throw new TestException ( "Main" ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , true ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > list = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( list , 0 , TestException . class , "Main" ) ; TestHelper . assertError ( list , 1 , TestException . class , "Disposer" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception throw new TestException ( "Main" ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , false ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Main" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Disposer" ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] call = 0 ; TestObserver < Integer > to = Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . never ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception call [ 0 ] ++ ; , false ) . test ( ) ; to . dispose ( ) ; assertEquals ( 1 , call [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . never ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( ) ; , false ) . test ( ) ; to . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . never ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . just ( 1 ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . empty ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , true ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . error ( new TestException ( "Main" ) ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , true ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > list = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( list , 0 , TestException . class , "Main" ) ; TestHelper . assertError ( list , 1 , TestException . class , "Disposer" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . wrap ( new MaybeSource < Integer > ( ) @ Override public void subscribe ( MaybeObserver < ? super Integer > observer ) Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) . test ( ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return ps . lastElement ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return ps . firstElement ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = Maybe . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return ps . firstElement ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final StringBuilder sb = new StringBuilder ( ) ; TestObserver < Integer > to = Maybe . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer t ) throws Throwable return Maybe . < Integer > never ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Dispose" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , true ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; assertEquals ( "ResourceDispose" , sb . toString ( ) ) ; 
final StringBuilder sb = new StringBuilder ( ) ; TestObserver < Integer > to = Maybe . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer t ) throws Throwable return Maybe . < Integer > never ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Dispose" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , false ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; assertEquals ( "DisposeResource" , sb . toString ( ) ) ; 
Maybe < Integer > source = Maybe . just ( 1 ) . cache ( ) ; assertEquals ( 1 , source . blockingGet ( ) . intValue ( ) ) ; source . test ( ) . assertResult ( 1 ) ; 
Maybe < Integer > source = Maybe . < Integer > error ( new TestException ( ) ) . cache ( ) ; try source . blockingGet ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) source . test ( ) . assertFailure ( TestException . class ) ; 
Maybe < Integer > source = Maybe . < Integer > empty ( ) . cache ( ) ; assertNull ( source . blockingGet ( ) ) ; source . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertNotNull ( ( ( MaybeCache < Integer > ) source ) . source . get ( ) ) ; TestObserver < Integer > to = source . test ( ) ; assertNull ( ( ( MaybeCache < Integer > ) source ) . source . get ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; source . test ( true ) . assertEmpty ( ) ; to . assertEmpty ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; to . assertResult ( 1 ) ; source . test ( ) . assertResult ( 1 ) ; source . test ( true ) . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertNotNull ( ( ( MaybeCache < Integer > ) source ) . source . get ( ) ) ; TestObserver < Integer > to = source . test ( ) ; assertNull ( ( ( MaybeCache < Integer > ) source ) . source . get ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; source . test ( true ) . assertEmpty ( ) ; to . assertEmpty ( ) ; pp . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; source . test ( ) . assertFailure ( TestException . class ) ; source . test ( true ) . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertNotNull ( ( ( MaybeCache < Integer > ) source ) . source . get ( ) ) ; TestObserver < Integer > to = source . test ( ) ; assertNull ( ( ( MaybeCache < Integer > ) source ) . source . get ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; source . test ( true ) . assertEmpty ( ) ; to . assertEmpty ( ) ; pp . onComplete ( ) ; to . assertResult ( ) ; source . test ( ) . assertResult ( ) ; source . test ( true ) . assertEmpty ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; source . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception ts . cancel ( ) ; ) ; source . toFlowable ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertEmpty ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; source . subscribe ( Functions . emptyConsumer ( ) , new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception ts . cancel ( ) ; ) ; source . toFlowable ( ) . subscribe ( ts ) ; pp . onError ( new TestException ( ) ) ; ts . assertEmpty ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; source . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) throws Exception ts . cancel ( ) ; ) ; source . toFlowable ( ) . subscribe ( ts ) ; pp . onComplete ( ) ; ts . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) source . test ( ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; final TestObserver < Integer > to1 = source . test ( ) ; final TestObserver < Integer > to2 = source . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to2 . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Maybe < Integer > source = pp . singleElement ( ) . cache ( ) ; final Disposable [ ] dout = null ; source . subscribe ( new MaybeObserver < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) dout [ 0 ] = d ; @ Override public void onSuccess ( Integer value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; dout [ 0 ] . dispose ( ) ; dout [ 0 ] . dispose ( ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Maybe . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Action run = new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ; Maybe . fromAction ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Maybe . fromAction ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Maybe < Object > maybe = Maybe . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; maybe . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Maybe . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final int [ ] counter = 0 ; Maybe < Void > m = Maybe . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter [ 0 ] ++ ; ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof Supplier ) ; assertNull ( ( ( Supplier < Void > ) m ) . get ( ) ) ; assertEquals ( 1 , counter [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Object > to = Maybe . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Action run = mock ( Action . class ) ; Maybe . fromAction ( run ) . test ( true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; Maybe . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . dispose ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; Maybe . just ( 1 ) . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) . assertResult ( 1 ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; Maybe . empty ( ) . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) . assertResult ( ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; Maybe . error ( new TestException ( ) ) . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) . assertFailure ( TestException . class ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; doThrow ( new TestException ( "First" ) ) . when ( onSubscribe ) . accept ( any ( ) ) ; Disposable bs = Disposable . empty ( ) ; new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( bs ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; observer . onSuccess ( 1 ) ; . doOnLifecycle ( onSubscribe , onDispose ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( bs . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; doThrow ( new TestException ( "First" ) ) . when ( onDispose ) . run ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ms . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) ; assertTrue ( ms . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ms . hasObservers ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "First" ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose ) . run ( ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ms . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) ; assertTrue ( ms . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ms . hasObservers ( ) ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose ) . run ( ) ; 
TestHelper . checkDisposed ( MaybeSubject . create ( ) . doOnLifecycle ( d -> , ( ) -> ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( m -> m . doOnLifecycle ( d -> , ( ) -> ) ) ; 
Maybe < Integer > m = Maybe . empty ( ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof ScalarSupplier ) ; assertNull ( ( ( ScalarSupplier < ? > ) m ) . get ( ) ) ; 
Maybe . just ( 1 ) . switchIfEmpty ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . < Integer > empty ( ) . switchIfEmpty ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 2 ) ; 
Maybe . just ( 1 ) . defaultIfEmpty ( 2 ) . test ( ) . assertResult ( 1 ) ; 
Maybe . < Integer > empty ( ) . defaultIfEmpty ( 2 ) . test ( ) . assertResult ( 2 ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . switchIfEmpty ( Maybe . just ( 2 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . switchIfEmpty ( Maybe . < Integer > error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . switchIfEmpty ( Maybe . empty ( ) ) . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp . singleElement ( ) . switchIfEmpty ( Maybe . just ( 2 ) ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . switchIfEmpty ( Maybe . just ( 2 ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Maybe < Integer > f ) throws Exception return f . switchIfEmpty ( Maybe . just ( 2 ) ) ; ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestObserver < Integer > to = pp . singleElement ( ) . switchIfEmpty ( Maybe . just ( 2 ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Maybe < Integer > source = Maybe . just ( 1 ) ; assertSame ( source , ( ( HasUpstreamMaybeSource < Integer > ) source . ignoreElement ( ) . toMaybe ( ) ) . source ( ) ) ; 
TestHelper . checkDisposed ( Maybe . never ( ) . ignoreElement ( ) . toMaybe ( ) ) ; 
Maybe . just ( 1 ) . ignoreElement ( ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToCompletable ( new Function < Maybe < Object > , CompletableSource > ( ) @ Override public CompletableSource apply ( Maybe < Object > m ) throws Exception return m . ignoreElement ( ) ; ) ; 
TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . singleElement ( ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Maybe < Integer > m ) throws Exception return m . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable bs = Disposable . empty ( ) ; new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( bs ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; observer . onSuccess ( 1 ) ; . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( "First" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( bs . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . takeUntil ( Flowable . never ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > m ) throws Exception return m . takeUntil ( Flowable . never ( ) ) ; ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 ) . test ( ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Maybe . just ( 1 ) . takeUntil ( Flowable . just ( 1 ) . take ( 1 ) ) . test ( ) . assertResult ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Maybe . concatArrayEagerDelayError ( Maybe . just ( 1 ) , Maybe . < Integer > error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Collections . < Integer > emptyList ( ) ; ) . test ( ) . assertResult ( ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . < Integer > empty ( ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertResult ( ) ; 
TestSubscriber < Integer > ts = Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( 0 ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . doOnSubscribe ( s -> s . request ( Long . MAX_VALUE ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 ) ; ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 ) ; ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 1 , 100 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 1 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 100 , 1 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 2 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . take ( 500 * 1000 ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . observeOn ( Schedulers . single ( ) ) . take ( 500 * 1000 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Arrays . asList ( 1 , 2 , 3 ) ; ) . subscribe ( new FlowableSubscriber < Integer > ( ) QueueSubscription < Integer > qs ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSubscribe ( Subscription s ) qs = ( QueueSubscription < Integer > ) s ; assertEquals ( QueueFuseable . ASYNC , qs . requestFusion ( QueueFuseable . ANY ) ) ; @ Override public void onNext ( Integer value ) assertFalse ( qs . isEmpty ( ) ) ; qs . clear ( ) ; assertTrue ( qs . isEmpty ( ) ) ; qs . cancel ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return new CrashingIterable ( 100 , 2 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return new CrashingIterable ( 100 , 100 , 1 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return new CrashingIterable ( 100 , 2 , 100 ) ; ) . to ( TestHelper . < Integer > testSubscriber ( 2L ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return new CrashingIterable ( 100 , 100 , 1 ) ; ) . to ( TestHelper . < Integer > testSubscriber ( 2L ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . singleElement ( ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( 1 , 2 , 3 ) ; ) . test ( 5L ) . assertEmpty ( ) ; 
final Integer [ ] a = new Integer [ 1000 ] ; Arrays . fill ( a , 1 ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . onNext ( 1 ) ; final TestSubscriber < Integer > ts = ps . singleElement ( ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( a ) ; ) . test ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; for ( int i = 0 ; i < 500 ; i ++ ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 500 ; i ++ ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . onNext ( 1 ) ; final TestSubscriber < Integer > ts = ps . singleElement ( ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( 1 , 2 , 3 ) ; ) . test ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final Integer [ ] a = new Integer [ 1000 ] ; Arrays . fill ( a , 1 ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ == 2 ) ts . cancel ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; ) . subscribe ( ts ) ; ts . request ( 3 ) ; ts . assertValues ( 1 , 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final Integer [ ] a = new Integer [ 1000 ] ; Arrays . fill ( a , 1 ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ == 2 ) ts . cancel ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; ) . subscribe ( ts ) ; ts . request ( Long . MAX_VALUE ) ; ts . assertValues ( 1 , 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestHelper . assertBadRequestReported ( MaybeSubject . create ( ) . flattenAsFlowable ( v -> Arrays . asList ( v ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToFlowable ( m -> m . flattenAsFlowable ( v -> Arrays . asList ( v ) ) ) ; 
List < Object > list = Arrays . asList ( 1 ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Object > ts = ms . flattenAsFlowable ( v -> list ) . test ( 0L ) ; TestHelper . race ( ( ) -> ms . onSuccess ( 1 ) , ( ) -> ts . request ( 1 ) ) ; ts . assertResult ( 1 ) ; 
Single . error ( new TestException ( ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToMaybe ( new Function < Single < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Single < Object > v ) throws Exception return v . filter ( Functions . alwaysTrue ( ) ) ; ) ; 
Maybe . just ( 1 ) . contains ( 1 ) . test ( ) . assertResult ( true ) ; 
Maybe . just ( 1 ) . contains ( 2 ) . test ( ) . assertResult ( false ) ; 
Maybe . empty ( ) . contains ( 2 ) . test ( ) . assertResult ( false ) ; 
Maybe . error ( new TestException ( ) ) . contains ( 2 ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Boolean > to = pp . singleElement ( ) . contains ( 1 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . contains ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToSingle ( new Function < Maybe < Object > , SingleSource < Boolean > > ( ) @ Override public SingleSource < Boolean > apply ( Maybe < Object > f ) throws Exception return f . contains ( 1 ) ; ) ; 
assertSame ( Maybe . empty ( ) , ( ( HasUpstreamMaybeSource < Object > ) ( Maybe . empty ( ) . contains ( 0 ) ) ) . source ( ) ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 , Maybe . < Integer > error ( new TestException ( ) ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 1 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 , Maybe . < Integer > empty ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 1 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TimeoutException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp1 . singleElement ( ) . timeout ( pp2 ) ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp1 . singleElement ( ) . timeout ( pp2 , Maybe . just ( 1 ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertSubscribed ( ) . assertNoValues ( ) ; if ( to . errors ( ) . size ( ) != 0 ) to . assertError ( TimeoutException . class ) . assertNotComplete ( ) ; else to . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return Maybe . never ( ) . timeout ( f , Maybe . just ( 1 ) ) ; , false , null , 1 , 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; new Maybe < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; pp . onNext ( 2 ) ; observer . onSuccess ( 1 ) ; . timeout ( pp ) . test ( ) . assertFailure ( TimeoutException . class ) ; 
Maybe . just ( 1 ) . timeout ( Flowable . never ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . error ( new TestException ( ) ) . onErrorReturnItem ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Maybe . error ( new TestException ( ) ) . onErrorReturn ( Functions . justFunction ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . error ( new TestException ( ) ) . onErrorComplete ( ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . onErrorComplete ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . onErrorComplete ( Functions . alwaysFalse ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . assertCompositeExceptions ( Maybe . error ( new TestException ( ) ) . onErrorReturn ( new Function < Throwable , Object > ( ) @ Override public Object apply ( Throwable v ) throws Exception throw new IOException ( ) ; ) . to ( TestHelper . testConsumer ( ) ) , TestException . class , IOException . class ) ; 
TestHelper . assertCompositeExceptions ( Maybe . error ( new TestException ( ) ) . onErrorComplete ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable v ) throws Exception throw new IOException ( ) ; ) . to ( TestHelper . testConsumer ( ) ) , TestException . class , IOException . class ) ; 
Maybe . error ( new TestException ( ) ) . onErrorResumeNext ( Functions . justFunction ( Maybe . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . assertCompositeExceptions ( Maybe . error ( new TestException ( ) ) . onErrorResumeNext ( new Function < Throwable , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Throwable v ) throws Exception throw new IOException ( ) ; ) . to ( TestHelper . testConsumer ( ) ) , TestException . class , IOException . class ) ; 
Maybe . just ( 1 ) . onErrorReturnItem ( 2 ) . test ( ) . assertResult ( 1 ) ; 
Maybe . < Integer > empty ( ) . onErrorReturnItem ( 2 ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . onErrorReturnItem ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > v ) throws Exception return v . onErrorReturnItem ( 1 ) ; ) ; 
Maybe . just ( 1 ) . onErrorComplete ( ) . test ( ) . assertResult ( 1 ) ; 
Maybe . < Integer > empty ( ) . onErrorComplete ( ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . onErrorComplete ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > v ) throws Exception return v . onErrorComplete ( ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . onErrorResumeWith ( Maybe . just ( 1 ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > v ) throws Exception return v . onErrorResumeWith ( Maybe . just ( 1 ) ) ; ) ; 
Maybe . error ( new TestException ( "Main" ) ) . onErrorResumeWith ( Maybe . error ( new TestException ( "Secondary" ) ) ) . to ( TestHelper . testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Secondary" ) ; 
TestHelper . checkDisposed ( Maybe . timer ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try for ( Scheduler s : new Scheduler [ ] Schedulers . single ( ) , Schedulers . computation ( ) , Schedulers . newThread ( ) , Schedulers . io ( ) , Schedulers . from ( exec , true ) ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; TestObserver < Long > to = Maybe . timer ( 1 , TimeUnit . MILLISECONDS , s ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long v ) throws Exception try Thread . sleep ( 3000 ) ; catch ( InterruptedException ex ) interrupted . set ( true ) ; return v ; ) . test ( ) ; Thread . sleep ( 500 ) ; to . dispose ( ) ; Thread . sleep ( 500 ) ; assertTrue ( s . getClass ( ) . getSimpleName ( ) , interrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
Maybe . just ( 1 ) . count ( ) . test ( ) . assertResult ( 1L ) ; 
Maybe . empty ( ) . count ( ) . test ( ) . assertResult ( 0L ) ; 
Maybe . error ( new TestException ( ) ) . count ( ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Long > to = pp . singleElement ( ) . count ( ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
