final AtomicInteger count = new AtomicInteger ( ) ; ConnectableFlowable < String > connectable = Flowable . < String > unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; count . incrementAndGet ( ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) subscriber . onNext ( "first" ) ; subscriber . onNext ( "last" ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) . takeLast ( 1 ) . publish ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; connectable . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String value ) assertEquals ( "last" , value ) ; latch . countDown ( ) ; ) ; connectable . subscribe ( ) ; Disposable subscription = connectable . connect ( ) ; assertTrue ( latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 1 , count . get ( ) ) ; subscription . dispose ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; ConnectableFlowable < String > f = Flowable . < String > unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; subscriber . onNext ( "one" ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) . replay ( ) ; Disposable connection = f . connect ( ) ; try final CountDownLatch latch = new CountDownLatch ( 2 ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; finally connection . dispose ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < String > f = Flowable . < String > unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; subscriber . onNext ( "one" ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) . cache ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < String > f = Flowable . < String > unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; subscriber . onNext ( "one" ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) . cacheWithInitialCapacity ( 1 ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Flowable . just ( "1" , "2" , "three" , "4" ) . take ( 3 ) . safeSubscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; @ Override public void onError ( Throwable e ) error . set ( e ) ; System . out . println ( "error" ) ; e . printStackTrace ( ) ; @ Override public void onNext ( String v ) int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; ) ; assertEquals ( 2 , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) fail ( "It should be a NumberFormatException" ) ; 
Flowable < String > flowable = Flowable . just ( 1 , "abc" , false , 2L ) . ofType ( String . class ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "abc" ) ; verify ( subscriber , never ( ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onNext ( 2L ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
ArrayList < Integer > l1 = new ArrayList < > ( ) ; l1 . add ( 1 ) ; LinkedList < Integer > l2 = new LinkedList < > ( ) ; l2 . add ( 2 ) ; @ SuppressWarnings ( "rawtypes" ) Flowable < List > flowable = Flowable . < Object > just ( l1 , l2 , "123" ) . ofType ( List . class ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( l1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( l2 ) ; verify ( subscriber , never ( ) ) . onNext ( "123" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Boolean > flowable = Flowable . just ( "a" , "b" , "c" ) . contains ( "b" ) . toFlowable ( ) ; FlowableSubscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Boolean > flowable = Flowable . just ( "a" , "b" ) . contains ( "c" ) . toFlowable ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Boolean > flowable = Flowable . < String > empty ( ) . contains ( "a" ) . toFlowable ( ) ; FlowableSubscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( false ) ; verify ( subscriber , never ( ) ) . onNext ( true ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Single < Boolean > single = Flowable . just ( "a" , "b" , "c" ) . contains ( "b" ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Single < Boolean > single = Flowable . just ( "a" , "b" ) . contains ( "c" ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Single < Boolean > single = Flowable . < String > empty ( ) . contains ( "a" ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 ) . ignoreElements ( ) . toFlowable ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Completable completable = Flowable . just ( 1 , 2 , 3 ) . ignoreElements ( ) ; CompletableObserver observer = TestHelper . mockCompletableObserver ( ) ; completable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Integer > flowable = Flowable . fromArray ( 1 , 2 ) . subscribeOn ( scheduler ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Integer > flowable = Flowable . just ( 3 , 4 ) . startWithIterable ( Arrays . asList ( 1 , 2 ) ) . subscribeOn ( scheduler ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Integer > flowable = Flowable . range ( 3 , 4 ) . subscribeOn ( scheduler ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 6 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . mergeWith ( Flowable . just ( 2 ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . concatWith ( Flowable . just ( 2 ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . ambWith ( Flowable . just ( 2 ) ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; 
final int expectedCount = 3 ; final AtomicInteger count = new AtomicInteger ( ) ; for ( int i = 0 ; i < expectedCount ; i ++ ) Flowable . just ( Boolean . TRUE , Boolean . FALSE ) . takeWhile ( new Predicate < Boolean > ( ) @ Override public boolean test ( Boolean v ) return v ; ) . toList ( ) . doOnSuccess ( new Consumer < List < Boolean > > ( ) @ Override public void accept ( List < Boolean > booleans ) count . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( expectedCount , count . get ( ) ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 , 2 , 3 ) . compose ( new FlowableTransformer < Integer , String > ( ) @ Override public Publisher < String > apply ( Flowable < Integer > t1 ) return t1 . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer v ) return String . valueOf ( v ) ; ) ; ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; ts . assertValues ( "1" , "2" , "3" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try FlowableProcessor < Object > processor = ReplayProcessor . create ( ) ; Flowable . error ( new RuntimeException ( "oops" ) ) . materialize ( ) . delay ( 1 , TimeUnit . SECONDS ) . dematerialize ( Functions . < Notification < Object > > identity ( ) ) . subscribe ( processor ) ; processor . subscribe ( ) ; processor . materialize ( ) . blockingFirst ( ) ; System . out . println ( "Done" ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
assertEquals ( Flowable . empty ( ) , Flowable . empty ( ) ) ; 
Flowable . < Integer > empty ( ) . subscribe ( w ) ; verify ( w ) . onComplete ( ) ; verify ( w , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final TestSubscriber < Object > subscriber = new TestSubscriber < > ( ) ; final Object value = new Object ( ) ; Object returned = Flowable . just ( value ) . to ( new FlowableConverter < Object , Object > ( ) @ Override public Object apply ( Flowable < Object > onSubscribe ) onSubscribe . subscribe ( subscriber ) ; subscriber . assertNoErrors ( ) ; subscriber . assertComplete ( ) ; subscriber . assertValue ( value ) ; return subscriber . values ( ) . get ( 0 ) ; ) ; assertSame ( returned , value ) ; 
final TestSubscriber < Object > subscriber = new TestSubscriber < > ( ) ; final Object value = new Object ( ) ; Object returned = Flowable . just ( value ) . to ( new FlowableConverter < Object , Object > ( ) @ Override public Object apply ( Flowable < Object > onSubscribe ) onSubscribe . subscribe ( subscriber ) ; subscriber . assertNoErrors ( ) ; subscriber . assertComplete ( ) ; subscriber . assertValue ( value ) ; return subscriber . values ( ) . get ( 0 ) ; ) ; assertSame ( returned , value ) ; 
Flowable . just ( 1 ) . to ( new FlowableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Flowable < Integer > v ) return v . toObservable ( ) ; ) . test ( ) . assertResult ( 1 ) ; 
Flowable . empty ( ) . toObservable ( ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . toObservable ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 5 ) . toObservable ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . error ( new TestException ( ) ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
final List < Flowable < Integer > > flowables = Arrays . asList ( Flowable . just ( 1 , 2 , 3 ) , Flowable . just ( 1 , 2 , 3 ) ) ; Flowable . zip ( flowables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] o ) throws Exception int sum = 0 ; for ( Object i : o ) sum += ( Integer ) i ; return sum ; ) . test ( ) . assertResult ( 2 , 4 , 6 ) ; 
final List < Flowable < Integer > > flowables = Arrays . asList ( Flowable . just ( 1 , 2 , 3 ) , Flowable . just ( 1 , 2 , 3 ) ) ; Flowable . combineLatest ( flowables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( final Object [ ] o ) throws Exception int sum = 1 ; for ( Object i : o ) sum *= ( Integer ) i ; return sum ; ) . test ( ) . assertResult ( 3 , 6 , 9 ) ; 
final Notification < Integer > integerNotification = Notification . createOnNext ( 1 ) ; final Notification < Integer > nullNotification = Notification . createOnNext ( null ) ; Assert . assertNotEquals ( integerNotification , nullNotification ) ; 
final Notification < Integer > integerNotification = Notification . createOnNext ( 1 ) ; final Notification < Integer > nullNotification = Notification . createOnNext ( null ) ; Assert . assertNotEquals ( nullNotification , integerNotification ) ; 
final Notification < Integer > integerNotification = Notification . createOnNext ( 1 ) ; final Notification < Integer > integerNotification2 = Notification . createOnNext ( 1 ) ; Assert . assertEquals ( integerNotification , integerNotification2 ) ; 
final Notification < Integer > integerNotification = Notification . createOnNext ( 1 ) ; final Notification < Integer > integerNotification2 = Notification . createOnNext ( 2 ) ; Assert . assertNotEquals ( integerNotification , integerNotification2 ) ; 
final Exception exception = new Exception ( ) ; final Notification < Integer > onErrorNotification = Notification . createOnError ( exception ) ; final Notification < Integer > onErrorNotification2 = Notification . createOnError ( exception ) ; Assert . assertEquals ( onErrorNotification , onErrorNotification2 ) ; 
final Notification < Integer > onErrorNotification = Notification . createOnError ( new Exception ( ) ) ; final Notification < Integer > onErrorNotification2 = Notification . createOnError ( new Exception ( ) ) ; Assert . assertNotEquals ( onErrorNotification , onErrorNotification2 ) ; 
Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; TestScheduler s = new TestScheduler ( ) ; PublishProcessor < Integer > o = PublishProcessor . create ( ) ; o . throttleWithTimeout ( 500 , TimeUnit . MILLISECONDS , s ) . subscribe ( subscriber ) ; s . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; s . advanceTimeTo ( 501 , TimeUnit . MILLISECONDS ) ; o . onNext ( 3 ) ; s . advanceTimeTo ( 600 , TimeUnit . MILLISECONDS ) ; o . onNext ( 4 ) ; s . advanceTimeTo ( 700 , TimeUnit . MILLISECONDS ) ; o . onNext ( 5 ) ; o . onNext ( 6 ) ; s . advanceTimeTo ( 1300 , TimeUnit . MILLISECONDS ) ; o . onNext ( 7 ) ; s . advanceTimeTo ( 1800 , TimeUnit . MILLISECONDS ) ; o . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 6 ) ; inOrder . verify ( subscriber ) . onNext ( 7 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable . just ( 1 ) . throttleWithTimeout ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; TestScheduler s = new TestScheduler ( ) ; PublishProcessor < Integer > o = PublishProcessor . create ( ) ; o . throttleLast ( 500 , TimeUnit . MILLISECONDS , s ) . subscribe ( subscriber ) ; s . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; s . advanceTimeTo ( 501 , TimeUnit . MILLISECONDS ) ; o . onNext ( 3 ) ; s . advanceTimeTo ( 600 , TimeUnit . MILLISECONDS ) ; o . onNext ( 4 ) ; s . advanceTimeTo ( 700 , TimeUnit . MILLISECONDS ) ; o . onNext ( 5 ) ; o . onNext ( 6 ) ; s . advanceTimeTo ( 1001 , TimeUnit . MILLISECONDS ) ; o . onNext ( 7 ) ; s . advanceTimeTo ( 1501 , TimeUnit . MILLISECONDS ) ; o . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 6 ) ; inOrder . verify ( subscriber ) . onNext ( 7 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < HorrorMovie > horrors = Flowable . just ( new HorrorMovie ( ) ) ; Flowable < CoolRating > ratings = Flowable . just ( new CoolRating ( ) ) ; Flowable . < Movie , CoolRating , Result > combineLatest ( horrors , ratings , combine ) . blockingForEach ( action ) ; Flowable . < Movie , CoolRating , Result > combineLatest ( horrors , ratings , combine ) . blockingForEach ( action ) ; Flowable . < Media , Rating , ExtendedResult > combineLatest ( horrors , ratings , combine ) . blockingForEach ( extendedAction ) ; Flowable . < Media , Rating , Result > combineLatest ( horrors , ratings , combine ) . blockingForEach ( action ) ; Flowable . < Media , Rating , ExtendedResult > combineLatest ( horrors , ratings , combine ) . blockingForEach ( action ) ; Flowable . < Movie , CoolRating , Result > combineLatest ( horrors , ratings , combine ) ; 
cancelled = true ; 
$EMPTY$
int num = ( int ) ( Flowable . bufferSize ( ) * 2.1 ) ; AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; incrementingIntegers ( c ) . observeOn ( Schedulers . computation ( ) ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testObserveOn => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertTrue ( c . get ( ) < Flowable . bufferSize ( ) * 4 ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 0.2 ) ; AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; incrementingIntegers ( c ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return i ; ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testObserveOnWithSlowConsumer => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertTrue ( c . get ( ) < Flowable . bufferSize ( ) * 2 ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 4.1 ) ; AtomicInteger c1 = new AtomicInteger ( ) ; AtomicInteger c2 = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable < Integer > merged = Flowable . merge ( incrementingIntegers ( c1 ) , incrementingIntegers ( c2 ) ) ; merged . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "Expected: " + num + " got: " + ts . values ( ) . size ( ) ) ; System . out . println ( "testMergeSync => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c1 . get ( ) + " / " + c2 . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertTrue ( c1 . get ( ) < Flowable . bufferSize ( ) * 5 ) ; assertTrue ( c2 . get ( ) < Flowable . bufferSize ( ) * 5 ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 4.1 ) ; AtomicInteger c1 = new AtomicInteger ( ) ; AtomicInteger c2 = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable < Integer > merged = Flowable . merge ( incrementingIntegers ( c1 ) . subscribeOn ( Schedulers . computation ( ) ) , incrementingIntegers ( c2 ) . subscribeOn ( Schedulers . computation ( ) ) ) ; merged . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testMergeAsync => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c1 . get ( ) + " / " + c2 . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; int max = Flowable . bufferSize ( ) * 7 ; assertTrue ( "" + c1 . get ( ) + " >= " + max , c1 . get ( ) < max ) ; assertTrue ( "" + c2 . get ( ) + " >= " + max , c2 . get ( ) < max ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) if ( i % 10 == 0 ) System . out . println ( "testMergeAsyncThenObserveOnLoop >> " + i ) ; int num = ( int ) ( Flowable . bufferSize ( ) * 4.1 ) ; AtomicInteger c1 = new AtomicInteger ( ) ; AtomicInteger c2 = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable < Integer > merged = Flowable . merge ( incrementingIntegers ( c1 ) . subscribeOn ( Schedulers . computation ( ) ) , incrementingIntegers ( c2 ) . subscribeOn ( Schedulers . computation ( ) ) ) ; merged . observeOn ( Schedulers . io ( ) ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; System . out . println ( "testMergeAsyncThenObserveOn => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c1 . get ( ) + " / " + c2 . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 4.1 ) ; AtomicInteger c1 = new AtomicInteger ( ) ; AtomicInteger c2 = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable < Integer > merged = Flowable . merge ( incrementingIntegers ( c1 ) . subscribeOn ( Schedulers . computation ( ) ) , incrementingIntegers ( c2 ) . subscribeOn ( Schedulers . computation ( ) ) ) ; merged . observeOn ( Schedulers . newThread ( ) ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testMergeAsyncThenObserveOn => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c1 . get ( ) + " / " + c2 . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertTrue ( c1 . get ( ) < Flowable . bufferSize ( ) * 7 ) ; assertTrue ( c2 . get ( ) < Flowable . bufferSize ( ) * 7 ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 2.1 ) ; AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; incrementingIntegers ( c ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer i ) return incrementingIntegers ( new AtomicInteger ( ) ) . take ( 10 ) ; ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testFlatMapSync => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertTrue ( c . get ( ) < Flowable . bufferSize ( ) ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 4.1 ) ; AtomicInteger c1 = new AtomicInteger ( ) ; AtomicInteger c2 = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable < Integer > zipped = Flowable . zip ( incrementingIntegers ( c1 ) , incrementingIntegers ( c2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) ; zipped . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testZipSync => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c1 . get ( ) + " / " + c2 . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertTrue ( c1 . get ( ) < Flowable . bufferSize ( ) * 7 ) ; assertTrue ( c2 . get ( ) < Flowable . bufferSize ( ) * 7 ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 2.1 ) ; AtomicInteger c1 = new AtomicInteger ( ) ; AtomicInteger c2 = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable < Integer > zipped = Flowable . zip ( incrementingIntegers ( c1 ) . subscribeOn ( Schedulers . computation ( ) ) , incrementingIntegers ( c2 ) . subscribeOn ( Schedulers . computation ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) ; zipped . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testZipAsync => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c1 . get ( ) + " / " + c2 . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; int max = Flowable . bufferSize ( ) * 5 ; assertTrue ( "" + c1 . get ( ) + " >= " + max , c1 . get ( ) < max ) ; assertTrue ( "" + c2 . get ( ) + " >= " + max , c2 . get ( ) < max ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) int num = ( int ) ( Flowable . bufferSize ( ) * 2.1 ) ; AtomicInteger c = new AtomicInteger ( ) ; ConcurrentLinkedQueue < Thread > threads = new ConcurrentLinkedQueue < > ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; incrementingIntegers ( c , threads ) . subscribeOn ( Schedulers . computation ( ) ) . observeOn ( Schedulers . computation ( ) ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testSubscribeOnScheduling => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertTrue ( c . get ( ) < Flowable . bufferSize ( ) * 4 ) ; Thread first = null ; for ( Thread t : threads ) System . out . println ( "testSubscribeOnScheduling => thread: " + t ) ; if ( first == null ) first = t ; else if ( ! first . equals ( t ) ) fail ( "Expected to see the same thread" ) ; System . out . println ( "testSubscribeOnScheduling => Number of batch requests seen: " + threads . size ( ) ) ; assertTrue ( threads . size ( ) > 1 ) ; System . out . println ( "-------------------------------------------------------------------------------------------" ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 2.1 ) ; AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; incrementingIntegers ( c ) . observeOn ( Schedulers . computation ( ) ) . skip ( 10000 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i > 11000 ; ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; int expected = 10000 + 1000 + Flowable . bufferSize ( ) * 3 + Flowable . bufferSize ( ) / 2 ; System . out . println ( "testTakeFilterSkipChain => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c . get ( ) + " Expected: " + expected ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertTrue ( c . get ( ) < expected ) ; 
AtomicInteger c = new AtomicInteger ( ) ; final AtomicInteger totalReceived = new AtomicInteger ( ) ; final AtomicInteger batches = new AtomicInteger ( ) ; final AtomicInteger received = new AtomicInteger ( ) ; incrementingIntegers ( c ) . subscribe ( new ResourceSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 100 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) int total = totalReceived . incrementAndGet ( ) ; received . incrementAndGet ( ) ; if ( total >= 2000 ) dispose ( ) ; if ( received . get ( ) == 100 ) batches . incrementAndGet ( ) ; request ( 100 ) ; received . set ( 0 ) ; ) ; System . out . println ( "testUserSubscriberUsingRequestSync => Received: " + totalReceived . get ( ) + "  Emitted: " + c . get ( ) + " Request Batches: " + batches . get ( ) ) ; assertEquals ( 2000 , c . get ( ) ) ; assertEquals ( 2000 , totalReceived . get ( ) ) ; assertEquals ( 20 , batches . get ( ) ) ; 
AtomicInteger c = new AtomicInteger ( ) ; final AtomicInteger totalReceived = new AtomicInteger ( ) ; final AtomicInteger received = new AtomicInteger ( ) ; final AtomicInteger batches = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; incrementingIntegers ( c ) . subscribeOn ( Schedulers . newThread ( ) ) . subscribe ( new ResourceSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 100 ) ; @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) latch . countDown ( ) ; @ Override public void onNext ( Integer t ) int total = totalReceived . incrementAndGet ( ) ; received . incrementAndGet ( ) ; boolean done = false ; if ( total >= 2000 ) done = true ; dispose ( ) ; if ( received . get ( ) == 100 ) batches . incrementAndGet ( ) ; received . set ( 0 ) ; if ( ! done ) request ( 100 ) ; if ( done ) latch . countDown ( ) ; ) ; latch . await ( ) ; System . out . println ( "testUserSubscriberUsingRequestAsync => Received: " + totalReceived . get ( ) + "  Emitted: " + c . get ( ) + " Request Batches: " + batches . get ( ) ) ; assertEquals ( 2000 , c . get ( ) ) ; assertEquals ( 2000 , totalReceived . get ( ) ) ; assertEquals ( 20 , batches . get ( ) ) ; 
AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; firehose ( c ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) try Thread . sleep ( 10 ) ; catch ( Exception e ) e . printStackTrace ( ) ; return v ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; System . out . println ( "testFirehoseFailsAsExpected => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c . get ( ) ) ; int vc = ts . values ( ) . size ( ) ; assertTrue ( "10 < " + vc , vc <= 10 ) ; ts . assertError ( MissingBackpressureException . class ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) firehoseFailsAsExpected ( ) ; 
long t = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) if ( System . currentTimeMillis ( ) - t > TimeUnit . SECONDS . toMillis ( 9 ) ) break ; int num = ( int ) ( Flowable . bufferSize ( ) * 1.1 ) ; AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; firehose ( c ) . onBackpressureDrop ( ) . observeOn ( Schedulers . computation ( ) ) . map ( SLOW_PASS_THRU ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( num , onNextEvents . size ( ) ) ; Integer lastEvent = onNextEvents . get ( num - 1 ) ; System . out . println ( "testOnBackpressureDrop => Received: " + onNextEvents . size ( ) + "  Emitted: " + c . get ( ) + " Last value: " + lastEvent ) ; assertTrue ( num - 1 <= lastEvent . intValue ( ) ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) final AtomicInteger emitCount = new AtomicInteger ( ) ; final AtomicInteger dropCount = new AtomicInteger ( ) ; final AtomicInteger passCount = new AtomicInteger ( ) ; final int num = Flowable . bufferSize ( ) * 3 ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; firehose ( emitCount ) . onBackpressureDrop ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) dropCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) passCount . incrementAndGet ( ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( SLOW_PASS_THRU ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; List < Integer > onNextEvents = ts . values ( ) ; Integer lastEvent = onNextEvents . get ( num - 1 ) ; System . out . println ( testName . getMethodName ( ) + " => Received: " + onNextEvents . size ( ) + " Passed: " + passCount . get ( ) + " Dropped: " + dropCount . get ( ) + "  Emitted: " + emitCount . get ( ) + " Last value: " + lastEvent ) ; assertEquals ( num , onNextEvents . size ( ) ) ; assertTrue ( num <= passCount . get ( ) ) ; assertTrue ( num - 1 <= lastEvent . intValue ( ) ) ; assertTrue ( 0 < dropCount . get ( ) ) ; assertEquals ( emitCount . get ( ) , passCount . get ( ) + dropCount . get ( ) ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) int num = ( int ) ( Flowable . bufferSize ( ) * 1.1 ) ; AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; firehose ( c ) . onBackpressureDrop ( ) . map ( SLOW_PASS_THRU ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( num , onNextEvents . size ( ) ) ; Integer lastEvent = onNextEvents . get ( num - 1 ) ; System . out . println ( "testOnBackpressureDrop => Received: " + onNextEvents . size ( ) + "  Emitted: " + c . get ( ) + " Last value: " + lastEvent ) ; assertTrue ( num - 1 <= lastEvent . intValue ( ) ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) final AtomicInteger dropCount = new AtomicInteger ( ) ; int num = ( int ) ( Flowable . bufferSize ( ) * 1.1 ) ; AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; firehose ( c ) . onBackpressureDrop ( new Consumer < Integer > ( ) @ Override public void accept ( Integer j ) dropCount . incrementAndGet ( ) ; ) . map ( SLOW_PASS_THRU ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( num , onNextEvents . size ( ) ) ; Integer lastEvent = onNextEvents . get ( num - 1 ) ; System . out . println ( "testOnBackpressureDrop => Received: " + onNextEvents . size ( ) + " Dropped: " + dropCount . get ( ) + "  Emitted: " + c . get ( ) + " Last value: " + lastEvent ) ; assertTrue ( num - 1 <= lastEvent . intValue ( ) ) ; assertEquals ( 0 , dropCount . get ( ) ) ; assertEquals ( c . get ( ) , onNextEvents . size ( ) ) ; 
int num = ( int ) ( Flowable . bufferSize ( ) * 1.1 ) ; AtomicInteger c = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; firehose ( c ) . takeWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 100000 ; ) . onBackpressureBuffer ( ) . observeOn ( Schedulers . computation ( ) ) . map ( SLOW_PASS_THRU ) . take ( num ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( "testOnBackpressureBuffer => Received: " + ts . values ( ) . size ( ) + "  Emitted: " + c . get ( ) ) ; assertEquals ( num , ts . values ( ) . size ( ) ) ; assertEquals ( num - 1 , ts . values ( ) . get ( num - 1 ) . intValue ( ) ) ; 
return incrementingIntegers ( counter , null ) ; 
return Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) int i ; volatile boolean cancelled ; final AtomicLong requested = new AtomicLong ( ) ; @ Override public void request ( long n ) if ( ! SubscriptionHelper . validate ( n ) ) return ; if ( threadsSeen != null ) threadsSeen . offer ( Thread . currentThread ( ) ) ; long c = BackpressureHelper . add ( requested , n ) ; if ( c == 0 ) while ( ! cancelled ) counter . incrementAndGet ( ) ; s . onNext ( i ++ ) ; if ( requested . decrementAndGet ( ) == 0 ) return ; @ Override public void cancel ( ) cancelled = true ; ) ; ) ; 
return Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) Subscription s2 = new FirehoseNoBackpressure ( counter , s ) ; s . onSubscribe ( s2 ) ; ) ; 
subscriber . onSubscribe ( new BurstSubscription ( subscriber ) ) ; 
cancelled = true ; 
this . error = e ; return create ( ) ; 
return new Burst < > ( error , items ) ; 
Flowable < String > f1 = Flowable . just ( "one" , "two" ) ; Flowable < String > f2 = Flowable . just ( "three" , "four" ) ; List < String > values = Flowable . concat ( f1 , f2 ) . toList ( ) . blockingGet ( ) ; assertEquals ( "one" , values . get ( 0 ) ) ; assertEquals ( "two" , values . get ( 1 ) ) ; assertEquals ( "three" , values . get ( 2 ) ) ; assertEquals ( "four" , values . get ( 3 ) ) ; 
Flowable < String > f1 = Flowable . just ( "one" , "two" ) ; Flowable < String > f2 = Flowable . just ( "three" , "four" ) ; Flowable < String > f3 = Flowable . just ( "five" , "six" ) ; Flowable < Flowable < String > > os = Flowable . just ( f1 , f2 , f3 ) ; List < String > values = Flowable . concat ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( "one" , values . get ( 0 ) ) ; assertEquals ( "two" , values . get ( 1 ) ) ; assertEquals ( "three" , values . get ( 2 ) ) ; assertEquals ( "four" , values . get ( 3 ) ) ; assertEquals ( "five" , values . get ( 4 ) ) ; assertEquals ( "six" , values . get ( 5 ) ) ; 
Flowable < String > f1 = Flowable . just ( "one" , "two" ) ; Flowable < String > f2 = Flowable . just ( "three" , "four" ) ; Flowable < String > f3 = Flowable . just ( "five" , "six" ) ; Iterable < Flowable < String > > is = Arrays . asList ( f1 , f2 , f3 ) ; List < String > values = Flowable . concat ( Flowable . fromIterable ( is ) ) . toList ( ) . blockingGet ( ) ; assertEquals ( "one" , values . get ( 0 ) ) ; assertEquals ( "two" , values . get ( 1 ) ) ; assertEquals ( "three" , values . get ( 2 ) ) ; assertEquals ( "four" , values . get ( 3 ) ) ; assertEquals ( "five" , values . get ( 4 ) ) ; assertEquals ( "six" , values . get ( 5 ) ) ; 
HorrorMovie horrorMovie1 = new HorrorMovie ( ) ; Movie movie = new Movie ( ) ; Media media = new Media ( ) ; HorrorMovie horrorMovie2 = new HorrorMovie ( ) ; Flowable < Media > f1 = Flowable . < Media > just ( horrorMovie1 , movie ) ; Flowable < Media > f2 = Flowable . just ( media , horrorMovie2 ) ; Flowable < Flowable < Media > > os = Flowable . just ( f1 , f2 ) ; List < Media > values = Flowable . concat ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( horrorMovie1 , values . get ( 0 ) ) ; assertEquals ( movie , values . get ( 1 ) ) ; assertEquals ( media , values . get ( 2 ) ) ; assertEquals ( horrorMovie2 , values . get ( 3 ) ) ; assertEquals ( 4 , values . size ( ) ) ; 
HorrorMovie horrorMovie1 = new HorrorMovie ( ) ; Movie movie = new Movie ( ) ; Media media1 = new Media ( ) ; Media media2 = new Media ( ) ; HorrorMovie horrorMovie2 = new HorrorMovie ( ) ; Flowable < Media > f1 = Flowable . just ( horrorMovie1 , movie , media1 ) ; Flowable < Media > f2 = Flowable . just ( media2 , horrorMovie2 ) ; Flowable < Flowable < Media > > os = Flowable . just ( f1 , f2 ) ; List < Media > values = Flowable . concat ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( horrorMovie1 , values . get ( 0 ) ) ; assertEquals ( movie , values . get ( 1 ) ) ; assertEquals ( media1 , values . get ( 2 ) ) ; assertEquals ( media2 , values . get ( 3 ) ) ; assertEquals ( horrorMovie2 , values . get ( 4 ) ) ; assertEquals ( 5 , values . size ( ) ) ; 
HorrorMovie horrorMovie1 = new HorrorMovie ( ) ; Movie movie = new Movie ( ) ; Media media = new Media ( ) ; HorrorMovie horrorMovie2 = new HorrorMovie ( ) ; Flowable < Movie > f1 = Flowable . just ( horrorMovie1 , movie ) ; Flowable < Media > f2 = Flowable . just ( media , horrorMovie2 ) ; List < Media > values = Flowable . concat ( f1 , f2 ) . toList ( ) . blockingGet ( ) ; assertEquals ( horrorMovie1 , values . get ( 0 ) ) ; assertEquals ( movie , values . get ( 1 ) ) ; assertEquals ( media , values . get ( 2 ) ) ; assertEquals ( horrorMovie2 , values . get ( 3 ) ) ; assertEquals ( 4 , values . size ( ) ) ; 
final HorrorMovie horrorMovie1 = new HorrorMovie ( ) ; final Movie movie = new Movie ( ) ; Media media = new Media ( ) ; HorrorMovie horrorMovie2 = new HorrorMovie ( ) ; Flowable < Movie > f1 = Flowable . unsafeCreate ( new Publisher < Movie > ( ) @ Override public void subscribe ( Subscriber < ? super Movie > subscriber ) subscriber . onNext ( horrorMovie1 ) ; subscriber . onNext ( movie ) ; subscriber . onComplete ( ) ; ) ; Flowable < Media > f2 = Flowable . just ( media , horrorMovie2 ) ; List < Media > values = Flowable . concat ( f1 , f2 ) . toList ( ) . blockingGet ( ) ; assertEquals ( horrorMovie1 , values . get ( 0 ) ) ; assertEquals ( movie , values . get ( 1 ) ) ; assertEquals ( media , values . get ( 2 ) ) ; assertEquals ( horrorMovie2 , values . get ( 3 ) ) ; assertEquals ( 4 , values . size ( ) ) ; 
Flowable . < Movie > just ( new HorrorMovie ( ) ) ; Flowable . < Movie > fromIterable ( new ArrayList < HorrorMovie > ( ) ) ; 
Comparator < Media > sortFunction = new Comparator < Media > ( ) @ Override public int compare ( Media t1 , Media t2 ) return 1 ; ; Flowable < Media > f = Flowable . just ( new Movie ( ) , new TVSeason ( ) , new Album ( ) ) ; f . toSortedList ( sortFunction ) ; Flowable < Movie > f2 = Flowable . just ( new Movie ( ) , new ActionMovie ( ) , new HorrorMovie ( ) ) ; f2 . toSortedList ( sortFunction ) ; 
Flowable < Movie > movies = Flowable . just ( new HorrorMovie ( ) , new ActionMovie ( ) , new Movie ( ) ) ; TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; movies . groupBy ( new Function < Movie , Object > ( ) @ Override public Object apply ( Movie v ) return v . getClass ( ) ; ) . doOnNext ( new Consumer < GroupedFlowable < Object , Movie > > ( ) @ Override public void accept ( GroupedFlowable < Object , Movie > g ) System . out . println ( g . getKey ( ) ) ; ) . flatMap ( new Function < GroupedFlowable < Object , Movie > , Publisher < String > > ( ) @ Override public Publisher < String > apply ( GroupedFlowable < Object , Movie > g ) return g . doOnNext ( new Consumer < Movie > ( ) @ Override public void accept ( Movie v ) System . out . println ( v ) ; ) . compose ( new FlowableTransformer < Movie , Movie > ( ) @ Override public Publisher < Movie > apply ( Flowable < Movie > m ) return m . concatWith ( Flowable . just ( new ActionMovie ( ) ) ) ; ) . map ( new Function < Object , String > ( ) @ Override public String apply ( Object v ) return v . toString ( ) ; ) ; ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; assertEquals ( 6 , ts . values ( ) . size ( ) ) ; 
Flowable < HorrorMovie > movie = Flowable . just ( new HorrorMovie ( ) ) ; Flowable < Movie > movie2 = movie . compose ( new FlowableTransformer < HorrorMovie , Movie > ( ) @ Override public Publisher < Movie > apply ( Flowable < HorrorMovie > t ) return Flowable . just ( new Movie ( ) ) ; ) ; 
Flowable < Movie > movie = Flowable . < Movie > just ( new HorrorMovie ( ) ) ; Flowable < HorrorMovie > movie2 = movie . compose ( new FlowableTransformer < Movie , HorrorMovie > ( ) @ Override public Publisher < HorrorMovie > apply ( Flowable < Movie > t ) return Flowable . just ( new HorrorMovie ( ) ) ; ) ; 
Flowable < Movie > movie = Flowable . < Movie > just ( new HorrorMovie ( ) ) ; Flowable < HorrorMovie > movie2 = movie . compose ( new FlowableTransformer < Movie , HorrorMovie > ( ) @ Override public Publisher < HorrorMovie > apply ( Flowable < Movie > t ) return Flowable . just ( new HorrorMovie ( ) ) . map ( new Function < HorrorMovie , HorrorMovie > ( ) @ Override public HorrorMovie apply ( HorrorMovie v ) return v ; ) ; ) ; 
Flowable < HorrorMovie > movie = Flowable . just ( new HorrorMovie ( ) ) ; Flowable < HorrorMovie > movie2 = movie . compose ( new FlowableTransformer < HorrorMovie , HorrorMovie > ( ) @ Override public Publisher < HorrorMovie > apply ( Flowable < HorrorMovie > t1 ) return t1 . map ( new Function < HorrorMovie , HorrorMovie > ( ) @ Override public HorrorMovie apply ( HorrorMovie v ) return v ; ) ; ) ; 
List < Movie > list1 = Arrays . asList ( new Movie ( ) , new HorrorMovie ( ) , new ActionMovie ( ) ) ; List < Movie > list2 = Arrays . asList ( new ActionMovie ( ) , new Movie ( ) , new HorrorMovie ( ) , new ActionMovie ( ) ) ; Flowable < List < Movie > > movies = Flowable . just ( list1 , list2 ) ; movies . compose ( deltaTransformer ) ; 
TestHelper . checkUtilityClass ( FlowableEventStream . class ) ; 
FlowableEventStream . getEventStream ( "HTTP-ClusterB" , 20 ) . groupBy ( new Function < Event , String > ( ) @ Override public String apply ( Event e ) return e . instanceId ; ) . flatMap ( new Function < GroupedFlowable < String , Event > , Publisher < HashMap < String , String > > > ( ) @ Override public Publisher < HashMap < String , String > > apply ( final GroupedFlowable < String , Event > ge ) return ge . scan ( new HashMap < > ( ) , new BiFunction < HashMap < String , String > , Event , HashMap < String , String > > ( ) @ Override public HashMap < String , String > apply ( HashMap < String , String > accum , Event perInstanceEvent ) synchronized ( accum ) accum . put ( "instance" , ge . getKey ( ) ) ; return accum ; ) ; ) . take ( 10 ) . blockingForEach ( new Consumer < HashMap < String , String > > ( ) @ Override public void accept ( HashMap < String , String > v ) synchronized ( v ) System . out . println ( v ) ; ) ; System . out . println ( "**** finished" ) ; 
Flowable < HorrorMovie > horrors = Flowable . just ( new HorrorMovie ( ) ) ; Flowable < CoolRating > ratings = Flowable . just ( new CoolRating ( ) ) ; Flowable . < Movie , CoolRating , Result > zip ( horrors , ratings , combine ) . blockingForEach ( action ) ; Flowable . < Movie , CoolRating , Result > zip ( horrors , ratings , combine ) . blockingForEach ( action ) ; Flowable . < Media , Rating , ExtendedResult > zip ( horrors , ratings , combine ) . blockingForEach ( extendedAction ) ; Flowable . < Media , Rating , Result > zip ( horrors , ratings , combine ) . blockingForEach ( action ) ; Flowable . < Media , Rating , ExtendedResult > zip ( horrors , ratings , combine ) . blockingForEach ( action ) ; Flowable . < Movie , CoolRating , Result > zip ( horrors , ratings , combine ) ; 
final Object invoked = new Object ( ) ; Collection < Flowable < Object > > observables = Collections . emptyList ( ) ; Flowable < Object > result = Flowable . zip ( observables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] args ) System . out . println ( "received: " + args ) ; assertEquals ( "No argument should have been passed" , 0 , args . length ) ; return invoked ; ) ; assertSame ( invoked , result . blockingLast ( ) ) ; 
Flowable . just ( 1 ) . zipWith ( Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true ) . test ( ) . assertResult ( 3 ) ; 
Flowable . just ( 1 ) . zipWith ( Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true , 16 ) . test ( ) . assertResult ( 3 ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final RuntimeException e = new RuntimeException ( ) ; Burst . items ( 1 , 2 ) . create ( ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Exception count . incrementAndGet ( ) ; throw e ; ) . test ( ) . assertError ( e ) . assertValue ( 1 ) ; assertEquals ( 1 , count . get ( ) ) ; 
Flowable < Integer > f = Flowable . just ( 1 , 2 , 3 ) ; int value = f . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . toFlowable ( ) . blockingSingle ( ) ; assertEquals ( 6 , value ) ; 
Flowable < Movie > horrorMovies = Flowable . < Movie > just ( new HorrorMovie ( ) ) ; Flowable < Movie > reduceResult = horrorMovies . scan ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) . takeLast ( 1 ) ; Flowable < Movie > reduceResult2 = horrorMovies . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) . toFlowable ( ) ; assertNotNull ( reduceResult2 ) ; 
Flowable < Movie > horrorMovies = Flowable . < Movie > just ( new HorrorMovie ( ) ) ; Flowable < Movie > reduceResult2 = horrorMovies . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) . toFlowable ( ) ; assertNotNull ( reduceResult2 ) ; 
Flowable < Integer > f = Flowable . just ( 1 , 2 , 3 ) ; int value = f . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . toFlowable ( ) . blockingSingle ( ) ; assertEquals ( 6 , value ) ; 
Flowable < Movie > horrorMovies = Flowable . < Movie > just ( new HorrorMovie ( ) ) ; Flowable < Movie > reduceResult = horrorMovies . scan ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) . takeLast ( 1 ) ; Maybe < Movie > reduceResult2 = horrorMovies . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) ; assertNotNull ( reduceResult2 ) ; 
Flowable < Movie > horrorMovies = Flowable . < Movie > just ( new HorrorMovie ( ) ) ; Maybe < Movie > reduceResult2 = horrorMovies . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) ; assertNotNull ( reduceResult2 ) ; 
Flowable < Movie > horrorMovies = Flowable . < Movie > just ( new HorrorMovie ( ) ) ; libraryFunctionActingOnMovieObservables ( horrorMovies ) ; 
obs . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) ; 
s . onNext ( randomEvent ( type , numInstances ) ) ; try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; s . onError ( e ) ; 
final AtomicReference < String > r = new AtomicReference < > ( ) ; String output = Flowable . just ( "one" ) . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String v ) r . set ( v ) ; ) . blockingSingle ( ) ; assertEquals ( "one" , output ) ; assertEquals ( "one" , r . get ( ) ) ; 
final AtomicReference < Throwable > r = new AtomicReference < > ( ) ; Throwable t = null ; try Flowable . < String > error ( new RuntimeException ( "an error" ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) r . set ( v ) ; ) . blockingSingle ( ) ; fail ( "expected exception, not a return value" ) ; catch ( Throwable e ) t = e ; assertNotNull ( t ) ; assertEquals ( t , r . get ( ) ) ; 
final AtomicBoolean r = new AtomicBoolean ( ) ; String output = Flowable . just ( "one" ) . doOnComplete ( new Action ( ) @ Override public void run ( ) r . set ( true ) ; ) . blockingSingle ( ) ; assertEquals ( "one" , output ) ; assertTrue ( r . get ( ) ) ; 
final AtomicBoolean r = new AtomicBoolean ( ) ; Flowable . < String > error ( new TestException ( ) ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) r . set ( true ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( r . get ( ) ) ; 
final AtomicBoolean r = new AtomicBoolean ( ) ; String output = Flowable . just ( "one" ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) r . set ( true ) ; ) . blockingSingle ( ) ; assertEquals ( "one" , output ) ; assertTrue ( r . get ( ) ) ; 
Flowable . ambArray ( Flowable . never ( ) , null ) . blockingLast ( ) ; 
Flowable . amb ( new Iterable < Publisher < Object > > ( ) @ Override public Iterator < Publisher < Object > > iterator ( ) return null ; ) . test ( ) . assertError ( NullPointerException . class ) ; 
Flowable . amb ( Arrays . asList ( Flowable . never ( ) , null ) ) . test ( ) . assertError ( NullPointerException . class ) ; 
Flowable . combineLatestDelayError ( new Iterable < Publisher < Object > > ( ) @ Override public Iterator < Publisher < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingLast ( ) ; 
Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . never ( ) , null ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingLast ( ) ; 
Flowable . combineLatestDelayError ( Arrays . asList ( just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return null ; ) . blockingLast ( ) ; 
Flowable . concat ( new Iterable < Publisher < Object > > ( ) @ Override public Iterator < Publisher < Object > > iterator ( ) return null ; ) . blockingLast ( ) ; 
Flowable . concat ( Arrays . asList ( just1 , null ) ) . blockingLast ( ) ; 
Flowable . concatArray ( just1 , null ) . blockingLast ( ) ; 
Flowable . defer ( new Supplier < Publisher < Object > > ( ) @ Override public Publisher < Object > get ( ) return null ; ) . blockingLast ( ) ; 
Flowable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return null ; ) . blockingSubscribe ( ) ; 
Flowable . fromArray ( 1 , null ) . blockingLast ( ) ; 
Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return null ; ) . blockingLast ( ) ; 
FutureTask < Object > f = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; f . run ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . fromFuture ( f ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( NullPointerException . class ) ; 
FutureTask < Object > f = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; f . run ( ) ; Flowable . fromFuture ( f , 1 , TimeUnit . SECONDS ) . blockingLast ( ) ; 
Flowable . fromIterable ( new Iterable < Object > ( ) @ Override public Iterator < Object > iterator ( ) return null ; ) . blockingLast ( ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , null ) ) . blockingLast ( ) ; 
Flowable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > s ) s . onNext ( null ) ; ) . blockingLast ( ) ; 
BiConsumer < Integer , Emitter < Integer > > generator = new BiConsumer < Integer , Emitter < Integer > > ( ) @ Override public void accept ( Integer s , Emitter < Integer > o ) o . onNext ( 1 ) ; ; Flowable . generate ( null , generator ) ; 
Flowable . generate ( null , new BiFunction < Object , Emitter < Object > , Object > ( ) @ Override public Object apply ( Object s , Emitter < Object > o ) o . onNext ( 1 ) ; return s ; ) ; 
Flowable . generate ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , ( BiConsumer < Integer , Emitter < Object > > ) null ) ; 
BiConsumer < Integer , Emitter < Integer > > generator = new BiConsumer < Integer , Emitter < Integer > > ( ) @ Override public void accept ( Integer s , Emitter < Integer > o ) o . onComplete ( ) ; ; Flowable . generate ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return null ; , generator ) . blockingSubscribe ( ) ; 
Flowable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; , new BiFunction < Object , Emitter < Object > , Object > ( ) @ Override public Object apply ( Object s , Emitter < Object > o ) o . onComplete ( ) ; return s ; ) . blockingSubscribe ( ) ; 
@ SuppressWarnings ( "rawtypes" ) Class < Flowable > clazz = Flowable . class ; for ( int argCount = 1 ; argCount < 10 ; argCount ++ ) for ( int argNull = 1 ; argNull <= argCount ; argNull ++ ) Class < ? > [ ] params = new Class [ argCount ] ; Arrays . fill ( params , Object . class ) ; Object [ ] values = new Object [ argCount ] ; Arrays . fill ( values , 1 ) ; values [ argNull - 1 ] = null ; Method m = clazz . getMethod ( "just" , params ) ; try m . invoke ( null , values ) ; Assert . fail ( "No exception for argCount " + argCount + " / argNull " + argNull ) ; catch ( InvocationTargetException ex ) if ( ! ( ex . getCause ( ) instanceof NullPointerException ) ) Assert . fail ( "Unexpected exception for argCount " + argCount + " / argNull " + argNull + ": " + ex ) ; 
Flowable . merge ( new Iterable < Publisher < Object > > ( ) @ Override public Iterator < Publisher < Object > > iterator ( ) return null ; , 128 , 128 ) . blockingLast ( ) ; 
Flowable . merge ( Arrays . asList ( just1 , null ) , 128 , 128 ) . blockingLast ( ) ; 
Flowable . mergeArray ( 128 , 128 , just1 , null ) . blockingLast ( ) ; 
Flowable . mergeDelayError ( new Iterable < Publisher < Object > > ( ) @ Override public Iterator < Publisher < Object > > iterator ( ) return null ; , 128 , 128 ) . blockingLast ( ) ; 
Flowable . mergeDelayError ( Arrays . asList ( just1 , null ) , 128 , 128 ) . blockingLast ( ) ; 
Flowable . mergeArrayDelayError ( 128 , 128 , just1 , null ) . blockingLast ( ) ; 
Flowable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , new Function < Object , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Object d ) return null ; , Functions . emptyConsumer ( ) ) . blockingLast ( ) ; 
Flowable . zip ( new Iterable < Publisher < Object > > ( ) @ Override public Iterator < Publisher < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingLast ( ) ; 
Flowable . zip ( Arrays . asList ( just1 , just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) return null ; ) . blockingLast ( ) ; 
Flowable . zip ( ( Iterable < Publisher < Object > > ) null , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) return 1 ; , true , 128 ) ; 
Flowable . zip ( new Iterable < Publisher < Object > > ( ) @ Override public Iterator < Publisher < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) return 1 ; , true , 128 ) . blockingLast ( ) ; 
Flowable . zip ( Arrays . asList ( just1 , just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) return null ; , true , 128 ) . blockingLast ( ) ; 
just1 . buffer ( 1 , 1 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . buffer ( 1L , 1L , TimeUnit . SECONDS , Schedulers . single ( ) , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . buffer ( just1 , new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . buffer ( just1 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . collect ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; , new BiConsumer < Object , Integer > ( ) @ Override public void accept ( Object a , Integer b ) ) . blockingGet ( ) ; 
just1 . concatMap ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . concatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . concatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) return new Iterable < Object > ( ) @ Override public Iterator < Object > iterator ( ) return null ; ; ) . blockingSubscribe ( ) ; 
just1 . debounce ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . delay ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . delay ( just1 , new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . distinct ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Supplier < Collection < Object > > ( ) @ Override public Collection < Object > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . distinct ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
Flowable . range ( 1 , 2 ) . distinctUntilChanged ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . test ( ) . assertResult ( 1 ) ; 
just1 . flatMap ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return null ; , new Function < Throwable , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Throwable e ) return just1 ; , new Supplier < Publisher < Integer > > ( ) @ Override public Publisher < Integer > get ( ) return just1 ; ) . blockingSubscribe ( ) ; 
just1 . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return just1 ; , new Function < Throwable , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Throwable e ) return just1 ; , new Supplier < Publisher < Integer > > ( ) @ Override public Publisher < Integer > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . flatMap ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer a , Object b ) return 1 ; ) . blockingSubscribe ( ) ; 
just1 . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return just1 ; , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . flatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . flatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) return new Iterable < Object > ( ) @ Override public Iterator < Object > iterator ( ) return null ; ; ) . blockingSubscribe ( ) ; 
just1 . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Arrays . asList ( 1 , null ) ; ) . blockingSubscribe ( ) ; 
just1 . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Arrays . asList ( 1 ) ; , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . groupBy ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . groupBy ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . lift ( new FlowableOperator < Object , Integer > ( ) @ Override public Subscriber < ? super Integer > apply ( Subscriber < ? super Object > s ) return null ; ) . blockingSubscribe ( ) ; 
just1 . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
try Flowable . error ( new TestException ( ) ) . onErrorResumeNext ( new Function < Throwable , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Throwable e ) return null ; ) . blockingSubscribe ( ) ; fail ( "Should have thrown" ) ; catch ( CompositeException ex ) List < Throwable > errors = ex . getExceptions ( ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , NullPointerException . class ) ; assertEquals ( 2 , errors . size ( ) ) ; 
try Flowable . error ( new TestException ( ) ) . onErrorReturn ( new Function < Throwable , Object > ( ) @ Override public Object apply ( Throwable e ) return null ; ) . blockingSubscribe ( ) ; fail ( "Should have thrown" ) ; catch ( CompositeException ex ) List < Throwable > errors = TestHelper . compositeList ( ex ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , NullPointerException . class , "The valueSupplier returned a null value" ) ; 
just1 . publish ( new Function < Flowable < Integer > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Integer > v ) return null ; ) . blockingSubscribe ( ) ; 
Flowable . just ( 1 , 1 ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return null ; ) . toFlowable ( ) . blockingSubscribe ( ) ; 
just1 . reduce ( 1 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return null ; ) . blockingGet ( ) ; 
just1 . reduceWith ( null , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) return 1 ; ) ; 
just1 . reduceWith ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) return 1 ; ) . blockingGet ( ) ; 
just1 . repeatWhen ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . replay ( ( Function < Flowable < Integer > , Flowable < Integer > > ) null ) ; 
just1 . replay ( new Function < Flowable < Integer > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Integer > f ) return null ; ) . blockingSubscribe ( ) ; 
just1 . replay ( new Function < Flowable < Integer > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Integer > v ) return null ; , 1 , 1 , TimeUnit . SECONDS ) . blockingSubscribe ( ) ; 
just1 . replay ( new Function < Flowable < Integer > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Integer > v ) return null ; , 1 , TimeUnit . SECONDS , Schedulers . single ( ) ) . blockingSubscribe ( ) ; 
Flowable . error ( new TestException ( ) ) . retryWhen ( new Function < Flowable < ? extends Throwable > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < ? extends Throwable > f ) return null ; ) . blockingSubscribe ( ) ; 
Flowable . just ( 1 , 1 ) . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . scan ( null , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) return 1 ; ) ; 
just1 . scan ( 1 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . scanWith ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) return 1 ; ) . blockingSubscribe ( ) ; 
just1 . scanWith ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . startWithIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . startWithIterable ( Arrays . asList ( 1 , null ) ) . blockingSubscribe ( ) ; 
just1 . startWithArray ( 1 , null ) . blockingSubscribe ( ) ; 
just1 . switchMap ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . timeout ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . timeout ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return just1 ; , null ) ; 
just1 . timeout ( Flowable . never ( ) , new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . timestamp ( null , Schedulers . single ( ) ) ; 
just1 . timestamp ( TimeUnit . SECONDS , null ) ; 
just1 . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . toFlowable ( ) . blockingSubscribe ( ) ; 
just1 . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . blockingGet ( ) ; 
just1 . toMap ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingGet ( ) ; 
just1 . toMap ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Supplier < Map < Object , Object > > ( ) @ Override public Map < Object , Object > get ( ) return null ; ) . blockingGet ( ) ; 
just1 . toMap ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingGet ( ) ; 
just1 . toMultimap ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Supplier < Map < Object , Collection < Object > > > ( ) @ Override public Map < Object , Collection < Object > > get ( ) return null ; ) . blockingGet ( ) ; 
just1 . toMultimap ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; , new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; , new Supplier < Map < Integer , Collection < Integer > > > ( ) @ Override public Map < Integer , Collection < Integer > > get ( ) return new HashMap < > ( ) ; , new Function < Integer , Collection < Integer > > ( ) @ Override public Collection < Integer > apply ( Integer v ) return null ; ) . blockingGet ( ) ; 
just1 . window ( null , new Function < Object , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Object v ) return just1 ; ) ; 
Flowable . never ( ) . window ( just1 , new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . withLatestFrom ( null , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer a , Object b ) return 1 ; ) ; 
just1 . withLatestFrom ( just1 , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . zipWith ( ( Iterable < Integer > ) null , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return 1 ; ) ; 
just1 . zipWith ( Arrays . asList ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . zipWith ( new Iterable < Object > ( ) @ Override public Iterator < Object > iterator ( ) return null ; , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer a , Object b ) return 1 ; ) . blockingSubscribe ( ) ; 
Flowable . just ( 1 , 2 ) . zipWith ( Arrays . asList ( 1 , null ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return 1 ; ) . blockingSubscribe ( ) ; 
just1 . zipWith ( ( Publisher < Integer > ) null , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return 1 ; ) ; 
just1 . zipWith ( just1 , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = AsyncProcessor . create ( ) ; processor . onNext ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = AsyncProcessor . create ( ) ; processor . onError ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = BehaviorProcessor . create ( ) ; processor . onNext ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = BehaviorProcessor . create ( ) ; processor . onError ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = PublishProcessor . create ( ) ; processor . onNext ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = PublishProcessor . create ( ) ; processor . onError ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = ReplayProcessor . create ( ) ; processor . onNext ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = ReplayProcessor . create ( ) ; processor . onError ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; processor . onNext ( null ) ; processor . blockingSubscribe ( ) ; 
FlowableProcessor < Integer > processor = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; processor . onError ( null ) ; processor . blockingSubscribe ( ) ; 
Flowable . combineLatestDelayError ( Arrays . asList ( just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return null ; , 128 ) . blockingLast ( ) ; 
Flowable . combineLatestDelayError ( new Iterable < Flowable < Object > > ( ) @ Override public Iterator < Flowable < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , 128 ) . blockingLast ( ) ; 
Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . never ( ) , null ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , 128 ) . blockingLast ( ) ; 
TestSubscriber < String > s = new TestSubscriber < > ( 0L ) ; s . request ( 10 ) ; final AtomicLong r = new AtomicLong ( ) ; s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) r . set ( n ) ; @ Override public void cancel ( ) ) ; assertEquals ( 10 , r . get ( ) ) ; 
TestSubscriber < String > s = new TestSubscriber < > ( ) ; final AtomicLong r = new AtomicLong ( ) ; s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) r . set ( n ) ; @ Override public void cancel ( ) ) ; assertEquals ( Long . MAX_VALUE , r . get ( ) ) ; 
TestSubscriber < String > s = new TestSubscriber < > ( 10L ) ; FlowableOperator < String , String > o = new FlowableOperator < String , String > ( ) @ Override public Subscriber < ? super String > apply ( final Subscriber < ? super String > s1 ) return new FlowableSubscriber < String > ( ) @ Override public void onSubscribe ( Subscription a ) s1 . onSubscribe ( a ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String t ) ; ; Subscriber < ? super String > ns = o . apply ( s ) ; final AtomicLong r = new AtomicLong ( ) ; ns . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) r . set ( n ) ; @ Override public void cancel ( ) ) ; assertEquals ( 10 , r . get ( ) ) ; 
TestSubscriber < String > s = new TestSubscriber < > ( 0L ) ; FlowableOperator < String , String > o = new FlowableOperator < String , String > ( ) @ Override public Subscriber < ? super String > apply ( final Subscriber < ? super String > s1 ) return new FlowableSubscriber < String > ( ) @ Override public void onSubscribe ( Subscription a ) s1 . onSubscribe ( a ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String t ) ; ; s . request ( 10 ) ; Subscriber < ? super String > ns = o . apply ( s ) ; final AtomicLong r = new AtomicLong ( ) ; ns . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) r . set ( n ) ; @ Override public void cancel ( ) ) ; assertEquals ( 10 , r . get ( ) ) ; 
TestSubscriber < String > s = new TestSubscriber < > ( 10L ) ; final AtomicLong innerR = new AtomicLong ( ) ; FlowableOperator < String , String > o = new FlowableOperator < String , String > ( ) @ Override public Subscriber < ? super String > apply ( Subscriber < ? super String > child ) child . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) innerR . set ( n ) ; @ Override public void cancel ( ) ) ; ResourceSubscriber < String > as = new ResourceSubscriber < String > ( ) @ Override protected void onStart ( ) request ( 99 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String t ) ; return as ; ; Subscriber < ? super String > ns = o . apply ( s ) ; final AtomicLong r = new AtomicLong ( ) ; ns . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) r . set ( n ) ; @ Override public void cancel ( ) ) ; assertEquals ( 99 , r . get ( ) ) ; assertEquals ( 10 , innerR . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 3L ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . < Integer > unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . subscribe ( ts ) ; assertEquals ( 3 , requested . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 3 ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . < Integer > unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . map ( Functions . < Integer > identity ( ) ) . subscribe ( ts ) ; assertEquals ( 3 , requested . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 3 ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . < Integer > unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . take ( 2 ) . subscribe ( ts ) ; assertEquals ( 2 , requested . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 3 ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . < Integer > unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . take ( 10 ) . subscribe ( ts ) ; assertEquals ( 3 , requested . get ( ) ) ; 
final AtomicInteger c = new AtomicInteger ( ) ; Flowable . just ( 1 , 2 , 3 , 4 ) . take ( 2 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) c . incrementAndGet ( ) ; request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) request ( 1 ) ; ) ; assertEquals ( 1 , c . get ( ) ) ; 
final AtomicInteger c = new AtomicInteger ( ) ; Flowable . just ( 1 , 2 , 3 , 4 ) . take ( 2 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) c . incrementAndGet ( ) ; request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) request ( 1 ) ; ) ; assertEquals ( 1 , c . get ( ) ) ; 
final AtomicInteger c = new AtomicInteger ( ) ; Flowable . just ( 1 , 2 , 3 , 4 ) . lift ( new FlowableOperator < Integer , Integer > ( ) @ Override public Subscriber < ? super Integer > apply ( final Subscriber < ? super Integer > child ) return new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) c . incrementAndGet ( ) ; request ( 1 ) ; @ Override public void onComplete ( ) child . onComplete ( ) ; @ Override public void onError ( Throwable e ) child . onError ( e ) ; @ Override public void onNext ( Integer t ) child . onNext ( t ) ; request ( 1 ) ; ; ) . subscribe ( ) ; assertEquals ( 1 , c . get ( ) ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 3 ) ; request ( 2 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) list . add ( t ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 2 ) ; request ( Long . MAX_VALUE - 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) list . add ( t ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final List < Integer > list = new ArrayList < > ( ) ; Disposable d = pp . forEachWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception list . add ( v ) ; return v < 3 ; ) ; assertFalse ( d . isDisposed ( ) ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onNext ( 3 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , list ) ; 
ForEachWhileSubscriber < Integer > s = new ForEachWhileSubscriber < > ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; , Functions . < Throwable > emptyConsumer ( ) , Functions . EMPTY_ACTION ) ; List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try s . onSubscribe ( new BooleanSubscription ( ) ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; s . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; TestHelper . assertError ( list , 0 , IllegalStateException . class , "Subscription already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ForEachWhileSubscriber < Integer > s = new ForEachWhileSubscriber < > ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception ts . onNext ( v ) ; return true ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception ts . onError ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception ts . onComplete ( ) ; ) ; s . onComplete ( ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; ts . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ForEachWhileSubscriber < Integer > s = new ForEachWhileSubscriber < > ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception ts . onError ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception ts . onComplete ( ) ; ) ; BooleanSubscription b = new BooleanSubscription ( ) ; s . onSubscribe ( b ) ; s . onNext ( 1 ) ; assertTrue ( b . isCancelled ( ) ) ; ts . assertFailure ( TestException . class ) ; 
ForEachWhileSubscriber < Integer > s = new ForEachWhileSubscriber < > ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; , new Action ( ) @ Override public void run ( ) throws Exception ) ; List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "Outer" ) ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > cel = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( cel , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( cel , 1 , TestException . class , "Inner" ) ; finally RxJavaPlugins . reset ( ) ; 
ForEachWhileSubscriber < Integer > s = new ForEachWhileSubscriber < > ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( "Inner" ) ; ) ; List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onComplete ( ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class , "Inner" ) ; finally RxJavaPlugins . reset ( ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable . < Integer > error ( new TestException ( ) ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 100 ) , list ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . test ( Long . MAX_VALUE , true ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . safeSubscribe ( new SafeSubscriber < > ( ts ) ) ; ts . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . test ( Long . MAX_VALUE , false ) ; assertTrue ( pp . hasSubscribers ( ) ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable . just ( 1 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 ) , list ) ; 
RxJavaPlugins . setOnFlowableSubscribe ( new BiFunction < Flowable , Subscriber , Subscriber > ( ) @ Override public Subscriber apply ( Flowable a , Subscriber b ) throws Exception return null ; ) ; try try Flowable . just ( 1 ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertEquals ( "The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins" , ex . getMessage ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
throw new IllegalArgumentException ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try try new BadFlowable ( ) . test ( ) ; fail ( "Should have thrown!" ) ; catch ( NullPointerException ex ) if ( ! ( ex . getCause ( ) instanceof IllegalArgumentException ) ) fail ( ex . toString ( ) + ": Should be NPE(IAE)" ) ; TestHelper . assertError ( list , 0 , IllegalArgumentException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . merge ( FlowableEventStream . getEventStream ( "HTTP-ClusterA" , 50 ) , FlowableEventStream . getEventStream ( "HTTP-ClusterB" , 20 ) ) . groupBy ( new Function < Event , Object > ( ) @ Override public Object apply ( Event event ) return event . type ; ) . take ( 1 ) . blockingForEach ( new Consumer < GroupedFlowable < Object , Event > > ( ) @ Override public void accept ( GroupedFlowable < Object , Event > v ) System . out . println ( v ) ; v . take ( 1 ) . subscribe ( ) ; ) ; System . out . println ( "**** finished" ) ; 
Flowable . merge ( FlowableEventStream . getEventStream ( "HTTP-ClusterA" , 50 ) , FlowableEventStream . getEventStream ( "HTTP-ClusterB" , 20 ) ) . groupBy ( new Function < Event , Object > ( ) @ Override public Object apply ( Event event ) return event . type ; ) . flatMap ( new Function < GroupedFlowable < Object , Event > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( GroupedFlowable < Object , Event > g ) return g . map ( new Function < Event , Object > ( ) @ Override public Object apply ( Event event ) return event . instanceId + " - " + event . values . get ( "count200" ) ; ) ; ) . take ( 20 ) . blockingForEach ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) System . out . println ( v ) ; ) ; System . out . println ( "**** finished" ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 0 , 20 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i % 5 ; ) . concatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( GroupedFlowable < Integer , Integer > v ) return v ; , 20 ) . subscribe ( ts ) ; ts . assertValues ( 0 , 5 , 10 , 15 , 1 , 2 , 3 , 4 , 6 , 7 , 8 , 9 , 11 , 12 , 13 , 14 , 16 , 17 , 18 , 19 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
File f = TestHelper . findSource ( "Flowable" ) ; if ( f == null ) return null ; String parent = f . getParentFile ( ) . getParentFile ( ) . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; if ( ! parent . endsWith ( "/" ) ) parent += "/" ; parent += "internal/operators/" + baseClassName . toLowerCase ( ) + "/" ; return new File ( parent ) ; 
File f = directoryOf ( baseClassName ) ; if ( f == null ) return ; StringBuilder e = new StringBuilder ( ) ; File [ ] files = f . listFiles ( ) ; if ( files != null ) for ( File g : files ) if ( g . getName ( ) . startsWith ( baseClassName ) && g . getName ( ) . endsWith ( ".java" ) ) String className = "io.reactivex.rxjava3.internal.operators." + baseClassName . toLowerCase ( ) + "." + g . getName ( ) . replace ( ".java" , "" ) ; Class < ? > clazz = Class . forName ( className ) ; if ( ( clazz . getModifiers ( ) & Modifier . FINAL ) == 0 && ( clazz . getModifiers ( ) & Modifier . ABSTRACT ) == 0 ) e . append ( "java.lang.RuntimeException: " ) . append ( className ) . append ( " is not final\r\n" ) ; e . append ( " at " ) . append ( className ) . append ( " (" ) . append ( g . getName ( ) ) . append ( ":14)\r\n\r\n" ) ; if ( e . length ( ) != 0 ) System . out . println ( e ) ; throw new AssertionError ( e . toString ( ) ) ; 
check ( "Flowable" ) ; 
check ( "Observable" ) ; 
check ( "Single" ) ; 
check ( "Completable" ) ; 
check ( "Maybe" ) ; 
File f = TestHelper . findSource ( "Flowable" ) ; if ( f == null ) return ; Queue < File > dirs = new ArrayDeque < > ( ) ; File parent = f . getParentFile ( ) . getParentFile ( ) ; dirs . offer ( parent ) ; StringBuilder fail = new StringBuilder ( ) ; while ( ! dirs . isEmpty ( ) ) f = dirs . poll ( ) ; File [ ] list = f . listFiles ( ) ; if ( list != null && list . length != 0 ) for ( File u : list ) if ( u . isDirectory ( ) ) dirs . offer ( u ) ; else if ( u . getName ( ) . endsWith ( ".java" ) ) List < String > lines = new ArrayList < > ( ) ; BufferedReader in = new BufferedReader ( new FileReader ( u ) ) ; try for ( ; ; ) String line = in . readLine ( ) ; if ( line == null ) break ; lines . add ( line ) ; finally in . close ( ) ; String clazz = u . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; int idx = clazz . indexOf ( "/io/reactivex/" ) ; clazz = clazz . substring ( idx + 14 ) . replace ( ".java" , "" ) ; processFile ( fail , lines , clazz , u . getName ( ) ) ; if ( fail . length ( ) != 0 ) System . out . println ( fail ) ; throw new AssertionError ( fail . toString ( ) ) ; 
int i = 1 ; for ( String s : lines ) if ( s . contains ( " a Observer" ) ) b . append ( "java.lang.RuntimeException: ' a Observer'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( "A Observer" ) ) b . append ( "java.lang.RuntimeException: 'A Observer'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( " a Observable" ) ) b . append ( "java.lang.RuntimeException: ' a Observable'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( "A Observable" ) ) b . append ( "java.lang.RuntimeException: 'A Observable'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( " an Subscriber" ) ) b . append ( "java.lang.RuntimeException: ' an Subscriber'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( "An Subscriber" ) ) b . append ( "java.lang.RuntimeException: 'An Subscriber'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( " an Publisher" ) ) b . append ( "java.lang.RuntimeException: ' an Publisher'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( "An Publisher" ) ) b . append ( "java.lang.RuntimeException: 'An Publisher'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( " an Flowable" ) ) b . append ( "java.lang.RuntimeException: ' an Flowable'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( "An Flowable" ) ) b . append ( "java.lang.RuntimeException: 'An Flowable'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( " an Single" ) ) b . append ( "java.lang.RuntimeException: ' an Single'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( "An Single" ) ) b . append ( "java.lang.RuntimeException: 'An Single'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( " an Maybe" ) ) b . append ( "java.lang.RuntimeException: ' an Maybe'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( "An Maybe" ) ) b . append ( "java.lang.RuntimeException: 'An Maybe'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( " an Completable" ) ) b . append ( "java.lang.RuntimeException: ' an Completable'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( "An Completable" ) ) b . append ( "java.lang.RuntimeException: 'An Completable'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; if ( s . contains ( " an cancel" ) ) b . append ( "java.lang.RuntimeException: ' an cancel'\r\n at io.reactivex." ) . append ( className ) . append ( " (" ) . append ( fileName ) . append ( ":" ) . append ( i ) . append ( ")\r\n" ) ; ; i ++ ; 
StringBuilder b = new StringBuilder ( ) ; for ( Method m : clazz . getMethods ( ) ) if ( m . getDeclaringClass ( ) == clazz ) boolean isSubscribeMethod = "subscribe" . equals ( m . getName ( ) ) && ( m . getParameterTypes ( ) . length == 0 || m . getParameterTypes ( ) [ m . getParameterCount ( ) - 1 ] == DisposableContainer . class ) ; boolean isConnectMethod = "connect" . equals ( m . getName ( ) ) && m . getParameterTypes ( ) . length == 0 ; boolean isAnnotationPresent = m . isAnnotationPresent ( CheckReturnValue . class ) ; if ( isSubscribeMethod || isConnectMethod ) if ( isAnnotationPresent ) b . append ( m . getName ( ) ) . append ( " method has @CheckReturnValue: " ) . append ( m ) . append ( "\r\n" ) ; continue ; if ( Modifier . isPrivate ( m . getModifiers ( ) ) && isAnnotationPresent ) b . append ( "Private method has @CheckReturnValue: " ) . append ( m ) . append ( "\r\n" ) ; continue ; if ( m . getReturnType ( ) . equals ( Void . TYPE ) ) if ( isAnnotationPresent ) b . append ( "Void method has @CheckReturnValue: " ) . append ( m ) . append ( "\r\n" ) ; continue ; if ( ! isAnnotationPresent ) b . append ( "Missing @CheckReturnValue: " ) . append ( m ) . append ( "\r\n" ) ; if ( b . length ( ) != 0 ) System . out . println ( clazz ) ; System . out . println ( "------------------------" ) ; System . out . println ( b ) ; fail ( b . toString ( ) ) ; 
StringBuilder b = new StringBuilder ( ) ; for ( Method m : clazz . getMethods ( ) ) if ( m . getName ( ) . equals ( "bufferSize" ) || m . getName ( ) . equals ( "parallelism" ) ) continue ; if ( m . getDeclaringClass ( ) == clazz ) if ( ! m . isAnnotationPresent ( SchedulerSupport . class ) ) b . append ( "Missing @SchedulerSupport: " ) . append ( m ) . append ( "\r\n" ) ; else SchedulerSupport ann = m . getAnnotation ( SchedulerSupport . class ) ; if ( ann . value ( ) . equals ( SchedulerSupport . CUSTOM ) ) boolean found = false ; for ( Class < ? > paramclazz : m . getParameterTypes ( ) ) if ( Scheduler . class . isAssignableFrom ( paramclazz ) ) found = true ; break ; if ( ! found ) b . append ( "Marked with CUSTOM scheduler but no Scheduler parameter: " ) . append ( m ) . append ( "\r\n" ) ; else for ( Class < ? > paramclazz : m . getParameterTypes ( ) ) if ( Scheduler . class . isAssignableFrom ( paramclazz ) ) if ( ! m . getName ( ) . equals ( "timestamp" ) && ! m . getName ( ) . equals ( "timeInterval" ) ) b . append ( "Marked with specific scheduler but Scheduler parameter found: " ) . append ( m ) . append ( "\r\n" ) ; break ; if ( b . length ( ) != 0 ) System . out . println ( clazz ) ; System . out . println ( "------------------------" ) ; System . out . println ( b ) ; fail ( b . toString ( ) ) ; 
StringBuilder b = new StringBuilder ( ) ; for ( Method m : clazz . getMethods ( ) ) if ( m . getName ( ) . equals ( "bufferSize" ) || m . getName ( ) . equals ( "parallelism" ) ) continue ; if ( m . getDeclaringClass ( ) == clazz ) if ( clazz == Flowable . class || clazz == ParallelFlowable . class ) if ( ! m . isAnnotationPresent ( BackpressureSupport . class ) ) b . append ( "No @BackpressureSupport annotation (being " ) . append ( clazz . getSimpleName ( ) ) . append ( "): " ) . append ( m ) . append ( "\r\n" ) ; else if ( m . getReturnType ( ) == Flowable . class || m . getReturnType ( ) == ParallelFlowable . class ) if ( ! m . isAnnotationPresent ( BackpressureSupport . class ) ) b . append ( "No @BackpressureSupport annotation (having " ) . append ( m . getReturnType ( ) . getSimpleName ( ) ) . append ( " return): " ) . append ( m ) . append ( "\r\n" ) ; else boolean found = false ; for ( Class < ? > paramclazz : m . getParameterTypes ( ) ) if ( Publisher . class . isAssignableFrom ( paramclazz ) ) found = true ; break ; if ( found ) if ( ! m . isAnnotationPresent ( BackpressureSupport . class ) ) b . append ( "No @BackpressureSupport annotation (has Publisher param): " ) . append ( m ) . append ( "\r\n" ) ; else if ( m . isAnnotationPresent ( BackpressureSupport . class ) ) b . append ( "Unnecessary @BackpressureSupport annotation: " ) . append ( m ) . append ( "\r\n" ) ; if ( b . length ( ) != 0 ) System . out . println ( clazz ) ; System . out . println ( "------------------------" ) ; System . out . println ( b ) ; fail ( b . toString ( ) ) ; 
checkCheckReturnValueSupport ( Flowable . class ) ; 
checkCheckReturnValueSupport ( Observable . class ) ; 
checkCheckReturnValueSupport ( Single . class ) ; 
checkCheckReturnValueSupport ( Completable . class ) ; 
checkCheckReturnValueSupport ( Maybe . class ) ; 
checkCheckReturnValueSupport ( ConnectableObservable . class ) ; 
checkCheckReturnValueSupport ( ConnectableFlowable . class ) ; 
checkCheckReturnValueSupport ( ParallelFlowable . class ) ; 
checkCheckReturnValueSupport ( AsyncSubject . class ) ; 
checkCheckReturnValueSupport ( BehaviorSubject . class ) ; 
checkCheckReturnValueSupport ( PublishSubject . class ) ; 
checkCheckReturnValueSupport ( ReplaySubject . class ) ; 
checkCheckReturnValueSupport ( UnicastSubject . class ) ; 
checkCheckReturnValueSupport ( AsyncProcessor . class ) ; 
checkCheckReturnValueSupport ( BehaviorProcessor . class ) ; 
checkCheckReturnValueSupport ( PublishProcessor . class ) ; 
checkCheckReturnValueSupport ( ReplayProcessor . class ) ; 
checkCheckReturnValueSupport ( UnicastProcessor . class ) ; 
checkCheckReturnValueSupport ( MulticastProcessor . class ) ; 
checkCheckReturnValueSupport ( Subject . class ) ; 
checkCheckReturnValueSupport ( FlowableProcessor . class ) ; 
checkSchedulerSupport ( Flowable . class ) ; 
checkSchedulerSupport ( Observable . class ) ; 
checkSchedulerSupport ( Single . class ) ; 
checkSchedulerSupport ( Completable . class ) ; 
checkSchedulerSupport ( Maybe . class ) ; 
checkSchedulerSupport ( ConnectableObservable . class ) ; 
checkSchedulerSupport ( ConnectableFlowable . class ) ; 
checkSchedulerSupport ( ParallelFlowable . class ) ; 
checkBackpressureSupport ( Flowable . class ) ; 
checkBackpressureSupport ( Observable . class ) ; 
checkBackpressureSupport ( Single . class ) ; 
checkBackpressureSupport ( Completable . class ) ; 
checkBackpressureSupport ( Maybe . class ) ; 
checkBackpressureSupport ( ConnectableFlowable . class ) ; 
checkBackpressureSupport ( ConnectableObservable . class ) ; 
checkBackpressureSupport ( ParallelFlowable . class ) ; 
URL u = NoAnonymousInnerClassesTest . class . getResource ( "/" ) ; File f = new File ( u . toURI ( ) ) ; String fs = f . toString ( ) . toLowerCase ( ) . replace ( "\\" , "/" ) ; System . out . println ( "Found " + fs ) ; int idx = fs . indexOf ( "/test" ) ; if ( idx >= 0 ) f = new File ( fs . substring ( 0 , idx ) ) ; StringBuilder b = new StringBuilder ( "Anonymous inner classes found:" ) ; Queue < File > queue = new ArrayDeque < > ( ) ; queue . offer ( f ) ; String prefix = f . getAbsolutePath ( ) ; int count = 0 ; while ( ! queue . isEmpty ( ) ) f = queue . poll ( ) ; if ( f . isDirectory ( ) ) File [ ] dir = f . listFiles ( ) ; if ( dir != null && dir . length != 0 ) for ( File g : dir ) queue . offer ( g ) ; else String name = f . getName ( ) ; if ( name . endsWith ( ".class" ) && name . contains ( "$" ) && ! name . contains ( "Perf" ) && ! name . contains ( "Test" ) && ! name . startsWith ( "Test" ) ) String baseName = name . substring ( 0 , name . length ( ) - 6 ) ; String [ ] parts = name . split ( "\\$" ) ; for ( String s : parts ) if ( Character . isDigit ( s . charAt ( 0 ) ) ) String n = f . getAbsolutePath ( ) . substring ( prefix . length ( ) ) . replace ( '\\' , '.' ) . replace ( '/' , '.' ) ; if ( n . startsWith ( "." ) ) n = n . substring ( 1 ) ; boolean found = false ; FileInputStream fin = new FileInputStream ( f ) ; try byte [ ] data = new byte [ fin . available ( ) ] ; fin . read ( data ) ; String content = new String ( data , "ISO-8859-1" ) ; if ( content . contains ( "$SwitchMap$" ) ) File [ ] filesInTheSameDir = f . getParentFile ( ) . listFiles ( ) ; for ( File fsame : filesInTheSameDir ) String fsameName = fsame . getName ( ) ; if ( fsameName . endsWith ( ".class" ) ) fsameName = fsameName . substring ( 0 , fsameName . length ( ) - 6 ) ; if ( fsameName . startsWith ( baseName ) && fsameName . length ( ) > baseName . length ( ) + 1 && fsameName . charAt ( baseName . length ( ) ) == '$' && Character . isDigit ( fsameName . charAt ( baseName . length ( ) + 1 ) ) ) found = true ; break ; else found = true ; finally fin . close ( ) ; if ( found ) b . append ( "\r\n" ) . append ( n ) ; count ++ ; break ; if ( count != 0 ) throw new AssertionError ( b . toString ( ) ) ; 
checkClass ( Flowable . class ) ; 
checkClass ( Observable . class ) ; 
checkClass ( Maybe . class ) ; 
checkClass ( Single . class ) ; 
checkClass ( Completable . class ) ; 
checkClass ( ParallelFlowable . class ) ; 
StringBuilder error = new StringBuilder ( ) ; int errors = 0 ; for ( Method method : clazz . getMethods ( ) ) if ( method . getDeclaringClass ( ) == clazz ) int pidx = 1 ; for ( Parameter param : method . getParameters ( ) ) Class < ? > type = param . getType ( ) ; if ( type . isArray ( ) ) type = type . getComponentType ( ) ; if ( CLASSES . contains ( type ) ) errors ++ ; error . append ( "Non-interface input parameter #" ) . append ( pidx ) . append ( ": " ) . append ( type ) . append ( "\r\n" ) . append ( "    " ) . append ( method ) . append ( "\r\n" ) ; if ( CAN_RETURN . contains ( type ) ) Type gtype = method . getGenericParameterTypes ( ) [ pidx - 1 ] ; if ( gtype instanceof GenericArrayType ) gtype = ( ( GenericArrayType ) gtype ) . getGenericComponentType ( ) ; ParameterizedType ptype = ( ParameterizedType ) gtype ; for ( ; ; ) Type [ ] parameterArgTypes = ptype . getActualTypeArguments ( ) ; Type argType = parameterArgTypes [ parameterArgTypes . length - 1 ] ; if ( argType instanceof GenericArrayType ) argType = ( ( GenericArrayType ) argType ) . getGenericComponentType ( ) ; if ( argType instanceof ParameterizedType ) ParameterizedType lastArg = ( ParameterizedType ) argType ; if ( CLASSES . contains ( lastArg . getRawType ( ) ) ) errors ++ ; error . append ( "Non-interface lambda return #" ) . append ( pidx ) . append ( ": " ) . append ( type ) . append ( "\r\n" ) . append ( "    " ) . append ( method ) . append ( "\r\n" ) ; if ( CAN_RETURN . contains ( lastArg . getRawType ( ) ) ) ptype = lastArg ; continue ; break ; pidx ++ ; if ( errors != 0 ) error . insert ( 0 , "Found " + errors + " issues\r\n" ) ; fail ( error . toString ( ) ) ; 
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
try checkClass ( OperatorsUseInterfaces . class ) ; throw new RuntimeException ( "Should have failed" ) ; catch ( AssertionError expected ) assertTrue ( expected . toString ( ) , expected . toString ( ) . contains ( "method1" ) ) ; assertTrue ( expected . toString ( ) , expected . toString ( ) . contains ( "method2" ) ) ; assertTrue ( expected . toString ( ) , expected . toString ( ) . contains ( "method3" ) ) ; assertTrue ( expected . toString ( ) , expected . toString ( ) . contains ( "method4" ) ) ; assertTrue ( expected . toString ( ) , expected . toString ( ) . contains ( "method5" ) ) ; assertTrue ( expected . toString ( ) , expected . toString ( ) . contains ( "method6" ) ) ; 
File f = TestHelper . findSource ( "Flowable" ) ; if ( f == null ) System . out . println ( "Unable to find sources of RxJava" ) ; return ; Queue < File > dirs = new ArrayDeque < > ( ) ; StringBuilder fail = new StringBuilder ( ) ; int errors = 0 ; File parent = f . getParentFile ( ) . getParentFile ( ) ; dirs . offer ( new File ( parent . getAbsolutePath ( ) . replace ( '\\' , '/' ) ) ) ; while ( ! dirs . isEmpty ( ) ) f = dirs . poll ( ) ; File [ ] list = f . listFiles ( ) ; if ( list != null && list . length != 0 ) for ( File u : list ) if ( u . isDirectory ( ) ) dirs . offer ( u ) ; else List < String > lines = Files . readAllLines ( u . toPath ( ) ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) String line = lines . get ( i ) . trim ( ) ; if ( line . startsWith ( "} catch (Throwable " ) ) String next = lines . get ( i + 1 ) . trim ( ) ; boolean throwIfFatal = next . contains ( "Exceptions.throwIfFatal" ) ; boolean wrapOrThrow = next . contains ( "ExceptionHelper.wrapOrThrow" ) ; boolean failCall = next . startsWith ( "fail(" ) ; if ( ! ( throwIfFatal || wrapOrThrow || failCall ) ) errors ++ ; fail . append ( "Missing Exceptions.throwIfFatal\n    " ) . append ( next ) . append ( "\n at " ) . append ( u . getName ( ) . replace ( ".java" , "" ) ) . append ( ".method(" ) . append ( u . getName ( ) ) . append ( ":" ) . append ( i + 1 ) . append ( ")\n" ) ; if ( errors != 0 ) fail . insert ( 0 , "Found " + errors + " cases\n" ) ; System . out . println ( fail ) ; throw new AssertionError ( fail . toString ( ) ) ; 
processFile ( Completable . class ) ; 
processFile ( Single . class ) ; 
processFile ( Maybe . class ) ; 
processFile ( Observable . class ) ; 
processFile ( Flowable . class ) ; 
processFile ( ParallelFlowable . class ) ; 
processFile ( ConnectableObservable . class ) ; 
processFile ( ConnectableFlowable . class ) ; 
processFile ( Subject . class ) ; 
processFile ( FlowableProcessor . class ) ; 
processFile ( Disposable . class ) ; 
processFile ( Scheduler . class ) ; 
processFile ( Schedulers . class ) ; 
processFile ( AsyncSubject . class ) ; 
processFile ( BehaviorSubject . class ) ; 
processFile ( PublishSubject . class ) ; 
processFile ( ReplaySubject . class ) ; 
processFile ( UnicastSubject . class ) ; 
processFile ( SingleSubject . class ) ; 
processFile ( MaybeSubject . class ) ; 
processFile ( CompletableSubject . class ) ; 
processFile ( AsyncProcessor . class ) ; 
processFile ( BehaviorProcessor . class ) ; 
processFile ( PublishProcessor . class ) ; 
processFile ( ReplayProcessor . class ) ; 
processFile ( UnicastProcessor . class ) ; 
processFile ( MulticastProcessor . class ) ; 
processFile ( CompositeDisposable . class ) ; 
String baseClassName = clazz . getSimpleName ( ) ; File f = TestHelper . findSource ( baseClassName , clazz . getPackage ( ) . getName ( ) ) ; if ( f == null ) return ; String fullClassName = clazz . getName ( ) ; int errorCount = 0 ; StringBuilder errors = new StringBuilder ( ) ; List < String > lines = Files . readAllLines ( f . toPath ( ) ) ; for ( int j = 0 ; j < lines . size ( ) ; j ++ ) String line = lines . get ( j ) . trim ( ) ; for ( ValidatorStrings validatorStr : VALIDATOR_STRINGS ) int strIdx = line . indexOf ( validatorStr . code ) ; if ( strIdx >= 0 ) int comma = line . indexOf ( ',' , strIdx + validatorStr . code . length ( ) ) ; String paramName = line . substring ( strIdx + validatorStr . code . length ( ) , comma ) ; int quote = line . indexOf ( '"' , comma ) ; String message = line . substring ( quote + 1 , Math . min ( line . length ( ) , quote + 2 + paramName . length ( ) ) ) ; if ( line . contains ( "\"A Disposable" ) ) continue ; if ( ! line . contains ( "\"The RxJavaPlugins" ) && ! ( message . startsWith ( paramName ) && ( message . endsWith ( " " ) || message . endsWith ( "\"" ) ) ) ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : Wrong validator message parameter name\r\n    " ) . append ( line ) . append ( "\r\n" ) . append ( "    " ) . append ( paramName ) . append ( " != " ) . append ( message ) . append ( "\r\n at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; int midx = j - 1 ; for ( ; midx >= 0 ; midx -- ) String linek = lines . get ( midx ) . trim ( ) ; if ( linek . startsWith ( "public" ) || linek . startsWith ( "private" ) || linek . startsWith ( "protected" ) || linek . startsWith ( "static" ) || linek . startsWith ( baseClassName ) ) break ; if ( line . contains ( "\"The RxJavaPlugins" ) ) continue ; boolean found = false ; for ( int k = midx - 1 ; k >= 0 ; k -- ) String linek = lines . get ( k ) . trim ( ) ; if ( linek . startsWith ( "/**" ) ) break ; if ( linek . startsWith ( "}" ) ) found = true ; break ; if ( linek . startsWith ( validatorStr . javadoc ) ) String paramStr = "{@code " + paramName + "}" ; for ( int m = k ; m < lines . size ( ) ; m ++ ) String linem = lines . get ( m ) . trim ( ) ; if ( linem . startsWith ( "* @see" ) || linem . startsWith ( "* @since" ) || linem . startsWith ( "*/" ) ) break ; if ( linem . contains ( paramStr ) ) found = true ; break ; break ; if ( ! found ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : missing '" ) . append ( validatorStr . javadoc ) . append ( "' for argument validation: " ) . append ( paramName ) . append ( "\r\n    " ) . append ( line ) . append ( "\r\n at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; for ( ValidatorStrings validatorStr : EXCEPTION_STRINGS ) int strIdx = line . indexOf ( validatorStr . code ) ; if ( strIdx >= 0 ) int midx = j - 1 ; for ( ; midx >= 0 ; midx -- ) String linek = lines . get ( midx ) . trim ( ) ; if ( linek . startsWith ( "public" ) || linek . startsWith ( "private" ) || linek . startsWith ( "protected" ) || linek . startsWith ( "static" ) || linek . startsWith ( baseClassName ) ) break ; boolean found = false ; for ( int k = midx - 1 ; k >= 0 ; k -- ) String linek = lines . get ( k ) . trim ( ) ; if ( linek . startsWith ( "/**" ) ) break ; if ( linek . startsWith ( "}" ) ) found = true ; break ; if ( linek . startsWith ( validatorStr . javadoc ) ) found = true ; if ( ! found ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : missing '" ) . append ( validatorStr . javadoc ) . append ( "' for exception\r\n    " ) . append ( line ) . append ( "\r\n at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; if ( line . startsWith ( "public" ) || line . startsWith ( "protected" ) || line . startsWith ( "final" ) || line . startsWith ( "private" ) || line . startsWith ( "static" ) ) for ( ValidatorStrings validatorStr : TYPICAL_ARGUMENT_STRINGS ) for ( int i = j ; i < lines . size ( ) ; i ++ ) String linei = lines . get ( i ) . trim ( ) ; String varPattern = " " + validatorStr . code ; if ( linei . contains ( varPattern + ")" ) || linei . contains ( varPattern + "," ) || linei . endsWith ( varPattern ) ) if ( ! linei . matches ( ".*\\@Nullable\\s.*" + validatorStr . code + ".*" ) ) boolean found = false ; for ( int k = i - 1 ; k >= 0 ; k -- ) String linek = lines . get ( k ) . trim ( ) ; if ( linek . startsWith ( "/**" ) ) break ; if ( linek . startsWith ( "}" ) ) found = true ; break ; if ( linek . startsWith ( validatorStr . javadoc ) ) String paramStr = "{@code " + validatorStr . code + "}" ; for ( int m = k ; m < lines . size ( ) ; m ++ ) String linem = lines . get ( m ) . trim ( ) ; if ( linem . startsWith ( "* @see" ) || linem . startsWith ( "* @since" ) || linem . startsWith ( "*/" ) ) break ; if ( linem . contains ( paramStr ) ) found = true ; break ; break ; if ( ! found ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : missing '" ) . append ( validatorStr . javadoc ) . append ( "' for typical argument: " ) . append ( validatorStr . code ) . append ( "\r\n    " ) . append ( line ) . append ( "\r\n at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; if ( linei . endsWith ( "{" ) || linei . endsWith ( ";" ) ) break ; if ( errorCount != 0 ) errors . insert ( 0 , errorCount + " problems\r\n" ) ; errors . setLength ( errors . length ( ) - 2 ) ; throw new AssertionError ( errors . toString ( ) ) ; 
checkClass ( Flowable . class ) ; 
checkClass ( Observable . class ) ; 
checkClass ( Single . class ) ; 
checkClass ( Maybe . class ) ; 
checkClass ( Completable . class ) ; 
checkClass ( ParallelFlowable . class ) ; 
return upstream ; 
return upstream ; 
return upstream ; 
return upstream ; 
return upstream ; 
return upstream ; 
List < Object > list = defaultInstances . get ( clazz ) ; if ( list == null ) list = new ArrayList < > ( ) ; defaultInstances . put ( clazz , list ) ; list . add ( o ) ; list . add ( tag ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try StringBuilder b = new StringBuilder ( ) ; int fail = 0 ; outer : for ( Method m : clazz . getMethods ( ) ) if ( m . getDeclaringClass ( ) != clazz ) continue ; String key = clazz . getName ( ) + " " + m . getName ( ) ; List < ParamIgnore > ignoreList = ignores . get ( key ) ; if ( ignoreList != null ) for ( ParamIgnore e : ignoreList ) if ( Arrays . equals ( e . arguments , m . getParameterTypes ( ) ) ) System . out . println ( "CheckClass - ignore: " + m ) ; continue outer ; List < ParamOverride > overrideList = overrides . get ( key ) ; List < Object > baseObjects = new ArrayList < > ( ) ; if ( ( m . getModifiers ( ) & Modifier . STATIC ) != 0 ) baseObjects . add ( null ) ; baseObjects . add ( "NULL" ) ; else List < Object > defaultInstancesList = defaultInstances . get ( clazz ) ; if ( defaultInstancesList == null ) b . append ( "\r\nNo default instances for " + clazz ) ; fail ++ ; continue outer ; baseObjects . addAll ( defaultInstancesList ) ; for ( int ii = 0 ; ii < baseObjects . size ( ) ; ii += 2 ) Object baseObject = baseObjects . get ( ii ) ; Object tag = baseObjects . get ( ii + 1 ) ; Class < ? > [ ] params = m . getParameterTypes ( ) ; int n = params . length ; for ( int i = 0 ; i < n ; i ++ ) ParamOverride overrideEntry = null ; if ( overrideList != null ) for ( ParamOverride e : overrideList ) if ( e . index == i && Arrays . equals ( e . arguments , params ) ) overrideEntry = e ; break ; Class < ? > entryClass = params [ i ] ; Object [ ] callParams = new Object [ n ] ; for ( int j = 0 ; j < n ; j ++ ) if ( j != i ) if ( params [ j ] . isPrimitive ( ) ) ParamOverride overrideParam = null ; if ( overrideList != null ) for ( ParamOverride e : overrideList ) if ( e . index == j && Arrays . equals ( e . arguments , params ) ) overrideParam = e ; break ; Object def = defaultPrimitive ( params [ j ] , overrideParam ) ; if ( def == null ) b . append ( "\r\nMissing default non-null value for " + m + " # " + j + " (" + params [ j ] + ")" ) ; fail ++ ; continue outer ; callParams [ j ] = def ; else Object def = defaultValues . get ( params [ j ] ) ; if ( def == null ) b . append ( "\r\nMissing default non-null value for " + m + " # " + j + " (" + params [ j ] + ")" ) ; fail ++ ; continue outer ; callParams [ j ] = def ; List < Object > entryValues = new ArrayList < > ( ) ; if ( entryClass . isPrimitive ( ) ) addCheckPrimitive ( params [ i ] , overrideEntry , entryValues ) ; else entryValues . add ( null ) ; entryValues . add ( overrideEntry != null && overrideEntry . mode == ParamMode . ANY ) ; Object def = defaultValues . get ( params [ i ] ) ; if ( def == null ) b . append ( "\r\nMissing default non-null value for " + m + " # " + i + " (" + params [ i ] + ")" ) ; fail ++ ; continue outer ; entryValues . add ( def ) ; entryValues . add ( true ) ; for ( int k = 0 ; k < entryValues . size ( ) ; k += 2 ) Object [ ] callParams2 = callParams . clone ( ) ; Object p = entryValues . get ( k ) ; callParams2 [ i ] = p ; boolean shouldSucceed = ( Boolean ) entryValues . get ( k + 1 ) ; boolean success = false ; Throwable error = null ; errors . clear ( ) ; try m . invoke ( baseObject , callParams2 ) ; success = true ; catch ( Throwable ex ) error = ex ; if ( ! success && error . getCause ( ) instanceof NullPointerException ) if ( ! error . getCause ( ) . toString ( ) . contains ( "is null" ) ) fail ++ ; b . append ( "\r\nNPEs should indicate which argument failed: " + m + " # " + i + " = " + p + ", tag = " + tag + ", params = " + Arrays . toString ( callParams2 ) ) ; if ( success != shouldSucceed ) fail ++ ; if ( shouldSucceed ) b . append ( "\r\nFailed (should have succeeded): " + m + " # " + i + " = " + p + ", tag = " + tag + ", params = " + Arrays . toString ( callParams2 ) ) ; b . append ( "\r\n    " ) . append ( error ) ; if ( error . getCause ( ) != null ) b . append ( "\r\n    " ) . append ( error . getCause ( ) ) ; else b . append ( "\r\nNo failure (should have failed): " + m + " # " + i + " = " + p + ", tag = " + tag + ", params = " + Arrays . toString ( callParams2 ) ) ; continue outer ; if ( ! errors . isEmpty ( ) ) fail ++ ; b . append ( "\r\nUndeliverable errors:" ) ; for ( Throwable err : errors ) b . append ( "\r\n    " ) . append ( err ) ; if ( err . getCause ( ) != null ) b . append ( "\r\n    " ) . append ( err . getCause ( ) ) ; continue outer ; if ( fail != 0 ) throw new AssertionError ( "Parameter validation problems: " + fail + b . toString ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
return null ; 
return null ; 
return null ; 
return null ; 
return null ; 
return null ; 
return null ; 
return null ; 
$EMPTY$
return null ; 
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
return false ; 
return false ; 
$EMPTY$
$EMPTY$
s . request ( Long . MAX_VALUE ) ; 
$EMPTY$
$EMPTY$
$EMPTY$
return upstream ; 
return upstream ; 
return upstream ; 
return upstream ; 
return upstream ; 
return observer ; 
return observer ; 
return observer ; 
return observer ; 
return observer ; 
return false ; 
return 0 ; 
return clazz . getName ( ) + " " + name ; 
return clazz . getName ( ) + " " + name ; 
$EMPTY$
return "NeverFlowable" ; 
$EMPTY$
return "NeverFlowable" ; 
$EMPTY$
return "NeverSingle" ; 
$EMPTY$
return "NeverMaybe" ; 
$EMPTY$
return "NeverCompletable" ; 
File base = TestHelper . findSource ( "Flowable" ) ; if ( base == null ) return ; base = base . getParentFile ( ) . getParentFile ( ) ; Queue < File [ ] > files = new ArrayDeque < > ( ) ; files . offer ( base . listFiles ( ) ) ; StringBuilder b = new StringBuilder ( ) ; int count = 0 ; while ( ! files . isEmpty ( ) ) for ( File file : files . poll ( ) ) if ( file . getName ( ) . endsWith ( ".java" ) ) String s = readFile ( file ) ; String fn = file . toString ( ) . substring ( base . toString ( ) . length ( ) ) ; fn = fn . replace ( "\\" , "." ) ; fn = fn . replace ( "//" , "." ) ; fn = fn . replace ( ".java" , "" ) ; fn = "io.reactivex" + fn ; int j = 0 ; for ( ; ; ) int idx = s . indexOf ( "<code>" , j ) ; if ( idx < 0 ) break ; int jdx = s . indexOf ( "</code>" , idx + 6 ) ; int k = idx + 6 ; for ( ; ; ) int kdx = s . indexOf ( '>' , k ) ; if ( kdx < 0 ) break ; if ( kdx < jdx ) b . append ( "at " ) . append ( fn ) . append ( ".gt(" ) . append ( file . getName ( ) ) . append ( ":" ) . append ( countLine ( s , kdx ) ) . append ( ")\r\n" ) ; count ++ ; else break ; k = kdx + 1 ; k = idx + 6 ; for ( ; ; ) int kdx = s . indexOf ( '<' , k ) ; if ( kdx < 0 ) break ; if ( kdx < jdx ) b . append ( "at " ) . append ( fn ) . append ( ".lt(" ) . append ( file . getName ( ) ) . append ( ":" ) . append ( countLine ( s , kdx ) ) . append ( ")\r\n" ) ; count ++ ; else break ; k = kdx + 1 ; j = jdx + 7 ; if ( b . length ( ) > 0 ) System . err . println ( "Should escape < and > in <code> blocks! " + count ) ; System . err . println ( b ) ; throw new Exception ( "Should escape < and > in <code> blocks! " + count + "\r\n" + b ) ; 
StringBuilder b = new StringBuilder ( ( int ) f . length ( ) ) ; BufferedReader in = new BufferedReader ( new FileReader ( f ) ) ; try String line = null ; while ( ( line = in . readLine ( ) ) != null ) b . append ( line ) . append ( "\n" ) ; finally in . close ( ) ; return b . toString ( ) ; 
findPattern ( 0 ) ; 
findPattern ( 2 ) ; 
findPattern ( 3 ) ; 
findPattern ( 4 ) ; 
findPattern ( 5 ) ; 
StringBuilder b = new StringBuilder ( ) ; BufferedReader in = new BufferedReader ( new FileReader ( f ) ) ; try for ( ; ; ) String line = in . readLine ( ) ; if ( line == null ) break ; b . append ( line ) . append ( '\n' ) ; finally in . close ( ) ; return b ; 
int index = 0 ; for ( ; ; ) int idx = sourceCode . indexOf ( annotation , index ) ; if ( idx < 0 ) break ; int j = sourceCode . lastIndexOf ( "/**" , idx ) ; if ( j > index ) int k = sourceCode . indexOf ( inDoc , j ) ; if ( k < 0 || k > idx ) e . append ( "java.lang.RuntimeException: missing " ) . append ( inDoc ) . append ( " section\r\n" ) ; int lc = lineNumber ( sourceCode , idx ) ; e . append ( " at io.reactivex.rxjava3.core." ) . append ( baseClassName ) . append ( " (" ) . append ( baseClassName ) . append ( ".java:" ) . append ( lc ) . append ( ")" ) . append ( "\r\n\r\n" ) ; index = idx + annotation . length ( ) ; 
int index = 0 ; for ( ; ; ) int idx = sourceCode . indexOf ( annotation , index ) ; if ( idx < 0 ) break ; int j = sourceCode . lastIndexOf ( "/**" , idx ) ; if ( j > index ) int k = sourceCode . indexOf ( inDoc , j ) ; if ( k >= 0 && k <= idx ) int ll = sourceCode . indexOf ( "You specify" , k ) ; if ( ll < 0 ) ll = sourceCode . indexOf ( "you specify" , k ) ; int lm = sourceCode . indexOf ( "This operator" , k ) ; if ( lm < 0 ) lm = sourceCode . indexOf ( "this operator" , k ) ; if ( ( ll < 0 || ll > idx ) && ( lm < 0 || lm > idx ) ) int n = sourceCode . indexOf ( "{@code " , k ) ; int endDD = sourceCode . indexOf ( "</dd>" , k ) ; if ( n < idx && n < endDD ) int m = sourceCode . indexOf ( "}" , n ) ; if ( m < idx ) String mname = sourceCode . substring ( n + 7 , m ) ; if ( ! "Scheduler" . equals ( mname ) ) int q = sourceCode . indexOf ( "@SuppressWarnings({" , idx ) ; int o = sourceCode . indexOf ( "{" , idx ) ; if ( q + 18 == o ) o = sourceCode . indexOf ( "{" , q + 20 ) ; if ( o >= 0 ) int p = sourceCode . indexOf ( " " + mname + "(" , idx ) ; if ( p < 0 || p > o ) e . append ( "java.lang.RuntimeException: wrong method name in description of " ) . append ( inDoc ) . append ( " '" ) . append ( mname ) . append ( "'\r\n" ) ; int lc = lineNumber ( sourceCode , idx ) ; e . append ( " at io.reactivex.rxjava3.core." ) . append ( baseClassName ) . append ( ".method(" ) . append ( baseClassName ) . append ( ".java:" ) . append ( lc ) . append ( ")" ) . append ( "\r\n" ) ; index = idx + annotation . length ( ) ; 
checkSource ( Flowable . class . getSimpleName ( ) , false ) ; 
checkSource ( Flowable . class . getSimpleName ( ) , true ) ; 
checkSource ( Observable . class . getSimpleName ( ) , false ) ; 
checkSource ( Observable . class . getSimpleName ( ) , true ) ; 
checkSource ( Single . class . getSimpleName ( ) , false ) ; 
checkSource ( Single . class . getSimpleName ( ) , true ) ; 
checkSource ( Completable . class . getSimpleName ( ) , false ) ; 
checkSource ( Completable . class . getSimpleName ( ) , true ) ; 
checkSource ( Maybe . class . getSimpleName ( ) , false ) ; 
checkSource ( Maybe . class . getSimpleName ( ) , true ) ; 
checkSchedulerBadMethod ( Flowable . class . getSimpleName ( ) ) ; 
checkSchedulerBadMethod ( Observable . class . getSimpleName ( ) ) ; 
checkSchedulerBadMethod ( Single . class . getSimpleName ( ) ) ; 
checkSchedulerBadMethod ( Completable . class . getSimpleName ( ) ) ; 
checkSchedulerBadMethod ( Maybe . class . getSimpleName ( ) ) ; 
String className = clazz . getSimpleName ( ) ; String parentPackage = clazz . getPackage ( ) . getName ( ) ; StringBuilder result = new StringBuilder ( ) ; int count = 0 ; try File f = TestHelper . findSource ( className , parentPackage ) ; try ( BufferedReader in = Files . newBufferedReader ( f . toPath ( ) ) ) int lineCount = 1 ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) line = line . trim ( ) ; if ( ! line . contains ( " to(" ) ) if ( line . startsWith ( "public static <" ) || line . startsWith ( "public final <" ) ) for ( String ta : parseTypeArguments ( line ) ) if ( ! ta . startsWith ( "@NonNull" ) && ! ta . startsWith ( "@Nullable" ) ) result . append ( "Missing annotation on argument " ) . append ( ta ) . append ( "\r\nat " ) . append ( parentPackage ) . append ( "." ) . append ( className ) . append ( ".method(" ) . append ( className ) . append ( ".java:" ) . append ( lineCount ) . append ( ")\r\n" ) ; count ++ ; lineCount ++ ; catch ( Exception ex ) throw new RuntimeException ( ex ) ; if ( count != 0 ) throw new IllegalArgumentException ( "Found " + count + " cases\r\n" + result . toString ( ) ) ; 
List < String > result = new ArrayList < > ( ) ; int offset = line . indexOf ( "<" ) ; int c = 1 ; int i = offset + 1 ; int j = i ; for ( ; i < line . length ( ) ; i ++ ) if ( line . charAt ( i ) == '<' ) c ++ ; else if ( line . charAt ( i ) == '>' ) c -- ; if ( c == 0 ) break ; else if ( line . charAt ( i ) == ',' && c == 1 ) result . add ( line . substring ( j , i ) . trim ( ) ) ; j = i + 1 ; result . add ( line . substring ( j , i ) . trim ( ) ) ; return result ; 
assertEquals ( new ArrayList < > ( Arrays . asList ( "T" ) ) , parseTypeArguments ( "<T>" ) ) ; assertEquals ( new ArrayList < > ( Arrays . asList ( "T" , "U" ) ) , parseTypeArguments ( "<T, U>" ) ) ; assertEquals ( new ArrayList < > ( Arrays . asList ( "T" , "Flowable<U>" ) ) , parseTypeArguments ( "<T, Flowable<U>>" ) ) ; assertEquals ( new ArrayList < > ( Arrays . asList ( "T" , "Flowable<U, V>" ) ) , parseTypeArguments ( "<T, Flowable<U, V>>" ) ) ; 
process ( Flowable . class ) ; 
process ( Observable . class ) ; 
process ( Maybe . class ) ; 
process ( Single . class ) ; 
process ( Completable . class ) ; 
process ( ParallelFlowable . class ) ; 
process ( RxJavaPlugins . class ) ; 
processFile ( Completable . class ) ; 
processFile ( Single . class ) ; 
processFile ( Maybe . class ) ; 
processFile ( Observable . class ) ; 
processFile ( Flowable . class ) ; 
processFile ( ParallelFlowable . class ) ; 
processFile ( ConnectableObservable . class ) ; 
processFile ( ConnectableFlowable . class ) ; 
processFile ( Subject . class ) ; 
processFile ( FlowableProcessor . class ) ; 
processFile ( Disposable . class ) ; 
processFile ( Scheduler . class ) ; 
processFile ( Schedulers . class ) ; 
processFile ( AsyncSubject . class ) ; 
processFile ( BehaviorSubject . class ) ; 
processFile ( PublishSubject . class ) ; 
processFile ( ReplaySubject . class ) ; 
processFile ( UnicastSubject . class ) ; 
processFile ( SingleSubject . class ) ; 
processFile ( MaybeSubject . class ) ; 
processFile ( CompletableSubject . class ) ; 
processFile ( AsyncProcessor . class ) ; 
processFile ( BehaviorProcessor . class ) ; 
processFile ( PublishProcessor . class ) ; 
processFile ( ReplayProcessor . class ) ; 
processFile ( UnicastProcessor . class ) ; 
processFile ( MulticastProcessor . class ) ; 
processFile ( RxJavaPlugins . class ) ; 
String baseClassName = clazz . getSimpleName ( ) ; File f = TestHelper . findSource ( baseClassName , clazz . getPackage ( ) . getName ( ) ) ; if ( f == null ) return ; String fullClassName = clazz . getName ( ) ; int errorCount = 0 ; StringBuilder errors = new StringBuilder ( ) ; List < String > lines = Files . readAllLines ( f . toPath ( ) ) ; for ( int j = 0 ; j < lines . size ( ) ; j ++ ) String line = lines . get ( j ) . trim ( ) ; if ( line . contains ( "class" ) ) continue ; if ( line . startsWith ( "public static" ) || line . startsWith ( "public final" ) || line . startsWith ( "protected final" ) || line . startsWith ( "protected abstract" ) || line . startsWith ( "public abstract" ) ) int methodArgStart = line . indexOf ( "(" ) ; int isBoolean = line . indexOf ( " boolean " ) ; int isInt = line . indexOf ( " int " ) ; int isLong = line . indexOf ( " long " ) ; int isVoid = line . indexOf ( " void " ) ; int isElementType = line . indexOf ( " R " ) ; boolean hasSafeVarargsAnnotation = false ; if ( ! ( ( isBoolean > 0 && isBoolean < methodArgStart ) || ( isInt > 0 && isInt < methodArgStart ) || ( isLong > 0 && isLong < methodArgStart ) || ( isVoid > 0 && isVoid < methodArgStart ) || ( isElementType > 0 && isElementType < methodArgStart ) ) ) boolean annotationFound = false ; for ( int k = j - 1 ; k >= 0 ; k -- ) String prevLine = lines . get ( k ) . trim ( ) ; if ( prevLine . startsWith ( "}" ) || prevLine . startsWith ( "*/" ) ) break ; if ( prevLine . startsWith ( "@NonNull" ) || prevLine . startsWith ( "@Nullable" ) ) annotationFound = true ; if ( prevLine . startsWith ( "@SafeVarargs" ) ) hasSafeVarargsAnnotation = true ; if ( ! annotationFound ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : Missing return type nullability annotation | " ) . append ( line ) . append ( "\r\n" ) . append ( " at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; StringBuilder arguments = new StringBuilder ( ) ; int methodArgEnd = line . indexOf ( ")" , methodArgStart ) ; if ( methodArgEnd > 0 ) arguments . append ( line . substring ( methodArgStart + 1 , methodArgEnd ) ) ; else arguments . append ( line . substring ( methodArgStart + 1 ) ) ; for ( int k = j + 1 ; k < lines . size ( ) ; k ++ ) String ln = lines . get ( k ) . trim ( ) ; int idx = ln . indexOf ( ")" ) ; if ( idx > 0 ) arguments . append ( ln . substring ( 0 , idx ) ) ; break ; arguments . append ( ln ) . append ( " " ) ; StringBuilder strippedArguments = new StringBuilder ( ) ; int skippingDepth = 0 ; for ( int k = 0 ; k < arguments . length ( ) ; k ++ ) char c = arguments . charAt ( k ) ; if ( c == '<' ) skippingDepth ++ ; else if ( c == '>' ) skippingDepth -- ; else if ( skippingDepth == 0 ) strippedArguments . append ( c ) ; String strippedArgumentsStr = strippedArguments . toString ( ) ; String [ ] args = strippedArgumentsStr . split ( "\\s*,\\s*" ) ; for ( int k = 0 ; k < args . length ; k ++ ) String typeDef = args [ k ] ; for ( String typeName : CLASS_NAMES ) String typeNameSpaced = typeName + " " ; if ( typeDef . contains ( typeNameSpaced ) && ! typeDef . contains ( "@NonNull" ) && ! typeDef . contains ( "@Nullable" ) ) if ( ! line . contains ( "@Nullable " + typeName ) && ! line . contains ( "@NonNull " + typeName ) ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " - argument " ) . append ( k + 1 ) . append ( " : Missing argument type nullability annotation\r\n    " ) . append ( typeDef ) . append ( "\r\n    " ) . append ( strippedArgumentsStr ) . append ( "\r\n" ) . append ( " at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; if ( typeDef . contains ( "final " ) ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " - argument " ) . append ( k + 1 ) . append ( " : unnecessary final on argument\r\n    " ) . append ( typeDef ) . append ( "\r\n    " ) . append ( strippedArgumentsStr ) . append ( "\r\n" ) . append ( " at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; if ( typeDef . contains ( "@NonNull int" ) || typeDef . contains ( "@NonNull long" ) || typeDef . contains ( "@Nullable int" ) || typeDef . contains ( "@Nullable long" ) ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " - argument " ) . append ( k + 1 ) . append ( " : unnecessary nullability annotation\r\n    " ) . append ( typeDef ) . append ( "\r\n    " ) . append ( strippedArgumentsStr ) . append ( "\r\n" ) . append ( " at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; if ( strippedArgumentsStr . contains ( "..." ) && ! hasSafeVarargsAnnotation ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : Missing @SafeVarargs annotation\r\n    " ) . append ( strippedArgumentsStr ) . append ( "\r\n" ) . append ( " at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; for ( String typeName : TYPES_REQUIRING_NONNULL_TYPEARG ) String pattern = typeName + "<?" ; String patternRegex = ".*" + typeName + "\\<\\? (extends|super) " + COMMON_TYPE_ARG_NAMES + "\\>.*" ; if ( line . contains ( pattern ) && ! line . matches ( patternRegex ) ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : Missing @NonNull type argument annotation on " ) . append ( typeName ) . append ( "\r\n" ) . append ( " at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; for ( String typeName : TYPES_FORBIDDEN_NONNULL_TYPEARG ) String patternRegex = ".*" + typeName + "\\<@NonNull (\\? (extends|super) )?" + COMMON_TYPE_ARG_NAMES + "\\>.*" ; if ( line . matches ( patternRegex ) ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : @NonNull type argument should be on the arg declaration " ) . append ( typeName ) . append ( "\r\n" ) . append ( " at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; for ( String typeName : TYPES_REQUIRING_NONNULL_TYPEARG_ON_FUNC ) if ( line . matches ( ".*Function[\\d]?\\<.*, (\\? (extends|super) )?" + typeName + ".*" ) ) errorCount ++ ; errors . append ( "L" ) . append ( j ) . append ( " : Missing @NonNull type argument annotation on Function argument " ) . append ( typeName ) . append ( "\r\n" ) . append ( " at " ) . append ( fullClassName ) . append ( ".method(" ) . append ( f . getName ( ) ) . append ( ":" ) . append ( j + 1 ) . append ( ")\r\n" ) ; if ( errorCount != 0 ) errors . insert ( 0 , errorCount + " problems\r\n" ) ; errors . setLength ( errors . length ( ) - 2 ) ; throw new AssertionError ( errors . toString ( ) ) ; 
File f = TestHelper . findSource ( "Flowable" ) ; if ( f == null ) System . out . println ( "Unable to find sources of RxJava" ) ; return ; Queue < File > dirs = new ArrayDeque < > ( ) ; StringBuilder fail = new StringBuilder ( ) ; fail . append ( "The following code pattern was found: " ) . append ( pattern ) . append ( "\n" ) ; fail . append ( "Refresh and re-run tests!\n\n" ) ; File parent = f . getParentFile ( ) . getParentFile ( ) ; dirs . offer ( new File ( parent . getAbsolutePath ( ) . replace ( '\\' , '/' ) ) ) ; dirs . offer ( new File ( parent . getAbsolutePath ( ) . replace ( '\\' , '/' ) . replace ( "src/main/java" , "src/test/java" ) ) ) ; Pattern p = Pattern . compile ( pattern ) ; int total = 0 ; while ( ! dirs . isEmpty ( ) ) f = dirs . poll ( ) ; File [ ] list = f . listFiles ( ) ; if ( list != null && list . length != 0 ) for ( File u : list ) if ( u . isDirectory ( ) ) dirs . offer ( u ) ; else String fname = u . getName ( ) ; if ( fname . endsWith ( ".java" ) ) int lineNum = 0 ; List < String > lines = new ArrayList < > ( ) ; BufferedReader in = new BufferedReader ( new FileReader ( u ) ) ; try for ( ; ; ) String line = in . readLine ( ) ; if ( line == null ) break ; lineNum ++ ; Matcher matcher = p . matcher ( line ) ; if ( ! line . startsWith ( "//" ) && ! line . startsWith ( "*" ) && matcher . find ( ) ) fail . append ( fname ) . append ( "#L" ) . append ( lineNum ) . append ( "    " ) . append ( line ) . append ( "\n" ) ; total ++ ; int methodNameStartIndex = matcher . end ( ) - 1 ; char firstChar = Character . toLowerCase ( line . charAt ( methodNameStartIndex ) ) ; String newLine = matcher . replaceAll ( replacement + firstChar ) ; lines . add ( newLine ) ; else lines . add ( line ) ; finally in . close ( ) ; if ( total != 0 ) fail . append ( "Found " ) . append ( total ) . append ( " instances" ) ; System . out . println ( fail ) ; throw new AssertionError ( fail . toString ( ) ) ; 
File f = TestHelper . findSource ( Maybe . class . getSimpleName ( ) ) ; String line ; StringBuilder b = new StringBuilder ( ) ; boolean classDefPassed = false ; BufferedReader in = new BufferedReader ( new FileReader ( f ) ) ; try int ln = 1 ; while ( true ) line = in . readLine ( ) ; if ( line == null ) break ; if ( line . startsWith ( "public abstract class Maybe<" ) ) classDefPassed = true ; if ( classDefPassed ) if ( line . contains ( "@since" ) && line . contains ( "2.0" ) && ! line . contains ( "2.0." ) ) b . append ( "java.lang.RuntimeException: @since 2.0 found" ) . append ( "\r\n" ) . append ( " at io.reactivex.Maybe (Maybe.java:" ) . append ( ln ) . append ( ")\r\n\r\n" ) ; ; ln ++ ; finally in . close ( ) ; if ( b . length ( ) != 0 ) System . out . println ( b ) ; fail ( b . toString ( ) ) ; 
findPattern ( 2 ) ; 
findPattern ( 3 ) ; 
findPattern ( 4 ) ; 
findPattern ( 5 ) ; 
checkSource ( "Flowable" , "io.reactivex.rxjava3.core" ) ; 
checkSource ( "Completable" , "io.reactivex.rxjava3.core" ) ; 
checkSource ( "Single" , "io.reactivex.rxjava3.core" ) ; 
checkSource ( "Maybe" , "io.reactivex.rxjava3.core" ) ; 
checkSource ( "Observable" , "io.reactivex.rxjava3.core" ) ; 
checkSource ( "ParallelFlowable" , "io.reactivex.rxjava3.parallel" ) ; 
checkSource ( "CompositeDisposable" , "io.reactivex.rxjava3.disposables" ) ; 
checkSource ( "ConnectableFlowable" , "io.reactivex.rxjava3.flowables" ) ; 
checkSource ( "ConnectableObservable" , "io.reactivex.rxjava3.observables" ) ; 
checkSource ( "Schedulers" , "io.reactivex.rxjava3.schedulers" ) ; 
File f = TestHelper . findSource ( baseClassName , packageName ) ; if ( f == null ) return ; StringBuilder errors = new StringBuilder ( 2048 ) ; int errorCount = 0 ; List < String > lines = Files . readAllLines ( f . toPath ( ) ) ; List < String > docs = new ArrayList < > ( ) ; for ( int i = 1 ; i < lines . size ( ) ; i ++ ) if ( lines . get ( i ) . trim ( ) . equals ( "/**" ) ) docs . clear ( ) ; boolean skipCode = false ; for ( int j = i + 1 ; j < lines . size ( ) ; j ++ ) String line = lines . get ( j ) . trim ( ) ; if ( line . contains ( "<code>" ) ) skipCode = true ; if ( line . equals ( "*/" ) ) break ; if ( ! skipCode ) line = stripTags ( line ) ; if ( line . startsWith ( "@see" ) ) docs . add ( "" ) ; else if ( line . startsWith ( "@throws" ) || line . startsWith ( "@param" ) ) int space = line . indexOf ( ' ' ) ; if ( space < 0 ) docs . add ( "" ) ; else space = line . indexOf ( " " , space + 1 ) ; if ( space < 0 ) docs . add ( "" ) ; else docs . add ( line . substring ( space + 1 ) ) ; else docs . add ( line ) ; else docs . add ( "" ) ; if ( line . contains ( "</code>" ) ) skipCode = false ; for ( String name : NAMES ) boolean isHostType = name . equals ( baseClassName ) ; boolean isAlwaysCode = ALWAYS_CODE . contains ( name ) ; String asLink = "{@link " + name + "}" ; String asCode = "{@code " + name + "}" ; boolean seenBefore = false ; for ( int j = 0 ; j < docs . size ( ) ; j ++ ) String line = docs . get ( j ) ; int idxLink = line . indexOf ( asLink ) ; if ( idxLink >= 0 && ! isHostType && ! isAlwaysCode ) int k = idxLink + asLink . length ( ) ; for ( ; ; ) int jdxLink = line . indexOf ( asLink , k ) ; if ( jdxLink < 0 ) break ; if ( jdxLink >= 0 ) errorCount ++ ; errors . append ( "The subsequent mention should be code: " ) . append ( "{@code " ) . append ( name ) . append ( "}\r\n at " ) . append ( packageName ) . append ( "." ) . append ( baseClassName ) . append ( ".method(" ) . append ( baseClassName ) . append ( ".java:" ) . append ( i + 2 + j ) . append ( ")\r\n" ) ; k = jdxLink + asLink . length ( ) ; if ( seenBefore ) if ( idxLink >= 0 && ! isHostType && ! isAlwaysCode ) errorCount ++ ; errors . append ( "The subsequent mention should be code: " ) . append ( "{@code " ) . append ( name ) . append ( "}\r\n at " ) . append ( packageName ) . append ( "." ) . append ( baseClassName ) . append ( ".method(" ) . append ( baseClassName ) . append ( ".java:" ) . append ( i + 2 + j ) . append ( ")\r\n" ) ; else int idxCode = line . indexOf ( asCode ) ; if ( isHostType ) if ( idxLink >= 0 ) errorCount ++ ; errors . append ( "The host type mention should be code: " ) . append ( "{@code " ) . append ( name ) . append ( "}\r\n at " ) . append ( packageName ) . append ( "." ) . append ( baseClassName ) . append ( ".method(" ) . append ( baseClassName ) . append ( ".java:" ) . append ( i + 2 + j ) . append ( ")\r\n" ) ; else if ( ( idxLink < 0 && idxCode >= 0 && ! isAlwaysCode ) || ( idxLink >= 0 && idxCode >= 0 && idxCode < idxLink ) ) errorCount ++ ; if ( isAlwaysCode ) errors . append ( "The first mention should be code: " ) . append ( "{@code " ) ; else errors . append ( "The first mention should be link: " ) . append ( "{@link " ) ; errors . append ( name ) . append ( "}\r\n at " ) . append ( packageName ) . append ( "." ) . append ( baseClassName ) . append ( ".method(" ) . append ( baseClassName ) . append ( ".java:" ) . append ( i + 2 + j ) . append ( ")\r\n" ) ; seenBefore = idxLink >= 0 || idxCode >= 0 ; String noCurly = removeCurlies ( line ) ; int k = 0 ; for ( ; ; ) int idx = noCurly . indexOf ( name , k ) ; if ( idx < 0 ) break ; k = idx + name . length ( ) ; if ( isHostType ) errorCount ++ ; errors . append ( "The host type mention should be code: " ) . append ( "{@code " ) . append ( name ) . append ( "}\r\n at " ) . append ( packageName ) . append ( "." ) . append ( baseClassName ) . append ( ".method(" ) . append ( baseClassName ) . append ( ".java:" ) . append ( i + 2 + j ) . append ( ")\r\n" ) ; else if ( ! seenBefore ) errorCount ++ ; if ( isAlwaysCode ) errors . append ( "The first mention should be code: " ) . append ( "{@code " ) ; else errors . append ( "The first mention should be link: " ) . append ( "{@link " ) ; errors . append ( name ) . append ( "}\r\n at " ) . append ( packageName ) . append ( "." ) . append ( baseClassName ) . append ( ".method(" ) . append ( baseClassName ) . append ( ".java:" ) . append ( i + 2 + j ) . append ( ")\r\n" ) ; else errorCount ++ ; errors . append ( "The subsequent mention should be code: " ) . append ( "{@code " ) . append ( name ) . append ( "}\r\n at " ) . append ( packageName ) . append ( "." ) . append ( baseClassName ) . append ( ".method(" ) . append ( baseClassName ) . append ( ".java:" ) . append ( i + 2 + j ) . append ( ")\r\n" ) ; seenBefore = true ; i += docs . size ( ) ; if ( errorCount >= ERROR_LIMIT ) break ; if ( errorCount != 0 ) errors . insert ( 0 , "Found " + ( errorCount > ERROR_LIMIT ? ERROR_LIMIT + "+" : errorCount + "" ) + " cases\r\n" ) ; throw new AssertionError ( errors . toString ( ) ) ; 
StringBuilder result = new StringBuilder ( input . length ( ) ) ; result . append ( input , input . length ( ) > 1 ? 2 : 1 , input . length ( ) ) ; clearTag ( result , "<a " , "</a>" ) ; clearTag ( result , "<b>" , "</b>" ) ; clearTag ( result , "<strong>" , "</strong>" ) ; clearTag ( result , "<em>" , "</em>" ) ; clearTag ( result , "<img " , ">" ) ; return result . toString ( ) ; 
int k = 0 ; for ( ; ; ) int j = builder . indexOf ( startTag , k ) ; if ( j < 0 ) break ; int e = builder . indexOf ( endTag , j ) ; if ( e < 0 ) e = builder . length ( ) ; blankRange ( builder , j , e ) ; k = e + endTag . length ( ) ; 
findPattern ( pattern , false ) ; 
findPattern ( "TestSubscriber(Ex)?<.*>\\s+to" ) ; 
findPattern ( "TestObserver(Ex)?<.*>\\s+ts" ) ; 
findPattern ( "TestSubscriber(Ex)?\\s+to" ) ; 
findPattern ( "TestObserver(Ex)?\\s+ts" ) ; 
findPattern ( "PublishSubject<.*>\\s+pp" ) ; 
findPattern ( "PublishProcessor<.*>\\s+ps" ) ; 
findPattern ( "UnicastSubject<.*>\\s+up" ) ; 
findPattern ( "UnicastProcessor<.*>\\s+us" ) ; 
findPattern ( "BehaviorProcessor<.*>\\s+bs" ) ; 
findPattern ( "BehaviorSubject<.*>\\s+bp" ) ; 
findPattern ( "ConnectableFlowable<.*>\\s+co(0-9|\\b)" ) ; 
findPattern ( "ConnectableObservable<.*>\\s+cf(0-9|\\b)" ) ; 
findPattern ( "QueueDisposable\\.(NONE|SYNC|ASYNC|ANY|BOUNDARY)" ) ; 
findPattern ( "QueueSubscription\\.(NONE|SYNC|ASYNC|ANY|BOUNDARY)" ) ; 
findPattern ( "SingleSource<.*>\\s+ms" ) ; 
findPattern ( "SingleSource<.*>\\s+cs" ) ; 
findPattern ( "MaybeSource<.*>\\s+ss" ) ; 
findPattern ( "MaybeSource<.*>\\s+cs" ) ; 
findPattern ( "CompletableSource<.*>\\s+ss" ) ; 
findPattern ( "CompletableSource<.*>\\s+ms" ) ; 
findPattern ( "Observable<.*>\\s+c\\b" ) ; 
findPattern ( "Subscriber<.*>\\s+observer[0-9]?\\b" ) ; 
findPattern ( "Subscriber<.*>\\s+o[0-9]?\\b" ) ; 
findPattern ( "Single<.*>\\s+observable\\b" ) ; 
findPattern ( "Single<.*>\\s+flowable\\b" ) ; 
findPattern ( "Observer<.*>\\s+subscriber[0-9]?\\b" ) ; 
findPattern ( "Observer<.*>\\s+s[0-9]?\\b" ) ; 
findPattern ( "Observer\\s+subscriber[0-9]?\\b" ) ; 
findPattern ( "Observer\\s+s[0-9]?\\b" ) ; 
findPattern ( "Flowable<.*>\\s+observable[0-9]?\\b" ) ; 
findPattern ( "Flowable<.*>\\s+o[0-9]?\\b" ) ; 
findPattern ( "Flowable\\s+o[0-9]?\\b" ) ; 
findPattern ( "Flowable\\s+observable[0-9]?\\b" ) ; 
findPattern ( "Processor<.*>\\s+subject(0-9)?\\b" ) ; 
findPattern ( "Maybe<.*>\\s+observable\\b" ) ; 
findPattern ( "Maybe<.*>\\s+flowable\\b" ) ; 
findPattern ( "Completable\\s+observable\\b" ) ; 
findPattern ( "Completable\\s+flowable\\b" ) ; 
findPattern ( "Subscription\\s+s[0-9]?;" , true ) ; 
findPattern ( "Subscription\\s+d[0-9]?" , true ) ; 
findPattern ( "Subscription\\s+subscription[0-9]?;" , true ) ; 
findPattern ( "Subscription\\s+d[0-9]?\\)" , true ) ; 
findPattern ( "Subscription<.*>\\s+q?d[0-9]?\\b" , true ) ; 
findPattern ( "BooleanSubscription\\s+bd[0-9]?;" , true ) ; 
findPattern ( "AtomicReference<Subscription>\\s+s[0-9]?;" , true ) ; 
findPattern ( "AtomicReference<Subscription>\\s+s[0-9]?\\s" , true ) ; 
findPattern ( "AtomicReference<Subscription>\\s+subscription[0-9]?" , true ) ; 
findPattern ( "AtomicReference<Subscription>\\s+d[0-9]?" , true ) ; 
findPattern ( "Disposable\\s+s[0-9]?\\b" , true ) ; 
findPattern ( "Disposable\\s+d[0-9]?;" , true ) ; 
findPattern ( "AtomicReference<Disposable>\\s+s[0-9]?" , true ) ; 
findPattern ( "AtomicReference<Disposable>\\s+d[0-9]?;" , true ) ; 
findPattern ( "Subscriber<.*>\\s+actual[;\\)]" , true ) ; 
findPattern ( "Subscriber\\s+actual[;\\)]" , true ) ; 
findPattern ( "Subscriber<.*>\\s+s[0-9]?;" , true ) ; 
findPattern ( "Observer<.*>\\s+actual[;\\)]" , true ) ; 
findPattern ( "Observer<.*>\\s+[so][0-9]?;" , true ) ; 
findPattern ( "Observer\\s+actual[;\\)]" , true ) ; 
findPattern ( "Observer\\s+cs[;\\)]" , true ) ; 
findPattern ( "Observer\\s+[so][0-9]?;" , true ) ; 
findPattern ( "Disposable<.*>\\s+q?s[0-9]?\\b" , true ) ; 
findPattern ( "Disposable\\s+s[0-9]?\\)" , true ) ; 
findPattern ( "CompositeDisposable\\s+cs[0-9]?" , true ) ; 
List < String > lines = new ArrayList < > ( ) ; BufferedReader in = new BufferedReader ( new FileReader ( u ) ) ; try for ( ; ; ) String line = in . readLine ( ) ; if ( line == null ) break ; lines . add ( line ) ; finally in . close ( ) ; return lines ; 
checkInternalOperatorNaming ( "Observable" , "Subscriber" , "ObservableFromPublisher" ) ; 
checkInternalOperatorNaming ( "Observable" , "subscribers" ) ; 
checkInternalOperatorNaming ( "Observable" , "Subscription" , "ObservableFromPublisher" , "ObservableDelaySubscriptionOther" ) ; 
checkInternalOperatorNaming ( "Observable" , "Publisher" , "ObservableFromPublisher" ) ; 
checkInternalOperatorNaming ( "Observable" , "Flowable" , "ObservableFromPublisher" ) ; 
checkInternalOperatorNaming ( "Observable" , "Producer" ) ; 
checkInternalOperatorNaming ( "Observable" , "producers" ) ; 
checkInternalOperatorNaming ( "Flowable" , "Producer" ) ; 
checkInternalOperatorNaming ( "Flowable" , "producers" ) ; 
checkInternalOperatorNaming ( "Flowable" , "unsubscrib" ) ; 
checkInternalOperatorNaming ( "Observable" , "unsubscrib" ) ; 
checkInternalOperatorNaming ( "Flowable" , "Observer" , "FlowableFromObservable" , "FlowableLastSingle" , "FlowableAnySingle" , "FlowableAllSingle" , "FlowableToListSingle" , "FlowableCollectSingle" , "FlowableCountSingle" , "FlowableElementAtMaybe" , "FlowableElementAtSingle" , "FlowableElementAtMaybePublisher" , "FlowableElementAtSinglePublisher" , "FlowableFromCompletable" , "FlowableSingleSingle" , "FlowableSingleMaybe" , "FlowableLastMaybe" , "FlowableIgnoreElementsCompletable" , "FlowableReduceMaybe" , "FlowableReduceWithSingle" , "FlowableReduceSeedSingle" , "FlowableFlatMapCompletable" , "FlowableFlatMapCompletableCompletable" , "FlowableFlatMapSingle" , "FlowableFlatMapMaybe" , "FlowableSequenceEqualSingle" , "FlowableConcatWithSingle" , "FlowableConcatWithMaybe" , "FlowableConcatWithCompletable" , "FlowableMergeWithSingle" , "FlowableMergeWithMaybe" , "FlowableMergeWithCompletable" ) ; 
assertEquals ( "Please enable saving parameter names via the -parameters javac argument" , "paramName" , getClass ( ) . getDeclaredMethod ( "method" , Integer . TYPE ) . getParameters ( ) [ 0 ] . getName ( ) ) ; 
if ( System . getenv ( "CI" ) != null ) return ; File f = TestHelper . findSource ( "Flowable" ) ; if ( f == null ) return ; Queue < File > dirs = new ArrayDeque < > ( ) ; File parent = f . getParentFile ( ) . getParentFile ( ) ; dirs . offer ( parent ) ; dirs . offer ( new File ( parent . getAbsolutePath ( ) . replace ( '\\' , '/' ) . replace ( "src/main/java" , "src/perf/java" ) ) ) ; dirs . offer ( new File ( parent . getAbsolutePath ( ) . replace ( '\\' , '/' ) . replace ( "src/main/java" , "src/test/java" ) ) ) ; StringBuilder fail = new StringBuilder ( ) ; while ( ! dirs . isEmpty ( ) ) f = dirs . poll ( ) ; File [ ] list = f . listFiles ( ) ; if ( list != null && list . length != 0 ) for ( File u : list ) if ( u . isDirectory ( ) ) dirs . offer ( u ) ; else if ( u . getName ( ) . endsWith ( ".java" ) ) List < String > lines = new ArrayList < > ( ) ; BufferedReader in = new BufferedReader ( new FileReader ( u ) ) ; try for ( ; ; ) String line = in . readLine ( ) ; if ( line == null ) break ; lines . add ( line ) ; finally in . close ( ) ; if ( ! lines . get ( 0 ) . equals ( header [ 0 ] ) || ! lines . get ( 1 ) . equals ( header [ 1 ] ) ) fail . append ( "java.lang.RuntimeException: missing header added, refresh and re-run tests!\r\n" ) . append ( " at " ) ; String fn = u . toString ( ) . replace ( '\\' , '/' ) ; int idx = fn . indexOf ( "io/reactivex/" ) ; fn = fn . substring ( idx ) . replace ( '/' , '.' ) . replace ( ".java" , "" ) ; fail . append ( fn ) . append ( " (" ) ; int jdx = fn . lastIndexOf ( '.' ) ; fail . append ( fn . substring ( jdx + 1 ) ) ; fail . append ( ".java:1)\r\n\r\n" ) ; lines . addAll ( 0 , Arrays . asList ( header ) ) ; PrintWriter w = new PrintWriter ( new FileWriter ( u ) ) ; try for ( String s : lines ) w . println ( s ) ; finally w . close ( ) ; if ( fail . length ( ) != 0 ) System . out . println ( fail ) ; throw new AssertionError ( fail . toString ( ) ) ; 
for ( Method m : clazz . getMethods ( ) ) if ( m . getDeclaringClass ( ) == clazz ) if ( ( m . getModifiers ( ) & Modifier . STATIC ) == 0 ) if ( ( m . getModifiers ( ) & ( Modifier . PUBLIC | Modifier . FINAL ) ) == Modifier . PUBLIC ) fail ( "Not final: " + m ) ; 
scan ( Flowable . class ) ; 
scan ( Observable . class ) ; 
scan ( Single . class ) ; 
scan ( Completable . class ) ; 
scan ( Maybe . class ) ; 
List < RxMethod > list = BaseTypeParser . parse ( TestHelper . findSource ( "Maybe" ) , "Maybe" ) ; assertFalse ( list . isEmpty ( ) ) ; StringBuilder e = new StringBuilder ( ) ; for ( RxMethod m : list ) int jdx ; if ( m . javadoc != null ) jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "onNext" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) && ! m . signature . contains ( "Flowable" ) && ! m . signature . contains ( "Observable" ) && ! m . signature . contains ( "ObservableSource" ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Subscriber" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) && ! m . signature . contains ( "Flowable" ) && ! m . signature . contains ( "TestSubscriber" ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " Subscription" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) && ! m . signature . contains ( "Flowable" ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Observer" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "ObservableSource" ) && ! m . signature . contains ( "Observable" ) && ! m . signature . contains ( "TestObserver" ) ) if ( idx < 5 || ! m . javadoc . substring ( idx - 5 , idx + 8 ) . equals ( "MaybeObserver" ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Publisher" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) ) if ( idx == 0 || ! m . javadoc . substring ( idx - 1 , idx + 9 ) . equals ( "(Publisher" ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Flowable" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Flowable" ) ) Pattern p = Pattern . compile ( "@see\\s+#[A-Za-z0-9 _.,()]*Flowable" ) ; if ( ! p . matcher ( m . javadoc ) . find ( ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Single" , jdx ) ; if ( idx >= 0 && m . javadoc . indexOf ( "Single#" , jdx ) != idx ) int j = m . javadoc . indexOf ( "#toSingle" , jdx ) ; int k = m . javadoc . indexOf ( "{@code Single" , jdx ) ; if ( ! m . signature . contains ( "Single" ) && ( j + 3 != idx && k + 7 != idx ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "SingleSource" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "SingleSource" ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Observable" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Observable" ) ) Pattern p = Pattern . compile ( "@see\\s+#[A-Za-z0-9 _.,()]*Observable" ) ; if ( ! p . matcher ( m . javadoc ) . find ( ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "ObservableSource" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "ObservableSource" ) ) e . append ( "java.lang.RuntimeException: Maybe doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; checkAtReturnAndSignatureMatch ( "Maybe" , m , e , "Flowable" , "Observable" , "Maybe" , "Single" , "Completable" , "Disposable" , "Iterable" , "Stream" , "Future" , "CompletionStage" ) ; aOrAn ( e , m , "Maybe" ) ; missingClosingDD ( e , m , "Maybe" , "io.reactivex.rxjava3.core" ) ; backpressureMentionedWithoutAnnotation ( e , m , "Maybe" ) ; if ( e . length ( ) != 0 ) System . out . println ( e ) ; fail ( e . toString ( ) ) ; 
List < RxMethod > list = BaseTypeParser . parse ( TestHelper . findSource ( "Single" ) , "Single" ) ; assertFalse ( list . isEmpty ( ) ) ; StringBuilder e = new StringBuilder ( ) ; for ( RxMethod m : list ) int jdx ; if ( m . javadoc != null ) jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "onNext" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) && ! m . signature . contains ( "Flowable" ) && ! m . signature . contains ( "Observable" ) && ! m . signature . contains ( "ObservableSource" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Subscriber" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) && ! m . signature . contains ( "Flowable" ) && ! m . signature . contains ( "TestSubscriber" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " Subscription" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Flowable" ) && ! m . signature . contains ( "Publisher" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Observer" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "ObservableSource" ) && ! m . signature . contains ( "Observable" ) && ! m . signature . contains ( "TestObserver" ) ) if ( idx < 6 || ! m . javadoc . substring ( idx - 6 , idx + 8 ) . equals ( "SingleObserver" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Publisher" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) ) if ( idx == 0 || ! m . javadoc . substring ( idx - 1 , idx + 9 ) . equals ( "(Publisher" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " Flowable" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Flowable" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " Maybe" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Maybe" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions Maybe but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " MaybeSource" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "MaybeSource" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Maybe.method(Maybe.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " Observable" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Observable" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " ObservableSource" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "ObservableSource" ) ) e . append ( "java.lang.RuntimeException: Single doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Single.method(Single.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; checkAtReturnAndSignatureMatch ( "Single" , m , e , "Flowable" , "Observable" , "Maybe" , "Single" , "Completable" , "Disposable" , "Iterable" , "Stream" , "Future" , "CompletionStage" ) ; aOrAn ( e , m , "Single" ) ; missingClosingDD ( e , m , "Single" , "io.reactivex.rxjava3.core" ) ; backpressureMentionedWithoutAnnotation ( e , m , "Single" ) ; if ( e . length ( ) != 0 ) System . out . println ( e ) ; fail ( e . toString ( ) ) ; 
List < RxMethod > list = BaseTypeParser . parse ( TestHelper . findSource ( "Completable" ) , "Completable" ) ; assertFalse ( list . isEmpty ( ) ) ; StringBuilder e = new StringBuilder ( ) ; for ( RxMethod m : list ) int jdx ; if ( m . javadoc != null ) jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "onNext" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) && ! m . signature . contains ( "Flowable" ) && ! m . signature . contains ( "Observable" ) && ! m . signature . contains ( "ObservableSource" ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions onNext but no Flowable/Observable in signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Subscriber" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) && ! m . signature . contains ( "Flowable" ) && ! m . signature . contains ( "TestSubscriber" ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions Subscriber but not using Flowable\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " Subscription" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Flowable" ) && ! m . signature . contains ( "Publisher" ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions Subscription but not using Flowable\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Observer" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "ObservableSource" ) && ! m . signature . contains ( "Observable" ) && ! m . signature . contains ( "TestObserver" ) ) if ( idx < 11 || ! m . javadoc . substring ( idx - 11 , idx + 8 ) . equals ( "CompletableObserver" ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions Observer but not using Observable\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Publisher" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Publisher" ) ) if ( idx == 0 || ! m . javadoc . substring ( idx - 1 , idx + 9 ) . equals ( "(Publisher" ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions Publisher but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Flowable" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Flowable" ) ) Pattern p = Pattern . compile ( "@see\\s+#[A-Za-z0-9 _.,()]*Flowable" ) ; if ( ! p . matcher ( m . javadoc ) . find ( ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions Flowable but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "Single" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Single" ) ) Pattern p = Pattern . compile ( "@see\\s+#[A-Za-z0-9 _.,()]*Single" ) ; if ( ! p . matcher ( m . javadoc ) . find ( ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions Single but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "SingleSource" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "SingleSource" ) ) Pattern p = Pattern . compile ( "@see\\s+#[A-Za-z0-9 _.,()]*SingleSource" ) ; if ( ! p . matcher ( m . javadoc ) . find ( ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions SingleSource but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( " Observable" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "Observable" ) ) Pattern p = Pattern . compile ( "@see\\s+#[A-Za-z0-9 _.,()]*Observable" ) ; if ( ! p . matcher ( m . javadoc ) . find ( ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions Observable but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; jdx = 0 ; for ( ; ; ) int idx = m . javadoc . indexOf ( "ObservableSource" , jdx ) ; if ( idx >= 0 ) if ( ! m . signature . contains ( "ObservableSource" ) ) Pattern p = Pattern . compile ( "@see\\s+#[A-Za-z0-9 _.,()]*ObservableSource" ) ; if ( ! p . matcher ( m . javadoc ) . find ( ) ) e . append ( "java.lang.RuntimeException: Completable doc mentions ObservableSource but not in the signature\r\n at io.reactivex.rxjava3.core." ) . append ( "Completable.method(Completable.java:" ) . append ( m . javadocLine + lineNumber ( m . javadoc , idx ) - 1 ) . append ( ")\r\n\r\n" ) ; jdx = idx + 6 ; else break ; checkAtReturnAndSignatureMatch ( "Completable" , m , e , "Flowable" , "Observable" , "Maybe" , "Single" , "Completable" , "Disposable" , "Iterable" , "Stream" , "Future" , "CompletionStage" ) ; aOrAn ( e , m , "Completable" ) ; missingClosingDD ( e , m , "Completable" , "io.reactivex.rxjava3.core" ) ; backpressureMentionedWithoutAnnotation ( e , m , "Completable" ) ; if ( e . length ( ) != 0 ) System . out . println ( e ) ; fail ( e . toString ( ) ) ; 
TestHelper . checkUtilityClass ( RxJavaPlugins . class ) ; 
RxJavaPlugins . reset ( ) ; RxJavaPlugins . lockdown ( ) ; try assertTrue ( RxJavaPlugins . isLockdown ( ) ) ; Consumer a1 = Functions . emptyConsumer ( ) ; Supplier f0 = new Supplier ( ) @ Override public Object get ( ) return null ; ; Function f1 = Functions . identity ( ) ; BiFunction f2 = new BiFunction ( ) @ Override public Object apply ( Object t1 , Object t2 ) return t2 ; ; BooleanSupplier bs = new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return true ; ; for ( Method m : RxJavaPlugins . class . getMethods ( ) ) if ( m . getName ( ) . startsWith ( "set" ) ) Method getter ; Class < ? > paramType = m . getParameterTypes ( ) [ 0 ] ; if ( paramType == Boolean . TYPE ) getter = RxJavaPlugins . class . getMethod ( "is" + m . getName ( ) . substring ( 3 ) ) ; else getter = RxJavaPlugins . class . getMethod ( "get" + m . getName ( ) . substring ( 3 ) ) ; Object before = getter . invoke ( null ) ; try if ( paramType . isAssignableFrom ( Boolean . TYPE ) ) m . invoke ( null , true ) ; else if ( paramType . isAssignableFrom ( Supplier . class ) ) m . invoke ( null , f0 ) ; else if ( paramType . isAssignableFrom ( Function . class ) ) m . invoke ( null , f1 ) ; else if ( paramType . isAssignableFrom ( Consumer . class ) ) m . invoke ( null , a1 ) ; else if ( paramType . isAssignableFrom ( BooleanSupplier . class ) ) m . invoke ( null , bs ) ; else m . invoke ( null , f2 ) ; fail ( "Should have thrown InvocationTargetException(IllegalStateException)" ) ; catch ( InvocationTargetException ex ) if ( ex . getCause ( ) instanceof IllegalStateException ) assertEquals ( "Plugins can't be changed anymore" , ex . getCause ( ) . getMessage ( ) ) ; else fail ( "Should have thrown InvocationTargetException(IllegalStateException)" ) ; Object after = getter . invoke ( null ) ; if ( paramType . isPrimitive ( ) ) assertEquals ( m . toString ( ) , before , after ) ; else assertSame ( m . toString ( ) , before , after ) ; finally RxJavaPlugins . unlock ( ) ; RxJavaPlugins . reset ( ) ; assertFalse ( RxJavaPlugins . isLockdown ( ) ) ; 
try RxJavaPlugins . setSingleSchedulerHandler ( replaceWithImmediate ) ; assertSame ( ImmediateThinScheduler . INSTANCE , Schedulers . single ( ) ) ; finally RxJavaPlugins . reset ( ) ; assertNotSame ( ImmediateThinScheduler . INSTANCE , Schedulers . single ( ) ) ; 
try RxJavaPlugins . setComputationSchedulerHandler ( replaceWithImmediate ) ; assertSame ( ImmediateThinScheduler . INSTANCE , Schedulers . computation ( ) ) ; finally RxJavaPlugins . reset ( ) ; assertNotSame ( ImmediateThinScheduler . INSTANCE , Schedulers . computation ( ) ) ; 
try RxJavaPlugins . setIoSchedulerHandler ( replaceWithImmediate ) ; assertSame ( ImmediateThinScheduler . INSTANCE , Schedulers . io ( ) ) ; finally RxJavaPlugins . reset ( ) ; assertNotSame ( ImmediateThinScheduler . INSTANCE , Schedulers . io ( ) ) ; 
try RxJavaPlugins . setNewThreadSchedulerHandler ( replaceWithImmediate ) ; assertSame ( ImmediateThinScheduler . INSTANCE , Schedulers . newThread ( ) ) ; finally RxJavaPlugins . reset ( ) ; assertNotSame ( ImmediateThinScheduler . INSTANCE , Schedulers . newThread ( ) ) ; 
final Scheduler s = Schedulers . single ( ) ; Supplier < Scheduler > c = new Supplier < Scheduler > ( ) @ Override public Scheduler get ( ) throws Exception return s ; ; try RxJavaPlugins . setInitSingleSchedulerHandler ( initReplaceWithImmediate ) ; assertSame ( ImmediateThinScheduler . INSTANCE , RxJavaPlugins . initSingleScheduler ( c ) ) ; finally RxJavaPlugins . reset ( ) ; assertSame ( s , RxJavaPlugins . initSingleScheduler ( c ) ) ; 
final Scheduler s = Schedulers . computation ( ) ; Supplier < Scheduler > c = new Supplier < Scheduler > ( ) @ Override public Scheduler get ( ) throws Exception return s ; ; try RxJavaPlugins . setInitComputationSchedulerHandler ( initReplaceWithImmediate ) ; assertSame ( ImmediateThinScheduler . INSTANCE , RxJavaPlugins . initComputationScheduler ( c ) ) ; finally RxJavaPlugins . reset ( ) ; assertSame ( s , RxJavaPlugins . initComputationScheduler ( c ) ) ; 
final Scheduler s = Schedulers . io ( ) ; Supplier < Scheduler > c = new Supplier < Scheduler > ( ) @ Override public Scheduler get ( ) throws Exception return s ; ; try RxJavaPlugins . setInitIoSchedulerHandler ( initReplaceWithImmediate ) ; assertSame ( ImmediateThinScheduler . INSTANCE , RxJavaPlugins . initIoScheduler ( c ) ) ; finally RxJavaPlugins . reset ( ) ; assertSame ( s , RxJavaPlugins . initIoScheduler ( c ) ) ; 
final Scheduler s = Schedulers . newThread ( ) ; Supplier < Scheduler > c = new Supplier < Scheduler > ( ) @ Override public Scheduler get ( ) throws Exception return s ; ; try RxJavaPlugins . setInitNewThreadSchedulerHandler ( initReplaceWithImmediate ) ; assertSame ( ImmediateThinScheduler . INSTANCE , RxJavaPlugins . initNewThreadScheduler ( c ) ) ; finally RxJavaPlugins . reset ( ) ; assertSame ( s , RxJavaPlugins . initNewThreadScheduler ( c ) ) ; 
try RxJavaPlugins . initSingleScheduler ( null ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException npe ) assertEquals ( "Scheduler Supplier can't be null" , npe . getMessage ( ) ) ; try RxJavaPlugins . initSingleScheduler ( nullResultSupplier ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException npe ) assertEquals ( "Scheduler Supplier result can't be null" , npe . getMessage ( ) ) ; 
try RxJavaPlugins . initComputationScheduler ( null ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException npe ) assertEquals ( "Scheduler Supplier can't be null" , npe . getMessage ( ) ) ; try RxJavaPlugins . initComputationScheduler ( nullResultSupplier ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException npe ) assertEquals ( "Scheduler Supplier result can't be null" , npe . getMessage ( ) ) ; 
try RxJavaPlugins . initIoScheduler ( null ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException npe ) assertEquals ( "Scheduler Supplier can't be null" , npe . getMessage ( ) ) ; try RxJavaPlugins . initIoScheduler ( nullResultSupplier ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException npe ) assertEquals ( "Scheduler Supplier result can't be null" , npe . getMessage ( ) ) ; 
try RxJavaPlugins . initNewThreadScheduler ( null ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException npe ) assertEquals ( "Scheduler Supplier can't be null" , npe . getMessage ( ) ) ; try RxJavaPlugins . initNewThreadScheduler ( nullResultSupplier ) ; fail ( "Should have thrown NullPointerException" ) ; catch ( NullPointerException npe ) assertEquals ( "Scheduler Supplier result can't be null" , npe . getMessage ( ) ) ; 
try RxJavaPlugins . setInitSingleSchedulerHandler ( initReplaceWithImmediate ) ; RxJavaPlugins . initSingleScheduler ( unsafeDefault ) ; finally RxJavaPlugins . reset ( ) ; assertNotSame ( ImmediateThinScheduler . INSTANCE , Schedulers . single ( ) ) ; 
try RxJavaPlugins . setInitIoSchedulerHandler ( initReplaceWithImmediate ) ; RxJavaPlugins . initIoScheduler ( unsafeDefault ) ; finally RxJavaPlugins . reset ( ) ; assertNotSame ( ImmediateThinScheduler . INSTANCE , Schedulers . io ( ) ) ; 
try RxJavaPlugins . setInitComputationSchedulerHandler ( initReplaceWithImmediate ) ; RxJavaPlugins . initComputationScheduler ( unsafeDefault ) ; finally RxJavaPlugins . reset ( ) ; assertNotSame ( ImmediateThinScheduler . INSTANCE , Schedulers . computation ( ) ) ; 
try RxJavaPlugins . setInitNewThreadSchedulerHandler ( initReplaceWithImmediate ) ; RxJavaPlugins . initNewThreadScheduler ( unsafeDefault ) ; finally RxJavaPlugins . reset ( ) ; assertNotSame ( ImmediateThinScheduler . INSTANCE , Schedulers . newThread ( ) ) ; 
try RxJavaPlugins . setOnObservableAssembly ( new Function < Observable , Observable > ( ) @ Override public Observable apply ( Observable t ) return new ObservableRange ( 1 , 2 ) ; ) ; Observable . range ( 10 , 3 ) . test ( ) . assertValues ( 1 , 2 ) . assertNoErrors ( ) . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; Observable . range ( 10 , 3 ) . test ( ) . assertValues ( 10 , 11 , 12 ) . assertNoErrors ( ) . assertComplete ( ) ; 
try RxJavaPlugins . setOnFlowableAssembly ( new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable t ) return new FlowableRange ( 1 , 2 ) ; ) ; Flowable . range ( 10 , 3 ) . test ( ) . assertValues ( 1 , 2 ) . assertNoErrors ( ) . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; Flowable . range ( 10 , 3 ) . test ( ) . assertValues ( 10 , 11 , 12 ) . assertNoErrors ( ) . assertComplete ( ) ; 
try RxJavaPlugins . setOnObservableSubscribe ( new BiFunction < Observable , Observer , Observer > ( ) @ Override public Observer apply ( Observable o , final Observer t ) return new Observer ( ) @ Override public void onSubscribe ( Disposable d ) t . onSubscribe ( d ) ; @ SuppressWarnings ( "unchecked" ) @ Override public void onNext ( Object value ) t . onNext ( ( Integer ) value - 9 ) ; @ Override public void onError ( Throwable e ) t . onError ( e ) ; @ Override public void onComplete ( ) t . onComplete ( ) ; ; ) ; Observable . range ( 10 , 3 ) . test ( ) . assertValues ( 1 , 2 , 3 ) . assertNoErrors ( ) . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; Observable . range ( 10 , 3 ) . test ( ) . assertValues ( 10 , 11 , 12 ) . assertNoErrors ( ) . assertComplete ( ) ; 
t . onSubscribe ( d ) ; 
t . onNext ( ( Integer ) value - 9 ) ; 
t . onError ( e ) ; 
t . onComplete ( ) ; 
try RxJavaPlugins . setOnFlowableSubscribe ( new BiFunction < Flowable , Subscriber , Subscriber > ( ) @ Override public Subscriber apply ( Flowable f , final Subscriber t ) return new Subscriber ( ) @ Override public void onSubscribe ( Subscription s ) t . onSubscribe ( s ) ; @ SuppressWarnings ( "unchecked" ) @ Override public void onNext ( Object value ) t . onNext ( ( Integer ) value - 9 ) ; @ Override public void onError ( Throwable e ) t . onError ( e ) ; @ Override public void onComplete ( ) t . onComplete ( ) ; ; ) ; Flowable . range ( 10 , 3 ) . test ( ) . assertValues ( 1 , 2 , 3 ) . assertNoErrors ( ) . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; Flowable . range ( 10 , 3 ) . test ( ) . assertValues ( 10 , 11 , 12 ) . assertNoErrors ( ) . assertComplete ( ) ; 
t . onSubscribe ( s ) ; 
try RxJavaPlugins . setOnParallelSubscribe ( new BiFunction < ParallelFlowable , Subscriber [ ] , Subscriber [ ] > ( ) @ Override public Subscriber [ ] apply ( ParallelFlowable f , final Subscriber [ ] t ) return new Subscriber [ ] new Subscriber ( ) @ Override public void onSubscribe ( Subscription s ) t [ 0 ] . onSubscribe ( s ) ; @ SuppressWarnings ( "unchecked" ) @ Override public void onNext ( Object value ) t [ 0 ] . onNext ( ( Integer ) value - 9 ) ; @ Override public void onError ( Throwable e ) t [ 0 ] . onError ( e ) ; @ Override public void onComplete ( ) t [ 0 ] . onComplete ( ) ; ; ) ; Flowable . range ( 10 , 3 ) . parallel ( 1 ) . sequential ( ) . test ( ) . assertValues ( 1 , 2 , 3 ) . assertNoErrors ( ) . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; Flowable . range ( 10 , 3 ) . parallel ( 1 ) . sequential ( ) . test ( ) . assertValues ( 10 , 11 , 12 ) . assertNoErrors ( ) . assertComplete ( ) ; 
try RxJavaPlugins . setOnSingleAssembly ( new Function < Single , Single > ( ) @ Override public Single apply ( Single t ) return new SingleJust < > ( 10 ) ; ) ; Single . just ( 1 ) . test ( ) . assertValue ( 10 ) . assertNoErrors ( ) . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; Single . just ( 1 ) . test ( ) . assertValue ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
try RxJavaPlugins . setOnSingleSubscribe ( new BiFunction < Single , SingleObserver , SingleObserver > ( ) @ Override public SingleObserver apply ( Single o , final SingleObserver t ) return new SingleObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) t . onSubscribe ( d ) ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSuccess ( Object value ) t . onSuccess ( 10 ) ; @ Override public void onError ( Throwable e ) t . onError ( e ) ; ; ) ; Single . just ( 1 ) . test ( ) . assertValue ( 10 ) . assertNoErrors ( ) . assertComplete ( ) ; finally RxJavaPlugins . reset ( ) ; Single . just ( 1 ) . test ( ) . assertValue ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
t . onSuccess ( 10 ) ; 
try RxJavaPlugins . setOnCompletableAssembly ( new Function < Completable , Completable > ( ) @ Override public Completable apply ( Completable t ) return new CompletableError ( new TestException ( ) ) ; ) ; Completable . complete ( ) . test ( ) . assertNoValues ( ) . assertNotComplete ( ) . assertError ( TestException . class ) ; finally RxJavaPlugins . reset ( ) ; Completable . complete ( ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
try RxJavaPlugins . setOnCompletableSubscribe ( new BiFunction < Completable , CompletableObserver , CompletableObserver > ( ) @ Override public CompletableObserver apply ( Completable o , final CompletableObserver t ) return new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) t . onSubscribe ( d ) ; @ Override public void onError ( Throwable e ) t . onError ( e ) ; @ Override public void onComplete ( ) t . onError ( new TestException ( ) ) ; ; ) ; Completable . complete ( ) . test ( ) . assertNoValues ( ) . assertNotComplete ( ) . assertError ( TestException . class ) ; finally RxJavaPlugins . reset ( ) ; Completable . complete ( ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
onSchedule ( Schedulers . computation ( ) . createWorker ( ) ) ; 
onSchedule ( Schedulers . io ( ) . createWorker ( ) ) ; 
onSchedule ( Schedulers . newThread ( ) . createWorker ( ) ) ; 
try final List < Throwable > list = new ArrayList < > ( ) ; RxJavaPlugins . setErrorHandler ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) list . add ( t ) ; ) ; RxJavaPlugins . onError ( new TestException ( "Forced failure" ) ) ; assertEquals ( 1 , list . size ( ) ) ; assertUndeliverableTestException ( list , 0 , "Forced failure" ) ; finally RxJavaPlugins . reset ( ) ; 
try final List < Throwable > list = new ArrayList < > ( ) ; RxJavaPlugins . setErrorHandler ( null ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) @ Override public void uncaughtException ( Thread t , Throwable e ) list . add ( e ) ; ) ; RxJavaPlugins . onError ( new TestException ( "Forced failure" ) ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; RxJavaPlugins . onError ( new TestException ( "Forced failure 3" ) ) ; assertEquals ( 1 , list . size ( ) ) ; assertUndeliverableTestException ( list , 0 , "Forced failure" ) ; finally RxJavaPlugins . reset ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; 
try final List < Throwable > list = new ArrayList < > ( ) ; RxJavaPlugins . setErrorHandler ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throw new TestException ( "Forced failure 2" ) ; ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) @ Override public void uncaughtException ( Thread t , Throwable e ) list . add ( e ) ; ) ; RxJavaPlugins . onError ( new TestException ( "Forced failure" ) ) ; assertEquals ( 2 , list . size ( ) ) ; assertTestException ( list , 0 , "Forced failure 2" ) ; assertUndeliverableTestException ( list , 1 , "Forced failure" ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; finally RxJavaPlugins . reset ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; 
try final List < Throwable > list = new ArrayList < > ( ) ; RxJavaPlugins . setErrorHandler ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throw new TestException ( "Forced failure 2" ) ; ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) @ Override public void uncaughtException ( Thread t , Throwable e ) list . add ( e ) ; ) ; RxJavaPlugins . onError ( null ) ; assertEquals ( 2 , list . size ( ) ) ; assertTestException ( list , 0 , "Forced failure 2" ) ; assertNPE ( list , 1 ) ; RxJavaPlugins . reset ( ) ; RxJavaPlugins . onError ( null ) ; assertNPE ( list , 2 ) ; finally RxJavaPlugins . reset ( ) ; Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; 
try Consumer < ? super Throwable > errorHandler = new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throw new TestException ( "Forced failure 2" ) ; ; RxJavaPlugins . setErrorHandler ( errorHandler ) ; Consumer < ? super Throwable > errorHandler1 = RxJavaPlugins . getErrorHandler ( ) ; assertSame ( errorHandler , errorHandler1 ) ; Function < ? super Scheduler , ? extends Scheduler > scheduler2scheduler = new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler scheduler ) throws Exception return scheduler ; ; Function < ? super Supplier < Scheduler > , ? extends Scheduler > callable2scheduler = new Function < Supplier < Scheduler > , Scheduler > ( ) @ Override public Scheduler apply ( Supplier < Scheduler > schedulerSupplier ) throws Throwable return schedulerSupplier . get ( ) ; ; Function < ? super ConnectableFlowable , ? extends ConnectableFlowable > connectableFlowable2ConnectableFlowable = new Function < ConnectableFlowable , ConnectableFlowable > ( ) @ Override public ConnectableFlowable apply ( ConnectableFlowable connectableFlowable ) throws Exception return connectableFlowable ; ; Function < ? super ConnectableObservable , ? extends ConnectableObservable > connectableObservable2ConnectableObservable = new Function < ConnectableObservable , ConnectableObservable > ( ) @ Override public ConnectableObservable apply ( ConnectableObservable connectableObservable ) throws Exception return connectableObservable ; ; Function < ? super Flowable , ? extends Flowable > flowable2Flowable = new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable flowable ) throws Exception return flowable ; ; BiFunction < ? super Flowable , ? super Subscriber , ? extends Subscriber > flowable2subscriber = new BiFunction < Flowable , Subscriber , Subscriber > ( ) @ Override public Subscriber apply ( Flowable flowable , Subscriber subscriber ) throws Exception return subscriber ; ; Function < Maybe , Maybe > maybe2maybe = new Function < Maybe , Maybe > ( ) @ Override public Maybe apply ( Maybe maybe ) throws Exception return maybe ; ; BiFunction < Maybe , MaybeObserver , MaybeObserver > maybe2observer = new BiFunction < Maybe , MaybeObserver , MaybeObserver > ( ) @ Override public MaybeObserver apply ( Maybe maybe , MaybeObserver maybeObserver ) throws Exception return maybeObserver ; ; Function < Observable , Observable > observable2observable = new Function < Observable , Observable > ( ) @ Override public Observable apply ( Observable observable ) throws Exception return observable ; ; BiFunction < ? super Observable , ? super Observer , ? extends Observer > observable2observer = new BiFunction < Observable , Observer , Observer > ( ) @ Override public Observer apply ( Observable observable , Observer observer ) throws Exception return observer ; ; Function < ? super ParallelFlowable , ? extends ParallelFlowable > parallelFlowable2parallelFlowable = new Function < ParallelFlowable , ParallelFlowable > ( ) @ Override public ParallelFlowable apply ( ParallelFlowable parallelFlowable ) throws Exception return parallelFlowable ; ; Function < Single , Single > single2single = new Function < Single , Single > ( ) @ Override public Single apply ( Single single ) throws Exception return single ; ; BiFunction < ? super Single , ? super SingleObserver , ? extends SingleObserver > single2observer = new BiFunction < Single , SingleObserver , SingleObserver > ( ) @ Override public SingleObserver apply ( Single single , SingleObserver singleObserver ) throws Exception return singleObserver ; ; Function < ? super Runnable , ? extends Runnable > runnable2runnable = new Function < Runnable , Runnable > ( ) @ Override public Runnable apply ( Runnable runnable ) throws Exception return runnable ; ; BiFunction < ? super Completable , ? super CompletableObserver , ? extends CompletableObserver > completableObserver2completableObserver = new BiFunction < Completable , CompletableObserver , CompletableObserver > ( ) @ Override public CompletableObserver apply ( Completable completable , CompletableObserver completableObserver ) throws Exception return completableObserver ; ; Function < ? super Completable , ? extends Completable > completable2completable = new Function < Completable , Completable > ( ) @ Override public Completable apply ( Completable completable ) throws Exception return completable ; ; RxJavaPlugins . setInitComputationSchedulerHandler ( callable2scheduler ) ; RxJavaPlugins . setComputationSchedulerHandler ( scheduler2scheduler ) ; RxJavaPlugins . setIoSchedulerHandler ( scheduler2scheduler ) ; RxJavaPlugins . setNewThreadSchedulerHandler ( scheduler2scheduler ) ; RxJavaPlugins . setOnConnectableFlowableAssembly ( connectableFlowable2ConnectableFlowable ) ; RxJavaPlugins . setOnConnectableObservableAssembly ( connectableObservable2ConnectableObservable ) ; RxJavaPlugins . setOnFlowableAssembly ( flowable2Flowable ) ; RxJavaPlugins . setOnFlowableSubscribe ( flowable2subscriber ) ; RxJavaPlugins . setOnMaybeAssembly ( maybe2maybe ) ; RxJavaPlugins . setOnMaybeSubscribe ( maybe2observer ) ; RxJavaPlugins . setOnObservableAssembly ( observable2observable ) ; RxJavaPlugins . setOnObservableSubscribe ( observable2observer ) ; RxJavaPlugins . setOnParallelAssembly ( parallelFlowable2parallelFlowable ) ; RxJavaPlugins . setOnSingleAssembly ( single2single ) ; RxJavaPlugins . setOnSingleSubscribe ( single2observer ) ; RxJavaPlugins . setScheduleHandler ( runnable2runnable ) ; RxJavaPlugins . setSingleSchedulerHandler ( scheduler2scheduler ) ; RxJavaPlugins . setOnCompletableSubscribe ( completableObserver2completableObserver ) ; RxJavaPlugins . setOnCompletableAssembly ( completable2completable ) ; RxJavaPlugins . setInitSingleSchedulerHandler ( callable2scheduler ) ; RxJavaPlugins . setInitNewThreadSchedulerHandler ( callable2scheduler ) ; RxJavaPlugins . setInitIoSchedulerHandler ( callable2scheduler ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . reset ( ) ; assertNull ( RxJavaPlugins . onAssembly ( ( Observable ) null ) ) ; assertNull ( RxJavaPlugins . onAssembly ( ( ConnectableObservable ) null ) ) ; assertNull ( RxJavaPlugins . onAssembly ( ( Flowable ) null ) ) ; assertNull ( RxJavaPlugins . onAssembly ( ( ConnectableFlowable ) null ) ) ; Observable oos = new Observable ( ) @ Override public void subscribeActual ( Observer t ) ; Flowable fos = new Flowable ( ) @ Override public void subscribeActual ( Subscriber t ) ; assertSame ( oos , RxJavaPlugins . onAssembly ( oos ) ) ; assertSame ( fos , RxJavaPlugins . onAssembly ( fos ) ) ; assertNull ( RxJavaPlugins . onAssembly ( ( Single ) null ) ) ; Single sos = new Single ( ) @ Override public void subscribeActual ( SingleObserver t ) ; assertSame ( sos , RxJavaPlugins . onAssembly ( sos ) ) ; assertNull ( RxJavaPlugins . onAssembly ( ( Completable ) null ) ) ; Completable cos = new Completable ( ) @ Override public void subscribeActual ( CompletableObserver t ) ; assertSame ( cos , RxJavaPlugins . onAssembly ( cos ) ) ; assertNull ( RxJavaPlugins . onAssembly ( ( Maybe ) null ) ) ; Maybe myb = new Maybe ( ) @ Override public void subscribeActual ( MaybeObserver t ) ; assertSame ( myb , RxJavaPlugins . onAssembly ( myb ) ) ; Runnable action = Functions . EMPTY_RUNNABLE ; assertSame ( action , RxJavaPlugins . onSchedule ( action ) ) ; class AllSubscriber implements Subscriber , Observer , SingleObserver , CompletableObserver , MaybeObserver @ Override public void onSuccess ( Object value ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSubscribe ( Subscription s ) @ Override public void onNext ( Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) AllSubscriber all = new AllSubscriber ( ) ; Subscriber [ ] allArray = all ; assertNull ( RxJavaPlugins . onSubscribe ( Observable . never ( ) , null ) ) ; assertSame ( all , RxJavaPlugins . onSubscribe ( Observable . never ( ) , all ) ) ; assertNull ( RxJavaPlugins . onSubscribe ( Flowable . never ( ) , null ) ) ; assertSame ( all , RxJavaPlugins . onSubscribe ( Flowable . never ( ) , all ) ) ; assertNull ( RxJavaPlugins . onSubscribe ( Single . just ( 1 ) , null ) ) ; assertSame ( all , RxJavaPlugins . onSubscribe ( Single . just ( 1 ) , all ) ) ; assertNull ( RxJavaPlugins . onSubscribe ( Completable . never ( ) , null ) ) ; assertSame ( all , RxJavaPlugins . onSubscribe ( Completable . never ( ) , all ) ) ; assertNull ( RxJavaPlugins . onSubscribe ( Maybe . never ( ) , null ) ) ; assertSame ( all , RxJavaPlugins . onSubscribe ( Maybe . never ( ) , all ) ) ; assertNull ( RxJavaPlugins . onSubscribe ( Flowable . never ( ) . parallel ( ) , null ) ) ; assertSame ( allArray , RxJavaPlugins . onSubscribe ( Flowable . never ( ) . parallel ( ) , allArray ) ) ; final Scheduler s = ImmediateThinScheduler . INSTANCE ; Supplier < Scheduler > c = new Supplier < Scheduler > ( ) @ Override public Scheduler get ( ) throws Exception return s ; ; assertSame ( s , RxJavaPlugins . onComputationScheduler ( s ) ) ; assertSame ( s , RxJavaPlugins . onIoScheduler ( s ) ) ; assertSame ( s , RxJavaPlugins . onNewThreadScheduler ( s ) ) ; assertSame ( s , RxJavaPlugins . onSingleScheduler ( s ) ) ; assertSame ( s , RxJavaPlugins . initComputationScheduler ( c ) ) ; assertSame ( s , RxJavaPlugins . initIoScheduler ( c ) ) ; assertSame ( s , RxJavaPlugins . initNewThreadScheduler ( c ) ) ; assertSame ( s , RxJavaPlugins . initSingleScheduler ( c ) ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setOnConnectableObservableAssembly ( new Function < ConnectableObservable , ConnectableObservable > ( ) @ Override public ConnectableObservable apply ( ConnectableObservable co ) throws Exception return new ConnectableObservable ( ) @ Override public void connect ( Consumer connection ) @ Override public void reset ( ) @ SuppressWarnings ( "unchecked" ) @ Override protected void subscribeActual ( Observer observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 10 ) ; observer . onComplete ( ) ; ; ) ; Observable . just ( 1 ) . publish ( ) . autoConnect ( ) . test ( ) . assertResult ( 10 ) ; finally RxJavaPlugins . reset ( ) ; Observable . just ( 1 ) . publish ( ) . autoConnect ( ) . test ( ) . assertResult ( 1 ) ; 
try RxJavaPlugins . setOnConnectableFlowableAssembly ( new Function < ConnectableFlowable , ConnectableFlowable > ( ) @ Override public ConnectableFlowable apply ( ConnectableFlowable co ) throws Exception return new ConnectableFlowable ( ) @ Override public void connect ( Consumer connection ) @ Override public void reset ( ) @ SuppressWarnings ( "unchecked" ) @ Override protected void subscribeActual ( Subscriber subscriber ) subscriber . onSubscribe ( new ScalarSubscription ( subscriber , 10 ) ) ; ; ) ; Flowable . just ( 1 ) . publish ( ) . autoConnect ( ) . test ( ) . assertResult ( 10 ) ; finally RxJavaPlugins . reset ( ) ; Flowable . just ( 1 ) . publish ( ) . autoConnect ( ) . test ( ) . assertResult ( 1 ) ; 
try RxJavaPlugins . setOnFlowableAssembly ( new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable f ) throws Exception throw new IllegalArgumentException ( ) ; ) ; try Flowable . empty ( ) ; fail ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) RxJavaPlugins . setOnFlowableAssembly ( new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable f ) throws Exception throw new InternalError ( ) ; ) ; try Flowable . empty ( ) ; fail ( "Should have thrown!" ) ; catch ( InternalError ex ) RxJavaPlugins . setOnFlowableAssembly ( new Function < Flowable , Flowable > ( ) @ Override public Flowable apply ( Flowable f ) throws Exception throw new IOException ( ) ; ) ; try Flowable . empty ( ) ; fail ( "Should have thrown!" ) ; catch ( RuntimeException ex ) if ( ! ( ex . getCause ( ) instanceof IOException ) ) fail ( ex . getCause ( ) . toString ( ) + ": Should have thrown RuntimeException(IOException)" ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setOnFlowableSubscribe ( new BiFunction < Flowable , Subscriber , Subscriber > ( ) @ Override public Subscriber apply ( Flowable f , Subscriber s ) throws Exception throw new IllegalArgumentException ( ) ; ) ; try Flowable . empty ( ) . test ( ) ; fail ( "Should have thrown!" ) ; catch ( NullPointerException ex ) if ( ! ( ex . getCause ( ) instanceof IllegalArgumentException ) ) fail ( ex . getCause ( ) . toString ( ) + ": Should have thrown NullPointerException(IllegalArgumentException)" ) ; RxJavaPlugins . setOnFlowableSubscribe ( new BiFunction < Flowable , Subscriber , Subscriber > ( ) @ Override public Subscriber apply ( Flowable f , Subscriber s ) throws Exception throw new InternalError ( ) ; ) ; try Flowable . empty ( ) . test ( ) ; fail ( "Should have thrown!" ) ; catch ( InternalError ex ) RxJavaPlugins . setOnFlowableSubscribe ( new BiFunction < Flowable , Subscriber , Subscriber > ( ) @ Override public Subscriber apply ( Flowable f , Subscriber s ) throws Exception throw new IOException ( ) ; ) ; try Flowable . empty ( ) . test ( ) ; fail ( "Should have thrown!" ) ; catch ( NullPointerException ex ) if ( ! ( ex . getCause ( ) instanceof RuntimeException ) ) fail ( ex . getCause ( ) . toString ( ) + ": Should have thrown NullPointerException(RuntimeException(IOException))" ) ; if ( ! ( ex . getCause ( ) . getCause ( ) instanceof IOException ) ) fail ( ex . getCause ( ) . toString ( ) + ": Should have thrown NullPointerException(RuntimeException(IOException))" ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setOnMaybeAssembly ( new Function < Maybe , Maybe > ( ) @ Override public Maybe apply ( Maybe t ) return new MaybeError ( new TestException ( ) ) ; ) ; Maybe . empty ( ) . test ( ) . assertNoValues ( ) . assertNotComplete ( ) . assertError ( TestException . class ) ; finally RxJavaPlugins . reset ( ) ; Maybe . empty ( ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
try RxJavaPlugins . setOnMaybeSubscribe ( new BiFunction < Maybe , MaybeObserver , MaybeObserver > ( ) @ Override public MaybeObserver apply ( Maybe o , final MaybeObserver t ) return new MaybeObserver ( ) @ Override public void onSubscribe ( Disposable d ) t . onSubscribe ( d ) ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSuccess ( Object value ) t . onSuccess ( value ) ; @ Override public void onError ( Throwable e ) t . onError ( e ) ; @ Override public void onComplete ( ) t . onError ( new TestException ( ) ) ; ; ) ; Maybe . empty ( ) . test ( ) . assertNoValues ( ) . assertNotComplete ( ) . assertError ( TestException . class ) ; finally RxJavaPlugins . reset ( ) ; Maybe . empty ( ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
try final AtomicReference < Throwable > t = new AtomicReference < > ( ) ; RxJavaPlugins . setErrorHandler ( new Consumer < Throwable > ( ) @ Override public void accept ( final Throwable throwable ) throws Exception t . set ( throwable ) ; ) ; RxJavaPlugins . onError ( null ) ; final Throwable throwable = t . get ( ) ; assertEquals ( ExceptionHelper . nullWarning ( "onError called with a null Throwable." ) , throwable . getMessage ( ) ) ; assertTrue ( throwable instanceof NullPointerException ) ; finally RxJavaPlugins . reset ( ) ; 
assertNotNull ( scheduler ) ; Worker w = scheduler . createWorker ( ) ; try final AtomicReference < Thread > value = new AtomicReference < > ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; w . schedule ( new Runnable ( ) @ Override public void run ( ) value . set ( Thread . currentThread ( ) ) ; cdl . countDown ( ) ; ) ; cdl . await ( ) ; Thread t = value . get ( ) ; assertNotNull ( t ) ; assertEquals ( expectedThreadName , t . getName ( ) ) ; catch ( Exception e ) fail ( ) ; finally w . dispose ( ) ; 
final String name = "ComputationSchedulerTest" ; ThreadFactory factory = new ThreadFactory ( ) @ Override public Thread newThread ( Runnable r ) return new Thread ( r , name ) ; ; final Scheduler customScheduler = RxJavaPlugins . createComputationScheduler ( factory ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler scheduler ) throws Exception return customScheduler ; ) ; try verifyThread ( Schedulers . computation ( ) , name ) ; finally customScheduler . shutdown ( ) ; RxJavaPlugins . reset ( ) ; 
final String name = "IoSchedulerTest" ; ThreadFactory factory = new ThreadFactory ( ) @ Override public Thread newThread ( Runnable r ) return new Thread ( r , name ) ; ; final Scheduler customScheduler = RxJavaPlugins . createIoScheduler ( factory ) ; RxJavaPlugins . setIoSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler scheduler ) throws Exception return customScheduler ; ) ; try verifyThread ( Schedulers . io ( ) , name ) ; finally customScheduler . shutdown ( ) ; RxJavaPlugins . reset ( ) ; 
final String name = "NewThreadSchedulerTest" ; ThreadFactory factory = new ThreadFactory ( ) @ Override public Thread newThread ( Runnable r ) return new Thread ( r , name ) ; ; final Scheduler customScheduler = RxJavaPlugins . createNewThreadScheduler ( factory ) ; RxJavaPlugins . setNewThreadSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler scheduler ) throws Exception return customScheduler ; ) ; try verifyThread ( Schedulers . newThread ( ) , name ) ; finally customScheduler . shutdown ( ) ; RxJavaPlugins . reset ( ) ; 
final String name = "SingleSchedulerTest" ; ThreadFactory factory = new ThreadFactory ( ) @ Override public Thread newThread ( Runnable r ) return new Thread ( r , name ) ; ; final Scheduler customScheduler = RxJavaPlugins . createSingleScheduler ( factory ) ; RxJavaPlugins . setSingleSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler scheduler ) throws Exception return customScheduler ; ) ; try verifyThread ( Schedulers . single ( ) , name ) ; finally customScheduler . shutdown ( ) ; RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setOnBeforeBlocking ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception throw new IllegalArgumentException ( ) ; ) ; try RxJavaPlugins . onBeforeBlocking ( ) ; fail ( "Should have thrown" ) ; catch ( IllegalArgumentException ex ) finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setOnParallelAssembly ( new Function < ParallelFlowable , ParallelFlowable > ( ) @ Override public ParallelFlowable apply ( ParallelFlowable pf ) throws Exception return new ParallelFromPublisher < > ( Flowable . just ( 2 ) , 2 , 2 ) ; ) ; Flowable . just ( 1 ) . parallel ( ) . sequential ( ) . test ( ) . assertResult ( 2 ) ; finally RxJavaPlugins . reset ( ) ; Flowable . just ( 1 ) . parallel ( ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
assertFalse ( RxJavaPlugins . isBug ( new RuntimeException ( ) ) ) ; assertFalse ( RxJavaPlugins . isBug ( new IOException ( ) ) ) ; assertFalse ( RxJavaPlugins . isBug ( new InterruptedException ( ) ) ) ; assertFalse ( RxJavaPlugins . isBug ( new InterruptedIOException ( ) ) ) ; assertTrue ( RxJavaPlugins . isBug ( new NullPointerException ( ) ) ) ; assertTrue ( RxJavaPlugins . isBug ( new IllegalArgumentException ( ) ) ) ; assertTrue ( RxJavaPlugins . isBug ( new IllegalStateException ( ) ) ) ; assertTrue ( RxJavaPlugins . isBug ( new MissingBackpressureException ( ) ) ) ; assertTrue ( RxJavaPlugins . isBug ( new ProtocolViolationException ( "" ) ) ) ; assertTrue ( RxJavaPlugins . isBug ( new UndeliverableException ( new TestException ( ) ) ) ) ; assertTrue ( RxJavaPlugins . isBug ( new CompositeException ( new TestException ( ) ) ) ) ; assertTrue ( RxJavaPlugins . isBug ( new OnErrorNotImplementedException ( new TestException ( ) ) ) ) ; 
return UnicastProcessor . create ( ) ; 
UnicastProcessor < Integer > ap = UnicastProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; ap . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) ; ts . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ap . onNext ( 1 ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; ap . onComplete ( ) ; ts . assertResult ( 1 ) ; 
UnicastProcessor < Integer > ap = UnicastProcessor . create ( ) ; ap . onNext ( 1 ) ; ap . onComplete ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; ap . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
UnicastProcessor < Integer > ap = UnicastProcessor . create ( false ) ; ap . onNext ( 1 ) ; ap . onError ( new RuntimeException ( ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ap . subscribe ( ts ) ; ts . assertValueCount ( 0 ) . assertError ( RuntimeException . class ) ; 
UnicastProcessor < Integer > ap = UnicastProcessor . create ( false ) ; ap . onNext ( 1 ) ; ap . onError ( new RuntimeException ( ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; ap . subscribe ( ts ) ; ts . assertValueCount ( 0 ) . assertError ( RuntimeException . class ) ; 
Runnable noop = new Runnable ( ) @ Override public void run ( ) ; UnicastProcessor < Integer > ap = UnicastProcessor . create ( 16 , noop , false ) ; ap . onNext ( 1 ) ; ap . onError ( new RuntimeException ( ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ap . subscribe ( ts ) ; ts . assertValueCount ( 0 ) . assertError ( RuntimeException . class ) ; 
final AtomicBoolean didRunOnTerminate = new AtomicBoolean ( ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( Observable . bufferSize ( ) , new Runnable ( ) @ Override public void run ( ) didRunOnTerminate . set ( true ) ; ) ; assertFalse ( didRunOnTerminate . get ( ) ) ; up . onError ( new RuntimeException ( "some error" ) ) ; assertTrue ( didRunOnTerminate . get ( ) ) ; 
final AtomicBoolean didRunOnTerminate = new AtomicBoolean ( ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( Observable . bufferSize ( ) , new Runnable ( ) @ Override public void run ( ) didRunOnTerminate . set ( true ) ; ) ; assertFalse ( didRunOnTerminate . get ( ) ) ; up . onComplete ( ) ; assertTrue ( didRunOnTerminate . get ( ) ) ; 
final AtomicBoolean didRunOnTerminate = new AtomicBoolean ( ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( Observable . bufferSize ( ) , new Runnable ( ) @ Override public void run ( ) didRunOnTerminate . set ( true ) ; ) ; final Disposable subscribe = up . subscribe ( ) ; assertFalse ( didRunOnTerminate . get ( ) ) ; subscribe . dispose ( ) ; assertTrue ( didRunOnTerminate . get ( ) ) ; 
UnicastProcessor . create ( 5 , null ) ; 
UnicastProcessor . create ( - 1 ) ; 
UnicastProcessor . create ( 0 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final int [ ] calls = 0 ; final UnicastProcessor < Object > up = UnicastProcessor . create ( 100 , new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; ) ; final TestSubscriber < Object > ts = up . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) up . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
UnicastProcessor < Object > p = UnicastProcessor . create ( ) ; p . onComplete ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; p . onSubscribe ( bs ) ; p . onNext ( 1 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try p . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; p . onComplete ( ) ; p . test ( ) . assertResult ( ) ; assertNull ( p . getThrowable ( ) ) ; assertTrue ( p . hasComplete ( ) ) ; assertFalse ( p . hasThrowable ( ) ) ; 
UnicastProcessor < Object > p = UnicastProcessor . create ( ) ; assertFalse ( p . hasComplete ( ) ) ; assertFalse ( p . hasThrowable ( ) ) ; assertNull ( p . getThrowable ( ) ) ; TestException ex = new TestException ( ) ; p . onError ( ex ) ; assertFalse ( p . hasComplete ( ) ) ; assertTrue ( p . hasThrowable ( ) ) ; assertSame ( ex , p . getThrowable ( ) ) ; 
UnicastProcessor < Object > p = UnicastProcessor . create ( ) ; TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; p . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) ; 
UnicastProcessor . create ( ) . test ( 0L , true ) . assertEmpty ( ) ; 
UnicastProcessor < Object > p = UnicastProcessor . create ( ) ; TestSubscriber < Object > ts = p . test ( ) ; p . test ( ) . assertFailure ( IllegalStateException . class ) ; p . onNext ( 1 ) ; p . onComplete ( ) ; ts . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final UnicastProcessor < Object > p = UnicastProcessor . create ( ) ; final TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; p . subscribe ( ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) p . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; final TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; final TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) up . subscribe ( ts1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) up . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts1 . errors ( ) . size ( ) == 0 ) ts2 . assertFailure ( IllegalStateException . class ) ; else if ( ts2 . errors ( ) . size ( ) == 0 ) ts1 . assertFailure ( IllegalStateException . class ) ; else fail ( "Neither TestObserver failed" ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; assertFalse ( up . hasSubscribers ( ) ) ; TestSubscriber < Integer > ts = up . test ( ) ; assertTrue ( up . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( up . hasSubscribers ( ) ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( false ) ; TestSubscriberEx < Integer > ts = up . to ( TestHelper . < Integer > testSubscriber ( 1 , QueueFuseable . ANY , false ) ) ; up . done = true ; up . drainFused ( ts ) ; ts . assertResult ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( false ) ; TestSubscriberEx < Integer > ts = up . to ( TestHelper . < Integer > testSubscriber ( 1 , QueueFuseable . ANY , false ) ) ; up . drainFused ( ts ) ; ts . assertEmpty ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( false ) ; TestSubscriberEx < Integer > ts = up . to ( TestHelper . < Integer > testSubscriber ( 1 , QueueFuseable . ANY , false ) ) ; up . checkTerminated ( true , true , false , ts , up . queue ) ; ts . assertEmpty ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( false ) ; up . test ( ) . cancel ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; up . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try up . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( false ) ; UnicastProcessor < Integer > . UnicastQueueSubscription usc = ( UnicastProcessor < Integer > . UnicastQueueSubscription ) up . wip ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try usc . request ( - 1 ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int j = 0 ; j < TestHelper . RACE_LONG_LOOPS ; j ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestObserver < Integer > to = up . observeOn ( Schedulers . io ( ) ) . map ( Functions . < Integer > identity ( ) ) . observeOn ( Schedulers . single ( ) ) . firstOrError ( ) . test ( ) ; for ( int i = 0 ; up . hasSubscribers ( ) ; i ++ ) up . onNext ( i ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( ! errors . isEmpty ( ) ) throw new CompositeException ( errors ) ; to . assertResult ( 0 ) ; finally RxJavaPlugins . reset ( ) ; 
return PublishProcessor . create ( ) ; 
PublishProcessor < String > processor = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; Subscriber < String > anotherSubscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( anotherSubscriber ) ; processor . onNext ( "four" ) ; processor . onComplete ( ) ; processor . onError ( new Throwable ( ) ) ; assertCompletedSubscriber ( subscriber ) ; 
PublishProcessor < Object > channel = PublishProcessor . create ( ) ; Subscriber < Object > observerA = TestHelper . mockSubscriber ( ) ; Subscriber < Object > observerB = TestHelper . mockSubscriber ( ) ; Subscriber < Object > observerC = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( observerA ) ; channel . subscribe ( ts ) ; channel . subscribe ( observerB ) ; InOrder inOrderA = inOrder ( observerA ) ; InOrder inOrderB = inOrder ( observerB ) ; InOrder inOrderC = inOrder ( observerC ) ; channel . onNext ( 42 ) ; inOrderA . verify ( observerA ) . onNext ( 42 ) ; inOrderB . verify ( observerB ) . onNext ( 42 ) ; ts . cancel ( ) ; inOrderA . verifyNoMoreInteractions ( ) ; channel . onNext ( 4711 ) ; inOrderB . verify ( observerB ) . onNext ( 4711 ) ; channel . onComplete ( ) ; inOrderB . verify ( observerB ) . onComplete ( ) ; channel . subscribe ( observerC ) ; inOrderC . verify ( observerC ) . onComplete ( ) ; channel . onNext ( 13 ) ; inOrderB . verifyNoMoreInteractions ( ) ; inOrderC . verifyNoMoreInteractions ( ) ; 
verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
PublishProcessor < String > processor = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; processor . onError ( testException ) ; Subscriber < String > anotherSubscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( anotherSubscriber ) ; processor . onNext ( "four" ) ; processor . onError ( new Throwable ( ) ) ; processor . onComplete ( ) ; assertErrorSubscriber ( subscriber ) ; 
verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onError ( testException ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
PublishProcessor < String > processor = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; assertObservedUntilTwo ( subscriber ) ; Subscriber < String > anotherSubscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( anotherSubscriber ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; assertCompletedSubscriber ( subscriber ) ; assertCompletedStartingWithThreeSubscriber ( anotherSubscriber ) ; 
verify ( subscriber , Mockito . never ( ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
PublishProcessor < String > processor = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; processor . subscribe ( ts ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; ts . cancel ( ) ; assertObservedUntilTwo ( subscriber ) ; Subscriber < String > anotherSubscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( anotherSubscriber ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; assertObservedUntilTwo ( subscriber ) ; assertCompletedStartingWithThreeSubscriber ( anotherSubscriber ) ; 
verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
final PublishProcessor < Integer > s = PublishProcessor . create ( ) ; final AtomicInteger countParent = new AtomicInteger ( ) ; final AtomicInteger countChildren = new AtomicInteger ( ) ; final AtomicInteger countTotal = new AtomicInteger ( ) ; final ArrayList < String > list = new ArrayList < > ( ) ; s . flatMap ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final Integer v ) countParent . incrementAndGet ( ) ; return s . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer v2 ) countChildren . incrementAndGet ( ) ; return "Parent: " + v + " Child: " + v2 ; ) ; ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) countTotal . incrementAndGet ( ) ; list . add ( v ) ; ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; s . onComplete ( ) ; assertEquals ( 45 , list . size ( ) ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Subscriber < Integer > subscriber1 = TestHelper . mockSubscriber ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( subscriber1 ) ; pp . subscribe ( ts ) ; pp . onNext ( 1 ) ; InOrder inOrder1 = inOrder ( subscriber1 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder1 . verifyNoMoreInteractions ( ) ; ts . cancel ( ) ; pp . onNext ( 2 ) ; Subscriber < Integer > subscriber2 = TestHelper . mockSubscriber ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( subscriber2 ) ; pp . subscribe ( ts2 ) ; pp . onNext ( 3 ) ; InOrder inOrder2 = inOrder ( subscriber2 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 3 ) ; inOrder2 . verifyNoMoreInteractions ( ) ; ts2 . cancel ( ) ; 
PublishProcessor < String > src = PublishProcessor . create ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; String v = "" + i ; System . out . printf ( "Turn: %d%n" , i ) ; src . firstElement ( ) . toFlowable ( ) . flatMap ( new Function < String , Flowable < String > > ( ) @ Override public Flowable < String > apply ( String t1 ) return Flowable . just ( t1 + ", " + t1 ) ; ) . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onNext ( String t ) subscriber . onNext ( t ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ) ; src . onNext ( v ) ; inOrder . verify ( subscriber ) . onNext ( v + ", " + v ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Object > as = PublishProcessor . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 1 ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
PublishProcessor < Object > as = PublishProcessor . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
PublishProcessor < Object > as = PublishProcessor . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onError ( new TestException ( ) ) ; assertTrue ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertTrue ( as . getThrowable ( ) instanceof TestException ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable . range ( 1 , 10 ) . subscribe ( pp ) ; assertTrue ( pp . hasComplete ( ) ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; pp2 . subscribe ( pp ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; 
TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) ) ; 
final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ts1 . cancel ( ) ; ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . subscribe ( ts2 ) ; pp . subscribe ( ts1 ) ; pp . onNext ( 1 ) ; ts2 . assertValue ( 1 ) ; ts1 . assertNoValues ( ) ; 
final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onError ( Throwable t ) super . onError ( t ) ; ts1 . cancel ( ) ; ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . subscribe ( ts2 ) ; pp . subscribe ( ts1 ) ; pp . onError ( new TestException ( ) ) ; ts2 . assertError ( TestException . class ) ; ts1 . assertNoErrors ( ) ; 
final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onComplete ( ) super . onComplete ( ) ; ts1 . cancel ( ) ; ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . subscribe ( ts2 ) ; pp . subscribe ( ts1 ) ; pp . onComplete ( ) ; ts2 . assertComplete ( ) ; ts1 . assertNotComplete ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . test ( 0L ) ; pp . onNext ( 1 ) ; ts . assertNoValues ( ) . assertNotComplete ( ) . assertError ( MissingBackpressureException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . test ( ) ; pp . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) s . cancel ( ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . test ( ) ; Runnable task = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; TestHelper . race ( task , task ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . subscribe ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . test ( 0 ) ; assertFalse ( pp . offer ( 1 ) ) ; ts . request ( 1 ) ; assertTrue ( pp . offer ( 1 ) ) ; assertFalse ( pp . offer ( 2 ) ) ; ts . cancel ( ) ; assertTrue ( pp . offer ( 2 ) ) ; ts = pp . test ( 0 ) ; try pp . offer ( null ) ; fail ( "Should have thrown NPE!" ) ; catch ( NullPointerException expected ) ts . assertEmpty ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) while ( ! pp . hasSubscribers ( ) ) try Thread . sleep ( 1 ) ; catch ( InterruptedException ex ) return ; for ( int i = 1 ; i <= 10 ; i ++ ) while ( ! pp . offer ( i ) ) pp . onComplete ( ) ; ) ; Thread . sleep ( 1 ) ; pp . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . test ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 2 ; i ++ ) while ( ! pp . offer ( i ) ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . values ( ) . size ( ) > 0 ) ts . assertValuesOnly ( 0 ) ; else ts . assertEmpty ( ) ; 
return BehaviorProcessor . create ( ) ; 
BehaviorProcessor < String > processor = BehaviorProcessor . createDefault ( "default" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "default" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( testException ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
BehaviorProcessor < String > processor = BehaviorProcessor . createDefault ( "default" ) ; processor . onNext ( "one" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "default" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( testException ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
BehaviorProcessor < String > processor = BehaviorProcessor . createDefault ( "default" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "default" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
BehaviorProcessor < String > processor = BehaviorProcessor . createDefault ( "default" ) ; processor . onNext ( "one" ) ; processor . onComplete ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( "default" ) ; verify ( subscriber , never ( ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
BehaviorProcessor < String > processor = BehaviorProcessor . createDefault ( "default" ) ; processor . onNext ( "one" ) ; RuntimeException re = new RuntimeException ( "test error" ) ; processor . onError ( re ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( "default" ) ; verify ( subscriber , never ( ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onError ( re ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
BehaviorProcessor < Integer > channel = BehaviorProcessor . createDefault ( 2013 ) ; Subscriber < Object > observerA = TestHelper . mockSubscriber ( ) ; Subscriber < Object > observerB = TestHelper . mockSubscriber ( ) ; Subscriber < Object > observerC = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( observerA ) ; channel . subscribe ( ts ) ; channel . subscribe ( observerB ) ; InOrder inOrderA = inOrder ( observerA ) ; InOrder inOrderB = inOrder ( observerB ) ; InOrder inOrderC = inOrder ( observerC ) ; inOrderA . verify ( observerA ) . onNext ( 2013 ) ; inOrderB . verify ( observerB ) . onNext ( 2013 ) ; channel . onNext ( 42 ) ; inOrderA . verify ( observerA ) . onNext ( 42 ) ; inOrderB . verify ( observerB ) . onNext ( 42 ) ; ts . cancel ( ) ; inOrderA . verifyNoMoreInteractions ( ) ; channel . onNext ( 4711 ) ; inOrderB . verify ( observerB ) . onNext ( 4711 ) ; channel . onComplete ( ) ; inOrderB . verify ( observerB ) . onComplete ( ) ; channel . subscribe ( observerC ) ; inOrderC . verify ( observerC ) . onComplete ( ) ; channel . onNext ( 13 ) ; inOrderB . verifyNoMoreInteractions ( ) ; inOrderC . verifyNoMoreInteractions ( ) ; 
BehaviorProcessor < String > processor = BehaviorProcessor . createDefault ( "default" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onError ( testException ) ; processor . onNext ( "two" ) ; processor . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "default" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onError ( testException ) ; verify ( subscriber , never ( ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
BehaviorProcessor < String > processor = BehaviorProcessor . createDefault ( "default" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onError ( testException ) ; processor . onNext ( "two" ) ; processor . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "default" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onError ( testException ) ; verify ( subscriber , never ( ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; Subscriber < Object > subscriber2 = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber2 ) ; verify ( subscriber2 , times ( 1 ) ) . onError ( testException ) ; verify ( subscriber2 , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber2 , never ( ) ) . onComplete ( ) ; 
BehaviorProcessor < String > processor = BehaviorProcessor . createDefault ( "default" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onComplete ( ) ; processor . onNext ( "two" ) ; processor . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "default" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( "two" ) ; Subscriber < Object > subscriber2 = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber2 ) ; verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber2 , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
BehaviorProcessor < String > src = BehaviorProcessor . createDefault ( "null" ) ; for ( int i = 0 ; i < 10 ; i ++ ) final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; String v = "" + i ; src . onNext ( v ) ; System . out . printf ( "Turn: %d%n" , i ) ; src . firstElement ( ) . toFlowable ( ) . flatMap ( new Function < String , Flowable < String > > ( ) @ Override public Flowable < String > apply ( String t1 ) return Flowable . just ( t1 + ", " + t1 ) ; ) . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onNext ( String t ) subscriber . onNext ( t ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ) ; inOrder . verify ( subscriber ) . onNext ( v + ", " + v ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . create ( ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . subscribe ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; source . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . create ( ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . onNext ( 1 ) ; source . subscribe ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; source . onComplete ( ) ; source . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . create ( ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; source . onNext ( 2 ) ; source . subscribe ( subscriber ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . take ( 1 ) . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; assertEquals ( 0 , source . subscriberCount ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
Scheduler s = Schedulers . io ( ) ; Scheduler . Worker worker = Schedulers . io ( ) . createWorker ( ) ; try for ( int i = 0 ; i < 50000 ; i ++ ) if ( i % 1000 == 0 ) System . out . println ( i ) ; final BehaviorProcessor < Object > rs = BehaviorProcessor . create ( ) ; final CountDownLatch finish = new CountDownLatch ( 1 ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) try start . await ( ) ; catch ( Exception e1 ) e1 . printStackTrace ( ) ; rs . onNext ( 1 ) ; ) ; final AtomicReference < Object > o = new AtomicReference < > ( ) ; rs . subscribeOn ( s ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new DefaultSubscriber < Object > ( ) @ Override public void onComplete ( ) o . set ( - 1 ) ; finish . countDown ( ) ; @ Override public void onError ( Throwable e ) o . set ( e ) ; finish . countDown ( ) ; @ Override public void onNext ( Object t ) o . set ( t ) ; finish . countDown ( ) ; ) ; start . countDown ( ) ; if ( ! finish . await ( 5 , TimeUnit . SECONDS ) ) System . out . println ( o . get ( ) ) ; System . out . println ( rs . hasSubscribers ( ) ) ; rs . onComplete ( ) ; Assert . fail ( "Timeout @ " + i ) ; break ; else Assert . assertEquals ( 1 , o . get ( ) ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) rs . onComplete ( ) ; ) ; finally worker . dispose ( ) ; 
BehaviorProcessor < Object > as = BehaviorProcessor . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 1 ) ; assertTrue ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertEquals ( 1 , as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
BehaviorProcessor < Object > as = BehaviorProcessor . createDefault ( ( Object ) 1 ) ; assertTrue ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertEquals ( 1 , as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 2 ) ; assertTrue ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertEquals ( 2 , as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
BehaviorProcessor < Object > as = BehaviorProcessor . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
BehaviorProcessor < Object > as = BehaviorProcessor . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onError ( new TestException ( ) ) ; assertFalse ( as . hasValue ( ) ) ; assertTrue ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertTrue ( as . getThrowable ( ) instanceof TestException ) ; 
BehaviorProcessor < Object > p = BehaviorProcessor . create ( ) ; assertFalse ( p . hasSubscribers ( ) ) ; p . test ( 0L , true ) . assertEmpty ( ) ; assertFalse ( p . hasSubscribers ( ) ) ; 
BehaviorProcessor < Object > p = BehaviorProcessor . create ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; p . onSubscribe ( bs ) ; assertFalse ( bs . isCancelled ( ) ) ; p . onComplete ( ) ; bs = new BooleanSubscription ( ) ; p . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; 
BehaviorProcessor < Object > p = BehaviorProcessor . create ( ) ; p . onComplete ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try p . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
BehaviorProcessor < Object > p = BehaviorProcessor . create ( ) ; TestSubscriber < Object > ts = p . test ( ) ; p . test ( 0L , true ) . assertEmpty ( ) ; p . onNext ( 1 ) ; p . onComplete ( ) ; ts . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorProcessor < Object > p = BehaviorProcessor . create ( ) ; final TestSubscriber < Object > ts = p . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) p . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorProcessor < Object > p = BehaviorProcessor . create ( ) ; final TestSubscriber < Object > ts1 = p . test ( ) ; final TestSubscriber < Object > ts2 = p . test ( ) ; final TestSubscriber < Object > ts3 = p . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts2 . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; p . onNext ( 1 ) ; ts3 . assertValuesOnly ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorProcessor < Object > p = BehaviorProcessor . createDefault ( ( Object ) 1 ) ; final TestSubscriber [ ] ts = null ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts [ 0 ] = p . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) p . onNext ( 2 ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts [ 0 ] . values ( ) . size ( ) == 1 ) ts [ 0 ] . assertValue ( 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; else ts [ 0 ] . assertValues ( 1 , 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
BehaviorProcessor < Object > p = BehaviorProcessor . createDefault ( ( Object ) 1 ) ; p . test ( 0L , false ) . assertFailure ( MissingBackpressureException . class ) ; assertFalse ( p . hasSubscribers ( ) ) ; 
BehaviorProcessor < Integer > pp = BehaviorProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . test ( 0 ) ; assertFalse ( pp . offer ( 1 ) ) ; ts . request ( 1 ) ; assertTrue ( pp . offer ( 1 ) ) ; assertFalse ( pp . offer ( 2 ) ) ; ts . cancel ( ) ; assertTrue ( pp . offer ( 2 ) ) ; ts = pp . test ( 1 ) ; try pp . offer ( null ) ; fail ( "Should have thrown NPE!" ) ; catch ( NullPointerException expected ) ts . assertValuesOnly ( 2 ) ; 
final BehaviorProcessor < Integer > pp = BehaviorProcessor . create ( ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) while ( ! pp . hasSubscribers ( ) ) try Thread . sleep ( 1 ) ; catch ( InterruptedException ex ) return ; for ( int i = 1 ; i <= 10 ; i ++ ) while ( ! pp . offer ( i ) ) pp . onComplete ( ) ; ) ; Thread . sleep ( 1 ) ; pp . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorProcessor < Object > p = BehaviorProcessor . create ( ) ; final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) p . subscribe ( ts ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) p . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorProcessor < Object > p = BehaviorProcessor . create ( ) ; final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) p . subscribe ( ts ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) p . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorProcessor < Integer > pp = BehaviorProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . test ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 2 ; i ++ ) while ( ! pp . offer ( i ) ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . values ( ) . size ( ) > 0 ) ts . assertValuesOnly ( 0 ) ; else ts . assertEmpty ( ) ; 
BehaviorProcessor < Integer > bp = BehaviorProcessor . create ( ) ; bp . onNext ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; BehaviorSubscription < Integer > bs = new BehaviorSubscription < > ( ts , bp ) ; ts . onSubscribe ( bs ) ; assertFalse ( bs . cancelled ) ; bs . cancel ( ) ; assertTrue ( bs . cancelled ) ; bs . cancel ( ) ; assertTrue ( bs . cancelled ) ; assertTrue ( bs . test ( 2 ) ) ; bs . emitFirst ( ) ; ts . assertEmpty ( ) ; bs . emitNext ( 2 , 0 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) BehaviorProcessor < Integer > bp = BehaviorProcessor . create ( ) ; bp . onNext ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final BehaviorSubscription < Integer > bs = new BehaviorSubscription < > ( ts , bp ) ; ts . onSubscribe ( bs ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) bs . emitFirst ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) bs . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) BehaviorProcessor < Integer > bp = BehaviorProcessor . create ( ) ; bp . onNext ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final BehaviorSubscription < Integer > bs = new BehaviorSubscription < > ( ts , bp ) ; ts . onSubscribe ( bs ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) bs . emitNext ( 2 , 0 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) bs . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
BehaviorProcessor < Integer > bp = BehaviorProcessor . create ( ) ; bp . onNext ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final BehaviorSubscription < Integer > bs = new BehaviorSubscription < > ( ts , bp ) ; ts . onSubscribe ( bs ) ; bs . emitting = true ; bs . emitNext ( 2 , 1 ) ; bs . emitNext ( 3 , 2 ) ; assertNotNull ( bs . queue ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BehaviorProcessor < Integer > bp = BehaviorProcessor . create ( ) ; bp . onNext ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final BehaviorSubscription < Integer > bs = new BehaviorSubscription < > ( ts , bp ) ; ts . onSubscribe ( bs ) ; bs . request ( - 1 ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final ReplayProcessor < Long > replay = ReplayProcessor . createUnbounded ( ) ; Thread source = new Thread ( new Runnable ( ) @ Override public void run ( ) Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( Subscriber < ? super Long > subscriber ) System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) subscriber . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; subscriber . onComplete ( ) ; ) . subscribe ( replay ) ; ) ; source . start ( ) ; long v = replay . blockingLast ( ) ; assertEquals ( 10000 , v ) ; final CountDownLatch slowLatch = new CountDownLatch ( 1 ) ; Thread slowThread = new Thread ( new Runnable ( ) @ Override public void run ( ) Subscriber < Long > slow = new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "*** Slow Observer completed" ) ; slowLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long args ) if ( args == 1 ) System . out . println ( "*** Slow Observer STARTED" ) ; try if ( args % 10 == 0 ) Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; ; replay . subscribe ( slow ) ; try slowLatch . await ( ) ; catch ( InterruptedException e1 ) e1 . printStackTrace ( ) ; ) ; slowThread . start ( ) ; Thread fastThread = new Thread ( new Runnable ( ) @ Override public void run ( ) final CountDownLatch fastLatch = new CountDownLatch ( 1 ) ; Subscriber < Long > fast = new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "*** Fast Observer completed" ) ; fastLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long args ) if ( args == 1 ) System . out . println ( "*** Fast Observer STARTED" ) ; ; replay . subscribe ( fast ) ; try fastLatch . await ( ) ; catch ( InterruptedException e1 ) e1 . printStackTrace ( ) ; ) ; fastThread . start ( ) ; fastThread . join ( ) ; assertEquals ( 1 , slowLatch . getCount ( ) ) ; slowThread . join ( ) ; 
Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( Subscriber < ? super Long > subscriber ) System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) subscriber . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; subscriber . onComplete ( ) ; ) . subscribe ( replay ) ; 
final ReplayProcessor < Long > replay = ReplayProcessor . createUnbounded ( ) ; Thread source = new Thread ( new Runnable ( ) @ Override public void run ( ) Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( Subscriber < ? super Long > subscriber ) System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) subscriber . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; subscriber . onComplete ( ) ; ) . subscribe ( replay ) ; ) ; final List < List < Long > > listOfListsOfValues = Collections . synchronizedList ( new ArrayList < > ( ) ) ; final List < Thread > threads = Collections . synchronizedList ( new ArrayList < > ( ) ) ; for ( int i = 1 ; i <= 200 ; i ++ ) final int count = i ; if ( count == 20 ) source . start ( ) ; if ( count == 100 ) source . join ( ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) List < Long > values = replay . toList ( ) . blockingGet ( ) ; listOfListsOfValues . add ( values ) ; System . out . println ( "Finished thread: " + count ) ; ) ; t . start ( ) ; System . out . println ( "Started thread: " + i ) ; threads . add ( t ) ; for ( Thread t : threads ) t . join ( ) ; List < Long > sums = new ArrayList < > ( ) ; for ( List < Long > values : listOfListsOfValues ) long v = 0 ; for ( long l : values ) v += l ; sums . add ( v ) ; long expected = sums . get ( 0 ) ; boolean success = true ; for ( long l : sums ) if ( l != expected ) success = false ; System . out . println ( "FAILURE => Expected " + expected + " but got: " + l ) ; if ( success ) System . out . println ( "Success! " + sums . size ( ) + " each had the same sum of " + expected ) ; else throw new RuntimeException ( "Concurrency Bug" ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final ReplayProcessor < String > processor = ReplayProcessor . createUnbounded ( ) ; final AtomicReference < String > value1 = new AtomicReference < > ( ) ; processor . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; value1 . set ( t1 ) ; ) ; Thread t1 = new Thread ( new Runnable ( ) @ Override public void run ( ) processor . onNext ( "value" ) ; processor . onComplete ( ) ; ) ; SubjectObserverThread t2 = new SubjectObserverThread ( processor ) ; SubjectObserverThread t3 = new SubjectObserverThread ( processor ) ; SubjectObserverThread t4 = new SubjectObserverThread ( processor ) ; SubjectObserverThread t5 = new SubjectObserverThread ( processor ) ; t2 . start ( ) ; t3 . start ( ) ; t1 . start ( ) ; t4 . start ( ) ; t5 . start ( ) ; try t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; t4 . join ( ) ; t5 . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertEquals ( "value" , value1 . get ( ) ) ; assertEquals ( "value" , t2 . value . get ( ) ) ; assertEquals ( "value" , t3 . value . get ( ) ) ; assertEquals ( "value" , t4 . value . get ( ) ) ; assertEquals ( "value" , t5 . value . get ( ) ) ; 
final List < Integer > expected = Arrays . asList ( 1 ) ; for ( int i = 0 ; i < 100000 ; i ++ ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . cache ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueSequence ( expected ) ; ts . assertTerminated ( ) ; 
Scheduler s = Schedulers . io ( ) ; Scheduler . Worker worker = Schedulers . io ( ) . createWorker ( ) ; try for ( int i = 0 ; i < 50000 ; i ++ ) if ( i % 1000 == 0 ) System . out . println ( i ) ; final ReplayProcessor < Object > rs = ReplayProcessor . createWithSize ( 2 ) ; final CountDownLatch finish = new CountDownLatch ( 1 ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) try start . await ( ) ; catch ( Exception e1 ) e1 . printStackTrace ( ) ; rs . onNext ( 1 ) ; ) ; final AtomicReference < Object > o = new AtomicReference < > ( ) ; rs . subscribeOn ( s ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new DefaultSubscriber < Object > ( ) @ Override protected void onStart ( ) super . onStart ( ) ; @ Override public void onComplete ( ) o . set ( - 1 ) ; finish . countDown ( ) ; @ Override public void onError ( Throwable e ) o . set ( e ) ; finish . countDown ( ) ; @ Override public void onNext ( Object t ) o . set ( t ) ; finish . countDown ( ) ; ) ; start . countDown ( ) ; if ( ! finish . await ( 5 , TimeUnit . SECONDS ) ) System . out . println ( o . get ( ) ) ; System . out . println ( rs . hasSubscribers ( ) ) ; rs . onComplete ( ) ; Assert . fail ( "Timeout @ " + i ) ; break ; else Assert . assertEquals ( 1 , o . get ( ) ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) rs . onComplete ( ) ; ) ; finally worker . dispose ( ) ; 
final ReplayProcessor < Object > rs = ReplayProcessor . createUnbounded ( ) ; final CyclicBarrier cb = new CyclicBarrier ( 2 ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( int i = 0 ; i < 1000000 ; i ++ ) rs . onNext ( i ) ; rs . onComplete ( ) ; System . out . println ( "Replay fill Thread finished!" ) ; ) ; t . start ( ) ; try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; int lastSize = 0 ; for ( ; ! rs . hasThrowable ( ) && ! rs . hasComplete ( ) ; ) int size = rs . size ( ) ; boolean hasAny = rs . hasValue ( ) ; Object [ ] values = rs . getValues ( ) ; if ( size < lastSize ) Assert . fail ( "Size decreased! " + lastSize + " -> " + size ) ; if ( ( size > 0 ) && ! hasAny ) Assert . fail ( "hasAnyValue reports emptyness but size doesn't" ) ; if ( size > values . length ) Assert . fail ( "Got fewer values than size! " + size + " -> " + values . length ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) Integer v1 = ( Integer ) values [ i ] ; Integer v2 = ( Integer ) values [ i + 1 ] ; assertEquals ( 1 , v2 - v1 ) ; lastSize = size ; t . join ( ) ; 
final ReplayProcessor < Object > rs = ReplayProcessor . createWithSize ( 3 ) ; final CyclicBarrier cb = new CyclicBarrier ( 2 ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( int i = 0 ; i < 1000000 ; i ++ ) rs . onNext ( i ) ; rs . onComplete ( ) ; System . out . println ( "Replay fill Thread finished!" ) ; ) ; t . start ( ) ; try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( ; ! rs . hasThrowable ( ) && ! rs . hasComplete ( ) ; ) rs . size ( ) ; rs . hasValue ( ) ; Object [ ] values = rs . getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) Integer v1 = ( Integer ) values [ i ] ; Integer v2 = ( Integer ) values [ i + 1 ] ; assertEquals ( 1 , v2 - v1 ) ; t . join ( ) ; 
final ReplayProcessor < Object > rs = ReplayProcessor . createWithTime ( 1 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; final CyclicBarrier cb = new CyclicBarrier ( 2 ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( int i = 0 ; i < 1000000 ; i ++ ) rs . onNext ( i ) ; if ( i % 10000 == 0 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return ; rs . onComplete ( ) ; System . out . println ( "Replay fill Thread finished!" ) ; ) ; t . start ( ) ; try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( ; ! rs . hasThrowable ( ) && ! rs . hasComplete ( ) ; ) rs . size ( ) ; rs . hasValue ( ) ; Object [ ] values = rs . getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) Integer v1 = ( Integer ) values [ i ] ; Integer v2 = ( Integer ) values [ i + 1 ] ; assertEquals ( 1 , v2 - v1 ) ; t . join ( ) ; 
final ReplayProcessor < Long > replay = ReplayProcessor . create ( ) ; Thread source = new Thread ( new Runnable ( ) @ Override public void run ( ) Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( Subscriber < ? super Long > subscriber ) System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) subscriber . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; subscriber . onComplete ( ) ; ) . subscribe ( replay ) ; ) ; source . start ( ) ; long v = replay . blockingLast ( ) ; assertEquals ( 10000 , v ) ; final CountDownLatch slowLatch = new CountDownLatch ( 1 ) ; Thread slowThread = new Thread ( new Runnable ( ) @ Override public void run ( ) Subscriber < Long > slow = new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "*** Slow Observer completed" ) ; slowLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long args ) if ( args == 1 ) System . out . println ( "*** Slow Observer STARTED" ) ; try if ( args % 10 == 0 ) Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; ; replay . subscribe ( slow ) ; try slowLatch . await ( ) ; catch ( InterruptedException e1 ) e1 . printStackTrace ( ) ; ) ; slowThread . start ( ) ; Thread fastThread = new Thread ( new Runnable ( ) @ Override public void run ( ) final CountDownLatch fastLatch = new CountDownLatch ( 1 ) ; Subscriber < Long > fast = new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "*** Fast Observer completed" ) ; fastLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long args ) if ( args == 1 ) System . out . println ( "*** Fast Observer STARTED" ) ; ; replay . subscribe ( fast ) ; try fastLatch . await ( ) ; catch ( InterruptedException e1 ) e1 . printStackTrace ( ) ; ) ; fastThread . start ( ) ; fastThread . join ( ) ; assertEquals ( 1 , slowLatch . getCount ( ) ) ; slowThread . join ( ) ; 
Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( Subscriber < ? super Long > subscriber ) System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) subscriber . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; subscriber . onComplete ( ) ; ) . subscribe ( replay ) ; 
final ReplayProcessor < Long > replay = ReplayProcessor . create ( ) ; Thread source = new Thread ( new Runnable ( ) @ Override public void run ( ) Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( Subscriber < ? super Long > subscriber ) System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) subscriber . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; subscriber . onComplete ( ) ; ) . subscribe ( replay ) ; ) ; final List < List < Long > > listOfListsOfValues = Collections . synchronizedList ( new ArrayList < > ( ) ) ; final List < Thread > threads = Collections . synchronizedList ( new ArrayList < > ( ) ) ; for ( int i = 1 ; i <= 200 ; i ++ ) final int count = i ; if ( count == 20 ) source . start ( ) ; if ( count == 100 ) source . join ( ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) List < Long > values = replay . toList ( ) . blockingGet ( ) ; listOfListsOfValues . add ( values ) ; System . out . println ( "Finished thread: " + count ) ; ) ; t . start ( ) ; System . out . println ( "Started thread: " + i ) ; threads . add ( t ) ; for ( Thread t : threads ) t . join ( ) ; List < Long > sums = new ArrayList < > ( ) ; for ( List < Long > values : listOfListsOfValues ) long v = 0 ; for ( long l : values ) v += l ; sums . add ( v ) ; long expected = sums . get ( 0 ) ; boolean success = true ; for ( long l : sums ) if ( l != expected ) success = false ; System . out . println ( "FAILURE => Expected " + expected + " but got: " + l ) ; if ( success ) System . out . println ( "Success! " + sums . size ( ) + " each had the same sum of " + expected ) ; else throw new RuntimeException ( "Concurrency Bug" ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final ReplayProcessor < String > processor = ReplayProcessor . create ( ) ; final AtomicReference < String > value1 = new AtomicReference < > ( ) ; processor . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; value1 . set ( t1 ) ; ) ; Thread t1 = new Thread ( new Runnable ( ) @ Override public void run ( ) processor . onNext ( "value" ) ; processor . onComplete ( ) ; ) ; SubjectObserverThread t2 = new SubjectObserverThread ( processor ) ; SubjectObserverThread t3 = new SubjectObserverThread ( processor ) ; SubjectObserverThread t4 = new SubjectObserverThread ( processor ) ; SubjectObserverThread t5 = new SubjectObserverThread ( processor ) ; t2 . start ( ) ; t3 . start ( ) ; t1 . start ( ) ; t4 . start ( ) ; t5 . start ( ) ; try t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; t4 . join ( ) ; t5 . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertEquals ( "value" , value1 . get ( ) ) ; assertEquals ( "value" , t2 . value . get ( ) ) ; assertEquals ( "value" , t3 . value . get ( ) ) ; assertEquals ( "value" , t4 . value . get ( ) ) ; assertEquals ( "value" , t5 . value . get ( ) ) ; 
final List < Integer > expected = Arrays . asList ( 1 ) ; for ( int i = 0 ; i < 100000 ; i ++ ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . cache ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueSequence ( expected ) ; ts . assertTerminated ( ) ; 
Scheduler s = Schedulers . io ( ) ; Scheduler . Worker worker = Schedulers . io ( ) . createWorker ( ) ; try for ( int i = 0 ; i < 50000 ; i ++ ) if ( i % 1000 == 0 ) System . out . println ( i ) ; final ReplayProcessor < Object > rs = ReplayProcessor . create ( ) ; final CountDownLatch finish = new CountDownLatch ( 1 ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) try start . await ( ) ; catch ( Exception e1 ) e1 . printStackTrace ( ) ; rs . onNext ( 1 ) ; ) ; final AtomicReference < Object > o = new AtomicReference < > ( ) ; rs . subscribeOn ( s ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new DefaultSubscriber < Object > ( ) @ Override public void onComplete ( ) o . set ( - 1 ) ; finish . countDown ( ) ; @ Override public void onError ( Throwable e ) o . set ( e ) ; finish . countDown ( ) ; @ Override public void onNext ( Object t ) o . set ( t ) ; finish . countDown ( ) ; ) ; start . countDown ( ) ; if ( ! finish . await ( 5 , TimeUnit . SECONDS ) ) System . out . println ( o . get ( ) ) ; System . out . println ( rs . hasSubscribers ( ) ) ; rs . onComplete ( ) ; Assert . fail ( "Timeout @ " + i ) ; break ; else Assert . assertEquals ( 1 , o . get ( ) ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) rs . onComplete ( ) ; ) ; finally worker . dispose ( ) ; 
final ReplayProcessor < Object > rs = ReplayProcessor . create ( ) ; final CyclicBarrier cb = new CyclicBarrier ( 2 ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( int i = 0 ; i < 1000000 ; i ++ ) rs . onNext ( i ) ; rs . onComplete ( ) ; System . out . println ( "Replay fill Thread finished!" ) ; ) ; t . start ( ) ; try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; int lastSize = 0 ; for ( ; ! rs . hasThrowable ( ) && ! rs . hasComplete ( ) ; ) int size = rs . size ( ) ; boolean hasAny = rs . hasValue ( ) ; Object [ ] values = rs . getValues ( ) ; if ( size < lastSize ) Assert . fail ( "Size decreased! " + lastSize + " -> " + size ) ; if ( ( size > 0 ) && ! hasAny ) Assert . fail ( "hasAnyValue reports emptyness but size doesn't" ) ; if ( size > values . length ) Assert . fail ( "Got fewer values than size! " + size + " -> " + values . length ) ; lastSize = size ; t . join ( ) ; 
return ReplayProcessor . create ( ) ; 
ReplayProcessor < String > processor = ReplayProcessor . create ( ) ; Subscriber < String > subscriber1 = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber1 ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; processor . onNext ( "four" ) ; processor . onComplete ( ) ; processor . onError ( new Throwable ( ) ) ; assertCompletedSubscriber ( subscriber1 ) ; Subscriber < String > subscriber2 = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber2 ) ; assertCompletedSubscriber ( subscriber2 ) ; 
ReplayProcessor < Integer > channel = ReplayProcessor . create ( ) ; Subscriber < Object > observerA = TestHelper . mockSubscriber ( ) ; Subscriber < Object > observerB = TestHelper . mockSubscriber ( ) ; Subscriber < Object > observerC = TestHelper . mockSubscriber ( ) ; Subscriber < Object > observerD = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( observerA ) ; channel . subscribe ( ts ) ; channel . subscribe ( observerB ) ; InOrder inOrderA = inOrder ( observerA ) ; InOrder inOrderB = inOrder ( observerB ) ; InOrder inOrderC = inOrder ( observerC ) ; InOrder inOrderD = inOrder ( observerD ) ; channel . onNext ( 42 ) ; inOrderA . verify ( observerA ) . onNext ( 42 ) ; inOrderB . verify ( observerB ) . onNext ( 42 ) ; ts . cancel ( ) ; inOrderA . verifyNoMoreInteractions ( ) ; channel . onNext ( 4711 ) ; inOrderB . verify ( observerB ) . onNext ( 4711 ) ; channel . onComplete ( ) ; inOrderB . verify ( observerB ) . onComplete ( ) ; channel . subscribe ( observerC ) ; inOrderC . verify ( observerC ) . onNext ( 42 ) ; inOrderC . verify ( observerC ) . onNext ( 4711 ) ; inOrderC . verify ( observerC ) . onComplete ( ) ; channel . onNext ( 13 ) ; channel . onNext ( 14 ) ; channel . onNext ( 15 ) ; channel . onError ( new RuntimeException ( ) ) ; channel . subscribe ( observerD ) ; inOrderD . verify ( observerD ) . onNext ( 42 ) ; inOrderD . verify ( observerD ) . onNext ( 4711 ) ; inOrderD . verify ( observerD ) . onComplete ( ) ; verify ( observerA ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; verify ( observerB ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; verify ( observerC ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; verify ( observerD ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; Mockito . verifyNoMoreInteractions ( observerA ) ; Mockito . verifyNoMoreInteractions ( observerB ) ; Mockito . verifyNoMoreInteractions ( observerC ) ; Mockito . verifyNoMoreInteractions ( observerD ) ; 
ReplayProcessor < String > processor = ReplayProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . onNext ( "one" ) ; processor . onError ( testException ) ; processor . onNext ( "two" ) ; processor . onComplete ( ) ; processor . onError ( new RuntimeException ( ) ) ; processor . subscribe ( subscriber ) ; verify ( subscriber ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onError ( testException ) ; verifyNoMoreInteractions ( subscriber ) ; 
InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
ReplayProcessor < String > processor = ReplayProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; processor . onError ( testException ) ; processor . onNext ( "four" ) ; processor . onError ( new Throwable ( ) ) ; processor . onComplete ( ) ; assertErrorSubscriber ( subscriber ) ; subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; assertErrorSubscriber ( subscriber ) ; 
verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onError ( testException ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
ReplayProcessor < String > processor = ReplayProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; assertObservedUntilTwo ( subscriber ) ; Subscriber < String > anotherSubscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( anotherSubscriber ) ; assertObservedUntilTwo ( anotherSubscriber ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; assertCompletedSubscriber ( subscriber ) ; assertCompletedSubscriber ( anotherSubscriber ) ; 
ReplayProcessor < String > processor = ReplayProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; processor . subscribe ( ts ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; ts . cancel ( ) ; assertObservedUntilTwo ( subscriber ) ; Subscriber < String > anotherSubscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( anotherSubscriber ) ; assertObservedUntilTwo ( anotherSubscriber ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; assertObservedUntilTwo ( subscriber ) ; assertCompletedSubscriber ( anotherSubscriber ) ; 
verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
final AtomicReference < String > lastValueForSubscriber1 = new AtomicReference < > ( ) ; Subscriber < String > subscriber1 = new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String v ) System . out . println ( "observer1: " + v ) ; lastValueForSubscriber1 . set ( v ) ; ; final AtomicReference < String > lastValueForSubscriber2 = new AtomicReference < > ( ) ; final CountDownLatch oneReceived = new CountDownLatch ( 1 ) ; final CountDownLatch makeSlow = new CountDownLatch ( 1 ) ; final CountDownLatch completed = new CountDownLatch ( 1 ) ; Subscriber < String > subscriber2 = new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) completed . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( String v ) System . out . println ( "observer2: " + v ) ; if ( v . equals ( "one" ) ) oneReceived . countDown ( ) ; else try makeSlow . await ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; lastValueForSubscriber2 . set ( v ) ; ; ReplayProcessor < String > processor = ReplayProcessor . create ( ) ; processor . subscribe ( subscriber1 ) ; processor . onNext ( "one" ) ; assertEquals ( "one" , lastValueForSubscriber1 . get ( ) ) ; processor . onNext ( "two" ) ; assertEquals ( "two" , lastValueForSubscriber1 . get ( ) ) ; processor . subscribeOn ( Schedulers . newThread ( ) ) . subscribe ( subscriber2 ) ; System . out . println ( "before waiting for one" ) ; oneReceived . await ( ) ; System . out . println ( "after waiting for one" ) ; processor . onNext ( "three" ) ; System . out . println ( "sent three" ) ; assertEquals ( "three" , lastValueForSubscriber1 . get ( ) ) ; System . out . println ( "about to send onComplete" ) ; processor . onComplete ( ) ; System . out . println ( "completed processor" ) ; makeSlow . countDown ( ) ; System . out . println ( "makeSlow released" ) ; completed . await ( ) ; assertEquals ( "three" , lastValueForSubscriber2 . get ( ) ) ; 
ReplayProcessor < Object > replaySubject = ReplayProcessor . create ( ) ; Disposable connection = replaySubject . subscribe ( ) ; assertEquals ( 1 , replaySubject . subscriberCount ( ) ) ; connection . dispose ( ) ; assertEquals ( 0 , replaySubject . subscriberCount ( ) ) ; 
ReplayProcessor < String > src = ReplayProcessor . create ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; String v = "" + i ; src . onNext ( v ) ; System . out . printf ( "Turn: %d%n" , i ) ; src . firstElement ( ) . toFlowable ( ) . flatMap ( new Function < String , Flowable < String > > ( ) @ Override public Flowable < String > apply ( String t1 ) return Flowable . just ( t1 + ", " + t1 ) ; ) . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onNext ( String t ) System . out . println ( t ) ; subscriber . onNext ( t ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ) ; inOrder . verify ( subscriber ) . onNext ( "0, 0" ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . create ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; final Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; source . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) subscriber . onNext ( t ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onNext ( 2 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; for ( int i = 0 ; i < 1 ; i ++ ) Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; source . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( 1 ) ; verify ( subscriber ) . onNext ( 2 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 1 ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . subscribe ( subscriber ) ; source . onNext ( 3 ) ; source . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( 1 ) ; verify ( subscriber ) . onNext ( 2 ) ; verify ( subscriber ) . onNext ( 3 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 1 , TimeUnit . SECONDS , scheduler ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 3 ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; source . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( 1 ) ; verify ( subscriber , never ( ) ) . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onNext ( 3 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 1 , TimeUnit . SECONDS , scheduler ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; source . subscribe ( subscriber ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( 1 ) ; verify ( subscriber ) . onNext ( 2 ) ; verify ( subscriber ) . onNext ( 3 ) ; verify ( subscriber ) . onComplete ( ) ; 
ReplayProcessor < Object > as = ReplayProcessor . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 1 ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
ReplayProcessor < Object > as = ReplayProcessor . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
ReplayProcessor < Object > as = ReplayProcessor . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onError ( new TestException ( ) ) ; assertTrue ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertTrue ( as . getThrowable ( ) instanceof TestException ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . create ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onComplete ( ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . createUnbounded ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onComplete ( ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . create ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onError ( new TestException ( ) ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . createUnbounded ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onError ( new TestException ( ) ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . create ( ) ; rs . onError ( new TestException ( ) ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . createUnbounded ( ) ; rs . onError ( new TestException ( ) ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . create ( ) ; rs . onComplete ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . createUnbounded ( ) ; rs . onComplete ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . createWithSize ( 1 ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) rs . onNext ( i ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onComplete ( ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
TestScheduler ts = new TestScheduler ( ) ; ReplayProcessor < Object > rs = ReplayProcessor . createWithTime ( 1 , TimeUnit . SECONDS , ts ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) rs . onNext ( i ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; ts . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onComplete ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . create ( ) ; Object [ ] expected = new Object [ 10 ] ; for ( int i = 0 ; i < expected . length ; i ++ ) expected [ i ] = i ; rs . onNext ( i ) ; assertArrayEquals ( Arrays . copyOf ( expected , i + 1 ) , rs . getValues ( ) ) ; rs . onComplete ( ) ; assertArrayEquals ( expected , rs . getValues ( ) ) ; 
ReplayProcessor < Object > rs = ReplayProcessor . createUnbounded ( ) ; Object [ ] expected = new Object [ 10 ] ; for ( int i = 0 ; i < expected . length ; i ++ ) expected [ i ] = i ; rs . onNext ( i ) ; assertArrayEquals ( Arrays . copyOf ( expected , i + 1 ) , rs . getValues ( ) ) ; rs . onComplete ( ) ; assertArrayEquals ( expected , rs . getValues ( ) ) ; 
ReplayProcessor < Integer > rs = ReplayProcessor . create ( ) ; rs . onNext ( 1 ) ; rs . onNext ( 2 ) ; rs . onNext ( 3 ) ; rs . onComplete ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; rs . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
ReplayProcessor < Integer > rs = ReplayProcessor . createWithSize ( 100 ) ; rs . onNext ( 1 ) ; rs . onNext ( 2 ) ; rs . onNext ( 3 ) ; rs . onComplete ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; rs . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
ReplayProcessor < Integer > rs = ReplayProcessor . createWithTime ( 1 , TimeUnit . DAYS , Schedulers . trampoline ( ) ) ; rs . onNext ( 1 ) ; rs . onNext ( 2 ) ; rs . onNext ( 3 ) ; rs . onComplete ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; rs . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
try ReplayProcessor . create ( - 99 ) ; fail ( "Didn't throw IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "capacityHint > 0 required but it was -99" , ex . getMessage ( ) ) ; 
try ReplayProcessor . createWithSize ( - 99 ) ; fail ( "Didn't throw IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "maxSize > 0 required but it was -99" , ex . getMessage ( ) ) ; 
try ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . computation ( ) , - 99 ) ; fail ( "Didn't throw IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "maxSize > 0 required but it was -99" , ex . getMessage ( ) ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . create ( ) ; assertFalse ( rp . hasSubscribers ( ) ) ; TestSubscriber < Integer > ts = rp . test ( ) ; assertTrue ( rp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( rp . hasSubscribers ( ) ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . create ( ) ; rp . onNext ( 1 ) ; assertEquals ( ( Integer ) 1 , rp . getValue ( ) ) ; assertEquals ( 1 , rp . getValues ( ) [ 0 ] ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . computation ( ) , 1 ) ; rp . onNext ( 1 ) ; assertEquals ( ( Integer ) 1 , rp . getValue ( ) ) ; assertEquals ( 1 , rp . getValues ( ) [ 0 ] ) ; rp . onNext ( 2 ) ; assertEquals ( ( Integer ) 2 , rp . getValue ( ) ) ; assertEquals ( 2 , rp . getValues ( ) [ 0 ] ) ; assertEquals ( ( Integer ) 2 , rp . getValues ( new Integer [ 0 ] ) [ 0 ] ) ; assertEquals ( ( Integer ) 2 , rp . getValues ( new Integer [ 1 ] ) [ 0 ] ) ; Integer [ ] a = new Integer [ 2 ] ; assertEquals ( ( Integer ) 2 , rp . getValues ( a ) [ 0 ] ) ; assertNull ( a [ 1 ] ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . computation ( ) , 1 ) ; assertNull ( rp . getValue ( ) ) ; assertEquals ( 0 , rp . getValues ( ) . length ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; rp . onComplete ( ) ; assertNull ( rp . getValue ( ) ) ; assertEquals ( 0 , rp . getValues ( ) . length ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . computation ( ) , 1 ) ; rp . onError ( new TestException ( ) ) ; assertNull ( rp . getValue ( ) ) ; assertEquals ( 0 , rp . getValues ( ) . length ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplayProcessor < Integer > rp = ReplayProcessor . createWithTime ( 1 , TimeUnit . DAYS , scheduler ) ; assertNull ( rp . getValue ( ) ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; rp . onNext ( 2 ) ; assertEquals ( ( Integer ) 2 , rp . getValue ( ) ) ; assertEquals ( 2 , rp . getValues ( ) [ 0 ] ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . DAYS ) ; assertNull ( rp . getValue ( ) ) ; assertEquals ( 0 , rp . getValues ( ) . length ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . create ( 8 ) ; for ( int i = 0 ; i < 15 ; i ++ ) rp . onNext ( i ) ; rp . onComplete ( ) ; rp . test ( ) . assertResult ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final ReplayProcessor < Integer > rp = ReplayProcessor . create ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) rp . subscribe ( ts ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . create ( ) ; rp . onComplete ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; rp . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ReplayProcessor < Integer > rp = ReplayProcessor . create ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) rp . test ( ) ; ; TestHelper . race ( r1 , r1 ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . create ( ) ; rp . test ( ) ; rp . test ( ) ; TestSubscriber < Integer > ts = rp . test ( 0L , true ) ; assertEquals ( 2 , rp . subscriberCount ( ) ) ; ts . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ReplayProcessor < Integer > rp = ReplayProcessor . create ( ) ; final TestSubscriber < Integer > ts1 = rp . test ( ) ; final TestSubscriber < Integer > ts2 = rp . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts2 . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertFalse ( rp . hasSubscribers ( ) ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithSize ( 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; rp . onNext ( 4 ) ; rp . onError ( new TestException ( ) ) ; rp . test ( ) . assertFailure ( TestException . class , 3 , 4 ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; rp . onNext ( 4 ) ; rp . onError ( new TestException ( ) ) ; rp . test ( ) . assertFailure ( TestException . class , 3 , 4 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 ) ; final TestSubscriber < Integer > ts = rp . test ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) rp . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; rp . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; rp . test ( ) . assertEmpty ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; rp . take ( 1 ) . test ( ) . assertResult ( 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; rp . subscribeWith ( ts ) . assertResult ( 2 ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithSize ( 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; rp . take ( 1 ) . test ( ) . assertResult ( 2 ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithSize ( 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; rp . subscribeWith ( ts ) . assertResult ( 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) rp . onNext ( 2 ) ; super . onNext ( t ) ; ; rp . subscribe ( ts ) ; rp . onNext ( 1 ) ; rp . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) if ( t == 1 ) rp . onNext ( 2 ) ; super . onNext ( t ) ; ; rp . subscribe ( ts ) ; rp . onNext ( 1 ) ; rp . onComplete ( ) ; ts . request ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 2 , TimeUnit . SECONDS , scheduler ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; source . test ( ) . assertResult ( 1 ) ; source . test ( ) . assertResult ( 1 ) ; scheduler . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; source . test ( ) . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final ReplayProcessor < Integer > source = ReplayProcessor . create ( ) ; final TestSubscriber < Integer > ts = source . test ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 10 ) ; final TestSubscriber < Integer > ts = source . test ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 2 , TimeUnit . HOURS , Schedulers . single ( ) ) ; final TestSubscriber < Integer > ts = source . test ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final ReplayProcessor < Integer > source = ReplayProcessor . createWithTimeAndSize ( 2 , TimeUnit . HOURS , Schedulers . single ( ) , 100 ) ; final TestSubscriber < Integer > ts = source . test ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; 
final ReplayProcessor < Integer > source = ReplayProcessor . create ( ) ; source . onComplete ( ) ; source . test ( 0 ) . assertResult ( ) ; 
final ReplayProcessor < Integer > source = ReplayProcessor . create ( ) ; source . onError ( new TestException ( ) ) ; source . test ( 0 ) . assertFailure ( TestException . class ) ; 
final ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 16 ) ; source . onComplete ( ) ; source . test ( 0 ) . assertResult ( ) ; 
final ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 16 ) ; source . onError ( new TestException ( ) ) ; source . test ( 0 ) . assertFailure ( TestException . class ) ; 
final ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 1 , TimeUnit . MINUTES , Schedulers . single ( ) ) ; source . onComplete ( ) ; source . test ( 0 ) . assertResult ( ) ; 
final ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 1 , TimeUnit . MINUTES , Schedulers . single ( ) ) ; source . onError ( new TestException ( ) ) ; source . test ( 0 ) . assertFailure ( TestException . class ) ; 
final ReplayProcessor < Integer > source = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . MINUTES , Schedulers . single ( ) , 16 ) ; source . onComplete ( ) ; source . test ( 0 ) . assertResult ( ) ; 
final ReplayProcessor < Integer > source = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . MINUTES , Schedulers . single ( ) , 16 ) ; source . onError ( new TestException ( ) ) ; source . test ( 0 ) . assertFailure ( TestException . class ) ; 
return new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; 
ReplayProcessor < Integer > source = ReplayProcessor . create ( ) ; source . onNext ( 1 ) ; source . subscribeWith ( take1AndCancel ( ) ) . assertResult ( 1 ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 16 ) ; source . onNext ( 1 ) ; source . subscribeWith ( take1AndCancel ( ) ) . assertResult ( 1 ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 1 , TimeUnit . MINUTES , Schedulers . single ( ) ) ; source . onNext ( 1 ) ; source . subscribeWith ( take1AndCancel ( ) ) . assertResult ( 1 ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . MINUTES , Schedulers . single ( ) , 16 ) ; source . onNext ( 1 ) ; source . subscribeWith ( take1AndCancel ( ) ) . assertResult ( 1 ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; SizeBoundReplayBuffer < Integer > buf = ( SizeBoundReplayBuffer < Integer > ) source . buffer ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; SizeBoundReplayBuffer < Integer > buf = ( SizeBoundReplayBuffer < Integer > ) source . buffer ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . create ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . cleanupBuffer ( ) ; source . test ( ) . assertValuesOnly ( 1 , 2 ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithSize ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; SizeBoundReplayBuffer < Integer > buf = ( SizeBoundReplayBuffer < Integer > ) source . buffer ; assertNotNull ( buf . head . value ) ; source . cleanupBuffer ( ) ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = ( SizeAndTimeBoundReplayBuffer < Integer > ) source . buffer ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = ( SizeAndTimeBoundReplayBuffer < Integer > ) source . buffer ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
TestScheduler sch = new TestScheduler ( ) ; ReplayProcessor < Integer > source = ReplayProcessor . createWithTime ( 1 , TimeUnit . MILLISECONDS , sch ) ; source . onNext ( 1 ) ; sch . advanceTimeBy ( 2 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = ( SizeAndTimeBoundReplayBuffer < Integer > ) source . buffer ; assertNotNull ( buf . head . value ) ; source . cleanupBuffer ( ) ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
TestHelper . assertBadRequestReported ( ReplayProcessor . create ( ) ) ; 
final ReplayProcessor < byte [ ] > rp = ReplayProcessor . createWithSize ( 1 ) ; Flowable < byte [ ] > source = rp . take ( 1 ) . concatMap ( new Function < byte [ ] , Publisher < byte [ ] > > ( ) @ Override public Publisher < byte [ ] > apply ( byte [ ] v ) throws Exception return rp ; ) . takeLast ( 1 ) ; System . out . println ( "Bounded Replay Leak check: Wait before GC" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check: GC" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long initial = memHeap . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; final AtomicLong after = new AtomicLong ( ) ; source . subscribe ( new Consumer < byte [ ] > ( ) @ Override public void accept ( byte [ ] v ) throws Exception System . out . println ( "Bounded Replay Leak check: Wait before GC 2" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check:  GC 2" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; after . set ( memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ) ; ) ; for ( int i = 0 ; i < 200 ; i ++ ) rp . onNext ( new byte [ 1024 * 1024 ] ) ; rp . onComplete ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after . get ( ) / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after . get ( ) ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after . get ( ) / 1024.0 / 1024.0 ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , 1 ) ; TestSubscriber < Integer > ts = rp . test ( ) ; rp . onNext ( 1 ) ; rp . cleanupBuffer ( ) ; rp . onComplete ( ) ; ts . assertNoErrors ( ) . assertComplete ( ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , 1 ) ; TestSubscriber < Integer > ts = rp . test ( ) ; rp . onNext ( 1 ) ; rp . cleanupBuffer ( ) ; rp . onNext ( 2 ) ; rp . cleanupBuffer ( ) ; rp . onComplete ( ) ; ts . assertNoErrors ( ) . assertComplete ( ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , 1 ) ; TestSubscriber < Integer > ts = rp . test ( ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onComplete ( ) ; ts . assertNoErrors ( ) . assertComplete ( ) ; 
ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , 10 ) ; TestSubscriber < Integer > ts = rp . test ( ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onComplete ( ) ; ts . assertNoErrors ( ) . assertComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplayProcessor < Integer > rp = ReplayProcessor . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; rp . onNext ( 4 ) ; rp . onNext ( 5 ) ; rp . test ( ) . assertValuesOnly ( 4 , 5 ) ; 
FlowableProcessor < T > p = create ( ) ; try p . onNext ( null ) ; fail ( "No NullPointerException thrown" ) ; catch ( NullPointerException ex ) assertEquals ( ExceptionHelper . nullWarning ( "onNext called with a null value." ) , ex . getMessage ( ) ) ; p . test ( ) . assertEmpty ( ) . cancel ( ) ; 
FlowableProcessor < T > p = create ( ) ; try p . onError ( null ) ; fail ( "No NullPointerException thrown" ) ; catch ( NullPointerException ex ) assertEquals ( ExceptionHelper . nullWarning ( "onError called with a null Throwable." ) , ex . getMessage ( ) ) ; p . test ( ) . assertEmpty ( ) . cancel ( ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; mp . start ( ) ; assertFalse ( mp . hasSubscribers ( ) ) ; assertFalse ( mp . hasComplete ( ) ) ; assertFalse ( mp . hasThrowable ( ) ) ; assertNull ( mp . getThrowable ( ) ) ; TestSubscriber < Integer > ts = mp . test ( ) ; assertTrue ( mp . hasSubscribers ( ) ) ; assertFalse ( mp . hasComplete ( ) ) ; assertFalse ( mp . hasThrowable ( ) ) ; assertNull ( mp . getThrowable ( ) ) ; mp . onNext ( 1 ) ; mp . onComplete ( ) ; ts . assertResult ( 1 ) ; assertFalse ( mp . hasSubscribers ( ) ) ; assertTrue ( mp . hasComplete ( ) ) ; assertFalse ( mp . hasThrowable ( ) ) ; assertNull ( mp . getThrowable ( ) ) ; mp . test ( ) . assertResult ( ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; mp . start ( ) ; assertFalse ( mp . hasSubscribers ( ) ) ; assertFalse ( mp . hasComplete ( ) ) ; assertFalse ( mp . hasThrowable ( ) ) ; assertNull ( mp . getThrowable ( ) ) ; TestSubscriber < Integer > ts = mp . test ( ) ; assertTrue ( mp . hasSubscribers ( ) ) ; assertFalse ( mp . hasComplete ( ) ) ; assertFalse ( mp . hasThrowable ( ) ) ; assertNull ( mp . getThrowable ( ) ) ; mp . onNext ( 1 ) ; mp . onError ( new IOException ( ) ) ; ts . assertFailure ( IOException . class , 1 ) ; assertFalse ( mp . hasSubscribers ( ) ) ; assertFalse ( mp . hasComplete ( ) ) ; assertTrue ( mp . hasThrowable ( ) ) ; assertNotNull ( mp . getThrowable ( ) ) ; assertTrue ( "" + mp . getThrowable ( ) , mp . getThrowable ( ) instanceof IOException ) ; mp . test ( ) . assertFailure ( IOException . class ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 1 ) ; mp . start ( ) ; TestSubscriber < Integer > ts = mp . test ( 0 ) ; assertTrue ( mp . offer ( 1 ) ) ; assertFalse ( mp . offer ( 2 ) ) ; mp . onNext ( 3 ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertFailure ( MissingBackpressureException . class , 1 ) ; mp . test ( ) . assertFailure ( MissingBackpressureException . class ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 16 , false ) ; mp . start ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) mp . onNext ( i ) ; mp . onComplete ( ) ; mp . test ( 0 ) . assertEmpty ( ) . requestMore ( 1 ) . assertValuesOnly ( 0 ) . requestMore ( 2 ) . assertValuesOnly ( 0 , 1 , 2 ) . requestMore ( 3 ) . assertValuesOnly ( 0 , 1 , 2 , 3 , 4 , 5 ) . requestMore ( 4 ) . assertResult ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( true ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; mp . onSubscribe ( bs ) ; assertFalse ( bs . isCancelled ( ) ) ; mp . test ( ) . cancel ( ) ; assertTrue ( bs . isCancelled ( ) ) ; assertFalse ( mp . hasSubscribers ( ) ) ; assertTrue ( mp . hasComplete ( ) ) ; assertFalse ( mp . hasThrowable ( ) ) ; assertNull ( mp . getThrowable ( ) ) ; mp . test ( ) . assertResult ( ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 16 , true ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; mp . onSubscribe ( bs ) ; assertFalse ( bs . isCancelled ( ) ) ; mp . test ( 1 , true ) ; assertTrue ( bs . isCancelled ( ) ) ; assertFalse ( mp . hasSubscribers ( ) ) ; assertTrue ( mp . hasComplete ( ) ) ; assertFalse ( mp . hasThrowable ( ) ) ; assertNull ( mp . getThrowable ( ) ) ; mp . test ( ) . assertResult ( ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 16 ) ; Flowable . range ( 1 , 1000 ) . subscribe ( mp ) ; mp . test ( ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 16 ) ; Flowable . range ( 1 , 1000 ) . subscribe ( mp ) ; mp . rebatchRequests ( 1 ) . test ( ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 16 ) ; Flowable . range ( 1 , 1000 ) . subscribe ( mp ) ; mp . take ( 10 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 16 , true ) ; Flowable . range ( 1 , 1000 ) . subscribe ( mp ) ; mp . take ( 10 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 16 , true ) ; Flowable . range ( 1 , 10 ) . subscribe ( mp ) ; mp . rebatchRequests ( 10 ) . take ( 10 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ts1 . cancel ( ) ; ts1 . onComplete ( ) ; ; MulticastProcessor < Integer > mp = MulticastProcessor . create ( false ) ; mp . subscribe ( ts2 ) ; mp . subscribe ( ts1 ) ; mp . start ( ) ; mp . onNext ( 1 ) ; mp . onComplete ( ) ; ts1 . assertResult ( ) ; ts2 . assertResult ( 1 ) ; 
final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onError ( Throwable t ) super . onError ( t ) ; ts1 . cancel ( ) ; ts1 . onComplete ( ) ; ; MulticastProcessor < Integer > mp = MulticastProcessor . create ( false ) ; mp . subscribe ( ts2 ) ; mp . subscribe ( ts1 ) ; mp . start ( ) ; mp . onNext ( 1 ) ; mp . onError ( new IOException ( ) ) ; ts1 . assertResult ( 1 ) ; ts2 . assertFailure ( IOException . class , 1 ) ; 
final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onComplete ( ) super . onComplete ( ) ; ts1 . cancel ( ) ; ts1 . onNext ( 2 ) ; ts1 . onComplete ( ) ; ; MulticastProcessor < Integer > mp = MulticastProcessor . create ( false ) ; mp . subscribe ( ts2 ) ; mp . subscribe ( ts1 ) ; mp . start ( ) ; mp . onNext ( 1 ) ; mp . onComplete ( ) ; ts1 . assertResult ( 1 , 2 ) ; ts2 . assertResult ( 1 ) ; 
final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( 1 ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ts1 . cancel ( ) ; ts1 . onComplete ( ) ; ; MulticastProcessor < Integer > mp = MulticastProcessor . create ( false ) ; mp . subscribe ( ts2 ) ; mp . subscribe ( ts1 ) ; mp . start ( ) ; mp . onNext ( 1 ) ; mp . onComplete ( ) ; ts1 . assertResult ( ) ; ts2 . assertResult ( 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try MulticastProcessor < Integer > mp = MulticastProcessor . create ( false ) ; mp . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( Subscription t ) t . request ( - 1 ) ; t . request ( 1 ) ; t . request ( Long . MAX_VALUE ) ; t . request ( Long . MAX_VALUE ) ; t . cancel ( ) ; t . cancel ( ) ; t . request ( 2 ) ; ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class ) ; finally RxJavaPlugins . reset ( ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 4 , false ) ; mp . startUnbounded ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) assertTrue ( mp . offer ( i ) ) ; mp . onComplete ( ) ; mp . test ( ) . assertResult ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try MulticastProcessor < Integer > mp = MulticastProcessor . create ( 4 , false ) ; mp . start ( ) ; mp . start ( ) ; mp . startUnbounded ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; mp . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertError ( errors , 1 , ProtocolViolationException . class ) ; TestHelper . assertError ( errors , 2 , ProtocolViolationException . class ) ; finally RxJavaPlugins . reset ( ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 4 , false ) ; mp . start ( ) ; mp . onNext ( null ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 4 , false ) ; mp . start ( ) ; mp . offer ( null ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( 4 , false ) ; mp . start ( ) ; mp . onError ( null ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; mp . start ( ) ; mp . onComplete ( ) ; mp . onComplete ( ) ; mp . onError ( new IOException ( ) ) ; mp . onNext ( 1 ) ; mp . offer ( 1 ) ; mp . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; MulticastProcessor < Integer > mp = MulticastProcessor . create ( 4 ) ; up . subscribe ( mp ) ; TestSubscriber < Integer > ts = mp . test ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) up . onNext ( i ) ; try mp . offer ( 10 ) ; fail ( "Should have thrown IllegalStateException" ) ; catch ( IllegalStateException expected ) up . onComplete ( ) ; ts . assertResult ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; 
MulticastProcessor < Integer > mp = Flowable . range ( 1 , 5 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new IOException ( ) ; ) . subscribeWith ( MulticastProcessor . < Integer > create ( ) ) ; mp . test ( ) . assertFailure ( IOException . class ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; TestSubscriber < Integer > ts1 = mp . test ( ) ; mp . start ( ) ; mp . onNext ( 1 ) ; mp . onNext ( 2 ) ; ts1 . assertValues ( 1 , 2 ) ; TestSubscriber < Integer > ts2 = mp . test ( 0 ) ; ts2 . assertEmpty ( ) ; mp . onNext ( 3 ) ; ts1 . assertValues ( 1 , 2 ) ; ts2 . assertEmpty ( ) ; mp . onComplete ( ) ; ts1 . assertValues ( 1 , 2 ) ; ts2 . assertEmpty ( ) ; ts2 . request ( 1 ) ; ts1 . assertResult ( 1 , 2 , 3 ) ; ts2 . assertResult ( 3 ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; TestHelper . < Integer > rejectFlowableFusion ( ) . subscribe ( mp ) ; mp . test ( ) . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; final TestSubscriber < Integer > ts = mp . test ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) mp . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( mp . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; mp . test ( ) ; final TestSubscriber < Integer > ts = mp . test ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) mp . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( mp . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = MulticastProcessor . create ( true ) ; final TestSubscriber < Integer > ts = mp . test ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) mp . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; mp . test ( 0 , true ) . assertEmpty ( ) ; assertFalse ( mp . hasSubscribers ( ) ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; mp . test ( ) ; mp . test ( 0 , true ) . assertEmpty ( ) ; assertTrue ( mp . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = MulticastProcessor . create ( true ) ; mp . startUnbounded ( ) ; mp . onNext ( 1 ) ; mp . onNext ( 2 ) ; final TestSubscriber < Integer > ts = mp . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValuesOnly ( 1 , 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = MulticastProcessor . create ( true ) ; final Flowable < Integer > source = Flowable . range ( 1 , 5 ) ; final TestSubscriber < Integer > ts = mp . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 5 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) source . subscribe ( mp ) ; ; TestHelper . race ( r1 , r2 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = MulticastProcessor . create ( true ) ; mp . startUnbounded ( ) ; final TestSubscriber < Integer > ts = mp . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) mp . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = MulticastProcessor . create ( true ) ; final TestSubscriber < Integer > ts1 = mp . test ( ) ; final TestSubscriber < Integer > ts2 = mp . test ( ) ; mp . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts2 . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = MulticastProcessor . create ( true ) ; final TestSubscriber < Integer > ts1 = mp . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts1 . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; TestSubscriber < Integer > ts = mp . test ( 0 ) ; ts . request ( 1 ) ; assertTrue ( mp . hasSubscribers ( ) ) ; 
for ( int j = 1 ; j < 12 ; j ++ ) MulticastProcessor < Integer > mp = MulticastProcessor . create ( j , true ) ; TestSubscriber < Integer > ts = mp . test ( 0 ) . withTag ( "Prefetch: " + j ) ; Flowable . range ( 1 , 10 ) . hide ( ) . subscribe ( mp ) ; ts . assertEmpty ( ) . requestMore ( 3 ) . assertValuesOnly ( 1 , 2 , 3 ) . requestMore ( 3 ) . assertValuesOnly ( 1 , 2 , 3 , 4 , 5 , 6 ) . requestMore ( 4 ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
for ( int j = 1 ; j < 12 ; j ++ ) MulticastProcessor < Integer > mp = MulticastProcessor . create ( j , true ) ; TestSubscriber < Integer > ts = mp . test ( 0 ) . withTag ( "Prefetch: " + j ) ; Flowable . range ( 1 , 10 ) . hide ( ) . subscribe ( mp ) ; ts . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 , 4 ) . requestMore ( 6 ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
return AsyncProcessor . create ( ) ; 
AsyncProcessor < String > processor = AsyncProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( testException ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
AsyncProcessor < String > processor = AsyncProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
AsyncProcessor < String > processor = AsyncProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; processor . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
AsyncProcessor < String > processor = AsyncProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; RuntimeException re = new RuntimeException ( "failed" ) ; processor . onError ( re ) ; processor . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onError ( re ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
AsyncProcessor < String > processor = AsyncProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; processor . onNext ( "three" ) ; processor . onError ( testException ) ; processor . onNext ( "four" ) ; processor . onError ( new Throwable ( ) ) ; processor . onComplete ( ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , times ( 1 ) ) . onError ( testException ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
AsyncProcessor < String > processor = AsyncProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; processor . subscribe ( ts ) ; processor . onNext ( "one" ) ; processor . onNext ( "two" ) ; ts . cancel ( ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; processor . onNext ( "three" ) ; processor . onComplete ( ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , Mockito . never ( ) ) . onComplete ( ) ; 
AsyncProcessor < String > processor = AsyncProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; processor . subscribe ( subscriber ) ; processor . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( null ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final AsyncProcessor < String > processor = AsyncProcessor . create ( ) ; final AtomicReference < String > value1 = new AtomicReference < > ( ) ; processor . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; value1 . set ( t1 ) ; ) ; Thread t1 = new Thread ( new Runnable ( ) @ Override public void run ( ) processor . onNext ( "value" ) ; processor . onComplete ( ) ; ) ; SubjectSubscriberThread t2 = new SubjectSubscriberThread ( processor ) ; SubjectSubscriberThread t3 = new SubjectSubscriberThread ( processor ) ; SubjectSubscriberThread t4 = new SubjectSubscriberThread ( processor ) ; SubjectSubscriberThread t5 = new SubjectSubscriberThread ( processor ) ; t2 . start ( ) ; t3 . start ( ) ; t1 . start ( ) ; t4 . start ( ) ; t5 . start ( ) ; try t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; t4 . join ( ) ; t5 . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertEquals ( "value" , value1 . get ( ) ) ; assertEquals ( "value" , t2 . value . get ( ) ) ; assertEquals ( "value" , t3 . value . get ( ) ) ; assertEquals ( "value" , t4 . value . get ( ) ) ; assertEquals ( "value" , t5 . value . get ( ) ) ; 
processor . onNext ( "value" ) ; processor . onComplete ( ) ; 
AsyncProcessor < Object > as = AsyncProcessor . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 1 ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertTrue ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertEquals ( 1 , as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
AsyncProcessor < Object > as = AsyncProcessor . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
AsyncProcessor < Object > as = AsyncProcessor . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onError ( new TestException ( ) ) ; assertFalse ( as . hasValue ( ) ) ; assertTrue ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertTrue ( as . getThrowable ( ) instanceof TestException ) ; 
AsyncProcessor < Integer > ap = new AsyncProcessor < > ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; ap . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) ; ts . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ap . onNext ( 1 ) ; ts . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ap . onComplete ( ) ; ts . assertResult ( 1 ) ; 
AsyncProcessor < Integer > ap = new AsyncProcessor < > ( ) ; ap . onNext ( 1 ) ; ap . onComplete ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; ap . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
AsyncProcessor < Object > p = AsyncProcessor . create ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; p . onSubscribe ( bs ) ; assertFalse ( bs . isCancelled ( ) ) ; p . onComplete ( ) ; bs = new BooleanSubscription ( ) ; p . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; p . test ( ) . assertResult ( ) ; 
AsyncProcessor < Object > p = AsyncProcessor . create ( ) ; assertFalse ( p . hasSubscribers ( ) ) ; p . test ( ) . assertEmpty ( ) ; p . test ( ) . assertEmpty ( ) ; p . test ( 0L , true ) . assertEmpty ( ) ; assertTrue ( p . hasSubscribers ( ) ) ; 
AsyncProcessor < Object > p = AsyncProcessor . create ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Object > ts1 = p . test ( ) ; final TestSubscriber < Object > ts2 = p . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts2 . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AsyncProcessor < Object > p = AsyncProcessor . create ( ) ; final TestSubscriberEx < Object > ts1 = p . to ( TestHelper . < Object > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; final TestException ex = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) p . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts1 . errors ( ) . size ( ) != 0 ) ts1 . assertFailure ( TestException . class ) ; else ts1 . assertEmpty ( ) ; 
AsyncProcessor < Object > p = AsyncProcessor . create ( ) ; final TestSubscriber < Object > ts2 = new TestSubscriber < > ( ) ; TestSubscriber < Object > ts1 = new TestSubscriber < Object > ( ) @ Override public void onNext ( Object t ) ts2 . cancel ( ) ; super . onNext ( t ) ; ; p . subscribe ( ts1 ) ; p . subscribe ( ts2 ) ; p . onNext ( 1 ) ; p . onComplete ( ) ; ts1 . assertResult ( 1 ) ; ts2 . assertEmpty ( ) ; 
AsyncProcessor < Object > p = AsyncProcessor . create ( ) ; final TestSubscriber < Object > ts2 = new TestSubscriber < > ( ) ; TestSubscriber < Object > ts1 = new TestSubscriber < Object > ( ) @ Override public void onError ( Throwable t ) ts2 . cancel ( ) ; super . onError ( t ) ; ; p . subscribe ( ts1 ) ; p . subscribe ( ts2 ) ; p . onError ( new TestException ( ) ) ; ts1 . assertFailure ( TestException . class ) ; ts2 . assertEmpty ( ) ; 
AsyncProcessor < Object > p = AsyncProcessor . create ( ) ; final TestSubscriber < Object > ts2 = new TestSubscriber < > ( ) ; TestSubscriber < Object > ts1 = new TestSubscriber < Object > ( ) @ Override public void onComplete ( ) ts2 . cancel ( ) ; super . onComplete ( ) ; ; p . subscribe ( ts1 ) ; p . subscribe ( ts2 ) ; p . onComplete ( ) ; ts1 . assertResult ( ) ; ts2 . assertEmpty ( ) ; 
TestHelper . checkDisposed ( AsyncProcessor . create ( ) ) ; 
SerializedProcessor < String > processor = new SerializedProcessor < > ( PublishProcessor . < String > create ( ) ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; processor . subscribe ( ts ) ; processor . onNext ( "hello" ) ; processor . onComplete ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValue ( "hello" ) ; 
AsyncProcessor < Integer > async = AsyncProcessor . create ( ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; 
AsyncProcessor < Integer > async = AsyncProcessor . create ( ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
AsyncProcessor < Integer > async = AsyncProcessor . create ( ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
PublishProcessor < Integer > async = PublishProcessor . create ( ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; 
PublishProcessor < Integer > async = PublishProcessor . create ( ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; 
PublishProcessor < Integer > async = PublishProcessor . create ( ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; 
BehaviorProcessor < Integer > async = BehaviorProcessor . create ( ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
BehaviorProcessor < Integer > async = BehaviorProcessor . create ( ) ; async . onNext ( 1 ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; 
BehaviorProcessor < Integer > async = BehaviorProcessor . create ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
BehaviorProcessor < Integer > async = BehaviorProcessor . create ( ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
BehaviorProcessor < Integer > async = BehaviorProcessor . create ( ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . create ( ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] 1 , null , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . create ( ) ; async . onNext ( 1 ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] 1 , null , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . createWithSize ( 1 ) ; async . onNext ( 0 ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] 1 , null , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . createWithSize ( 1 ) ; async . onNext ( 0 ) ; async . onNext ( 1 ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] 1 , null , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . createWithSize ( 1 ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . create ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . create ( ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . create ( ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . createWithSize ( 1 ) ; async . onComplete ( ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplayProcessor < Integer > async = ReplayProcessor . createWithSize ( 1 ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; FlowableProcessor < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasSubscribers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
PublishProcessor < Object > s = PublishProcessor . create ( ) ; FlowableProcessor < Object > s1 = s . toSerialized ( ) ; FlowableProcessor < Object > s2 = s1 . toSerialized ( ) ; assertSame ( s1 , s2 ) ; 
FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = s . test ( ) ; Flowable . range ( 1 , 10 ) . subscribe ( s ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertFalse ( s . hasSubscribers ( ) ) ; s . onNext ( 11 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try s . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; s . onComplete ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; s . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; 
Set < Integer > expectedSet = new HashSet < > ( Arrays . asList ( 1 , 2 ) ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriberEx < Integer > ts = s . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 2 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertSubscribed ( ) . assertNoErrors ( ) . assertNotComplete ( ) . assertValueCount ( 2 ) ; Set < Integer > actualSet = new HashSet < > ( ts . values ( ) ) ; assertEquals ( "" + actualSet , expectedSet , actualSet ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = s . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertError ( ex ) . assertNotComplete ( ) ; if ( ts . values ( ) . size ( ) != 0 ) ts . assertValue ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = s . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertComplete ( ) . assertNoErrors ( ) ; if ( ts . values ( ) . size ( ) != 0 ) ts . assertValue ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = s . test ( ) ; final BooleanSubscription bs = new BooleanSubscription ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onSubscribe ( bs ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValue ( 1 ) . assertNotComplete ( ) . assertNoErrors ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = s . test ( ) ; final BooleanSubscription bs = new BooleanSubscription ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onSubscribe ( bs ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = s . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = s . test ( ) ; final TestException ex = new TestException ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FlowableProcessor < Integer > s = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = s . test ( ) ; final BooleanSubscription bs1 = new BooleanSubscription ( ) ; final BooleanSubscription bs2 = new BooleanSubscription ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onSubscribe ( bs1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onSubscribe ( bs2 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertEmpty ( ) ; 
FlowableProcessor < Integer > sp = PublishProcessor . < Integer > create ( ) . toSerialized ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) super . onNext ( t ) ; if ( t == 1 ) sp . onNext ( 2 ) ; sp . onSubscribe ( new BooleanSubscription ( ) ) ; sp . onError ( new TestException ( ) ) ; ; sp . subscribe ( ts ) ; sp . onNext ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = cs . test ( ) ; cs . onComplete ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try cs . onError ( new IOException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; cs . onComplete ( ) ; to . assertResult ( ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; assertFalse ( cs . hasComplete ( ) ) ; assertFalse ( cs . hasThrowable ( ) ) ; assertNull ( cs . getThrowable ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; assertEquals ( 0 , cs . observerCount ( ) ) ; TestObserver < Void > to = cs . test ( ) ; to . assertEmpty ( ) ; assertTrue ( cs . hasObservers ( ) ) ; assertEquals ( 1 , cs . observerCount ( ) ) ; cs . onError ( new IOException ( ) ) ; assertFalse ( cs . hasComplete ( ) ) ; assertTrue ( cs . hasThrowable ( ) ) ; assertTrue ( cs . getThrowable ( ) . toString ( ) , cs . getThrowable ( ) instanceof IOException ) ; assertFalse ( cs . hasObservers ( ) ) ; assertEquals ( 0 , cs . observerCount ( ) ) ; to . assertFailure ( IOException . class ) ; cs . test ( ) . assertFailure ( IOException . class ) ; assertFalse ( cs . hasComplete ( ) ) ; assertTrue ( cs . hasThrowable ( ) ) ; assertTrue ( cs . getThrowable ( ) . toString ( ) , cs . getThrowable ( ) instanceof IOException ) ; assertFalse ( cs . hasObservers ( ) ) ; assertEquals ( 0 , cs . observerCount ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; assertFalse ( cs . hasComplete ( ) ) ; assertFalse ( cs . hasThrowable ( ) ) ; assertNull ( cs . getThrowable ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; assertEquals ( 0 , cs . observerCount ( ) ) ; TestObserver < Void > to = cs . test ( ) ; to . assertEmpty ( ) ; assertTrue ( cs . hasObservers ( ) ) ; assertEquals ( 1 , cs . observerCount ( ) ) ; cs . onComplete ( ) ; assertTrue ( cs . hasComplete ( ) ) ; assertFalse ( cs . hasThrowable ( ) ) ; assertNull ( cs . getThrowable ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; assertEquals ( 0 , cs . observerCount ( ) ) ; to . assertResult ( ) ; cs . test ( ) . assertResult ( ) ; assertTrue ( cs . hasComplete ( ) ) ; assertFalse ( cs . hasThrowable ( ) ) ; assertNull ( cs . getThrowable ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; assertEquals ( 0 , cs . observerCount ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; try cs . onError ( null ) ; fail ( "No NullPointerException thrown" ) ; catch ( NullPointerException ex ) assertEquals ( ExceptionHelper . nullWarning ( "onError called with a null Throwable." ) , ex . getMessage ( ) ) ; cs . test ( ) . assertEmpty ( ) . dispose ( ) ; 
CompletableSubject . create ( ) . test ( true ) . assertEmpty ( ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; cs . test ( ) ; cs . test ( true ) . assertEmpty ( ) ; 
TestHelper . checkDisposed ( CompletableSubject . create ( ) ) ; 
CompletableSubject . create ( ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; Disposable d = Disposable . empty ( ) ; cs . onSubscribe ( d ) ; assertFalse ( d . isDisposed ( ) ) ; cs . onComplete ( ) ; d = Disposable . empty ( ) ; cs . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompletableSubject cs = CompletableSubject . create ( ) ; final TestObserver < Void > to = cs . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cs . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Subject < T > p = create ( ) ; try p . onNext ( null ) ; fail ( "No NullPointerException thrown" ) ; catch ( NullPointerException ex ) assertEquals ( ExceptionHelper . nullWarning ( "onNext called with a null value." ) , ex . getMessage ( ) ) ; p . test ( ) . assertEmpty ( ) . dispose ( ) ; 
Subject < T > p = create ( ) ; try p . onError ( null ) ; fail ( "No NullPointerException thrown" ) ; catch ( NullPointerException ex ) assertEquals ( ExceptionHelper . nullWarning ( "onError called with a null Throwable." ) , ex . getMessage ( ) ) ; p . test ( ) . assertEmpty ( ) . dispose ( ) ; 
return ReplaySubject . create ( ) ; 
ReplaySubject < String > subject = ReplaySubject . create ( ) ; Observer < String > o1 = TestHelper . mockObserver ( ) ; subject . subscribe ( o1 ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; subject . onNext ( "four" ) ; subject . onComplete ( ) ; subject . onError ( new Throwable ( ) ) ; assertCompletedSubscriber ( o1 ) ; Observer < String > o2 = TestHelper . mockObserver ( ) ; subject . subscribe ( o2 ) ; assertCompletedSubscriber ( o2 ) ; 
ReplaySubject < Integer > channel = ReplaySubject . create ( ) ; Observer < Object > observerA = TestHelper . mockObserver ( ) ; Observer < Object > observerB = TestHelper . mockObserver ( ) ; Observer < Object > observerC = TestHelper . mockObserver ( ) ; Observer < Object > observerD = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( observerA ) ; channel . subscribe ( to ) ; channel . subscribe ( observerB ) ; InOrder inOrderA = inOrder ( observerA ) ; InOrder inOrderB = inOrder ( observerB ) ; InOrder inOrderC = inOrder ( observerC ) ; InOrder inOrderD = inOrder ( observerD ) ; channel . onNext ( 42 ) ; inOrderA . verify ( observerA ) . onNext ( 42 ) ; inOrderB . verify ( observerB ) . onNext ( 42 ) ; to . dispose ( ) ; inOrderA . verifyNoMoreInteractions ( ) ; channel . onNext ( 4711 ) ; inOrderB . verify ( observerB ) . onNext ( 4711 ) ; channel . onComplete ( ) ; inOrderB . verify ( observerB ) . onComplete ( ) ; channel . subscribe ( observerC ) ; inOrderC . verify ( observerC ) . onNext ( 42 ) ; inOrderC . verify ( observerC ) . onNext ( 4711 ) ; inOrderC . verify ( observerC ) . onComplete ( ) ; channel . onNext ( 13 ) ; channel . onNext ( 14 ) ; channel . onNext ( 15 ) ; channel . onError ( new RuntimeException ( ) ) ; channel . subscribe ( observerD ) ; inOrderD . verify ( observerD ) . onNext ( 42 ) ; inOrderD . verify ( observerD ) . onNext ( 4711 ) ; inOrderD . verify ( observerD ) . onComplete ( ) ; verify ( observerA ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; verify ( observerB ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; verify ( observerC ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; verify ( observerD ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; Mockito . verifyNoMoreInteractions ( observerA ) ; Mockito . verifyNoMoreInteractions ( observerB ) ; Mockito . verifyNoMoreInteractions ( observerC ) ; Mockito . verifyNoMoreInteractions ( observerD ) ; 
ReplaySubject < String > subject = ReplaySubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . onNext ( "one" ) ; subject . onError ( testException ) ; subject . onNext ( "two" ) ; subject . onComplete ( ) ; subject . onError ( new RuntimeException ( ) ) ; subject . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onError ( testException ) ; verifyNoMoreInteractions ( observer ) ; 
InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
ReplaySubject < String > subject = ReplaySubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; subject . onError ( testException ) ; subject . onNext ( "four" ) ; subject . onError ( new Throwable ( ) ) ; subject . onComplete ( ) ; assertErrorSubscriber ( observer ) ; observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; assertErrorSubscriber ( observer ) ; 
verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onError ( testException ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
ReplaySubject < String > subject = ReplaySubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; assertObservedUntilTwo ( observer ) ; Observer < String > anotherSubscriber = TestHelper . mockObserver ( ) ; subject . subscribe ( anotherSubscriber ) ; assertObservedUntilTwo ( anotherSubscriber ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; assertCompletedSubscriber ( observer ) ; assertCompletedSubscriber ( anotherSubscriber ) ; 
ReplaySubject < String > subject = ReplaySubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; subject . subscribe ( to ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; to . dispose ( ) ; assertObservedUntilTwo ( observer ) ; Observer < String > anotherSubscriber = TestHelper . mockObserver ( ) ; subject . subscribe ( anotherSubscriber ) ; assertObservedUntilTwo ( anotherSubscriber ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; assertObservedUntilTwo ( observer ) ; assertCompletedSubscriber ( anotherSubscriber ) ; 
verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
final AtomicReference < String > lastValueForSubscriber1 = new AtomicReference < > ( ) ; Observer < String > observer1 = new DefaultObserver < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String v ) System . out . println ( "observer1: " + v ) ; lastValueForSubscriber1 . set ( v ) ; ; final AtomicReference < String > lastValueForSubscriber2 = new AtomicReference < > ( ) ; final CountDownLatch oneReceived = new CountDownLatch ( 1 ) ; final CountDownLatch makeSlow = new CountDownLatch ( 1 ) ; final CountDownLatch completed = new CountDownLatch ( 1 ) ; Observer < String > observer2 = new DefaultObserver < String > ( ) @ Override public void onComplete ( ) completed . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( String v ) System . out . println ( "observer2: " + v ) ; if ( v . equals ( "one" ) ) oneReceived . countDown ( ) ; else try makeSlow . await ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; lastValueForSubscriber2 . set ( v ) ; ; ReplaySubject < String > subject = ReplaySubject . create ( ) ; subject . subscribe ( observer1 ) ; subject . onNext ( "one" ) ; assertEquals ( "one" , lastValueForSubscriber1 . get ( ) ) ; subject . onNext ( "two" ) ; assertEquals ( "two" , lastValueForSubscriber1 . get ( ) ) ; subject . subscribeOn ( Schedulers . newThread ( ) ) . subscribe ( observer2 ) ; System . out . println ( "before waiting for one" ) ; oneReceived . await ( ) ; System . out . println ( "after waiting for one" ) ; subject . onNext ( "three" ) ; System . out . println ( "sent three" ) ; assertEquals ( "three" , lastValueForSubscriber1 . get ( ) ) ; System . out . println ( "about to send onComplete" ) ; subject . onComplete ( ) ; System . out . println ( "completed subject" ) ; makeSlow . countDown ( ) ; System . out . println ( "makeSlow released" ) ; completed . await ( ) ; assertEquals ( "three" , lastValueForSubscriber2 . get ( ) ) ; 
ReplaySubject < Object > subject = ReplaySubject . create ( ) ; Disposable d = subject . subscribe ( ) ; assertEquals ( 1 , subject . observerCount ( ) ) ; d . dispose ( ) ; assertEquals ( 0 , subject . observerCount ( ) ) ; 
ReplaySubject < String > src = ReplaySubject . create ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) final Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; String v = "" + i ; src . onNext ( v ) ; System . out . printf ( "Turn: %d%n" , i ) ; src . firstElement ( ) . toObservable ( ) . flatMap ( new Function < String , Observable < String > > ( ) @ Override public Observable < String > apply ( String t1 ) return Observable . just ( t1 + ", " + t1 ) ; ) . subscribe ( new DefaultObserver < String > ( ) @ Override public void onNext ( String t ) System . out . println ( t ) ; o . onNext ( t ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; ) ; inOrder . verify ( o ) . onNext ( "0, 0" ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
ReplaySubject < Integer > source = ReplaySubject . create ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; final Observer < Integer > o = TestHelper . mockObserver ( ) ; source . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onNext ( Integer t ) o . onNext ( t ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onNext ( 2 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
ReplaySubject < Integer > source = ReplaySubject . createWithSize ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; for ( int i = 0 ; i < 1 ; i ++ ) Observer < Integer > o = TestHelper . mockObserver ( ) ; source . subscribe ( o ) ; verify ( o , never ( ) ) . onNext ( 1 ) ; verify ( o ) . onNext ( 2 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
ReplaySubject < Integer > source = ReplaySubject . createWithSize ( 1 ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . subscribe ( o ) ; source . onNext ( 3 ) ; source . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( 1 ) ; verify ( o ) . onNext ( 2 ) ; verify ( o ) . onNext ( 3 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplaySubject < Integer > source = ReplaySubject . createWithTime ( 1 , TimeUnit . SECONDS , scheduler ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 3 ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; source . subscribe ( o ) ; verify ( o , never ( ) ) . onNext ( 1 ) ; verify ( o , never ( ) ) . onNext ( 2 ) ; verify ( o , never ( ) ) . onNext ( 3 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplaySubject < Integer > source = ReplaySubject . createWithTime ( 1 , TimeUnit . SECONDS , scheduler ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; source . subscribe ( o ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o , never ( ) ) . onNext ( 1 ) ; verify ( o ) . onNext ( 2 ) ; verify ( o ) . onNext ( 3 ) ; verify ( o ) . onComplete ( ) ; 
ReplaySubject < Object > as = ReplaySubject . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 1 ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
ReplaySubject < Object > as = ReplaySubject . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
ReplaySubject < Object > as = ReplaySubject . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onError ( new TestException ( ) ) ; assertTrue ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertTrue ( as . getThrowable ( ) instanceof TestException ) ; 
ReplaySubject < Object > rs = ReplaySubject . create ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onComplete ( ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . createUnbounded ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onComplete ( ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . create ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onError ( new TestException ( ) ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . createUnbounded ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onNext ( 1 ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onError ( new TestException ( ) ) ; assertEquals ( 2 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . create ( ) ; rs . onError ( new TestException ( ) ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . createUnbounded ( ) ; rs . onError ( new TestException ( ) ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . create ( ) ; rs . onComplete ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . createUnbounded ( ) ; rs . onComplete ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . createWithSize ( 1 ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) rs . onNext ( i ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; rs . onComplete ( ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; 
TestScheduler to = new TestScheduler ( ) ; ReplaySubject < Object > rs = ReplaySubject . createWithTime ( 1 , TimeUnit . SECONDS , to ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) rs . onNext ( i ) ; assertEquals ( 1 , rs . size ( ) ) ; assertTrue ( rs . hasValue ( ) ) ; to . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; rs . onComplete ( ) ; assertEquals ( 0 , rs . size ( ) ) ; assertFalse ( rs . hasValue ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . create ( ) ; Object [ ] expected = new Object [ 10 ] ; for ( int i = 0 ; i < expected . length ; i ++ ) expected [ i ] = i ; rs . onNext ( i ) ; assertArrayEquals ( Arrays . copyOf ( expected , i + 1 ) , rs . getValues ( ) ) ; rs . onComplete ( ) ; assertArrayEquals ( expected , rs . getValues ( ) ) ; 
ReplaySubject < Object > rs = ReplaySubject . createUnbounded ( ) ; Object [ ] expected = new Object [ 10 ] ; for ( int i = 0 ; i < expected . length ; i ++ ) expected [ i ] = i ; rs . onNext ( i ) ; assertArrayEquals ( Arrays . copyOf ( expected , i + 1 ) , rs . getValues ( ) ) ; rs . onComplete ( ) ; assertArrayEquals ( expected , rs . getValues ( ) ) ; 
try ReplaySubject . create ( - 99 ) ; fail ( "Didn't throw IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "capacityHint > 0 required but it was -99" , ex . getMessage ( ) ) ; 
try ReplaySubject . createWithSize ( - 99 ) ; fail ( "Didn't throw IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "maxSize > 0 required but it was -99" , ex . getMessage ( ) ) ; 
try ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . computation ( ) , - 99 ) ; fail ( "Didn't throw IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "maxSize > 0 required but it was -99" , ex . getMessage ( ) ) ; 
ReplaySubject < Integer > rp = ReplaySubject . create ( ) ; assertFalse ( rp . hasObservers ( ) ) ; TestObserver < Integer > to = rp . test ( ) ; assertTrue ( rp . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( rp . hasObservers ( ) ) ; 
ReplaySubject < Integer > rp = ReplaySubject . create ( ) ; rp . onNext ( 1 ) ; assertEquals ( ( Integer ) 1 , rp . getValue ( ) ) ; assertEquals ( 1 , rp . getValues ( ) [ 0 ] ) ; 
ReplaySubject < Integer > rp = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . computation ( ) , 1 ) ; rp . onNext ( 1 ) ; assertEquals ( ( Integer ) 1 , rp . getValue ( ) ) ; assertEquals ( 1 , rp . getValues ( ) [ 0 ] ) ; rp . onNext ( 2 ) ; assertEquals ( ( Integer ) 2 , rp . getValue ( ) ) ; assertEquals ( 2 , rp . getValues ( ) [ 0 ] ) ; assertEquals ( ( Integer ) 2 , rp . getValues ( new Integer [ 0 ] ) [ 0 ] ) ; assertEquals ( ( Integer ) 2 , rp . getValues ( new Integer [ 1 ] ) [ 0 ] ) ; Integer [ ] a = new Integer [ 2 ] ; assertEquals ( ( Integer ) 2 , rp . getValues ( a ) [ 0 ] ) ; assertNull ( a [ 1 ] ) ; 
ReplaySubject < Integer > rp = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . computation ( ) , 1 ) ; assertNull ( rp . getValue ( ) ) ; assertEquals ( 0 , rp . getValues ( ) . length ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; rp . onComplete ( ) ; assertNull ( rp . getValue ( ) ) ; assertEquals ( 0 , rp . getValues ( ) . length ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; rp = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . computation ( ) , 1 ) ; rp . onError ( new TestException ( ) ) ; assertNull ( rp . getValue ( ) ) ; assertEquals ( 0 , rp . getValues ( ) . length ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplaySubject < Integer > rp = ReplaySubject . createWithTime ( 1 , TimeUnit . DAYS , scheduler ) ; assertNull ( rp . getValue ( ) ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; rp . onNext ( 2 ) ; assertEquals ( ( Integer ) 2 , rp . getValue ( ) ) ; assertEquals ( 2 , rp . getValues ( ) [ 0 ] ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . DAYS ) ; assertNull ( rp . getValue ( ) ) ; assertEquals ( 0 , rp . getValues ( ) . length ) ; assertNull ( rp . getValues ( new Integer [ 2 ] ) [ 0 ] ) ; 
ReplaySubject < Integer > rp = ReplaySubject . create ( 8 ) ; for ( int i = 0 ; i < 15 ; i ++ ) rp . onNext ( i ) ; rp . onComplete ( ) ; rp . test ( ) . assertResult ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestObserver < Integer > to = new TestObserver < > ( ) ; final ReplaySubject < Integer > rp = ReplaySubject . create ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) rp . subscribe ( to ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
ReplaySubject < Integer > rp = ReplaySubject . create ( ) ; rp . onComplete ( ) ; Disposable bs = Disposable . empty ( ) ; rp . onSubscribe ( bs ) ; assertTrue ( bs . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ReplaySubject < Integer > rp = ReplaySubject . create ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) rp . test ( ) ; ; TestHelper . race ( r1 , r1 ) ; 
ReplaySubject < Integer > rp = ReplaySubject . create ( ) ; rp . test ( ) ; rp . test ( ) ; TestObserver < Integer > to = rp . test ( true ) ; assertEquals ( 2 , rp . observerCount ( ) ) ; to . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ReplaySubject < Integer > rp = ReplaySubject . create ( ) ; final TestObserver < Integer > to1 = rp . test ( ) ; final TestObserver < Integer > to2 = rp . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to2 . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertFalse ( rp . hasObservers ( ) ) ; 
ReplaySubject < Integer > rp = ReplaySubject . createWithSize ( 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; rp . onNext ( 4 ) ; rp . onError ( new TestException ( ) ) ; rp . test ( ) . assertFailure ( TestException . class , 3 , 4 ) ; 
ReplaySubject < Integer > rp = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; rp . onNext ( 4 ) ; rp . onError ( new TestException ( ) ) ; rp . test ( ) . assertFailure ( TestException . class , 3 , 4 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplaySubject < Integer > rp = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; rp . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; rp . test ( ) . assertEmpty ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplaySubject < Integer > rp = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; rp . take ( 1 ) . test ( ) . assertResult ( 2 ) ; 
ReplaySubject < Integer > rp = ReplaySubject . createWithSize ( 2 ) ; rp . onNext ( 1 ) ; rp . onNext ( 2 ) ; rp . onNext ( 3 ) ; rp . take ( 1 ) . test ( ) . assertResult ( 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final ReplaySubject < Integer > rp = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) rp . onNext ( 2 ) ; super . onNext ( t ) ; ; rp . subscribe ( to ) ; rp . onNext ( 1 ) ; rp . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
TestHelper . checkDisposed ( ReplaySubject . create ( ) ) ; TestHelper . checkDisposed ( ReplaySubject . createUnbounded ( ) ) ; TestHelper . checkDisposed ( ReplaySubject . createWithSize ( 10 ) ) ; TestHelper . checkDisposed ( ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , Schedulers . single ( ) , 10 ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplaySubject < Integer > source = ReplaySubject . createWithTime ( 2 , TimeUnit . SECONDS , scheduler ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; source . test ( ) . assertResult ( 1 ) ; source . test ( ) . assertResult ( 1 ) ; scheduler . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; source . test ( ) . assertResult ( ) ; 
ReplaySubject < Integer > source = ReplaySubject . createWithSize ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; SizeBoundReplayBuffer < Integer > buf = ( SizeBoundReplayBuffer < Integer > ) source . buffer ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
ReplaySubject < Integer > source = ReplaySubject . createWithSize ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; SizeBoundReplayBuffer < Integer > buf = ( SizeBoundReplayBuffer < Integer > ) source . buffer ; assertNotNull ( buf . head . value ) ; source . cleanupBuffer ( ) ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
ReplaySubject < Integer > source = ReplaySubject . createWithTime ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = ( SizeAndTimeBoundReplayBuffer < Integer > ) source . buffer ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
TestScheduler sch = new TestScheduler ( ) ; ReplaySubject < Integer > source = ReplaySubject . createWithTime ( 1 , TimeUnit . MILLISECONDS , sch ) ; source . onNext ( 1 ) ; sch . advanceTimeBy ( 2 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = ( SizeAndTimeBoundReplayBuffer < Integer > ) source . buffer ; assertNotNull ( buf . head . value ) ; source . cleanupBuffer ( ) ; assertNull ( buf . head . value ) ; Object o = buf . head ; source . cleanupBuffer ( ) ; assertSame ( o , buf . head ) ; 
final ReplaySubject < byte [ ] > rs = ReplaySubject . createWithSize ( 1 ) ; Observable < byte [ ] > source = rs . take ( 1 ) . concatMap ( new Function < byte [ ] , Observable < byte [ ] > > ( ) @ Override public Observable < byte [ ] > apply ( byte [ ] v ) throws Exception return rs ; ) . takeLast ( 1 ) ; System . out . println ( "Bounded Replay Leak check: Wait before GC" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check: GC" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long initial = memHeap . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; final AtomicLong after = new AtomicLong ( ) ; source . subscribe ( new Consumer < byte [ ] > ( ) @ Override public void accept ( byte [ ] v ) throws Exception System . out . println ( "Bounded Replay Leak check: Wait before GC 2" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check:  GC 2" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; after . set ( memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ) ; ) ; for ( int i = 0 ; i < 200 ; i ++ ) rs . onNext ( new byte [ 1024 * 1024 ] ) ; rs . onComplete ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after . get ( ) / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after . get ( ) ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after . get ( ) / 1024.0 / 1024.0 ) ; 
ReplaySubject < Integer > rs = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , 1 ) ; TestObserver < Integer > to = rs . test ( ) ; rs . onNext ( 1 ) ; rs . cleanupBuffer ( ) ; rs . onComplete ( ) ; to . assertNoErrors ( ) . assertComplete ( ) ; 
ReplaySubject < Integer > rs = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , 1 ) ; TestObserver < Integer > to = rs . test ( ) ; rs . onNext ( 1 ) ; rs . cleanupBuffer ( ) ; rs . onNext ( 2 ) ; rs . cleanupBuffer ( ) ; rs . onComplete ( ) ; to . assertNoErrors ( ) . assertComplete ( ) ; 
ReplaySubject < Integer > rs = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , 1 ) ; TestObserver < Integer > to = rs . test ( ) ; rs . onNext ( 1 ) ; rs . onNext ( 2 ) ; rs . onComplete ( ) ; to . assertNoErrors ( ) . assertComplete ( ) ; 
ReplaySubject < Integer > rs = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , 10 ) ; TestObserver < Integer > to = rs . test ( ) ; rs . onNext ( 1 ) ; rs . onNext ( 2 ) ; rs . onComplete ( ) ; to . assertNoErrors ( ) . assertComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ReplaySubject < Integer > rs = ReplaySubject . createWithTimeAndSize ( 1 , TimeUnit . SECONDS , scheduler , 2 ) ; rs . onNext ( 1 ) ; rs . onNext ( 2 ) ; rs . onNext ( 3 ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; rs . onNext ( 4 ) ; rs . onNext ( 5 ) ; rs . test ( ) . assertValuesOnly ( 4 , 5 ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; assertFalse ( ss . hasValue ( ) ) ; assertNull ( ss . getValue ( ) ) ; assertFalse ( ss . hasThrowable ( ) ) ; assertNull ( ss . getThrowable ( ) ) ; assertFalse ( ss . hasObservers ( ) ) ; assertEquals ( 0 , ss . observerCount ( ) ) ; TestObserver < Integer > to = ss . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ss . hasObservers ( ) ) ; assertEquals ( 1 , ss . observerCount ( ) ) ; ss . onSuccess ( 1 ) ; assertTrue ( ss . hasValue ( ) ) ; assertEquals ( 1 , ss . getValue ( ) . intValue ( ) ) ; assertFalse ( ss . hasThrowable ( ) ) ; assertNull ( ss . getThrowable ( ) ) ; assertFalse ( ss . hasObservers ( ) ) ; assertEquals ( 0 , ss . observerCount ( ) ) ; to . assertResult ( 1 ) ; ss . test ( ) . assertResult ( 1 ) ; assertTrue ( ss . hasValue ( ) ) ; assertEquals ( 1 , ss . getValue ( ) . intValue ( ) ) ; assertFalse ( ss . hasThrowable ( ) ) ; assertNull ( ss . getThrowable ( ) ) ; assertFalse ( ss . hasObservers ( ) ) ; assertEquals ( 0 , ss . observerCount ( ) ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = ss . test ( ) ; ss . onSuccess ( 1 ) ; ss . onSuccess ( 2 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ss . onError ( new IOException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; to . assertResult ( 1 ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; assertFalse ( ss . hasValue ( ) ) ; assertNull ( ss . getValue ( ) ) ; assertFalse ( ss . hasThrowable ( ) ) ; assertNull ( ss . getThrowable ( ) ) ; assertFalse ( ss . hasObservers ( ) ) ; assertEquals ( 0 , ss . observerCount ( ) ) ; TestObserver < Integer > to = ss . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ss . hasObservers ( ) ) ; assertEquals ( 1 , ss . observerCount ( ) ) ; ss . onError ( new IOException ( ) ) ; assertFalse ( ss . hasValue ( ) ) ; assertNull ( ss . getValue ( ) ) ; assertTrue ( ss . hasThrowable ( ) ) ; assertTrue ( ss . getThrowable ( ) . toString ( ) , ss . getThrowable ( ) instanceof IOException ) ; assertFalse ( ss . hasObservers ( ) ) ; assertEquals ( 0 , ss . observerCount ( ) ) ; to . assertFailure ( IOException . class ) ; ss . test ( ) . assertFailure ( IOException . class ) ; assertFalse ( ss . hasValue ( ) ) ; assertNull ( ss . getValue ( ) ) ; assertTrue ( ss . hasThrowable ( ) ) ; assertTrue ( ss . getThrowable ( ) . toString ( ) , ss . getThrowable ( ) instanceof IOException ) ; assertFalse ( ss . hasObservers ( ) ) ; assertEquals ( 0 , ss . observerCount ( ) ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; try ss . onSuccess ( null ) ; fail ( "No NullPointerException thrown" ) ; catch ( NullPointerException ex ) assertEquals ( ExceptionHelper . nullWarning ( "onSuccess called with a null value." ) , ex . getMessage ( ) ) ; ss . test ( ) . assertEmpty ( ) . dispose ( ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; try ss . onError ( null ) ; fail ( "No NullPointerException thrown" ) ; catch ( NullPointerException ex ) assertEquals ( ExceptionHelper . nullWarning ( "onError called with a null Throwable." ) , ex . getMessage ( ) ) ; ss . test ( ) . assertEmpty ( ) . dispose ( ) ; 
SingleSubject . create ( ) . test ( true ) . assertEmpty ( ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; ss . test ( ) ; ss . test ( true ) . assertEmpty ( ) ; 
TestHelper . checkDisposed ( SingleSubject . create ( ) ) ; 
SingleSubject . create ( ) . subscribe ( new SingleObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; Disposable d = Disposable . empty ( ) ; ss . onSubscribe ( d ) ; assertFalse ( d . isDisposed ( ) ) ; ss . onSuccess ( 1 ) ; d = Disposable . empty ( ) ; ss . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final SingleSubject < Integer > ss = SingleSubject . create ( ) ; final TestObserver < Integer > to = ss . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ss . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
return PublishSubject . create ( ) ; 
PublishSubject < String > subject = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; Observer < String > anotherSubscriber = TestHelper . mockObserver ( ) ; subject . subscribe ( anotherSubscriber ) ; subject . onNext ( "four" ) ; subject . onComplete ( ) ; subject . onError ( new Throwable ( ) ) ; assertCompletedSubscriber ( observer ) ; 
PublishSubject < Object > channel = PublishSubject . create ( ) ; Observer < Object > observerA = TestHelper . mockObserver ( ) ; Observer < Object > observerB = TestHelper . mockObserver ( ) ; Observer < Object > observerC = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( observerA ) ; channel . subscribe ( to ) ; channel . subscribe ( observerB ) ; InOrder inOrderA = inOrder ( observerA ) ; InOrder inOrderB = inOrder ( observerB ) ; InOrder inOrderC = inOrder ( observerC ) ; channel . onNext ( 42 ) ; inOrderA . verify ( observerA ) . onNext ( 42 ) ; inOrderB . verify ( observerB ) . onNext ( 42 ) ; to . dispose ( ) ; inOrderA . verifyNoMoreInteractions ( ) ; channel . onNext ( 4711 ) ; inOrderB . verify ( observerB ) . onNext ( 4711 ) ; channel . onComplete ( ) ; inOrderB . verify ( observerB ) . onComplete ( ) ; channel . subscribe ( observerC ) ; inOrderC . verify ( observerC ) . onComplete ( ) ; channel . onNext ( 13 ) ; inOrderB . verifyNoMoreInteractions ( ) ; inOrderC . verifyNoMoreInteractions ( ) ; 
verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
PublishSubject < String > subject = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; subject . onError ( testException ) ; Observer < String > anotherSubscriber = TestHelper . mockObserver ( ) ; subject . subscribe ( anotherSubscriber ) ; subject . onNext ( "four" ) ; subject . onError ( new Throwable ( ) ) ; subject . onComplete ( ) ; assertErrorSubscriber ( observer ) ; 
verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onError ( testException ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
PublishSubject < String > subject = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; assertObservedUntilTwo ( observer ) ; Observer < String > anotherSubscriber = TestHelper . mockObserver ( ) ; subject . subscribe ( anotherSubscriber ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; assertCompletedSubscriber ( observer ) ; assertCompletedStartingWithThreeSubscriber ( anotherSubscriber ) ; 
verify ( observer , Mockito . never ( ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
PublishSubject < String > subject = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; subject . subscribe ( to ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; to . dispose ( ) ; assertObservedUntilTwo ( observer ) ; Observer < String > anotherSubscriber = TestHelper . mockObserver ( ) ; subject . subscribe ( anotherSubscriber ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; assertObservedUntilTwo ( observer ) ; assertCompletedStartingWithThreeSubscriber ( anotherSubscriber ) ; 
verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
final PublishSubject < Integer > s = PublishSubject . create ( ) ; final AtomicInteger countParent = new AtomicInteger ( ) ; final AtomicInteger countChildren = new AtomicInteger ( ) ; final AtomicInteger countTotal = new AtomicInteger ( ) ; final ArrayList < String > list = new ArrayList < > ( ) ; s . flatMap ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( final Integer v ) countParent . incrementAndGet ( ) ; return s . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer v2 ) countChildren . incrementAndGet ( ) ; return "Parent: " + v + " Child: " + v2 ; ) ; ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) countTotal . incrementAndGet ( ) ; list . add ( v ) ; ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; s . onComplete ( ) ; assertEquals ( 45 , list . size ( ) ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observer < Integer > o1 = TestHelper . mockObserver ( ) ; TestObserver < Integer > to = new TestObserver < > ( o1 ) ; ps . subscribe ( to ) ; ps . onNext ( 1 ) ; InOrder inOrder1 = inOrder ( o1 ) ; inOrder1 . verify ( o1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder1 . verifyNoMoreInteractions ( ) ; to . dispose ( ) ; ps . onNext ( 2 ) ; Observer < Integer > o2 = TestHelper . mockObserver ( ) ; TestObserver < Integer > to2 = new TestObserver < > ( o2 ) ; ps . subscribe ( to2 ) ; ps . onNext ( 3 ) ; InOrder inOrder2 = inOrder ( o2 ) ; inOrder2 . verify ( o2 , times ( 1 ) ) . onNext ( 3 ) ; inOrder2 . verifyNoMoreInteractions ( ) ; to2 . dispose ( ) ; 
PublishSubject < String > src = PublishSubject . create ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) final Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; String v = "" + i ; System . out . printf ( "Turn: %d%n" , i ) ; src . firstElement ( ) . toObservable ( ) . flatMap ( new Function < String , Observable < String > > ( ) @ Override public Observable < String > apply ( String t1 ) return Observable . just ( t1 + ", " + t1 ) ; ) . subscribe ( new DefaultObserver < String > ( ) @ Override public void onNext ( String t ) o . onNext ( t ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; ) ; src . onNext ( v ) ; inOrder . verify ( o ) . onNext ( v + ", " + v ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Object > as = PublishSubject . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 1 ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
PublishSubject < Object > as = PublishSubject . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
PublishSubject < Object > as = PublishSubject . create ( ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onError ( new TestException ( ) ) ; assertTrue ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertTrue ( as . getThrowable ( ) instanceof TestException ) ; 
final TestObserver < Integer > to1 = new TestObserver < > ( ) ; TestObserver < Integer > to2 = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; to1 . dispose ( ) ; ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . subscribe ( to2 ) ; ps . subscribe ( to1 ) ; ps . onNext ( 1 ) ; to2 . assertValue ( 1 ) ; to1 . assertNoValues ( ) ; 
final TestObserver < Integer > to1 = new TestObserver < > ( ) ; TestObserver < Integer > to2 = new TestObserver < Integer > ( ) @ Override public void onError ( Throwable t ) super . onError ( t ) ; to1 . dispose ( ) ; ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . subscribe ( to2 ) ; ps . subscribe ( to1 ) ; ps . onError ( new TestException ( ) ) ; to2 . assertError ( TestException . class ) ; to1 . assertNoErrors ( ) ; 
final TestObserver < Integer > to1 = new TestObserver < > ( ) ; TestObserver < Integer > to2 = new TestObserver < Integer > ( ) @ Override public void onComplete ( ) super . onComplete ( ) ; to1 . dispose ( ) ; ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . subscribe ( to2 ) ; ps . subscribe ( to1 ) ; ps . onComplete ( ) ; to2 . assertComplete ( ) ; to1 . assertNotComplete ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . test ( ) ; ps . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) d . dispose ( ) ; d . dispose ( ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . test ( ) ; Runnable task = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( task , task ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . subscribe ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . subscribe ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . subscribe ( to ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . onComplete ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; ps2 . subscribe ( ps ) ; assertFalse ( ps2 . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; ps . subscribe ( ps2 ) ; TestObserver < Integer > to = ps2 . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; assertFalse ( ms . hasValue ( ) ) ; assertNull ( ms . getValue ( ) ) ; assertFalse ( ms . hasComplete ( ) ) ; assertFalse ( ms . hasThrowable ( ) ) ; assertNull ( ms . getThrowable ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; TestObserver < Integer > to = ms . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; assertEquals ( 1 , ms . observerCount ( ) ) ; ms . onSuccess ( 1 ) ; assertTrue ( ms . hasValue ( ) ) ; assertEquals ( 1 , ms . getValue ( ) . intValue ( ) ) ; assertFalse ( ms . hasComplete ( ) ) ; assertFalse ( ms . hasThrowable ( ) ) ; assertNull ( ms . getThrowable ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; to . assertResult ( 1 ) ; ms . test ( ) . assertResult ( 1 ) ; assertTrue ( ms . hasValue ( ) ) ; assertEquals ( 1 , ms . getValue ( ) . intValue ( ) ) ; assertFalse ( ms . hasComplete ( ) ) ; assertFalse ( ms . hasThrowable ( ) ) ; assertNull ( ms . getThrowable ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ms . test ( ) ; ms . onSuccess ( 1 ) ; ms . onSuccess ( 2 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ms . onError ( new IOException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; ms . onComplete ( ) ; to . assertResult ( 1 ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; assertFalse ( ms . hasValue ( ) ) ; assertNull ( ms . getValue ( ) ) ; assertFalse ( ms . hasComplete ( ) ) ; assertFalse ( ms . hasThrowable ( ) ) ; assertNull ( ms . getThrowable ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; TestObserver < Integer > to = ms . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; assertEquals ( 1 , ms . observerCount ( ) ) ; ms . onError ( new IOException ( ) ) ; assertFalse ( ms . hasValue ( ) ) ; assertNull ( ms . getValue ( ) ) ; assertFalse ( ms . hasComplete ( ) ) ; assertTrue ( ms . hasThrowable ( ) ) ; assertTrue ( ms . getThrowable ( ) . toString ( ) , ms . getThrowable ( ) instanceof IOException ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; to . assertFailure ( IOException . class ) ; ms . test ( ) . assertFailure ( IOException . class ) ; assertFalse ( ms . hasValue ( ) ) ; assertNull ( ms . getValue ( ) ) ; assertFalse ( ms . hasComplete ( ) ) ; assertTrue ( ms . hasThrowable ( ) ) ; assertTrue ( ms . getThrowable ( ) . toString ( ) , ms . getThrowable ( ) instanceof IOException ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; assertFalse ( ms . hasValue ( ) ) ; assertNull ( ms . getValue ( ) ) ; assertFalse ( ms . hasComplete ( ) ) ; assertFalse ( ms . hasThrowable ( ) ) ; assertNull ( ms . getThrowable ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; TestObserver < Integer > to = ms . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; assertEquals ( 1 , ms . observerCount ( ) ) ; ms . onComplete ( ) ; assertFalse ( ms . hasValue ( ) ) ; assertNull ( ms . getValue ( ) ) ; assertTrue ( ms . hasComplete ( ) ) ; assertFalse ( ms . hasThrowable ( ) ) ; assertNull ( ms . getThrowable ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; to . assertResult ( ) ; ms . test ( ) . assertResult ( ) ; assertFalse ( ms . hasValue ( ) ) ; assertNull ( ms . getValue ( ) ) ; assertTrue ( ms . hasComplete ( ) ) ; assertFalse ( ms . hasThrowable ( ) ) ; assertNull ( ms . getThrowable ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; assertEquals ( 0 , ms . observerCount ( ) ) ; 
MaybeSubject . create ( ) . test ( true ) . assertEmpty ( ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; ms . test ( ) ; ms . test ( true ) . assertEmpty ( ) ; 
TestHelper . checkDisposed ( MaybeSubject . create ( ) ) ; 
MaybeSubject . create ( ) . subscribe ( new MaybeObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; Disposable d = Disposable . empty ( ) ; ms . onSubscribe ( d ) ; assertFalse ( d . isDisposed ( ) ) ; ms . onComplete ( ) ; d = Disposable . empty ( ) ; ms . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestObserver < Integer > to = ms . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ms . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
return BehaviorSubject . create ( ) ; 
BehaviorSubject < String > subject = BehaviorSubject . createDefault ( "default" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onNext ( "default" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( testException ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
BehaviorSubject < String > subject = BehaviorSubject . createDefault ( "default" ) ; subject . onNext ( "one" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "default" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( testException ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
BehaviorSubject < String > subject = BehaviorSubject . createDefault ( "default" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "default" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
BehaviorSubject < String > subject = BehaviorSubject . createDefault ( "default" ) ; subject . onNext ( "one" ) ; subject . onComplete ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( "default" ) ; verify ( observer , never ( ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
BehaviorSubject < String > subject = BehaviorSubject . createDefault ( "default" ) ; subject . onNext ( "one" ) ; RuntimeException re = new RuntimeException ( "test error" ) ; subject . onError ( re ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( "default" ) ; verify ( observer , never ( ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onError ( re ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
BehaviorSubject < Integer > channel = BehaviorSubject . createDefault ( 2013 ) ; Observer < Object > observerA = TestHelper . mockObserver ( ) ; Observer < Object > observerB = TestHelper . mockObserver ( ) ; Observer < Object > observerC = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( observerA ) ; channel . subscribe ( to ) ; channel . subscribe ( observerB ) ; InOrder inOrderA = inOrder ( observerA ) ; InOrder inOrderB = inOrder ( observerB ) ; InOrder inOrderC = inOrder ( observerC ) ; inOrderA . verify ( observerA ) . onNext ( 2013 ) ; inOrderB . verify ( observerB ) . onNext ( 2013 ) ; channel . onNext ( 42 ) ; inOrderA . verify ( observerA ) . onNext ( 42 ) ; inOrderB . verify ( observerB ) . onNext ( 42 ) ; to . dispose ( ) ; inOrderA . verifyNoMoreInteractions ( ) ; channel . onNext ( 4711 ) ; inOrderB . verify ( observerB ) . onNext ( 4711 ) ; channel . onComplete ( ) ; inOrderB . verify ( observerB ) . onComplete ( ) ; channel . subscribe ( observerC ) ; inOrderC . verify ( observerC ) . onComplete ( ) ; channel . onNext ( 13 ) ; inOrderB . verifyNoMoreInteractions ( ) ; inOrderC . verifyNoMoreInteractions ( ) ; 
BehaviorSubject < String > subject = BehaviorSubject . createDefault ( "default" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onError ( testException ) ; subject . onNext ( "two" ) ; subject . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "default" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onError ( testException ) ; verify ( observer , never ( ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
BehaviorSubject < String > subject = BehaviorSubject . createDefault ( "default" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onError ( testException ) ; subject . onNext ( "two" ) ; subject . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "default" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onError ( testException ) ; verify ( observer , never ( ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; Observer < Object > o2 = TestHelper . mockObserver ( ) ; subject . subscribe ( o2 ) ; verify ( o2 , times ( 1 ) ) . onError ( testException ) ; verify ( o2 , never ( ) ) . onNext ( any ( ) ) ; verify ( o2 , never ( ) ) . onComplete ( ) ; 
BehaviorSubject < String > subject = BehaviorSubject . createDefault ( "default" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onComplete ( ) ; subject . onNext ( "two" ) ; subject . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "default" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onNext ( "two" ) ; Observer < Object > o2 = TestHelper . mockObserver ( ) ; subject . subscribe ( o2 ) ; verify ( o2 , times ( 1 ) ) . onComplete ( ) ; verify ( o2 , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
BehaviorSubject < String > src = BehaviorSubject . createDefault ( "null" ) ; for ( int i = 0 ; i < 10 ; i ++ ) final Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; String v = "" + i ; src . onNext ( v ) ; System . out . printf ( "Turn: %d%n" , i ) ; src . firstElement ( ) . toObservable ( ) . flatMap ( new Function < String , Observable < String > > ( ) @ Override public Observable < String > apply ( String t1 ) return Observable . just ( t1 + ", " + t1 ) ; ) . subscribe ( new DefaultObserver < String > ( ) @ Override public void onNext ( String t ) o . onNext ( t ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; ) ; inOrder . verify ( o ) . onNext ( v + ", " + v ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . create ( ) ; final Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . subscribe ( o ) ; inOrder . verify ( o , never ( ) ) . onNext ( any ( ) ) ; inOrder . verify ( o , never ( ) ) . onComplete ( ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; source . onNext ( 2 ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . create ( ) ; final Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . onNext ( 1 ) ; source . subscribe ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; source . onComplete ( ) ; source . onNext ( 2 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . create ( ) ; final Observer < Object > o = TestHelper . mockObserver ( ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; source . onNext ( 2 ) ; source . subscribe ( o ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . createDefault ( 1 ) ; final Observer < Object > o = TestHelper . mockObserver ( ) ; source . take ( 1 ) . subscribe ( o ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; assertEquals ( 0 , source . subscriberCount ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
Scheduler s = Schedulers . io ( ) ; Scheduler . Worker worker = Schedulers . io ( ) . createWorker ( ) ; try for ( int i = 0 ; i < 50000 ; i ++ ) if ( i % 1000 == 0 ) System . out . println ( i ) ; final BehaviorSubject < Object > rs = BehaviorSubject . create ( ) ; final CountDownLatch finish = new CountDownLatch ( 1 ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) try start . await ( ) ; catch ( Exception e1 ) e1 . printStackTrace ( ) ; rs . onNext ( 1 ) ; ) ; final AtomicReference < Object > o = new AtomicReference < > ( ) ; rs . subscribeOn ( s ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new DefaultObserver < Object > ( ) @ Override public void onComplete ( ) o . set ( - 1 ) ; finish . countDown ( ) ; @ Override public void onError ( Throwable e ) o . set ( e ) ; finish . countDown ( ) ; @ Override public void onNext ( Object t ) o . set ( t ) ; finish . countDown ( ) ; ) ; start . countDown ( ) ; if ( ! finish . await ( 5 , TimeUnit . SECONDS ) ) System . out . println ( o . get ( ) ) ; System . out . println ( rs . hasObservers ( ) ) ; rs . onComplete ( ) ; Assert . fail ( "Timeout @ " + i ) ; break ; else Assert . assertEquals ( 1 , o . get ( ) ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) rs . onComplete ( ) ; ) ; finally worker . dispose ( ) ; 
BehaviorSubject < Object > as = BehaviorSubject . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 1 ) ; assertTrue ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertEquals ( 1 , as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
BehaviorSubject < Object > as = BehaviorSubject . createDefault ( ( Object ) 1 ) ; assertTrue ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertEquals ( 1 , as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 2 ) ; assertTrue ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertEquals ( 2 , as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
BehaviorSubject < Object > as = BehaviorSubject . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
BehaviorSubject < Object > as = BehaviorSubject . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onError ( new TestException ( ) ) ; assertFalse ( as . hasValue ( ) ) ; assertTrue ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertTrue ( as . getThrowable ( ) instanceof TestException ) ; 
BehaviorSubject < Object > p = BehaviorSubject . create ( ) ; assertFalse ( p . hasObservers ( ) ) ; p . test ( true ) . assertEmpty ( ) ; assertFalse ( p . hasObservers ( ) ) ; 
BehaviorSubject < Object > p = BehaviorSubject . create ( ) ; Disposable bs = Disposable . empty ( ) ; p . onSubscribe ( bs ) ; assertFalse ( bs . isDisposed ( ) ) ; p . onComplete ( ) ; bs = Disposable . empty ( ) ; p . onSubscribe ( bs ) ; assertTrue ( bs . isDisposed ( ) ) ; 
BehaviorSubject < Object > p = BehaviorSubject . create ( ) ; p . onComplete ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try p . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
BehaviorSubject < Object > p = BehaviorSubject . create ( ) ; TestObserver < Object > to = p . test ( ) ; p . test ( true ) . assertEmpty ( ) ; p . onNext ( 1 ) ; p . onComplete ( ) ; to . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorSubject < Object > p = BehaviorSubject . create ( ) ; final TestObserver < Object > to = p . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) p . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorSubject < Object > p = BehaviorSubject . createDefault ( ( Object ) 1 ) ; final TestObserver [ ] to = null ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to [ 0 ] = p . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) p . onNext ( 2 ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to [ 0 ] . values ( ) . size ( ) == 1 ) to [ 0 ] . assertValue ( 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; else to [ 0 ] . assertValues ( 1 , 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
BehaviorSubject . create ( ) . subscribe ( new Observer < Object > ( ) @ Override public void onSubscribe ( Disposable d ) assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorSubject < Object > p = BehaviorSubject . create ( ) ; final TestObserver < Object > to = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) p . subscribe ( to ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) p . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final BehaviorSubject < Object > p = BehaviorSubject . create ( ) ; final TestObserver < Object > to = new TestObserver < > ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) p . subscribe ( to ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) p . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; 
BehaviorSubject < Integer > bs = BehaviorSubject . create ( ) ; bs . onNext ( 1 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; BehaviorDisposable < Integer > bd = new BehaviorDisposable < > ( to , bs ) ; to . onSubscribe ( bd ) ; assertFalse ( bd . isDisposed ( ) ) ; bd . dispose ( ) ; assertTrue ( bd . isDisposed ( ) ) ; bd . dispose ( ) ; assertTrue ( bd . isDisposed ( ) ) ; assertTrue ( bd . test ( 2 ) ) ; bd . emitFirst ( ) ; to . assertEmpty ( ) ; bd . emitNext ( 2 , 0 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) BehaviorSubject < Integer > bs = BehaviorSubject . create ( ) ; bs . onNext ( 1 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; final BehaviorDisposable < Integer > bd = new BehaviorDisposable < > ( to , bs ) ; to . onSubscribe ( bd ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) bd . emitFirst ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) bd . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) BehaviorSubject < Integer > bs = BehaviorSubject . create ( ) ; bs . onNext ( 1 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; final BehaviorDisposable < Integer > bd = new BehaviorDisposable < > ( to , bs ) ; to . onSubscribe ( bd ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) bd . emitNext ( 2 , 0 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) bd . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
BehaviorSubject < Integer > bs = BehaviorSubject . create ( ) ; bs . onNext ( 1 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; final BehaviorDisposable < Integer > bd = new BehaviorDisposable < > ( to , bs ) ; to . onSubscribe ( bd ) ; bd . emitting = true ; bd . emitNext ( 2 , 1 ) ; bd . emitNext ( 3 , 2 ) ; assertNotNull ( bd . queue ) ; 
BehaviorSubject < Integer > bs = BehaviorSubject . create ( ) ; assertFalse ( bs . hasObservers ( ) ) ; TestObserver < Integer > to = bs . test ( ) ; assertTrue ( bs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( bs . hasObservers ( ) ) ; 
return AsyncSubject . create ( ) ; 
AsyncSubject < String > subject = AsyncSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( testException ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
AsyncSubject < String > subject = AsyncSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
AsyncSubject < String > subject = AsyncSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; subject . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
AsyncSubject < String > subject = AsyncSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; RuntimeException re = new RuntimeException ( "failed" ) ; subject . onError ( re ) ; subject . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onError ( re ) ; verify ( observer , Mockito . never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
AsyncSubject < String > subject = AsyncSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; subject . onNext ( "three" ) ; subject . onError ( testException ) ; subject . onNext ( "four" ) ; subject . onError ( new Throwable ( ) ) ; subject . onComplete ( ) ; verify ( observer , Mockito . never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , times ( 1 ) ) . onError ( testException ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
AsyncSubject < String > subject = AsyncSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; subject . subscribe ( to ) ; subject . onNext ( "one" ) ; subject . onNext ( "two" ) ; to . dispose ( ) ; verify ( observer , Mockito . never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; subject . onNext ( "three" ) ; subject . onComplete ( ) ; verify ( observer , Mockito . never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
AsyncSubject < String > subject = AsyncSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; subject . subscribe ( observer ) ; subject . onComplete ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , never ( ) ) . onNext ( null ) ; inOrder . verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final AsyncSubject < String > subject = AsyncSubject . create ( ) ; final AtomicReference < String > value1 = new AtomicReference < > ( ) ; subject . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; value1 . set ( t1 ) ; ) ; Thread t1 = new Thread ( new Runnable ( ) @ Override public void run ( ) subject . onNext ( "value" ) ; subject . onComplete ( ) ; ) ; SubjectSubscriberThread t2 = new SubjectSubscriberThread ( subject ) ; SubjectSubscriberThread t3 = new SubjectSubscriberThread ( subject ) ; SubjectSubscriberThread t4 = new SubjectSubscriberThread ( subject ) ; SubjectSubscriberThread t5 = new SubjectSubscriberThread ( subject ) ; t2 . start ( ) ; t3 . start ( ) ; t1 . start ( ) ; t4 . start ( ) ; t5 . start ( ) ; try t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; t4 . join ( ) ; t5 . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertEquals ( "value" , value1 . get ( ) ) ; assertEquals ( "value" , t2 . value . get ( ) ) ; assertEquals ( "value" , t3 . value . get ( ) ) ; assertEquals ( "value" , t4 . value . get ( ) ) ; assertEquals ( "value" , t5 . value . get ( ) ) ; 
subject . onNext ( "value" ) ; subject . onComplete ( ) ; 
AsyncSubject < Object > as = AsyncSubject . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onNext ( 1 ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertTrue ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertEquals ( 1 , as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
AsyncSubject < Object > as = AsyncSubject . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onComplete ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertTrue ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; 
AsyncSubject < Object > as = AsyncSubject . create ( ) ; assertFalse ( as . hasValue ( ) ) ; assertFalse ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertNull ( as . getThrowable ( ) ) ; as . onError ( new TestException ( ) ) ; assertFalse ( as . hasValue ( ) ) ; assertTrue ( as . hasThrowable ( ) ) ; assertFalse ( as . hasComplete ( ) ) ; assertNull ( as . getValue ( ) ) ; assertTrue ( as . getThrowable ( ) instanceof TestException ) ; 
AsyncSubject < Integer > ap = new AsyncSubject < > ( ) ; TestObserverEx < Integer > to = ap . to ( TestHelper . < Integer > testConsumer ( false , QueueFuseable . ANY ) ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) ; to . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ap . onNext ( 1 ) ; to . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ap . onComplete ( ) ; to . assertResult ( 1 ) ; 
AsyncSubject < Integer > ap = new AsyncSubject < > ( ) ; ap . onNext ( 1 ) ; ap . onComplete ( ) ; TestObserverEx < Integer > to = ap . to ( TestHelper . < Integer > testConsumer ( false , QueueFuseable . ANY ) ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
AsyncSubject < Object > p = AsyncSubject . create ( ) ; Disposable bs = Disposable . empty ( ) ; p . onSubscribe ( bs ) ; assertFalse ( bs . isDisposed ( ) ) ; p . onComplete ( ) ; bs = Disposable . empty ( ) ; p . onSubscribe ( bs ) ; assertTrue ( bs . isDisposed ( ) ) ; p . test ( ) . assertResult ( ) ; 
AsyncSubject < Object > p = AsyncSubject . create ( ) ; assertFalse ( p . hasObservers ( ) ) ; p . test ( ) . assertEmpty ( ) ; p . test ( ) . assertEmpty ( ) ; p . test ( true ) . assertEmpty ( ) ; assertTrue ( p . hasObservers ( ) ) ; 
AsyncSubject < Object > p = AsyncSubject . create ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestObserver < Object > to1 = p . test ( ) ; final TestObserver < Object > to2 = p . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to2 . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AsyncSubject < Object > p = AsyncSubject . create ( ) ; final TestObserverEx < Object > to1 = p . to ( TestHelper . testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; final TestException ex = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) p . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to1 . errors ( ) . size ( ) != 0 ) to1 . assertFailure ( TestException . class ) ; else to1 . assertEmpty ( ) ; 
AsyncSubject < Object > p = AsyncSubject . create ( ) ; final TestObserver < Object > to2 = new TestObserver < > ( ) ; TestObserver < Object > to1 = new TestObserver < Object > ( ) @ Override public void onNext ( Object t ) to2 . dispose ( ) ; super . onNext ( t ) ; ; p . subscribe ( to1 ) ; p . subscribe ( to2 ) ; p . onNext ( 1 ) ; p . onComplete ( ) ; to1 . assertResult ( 1 ) ; to2 . assertEmpty ( ) ; 
AsyncSubject < Object > p = AsyncSubject . create ( ) ; final TestObserver < Object > to2 = new TestObserver < > ( ) ; TestObserver < Object > to1 = new TestObserver < Object > ( ) @ Override public void onError ( Throwable t ) to2 . dispose ( ) ; super . onError ( t ) ; ; p . subscribe ( to1 ) ; p . subscribe ( to2 ) ; p . onError ( new TestException ( ) ) ; to1 . assertFailure ( TestException . class ) ; to2 . assertEmpty ( ) ; 
AsyncSubject < Object > p = AsyncSubject . create ( ) ; final TestObserver < Object > to2 = new TestObserver < > ( ) ; TestObserver < Object > to1 = new TestObserver < Object > ( ) @ Override public void onComplete ( ) to2 . dispose ( ) ; super . onComplete ( ) ; ; p . subscribe ( to1 ) ; p . subscribe ( to2 ) ; p . onComplete ( ) ; to1 . assertResult ( ) ; to2 . assertEmpty ( ) ; 
TestHelper . checkDisposed ( AsyncSubject . create ( ) ) ; 
final ReplaySubject < Long > replay = ReplaySubject . create ( ) ; Thread source = new Thread ( new Runnable ( ) @ Override public void run ( ) Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( Observer < ? super Long > o ) o . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) o . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; o . onComplete ( ) ; ) . subscribe ( replay ) ; ) ; source . start ( ) ; long v = replay . blockingLast ( ) ; assertEquals ( 10000 , v ) ; final CountDownLatch slowLatch = new CountDownLatch ( 1 ) ; Thread slowThread = new Thread ( new Runnable ( ) @ Override public void run ( ) Observer < Long > slow = new DefaultObserver < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "*** Slow Observer completed" ) ; slowLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long args ) if ( args == 1 ) System . out . println ( "*** Slow Observer STARTED" ) ; try if ( args % 10 == 0 ) Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; ; replay . subscribe ( slow ) ; try slowLatch . await ( ) ; catch ( InterruptedException e1 ) e1 . printStackTrace ( ) ; ) ; slowThread . start ( ) ; Thread fastThread = new Thread ( new Runnable ( ) @ Override public void run ( ) final CountDownLatch fastLatch = new CountDownLatch ( 1 ) ; Observer < Long > fast = new DefaultObserver < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "*** Fast Observer completed" ) ; fastLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long args ) if ( args == 1 ) System . out . println ( "*** Fast Observer STARTED" ) ; ; replay . subscribe ( fast ) ; try fastLatch . await ( ) ; catch ( InterruptedException e1 ) e1 . printStackTrace ( ) ; ) ; fastThread . start ( ) ; fastThread . join ( ) ; assertEquals ( 1 , slowLatch . getCount ( ) ) ; slowThread . join ( ) ; 
Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( Observer < ? super Long > o ) o . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) o . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; o . onComplete ( ) ; ) . subscribe ( replay ) ; 
final ReplaySubject < Long > replay = ReplaySubject . create ( ) ; Thread source = new Thread ( new Runnable ( ) @ Override public void run ( ) Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( Observer < ? super Long > o ) o . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) o . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; o . onComplete ( ) ; ) . subscribe ( replay ) ; ) ; final List < List < Long > > listOfListsOfValues = Collections . synchronizedList ( new ArrayList < > ( ) ) ; final List < Thread > threads = Collections . synchronizedList ( new ArrayList < > ( ) ) ; for ( int i = 1 ; i <= 200 ; i ++ ) final int count = i ; if ( count == 20 ) source . start ( ) ; if ( count == 100 ) source . join ( ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) List < Long > values = replay . toList ( ) . blockingGet ( ) ; listOfListsOfValues . add ( values ) ; System . out . println ( "Finished thread: " + count ) ; ) ; t . start ( ) ; System . out . println ( "Started thread: " + i ) ; threads . add ( t ) ; for ( Thread t : threads ) t . join ( ) ; List < Long > sums = new ArrayList < > ( ) ; for ( List < Long > values : listOfListsOfValues ) long v = 0 ; for ( long l : values ) v += l ; sums . add ( v ) ; long expected = sums . get ( 0 ) ; boolean success = true ; for ( long l : sums ) if ( l != expected ) success = false ; System . out . println ( "FAILURE => Expected " + expected + " but got: " + l ) ; if ( success ) System . out . println ( "Success! " + sums . size ( ) + " each had the same sum of " + expected ) ; else throw new RuntimeException ( "Concurrency Bug" ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final ReplaySubject < String > subject = ReplaySubject . create ( ) ; final AtomicReference < String > value1 = new AtomicReference < > ( ) ; subject . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; value1 . set ( t1 ) ; ) ; Thread t1 = new Thread ( new Runnable ( ) @ Override public void run ( ) subject . onNext ( "value" ) ; subject . onComplete ( ) ; ) ; SubjectObserverThread t2 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t3 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t4 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t5 = new SubjectObserverThread ( subject ) ; t2 . start ( ) ; t3 . start ( ) ; t1 . start ( ) ; t4 . start ( ) ; t5 . start ( ) ; try t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; t4 . join ( ) ; t5 . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertEquals ( "value" , value1 . get ( ) ) ; assertEquals ( "value" , t2 . value . get ( ) ) ; assertEquals ( "value" , t3 . value . get ( ) ) ; assertEquals ( "value" , t4 . value . get ( ) ) ; assertEquals ( "value" , t5 . value . get ( ) ) ; 
final List < Integer > expected = Arrays . asList ( 1 ) ; for ( int i = 0 ; i < 100000 ; i ++ ) TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . cache ( ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertValueSequence ( expected ) ; to . assertTerminated ( ) ; 
Scheduler s = Schedulers . io ( ) ; Scheduler . Worker worker = Schedulers . io ( ) . createWorker ( ) ; try for ( int i = 0 ; i < 50000 ; i ++ ) if ( i % 1000 == 0 ) System . out . println ( i ) ; final ReplaySubject < Object > rs = ReplaySubject . create ( ) ; final CountDownLatch finish = new CountDownLatch ( 1 ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) try start . await ( ) ; catch ( Exception e1 ) e1 . printStackTrace ( ) ; rs . onNext ( 1 ) ; ) ; final AtomicReference < Object > o = new AtomicReference < > ( ) ; rs . subscribeOn ( s ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new DefaultObserver < Object > ( ) @ Override public void onComplete ( ) o . set ( - 1 ) ; finish . countDown ( ) ; @ Override public void onError ( Throwable e ) o . set ( e ) ; finish . countDown ( ) ; @ Override public void onNext ( Object t ) o . set ( t ) ; finish . countDown ( ) ; ) ; start . countDown ( ) ; if ( ! finish . await ( 5 , TimeUnit . SECONDS ) ) System . out . println ( o . get ( ) ) ; System . out . println ( rs . hasObservers ( ) ) ; rs . onComplete ( ) ; Assert . fail ( "Timeout @ " + i ) ; break ; else Assert . assertEquals ( 1 , o . get ( ) ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) rs . onComplete ( ) ; ) ; finally worker . dispose ( ) ; 
final ReplaySubject < Object > rs = ReplaySubject . create ( ) ; final CyclicBarrier cb = new CyclicBarrier ( 2 ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( int i = 0 ; i < 1000000 ; i ++ ) rs . onNext ( i ) ; rs . onComplete ( ) ; System . out . println ( "Replay fill Thread finished!" ) ; ) ; t . start ( ) ; try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; int lastSize = 0 ; for ( ; ! rs . hasThrowable ( ) && ! rs . hasComplete ( ) ; ) int size = rs . size ( ) ; boolean hasAny = rs . hasValue ( ) ; Object [ ] values = rs . getValues ( ) ; if ( size < lastSize ) Assert . fail ( "Size decreased! " + lastSize + " -> " + size ) ; if ( ( size > 0 ) && ! hasAny ) Assert . fail ( "hasAnyValue reports emptyness but size doesn't" ) ; if ( size > values . length ) Assert . fail ( "Got fewer values than size! " + size + " -> " + values . length ) ; lastSize = size ; t . join ( ) ; 
final ReplaySubject < Long > replay = ReplaySubject . createUnbounded ( ) ; Thread source = new Thread ( new Runnable ( ) @ Override public void run ( ) Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( Observer < ? super Long > o ) o . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) o . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; o . onComplete ( ) ; ) . subscribe ( replay ) ; ) ; source . start ( ) ; long v = replay . blockingLast ( ) ; assertEquals ( 10000 , v ) ; final CountDownLatch slowLatch = new CountDownLatch ( 1 ) ; Thread slowThread = new Thread ( new Runnable ( ) @ Override public void run ( ) Observer < Long > slow = new DefaultObserver < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "*** Slow Observer completed" ) ; slowLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long args ) if ( args == 1 ) System . out . println ( "*** Slow Observer STARTED" ) ; try if ( args % 10 == 0 ) Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; ; replay . subscribe ( slow ) ; try slowLatch . await ( ) ; catch ( InterruptedException e1 ) e1 . printStackTrace ( ) ; ) ; slowThread . start ( ) ; Thread fastThread = new Thread ( new Runnable ( ) @ Override public void run ( ) final CountDownLatch fastLatch = new CountDownLatch ( 1 ) ; Observer < Long > fast = new DefaultObserver < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "*** Fast Observer completed" ) ; fastLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long args ) if ( args == 1 ) System . out . println ( "*** Fast Observer STARTED" ) ; ; replay . subscribe ( fast ) ; try fastLatch . await ( ) ; catch ( InterruptedException e1 ) e1 . printStackTrace ( ) ; ) ; fastThread . start ( ) ; fastThread . join ( ) ; assertEquals ( 1 , slowLatch . getCount ( ) ) ; slowThread . join ( ) ; 
Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( Observer < ? super Long > o ) o . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) o . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; o . onComplete ( ) ; ) . subscribe ( replay ) ; 
final ReplaySubject < Long > replay = ReplaySubject . createUnbounded ( ) ; Thread source = new Thread ( new Runnable ( ) @ Override public void run ( ) Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( Observer < ? super Long > o ) o . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "********* Start Source Data ***********" ) ; for ( long l = 1 ; l <= 10000 ; l ++ ) o . onNext ( l ) ; System . out . println ( "********* Finished Source Data ***********" ) ; o . onComplete ( ) ; ) . subscribe ( replay ) ; ) ; final List < List < Long > > listOfListsOfValues = Collections . synchronizedList ( new ArrayList < > ( ) ) ; final List < Thread > threads = Collections . synchronizedList ( new ArrayList < > ( ) ) ; for ( int i = 1 ; i <= 200 ; i ++ ) final int count = i ; if ( count == 20 ) source . start ( ) ; if ( count == 100 ) source . join ( ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) List < Long > values = replay . toList ( ) . blockingGet ( ) ; listOfListsOfValues . add ( values ) ; System . out . println ( "Finished thread: " + count ) ; ) ; t . start ( ) ; System . out . println ( "Started thread: " + i ) ; threads . add ( t ) ; for ( Thread t : threads ) t . join ( ) ; List < Long > sums = new ArrayList < > ( ) ; for ( List < Long > values : listOfListsOfValues ) long v = 0 ; for ( long l : values ) v += l ; sums . add ( v ) ; long expected = sums . get ( 0 ) ; boolean success = true ; for ( long l : sums ) if ( l != expected ) success = false ; System . out . println ( "FAILURE => Expected " + expected + " but got: " + l ) ; if ( success ) System . out . println ( "Success! " + sums . size ( ) + " each had the same sum of " + expected ) ; else throw new RuntimeException ( "Concurrency Bug" ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final ReplaySubject < String > subject = ReplaySubject . createUnbounded ( ) ; final AtomicReference < String > value1 = new AtomicReference < > ( ) ; subject . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; value1 . set ( t1 ) ; ) ; Thread t1 = new Thread ( new Runnable ( ) @ Override public void run ( ) subject . onNext ( "value" ) ; subject . onComplete ( ) ; ) ; SubjectObserverThread t2 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t3 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t4 = new SubjectObserverThread ( subject ) ; SubjectObserverThread t5 = new SubjectObserverThread ( subject ) ; t2 . start ( ) ; t3 . start ( ) ; t1 . start ( ) ; t4 . start ( ) ; t5 . start ( ) ; try t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; t4 . join ( ) ; t5 . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertEquals ( "value" , value1 . get ( ) ) ; assertEquals ( "value" , t2 . value . get ( ) ) ; assertEquals ( "value" , t3 . value . get ( ) ) ; assertEquals ( "value" , t4 . value . get ( ) ) ; assertEquals ( "value" , t5 . value . get ( ) ) ; 
final List < Integer > expected = Arrays . asList ( 1 ) ; for ( int i = 0 ; i < 100000 ; i ++ ) TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . cache ( ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertValueSequence ( expected ) ; to . assertTerminated ( ) ; 
Scheduler s = Schedulers . io ( ) ; Scheduler . Worker worker = Schedulers . io ( ) . createWorker ( ) ; try for ( int i = 0 ; i < 50000 ; i ++ ) if ( i % 1000 == 0 ) System . out . println ( i ) ; final ReplaySubject < Object > rs = ReplaySubject . createWithSize ( 2 ) ; final CountDownLatch finish = new CountDownLatch ( 1 ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) try start . await ( ) ; catch ( Exception e1 ) e1 . printStackTrace ( ) ; rs . onNext ( 1 ) ; ) ; final AtomicReference < Object > o = new AtomicReference < > ( ) ; rs . subscribeOn ( s ) . observeOn ( Schedulers . io ( ) ) . subscribe ( new DefaultObserver < Object > ( ) @ Override protected void onStart ( ) super . onStart ( ) ; @ Override public void onComplete ( ) o . set ( - 1 ) ; finish . countDown ( ) ; @ Override public void onError ( Throwable e ) o . set ( e ) ; finish . countDown ( ) ; @ Override public void onNext ( Object t ) o . set ( t ) ; finish . countDown ( ) ; ) ; start . countDown ( ) ; if ( ! finish . await ( 5 , TimeUnit . SECONDS ) ) System . out . println ( o . get ( ) ) ; System . out . println ( rs . hasObservers ( ) ) ; rs . onComplete ( ) ; Assert . fail ( "Timeout @ " + i ) ; break ; else Assert . assertEquals ( 1 , o . get ( ) ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) rs . onComplete ( ) ; ) ; finally worker . dispose ( ) ; 
final ReplaySubject < Object > rs = ReplaySubject . createUnbounded ( ) ; final CyclicBarrier cb = new CyclicBarrier ( 2 ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( int i = 0 ; i < 1000000 ; i ++ ) rs . onNext ( i ) ; rs . onComplete ( ) ; System . out . println ( "Replay fill Thread finished!" ) ; ) ; t . start ( ) ; try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; int lastSize = 0 ; for ( ; ! rs . hasThrowable ( ) && ! rs . hasComplete ( ) ; ) int size = rs . size ( ) ; boolean hasAny = rs . hasValue ( ) ; Object [ ] values = rs . getValues ( ) ; if ( size < lastSize ) Assert . fail ( "Size decreased! " + lastSize + " -> " + size ) ; if ( ( size > 0 ) && ! hasAny ) Assert . fail ( "hasAnyValue reports emptyness but size doesn't" ) ; if ( size > values . length ) Assert . fail ( "Got fewer values than size! " + size + " -> " + values . length ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) Integer v1 = ( Integer ) values [ i ] ; Integer v2 = ( Integer ) values [ i + 1 ] ; assertEquals ( 1 , v2 - v1 ) ; lastSize = size ; t . join ( ) ; 
final ReplaySubject < Object > rs = ReplaySubject . createWithSize ( 3 ) ; final CyclicBarrier cb = new CyclicBarrier ( 2 ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( int i = 0 ; i < 1000000 ; i ++ ) rs . onNext ( i ) ; rs . onComplete ( ) ; System . out . println ( "Replay fill Thread finished!" ) ; ) ; t . start ( ) ; try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( ; ! rs . hasThrowable ( ) && ! rs . hasComplete ( ) ; ) rs . size ( ) ; rs . hasValue ( ) ; Object [ ] values = rs . getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) Integer v1 = ( Integer ) values [ i ] ; Integer v2 = ( Integer ) values [ i + 1 ] ; assertEquals ( 1 , v2 - v1 ) ; t . join ( ) ; 
final ReplaySubject < Object > rs = ReplaySubject . createWithTime ( 1 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; final CyclicBarrier cb = new CyclicBarrier ( 2 ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( int i = 0 ; i < 1000000 ; i ++ ) rs . onNext ( i ) ; if ( i % 10000 == 0 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return ; rs . onComplete ( ) ; System . out . println ( "Replay fill Thread finished!" ) ; ) ; t . start ( ) ; try cb . await ( ) ; catch ( InterruptedException e ) return ; catch ( BrokenBarrierException e ) return ; for ( ; ! rs . hasThrowable ( ) && ! rs . hasComplete ( ) ; ) rs . size ( ) ; rs . hasValue ( ) ; Object [ ] values = rs . getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) Integer v1 = ( Integer ) values [ i ] ; Integer v2 = ( Integer ) values [ i + 1 ] ; assertEquals ( 1 , v2 - v1 ) ; t . join ( ) ; 
SerializedSubject < String > subject = new SerializedSubject < > ( PublishSubject . < String > create ( ) ) ; TestObserver < String > to = new TestObserver < > ( ) ; subject . subscribe ( to ) ; subject . onNext ( "hello" ) ; subject . onComplete ( ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertValue ( "hello" ) ; 
AsyncSubject < Integer > async = AsyncSubject . create ( ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; 
AsyncSubject < Integer > async = AsyncSubject . create ( ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
AsyncSubject < Integer > async = AsyncSubject . create ( ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
PublishSubject < Integer > async = PublishSubject . create ( ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; 
PublishSubject < Integer > async = PublishSubject . create ( ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; 
PublishSubject < Integer > async = PublishSubject . create ( ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; 
BehaviorSubject < Integer > async = BehaviorSubject . create ( ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
BehaviorSubject < Integer > async = BehaviorSubject . create ( ) ; async . onNext ( 1 ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; 
BehaviorSubject < Integer > async = BehaviorSubject . create ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
BehaviorSubject < Integer > async = BehaviorSubject . create ( ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
BehaviorSubject < Integer > async = BehaviorSubject . create ( ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . create ( ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] 1 , null , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . create ( ) ; async . onNext ( 1 ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] 1 , null , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . createWithSize ( 1 ) ; async . onNext ( 0 ) ; async . onNext ( 1 ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] 1 , null , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . createWithSize ( 1 ) ; async . onNext ( 0 ) ; async . onNext ( 1 ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertEquals ( ( Integer ) 1 , async . getValue ( ) ) ; assertTrue ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] 1 , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] 1 , null , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . createWithSize ( 1 ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . create ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . create ( ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . create ( ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . createWithSize ( 1 ) ; async . onComplete ( ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertTrue ( serial . hasComplete ( ) ) ; assertFalse ( serial . hasThrowable ( ) ) ; assertNull ( serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
ReplaySubject < Integer > async = ReplaySubject . createWithSize ( 1 ) ; TestException te = new TestException ( ) ; async . onError ( te ) ; Subject < Integer > serial = async . toSerialized ( ) ; assertFalse ( serial . hasObservers ( ) ) ; assertFalse ( serial . hasComplete ( ) ) ; assertTrue ( serial . hasThrowable ( ) ) ; assertSame ( te , serial . getThrowable ( ) ) ; assertNull ( async . getValue ( ) ) ; assertFalse ( async . hasValue ( ) ) ; assertArrayEquals ( new Object [ ] , async . getValues ( ) ) ; assertArrayEquals ( new Integer [ ] , async . getValues ( new Integer [ 0 ] ) ) ; assertArrayEquals ( new Integer [ ] null , async . getValues ( new Integer [ ] 0 ) ) ; assertArrayEquals ( new Integer [ ] null , 0 , async . getValues ( new Integer [ ] 0 , 0 ) ) ; 
PublishSubject < Object > s = PublishSubject . create ( ) ; Subject < Object > s1 = s . toSerialized ( ) ; Subject < Object > s2 = s1 . toSerialized ( ) ; assertSame ( s1 , s2 ) ; 
Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = s . test ( ) ; Observable . range ( 1 , 10 ) . subscribe ( s ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertFalse ( s . hasObservers ( ) ) ; s . onNext ( 11 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try s . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; s . onComplete ( ) ; Disposable bs = Disposable . empty ( ) ; s . onSubscribe ( bs ) ; assertTrue ( bs . isDisposed ( ) ) ; 
Set < Integer > expectedSet = new HashSet < > ( Arrays . asList ( 1 , 2 ) ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserverEx < Integer > to = s . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertSubscribed ( ) . assertNoErrors ( ) . assertNotComplete ( ) . assertValueCount ( 2 ) ; Set < Integer > actualSet = new HashSet < > ( to . values ( ) ) ; assertEquals ( "" + actualSet , expectedSet , actualSet ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = s . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( ex ) . assertNotComplete ( ) ; if ( to . values ( ) . size ( ) != 0 ) to . assertValue ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = s . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertComplete ( ) . assertNoErrors ( ) ; if ( to . values ( ) . size ( ) != 0 ) to . assertValue ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = s . test ( ) ; final Disposable bs = Disposable . empty ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onSubscribe ( bs ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertValue ( 1 ) . assertNotComplete ( ) . assertNoErrors ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = s . test ( ) ; final Disposable bs = Disposable . empty ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onSubscribe ( bs ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = s . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = s . test ( ) ; final TestException ex = new TestException ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Subject < Integer > s = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = s . test ( ) ; final Disposable bs1 = Disposable . empty ( ) ; final Disposable bs2 = Disposable . empty ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . onSubscribe ( bs1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) s . onSubscribe ( bs2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
Subject < Integer > sp = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) super . onNext ( t ) ; if ( t == 1 ) sp . onNext ( 2 ) ; sp . onNext ( 3 ) ; sp . onSubscribe ( Disposable . empty ( ) ) ; sp . onError ( new TestException ( ) ) ; ; sp . subscribe ( to ) ; sp . onNext ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; 
Subject < Integer > sp = PublishSubject . < Integer > create ( ) . toSerialized ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) super . onNext ( t ) ; if ( t == 1 ) sp . onNext ( 2 ) ; sp . onNext ( 3 ) ; sp . onComplete ( ) ; ; sp . subscribe ( to ) ; sp . onNext ( 1 ) ; to . assertResult ( 1 , 2 , 3 ) ; 
return UnicastSubject . create ( ) ; 
UnicastSubject < Integer > ap = UnicastSubject . create ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; ap . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) ; to . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ap . onNext ( 1 ) ; to . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; ap . onComplete ( ) ; to . assertResult ( 1 ) ; 
UnicastSubject < Integer > ap = UnicastSubject . create ( ) ; ap . onNext ( 1 ) ; ap . onComplete ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; ap . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
UnicastSubject < Integer > ap = UnicastSubject . create ( false ) ; ap . onNext ( 1 ) ; ap . onError ( new RuntimeException ( ) ) ; TestObserver < Integer > to = TestObserver . create ( ) ; ap . subscribe ( to ) ; to . assertValueCount ( 0 ) . assertError ( RuntimeException . class ) ; 
Runnable noop = mock ( Runnable . class ) ; UnicastSubject < Integer > ap = UnicastSubject . create ( 16 , noop , false ) ; ap . onNext ( 1 ) ; ap . onError ( new RuntimeException ( ) ) ; TestObserver < Integer > to = TestObserver . create ( ) ; ap . subscribe ( to ) ; to . assertValueCount ( 0 ) . assertError ( RuntimeException . class ) ; 
Runnable noop = mock ( Runnable . class ) ; UnicastSubject < Integer > ap = UnicastSubject . create ( 16 , noop , true ) ; ap . onNext ( 1 ) ; ap . onError ( new RuntimeException ( ) ) ; TestObserver < Integer > to = TestObserver . create ( ) ; ap . subscribe ( to ) ; to . assertValueCount ( 1 ) . assertError ( RuntimeException . class ) ; 
UnicastSubject < Integer > ap = UnicastSubject . create ( false ) ; ap . onNext ( 1 ) ; ap . onError ( new RuntimeException ( ) ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; ap . subscribe ( to ) ; to . assertValueCount ( 0 ) . assertError ( RuntimeException . class ) ; 
UnicastSubject < Integer > ap = UnicastSubject . create ( false ) ; ap . onNext ( 1 ) ; ap . onNext ( 2 ) ; ap . onNext ( 3 ) ; ap . onComplete ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; ap . subscribe ( to ) ; to . assertValueCount ( 3 ) . assertComplete ( ) ; 
UnicastSubject < Integer > ap = UnicastSubject . create ( false ) ; ap . onNext ( 1 ) ; ap . onNext ( 2 ) ; ap . onNext ( 3 ) ; ap . onComplete ( ) ; TestObserver < Integer > to = TestObserver . create ( ) ; ap . subscribe ( to ) ; to . assertValueCount ( 3 ) . assertComplete ( ) ; 
final AtomicBoolean didRunOnTerminate = new AtomicBoolean ( ) ; UnicastSubject < Integer > us = UnicastSubject . create ( Observable . bufferSize ( ) , new Runnable ( ) @ Override public void run ( ) didRunOnTerminate . set ( true ) ; ) ; assertFalse ( didRunOnTerminate . get ( ) ) ; us . onError ( new RuntimeException ( "some error" ) ) ; assertTrue ( didRunOnTerminate . get ( ) ) ; 
final AtomicBoolean didRunOnTerminate = new AtomicBoolean ( ) ; UnicastSubject < Integer > us = UnicastSubject . create ( Observable . bufferSize ( ) , new Runnable ( ) @ Override public void run ( ) didRunOnTerminate . set ( true ) ; ) ; assertFalse ( didRunOnTerminate . get ( ) ) ; us . onComplete ( ) ; assertTrue ( didRunOnTerminate . get ( ) ) ; 
final AtomicBoolean didRunOnTerminate = new AtomicBoolean ( ) ; UnicastSubject < Integer > us = UnicastSubject . create ( Observable . bufferSize ( ) , new Runnable ( ) @ Override public void run ( ) didRunOnTerminate . set ( true ) ; ) ; final Disposable subscribe = us . subscribe ( ) ; assertFalse ( didRunOnTerminate . get ( ) ) ; subscribe . dispose ( ) ; assertTrue ( didRunOnTerminate . get ( ) ) ; 
UnicastSubject . create ( 5 , null ) ; 
UnicastSubject . create ( - 1 ) ; 
UnicastSubject . create ( 0 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final int [ ] calls = 0 ; final UnicastSubject < Object > us = UnicastSubject . create ( 100 , new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; ) ; final TestObserver < Object > to = us . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) us . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
UnicastSubject < Object > p = UnicastSubject . create ( ) ; p . onComplete ( ) ; Disposable bs = Disposable . empty ( ) ; p . onSubscribe ( bs ) ; p . onNext ( 1 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try p . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; p . onComplete ( ) ; p . test ( ) . assertResult ( ) ; assertNull ( p . getThrowable ( ) ) ; assertTrue ( p . hasComplete ( ) ) ; assertFalse ( p . hasThrowable ( ) ) ; 
UnicastSubject < Object > p = UnicastSubject . create ( ) ; assertFalse ( p . hasComplete ( ) ) ; assertFalse ( p . hasThrowable ( ) ) ; assertNull ( p . getThrowable ( ) ) ; TestException ex = new TestException ( ) ; p . onError ( ex ) ; assertFalse ( p . hasComplete ( ) ) ; assertTrue ( p . hasThrowable ( ) ) ; assertSame ( ex , p . getThrowable ( ) ) ; 
UnicastSubject < Object > p = UnicastSubject . create ( ) ; TestObserverEx < Object > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; p . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) ; 
UnicastSubject . create ( ) . test ( true ) . assertEmpty ( ) ; 
UnicastSubject < Object > p = UnicastSubject . create ( ) ; TestObserver < Object > to = p . test ( ) ; p . test ( ) . assertFailure ( IllegalStateException . class ) ; p . onNext ( 1 ) ; p . onComplete ( ) ; to . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final UnicastSubject < Object > p = UnicastSubject . create ( ) ; final TestObserverEx < Object > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; p . subscribe ( to ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) p . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final int [ ] calls = 0 ; UnicastSubject < Integer > us = new UnicastSubject < > ( 128 , new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; , true ) ; TestHelper . checkDisposed ( us ) ; assertEquals ( 1 , calls [ 0 ] ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try us . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; Disposable d = Disposable . empty ( ) ; us . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final UnicastSubject < Integer > us = UnicastSubject . create ( ) ; final TestObserverEx < Integer > to1 = new TestObserverEx < > ( ) ; final TestObserverEx < Integer > to2 = new TestObserverEx < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) us . subscribe ( to1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) us . subscribe ( to2 ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to1 . errors ( ) . size ( ) == 0 ) to2 . assertFailure ( IllegalStateException . class ) ; else if ( to2 . errors ( ) . size ( ) == 0 ) to1 . assertFailure ( IllegalStateException . class ) ; else fail ( "Neither TestObserver failed" ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; assertFalse ( us . hasObservers ( ) ) ; TestObserver < Integer > to = us . test ( ) ; assertTrue ( us . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( us . hasObservers ( ) ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( false ) ; TestObserverEx < Integer > to = us . to ( TestHelper . < Integer > testConsumer ( QueueFuseable . ANY , false ) ) ; us . done = true ; us . drainFused ( to ) ; to . assertResult ( ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( false ) ; TestObserverEx < Integer > to = us . to ( TestHelper . < Integer > testConsumer ( QueueFuseable . ANY , false ) ) ; us . drainFused ( to ) ; to . assertEmpty ( ) ; 
for ( int j = 0 ; j < TestHelper . RACE_LONG_LOOPS ; j ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . observeOn ( Schedulers . io ( ) ) . map ( Functions . < Integer > identity ( ) ) . observeOn ( Schedulers . single ( ) ) . firstOrError ( ) . test ( ) ; for ( int i = 0 ; us . hasObservers ( ) ; i ++ ) us . onNext ( i ) ; to . awaitDone ( 10 , TimeUnit . SECONDS ) ; if ( ! errors . isEmpty ( ) ) throw new CompositeException ( errors ) ; to . assertResult ( 0 ) ; finally RxJavaPlugins . reset ( ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( 16 ) ; TestObserver < Integer > to = us . test ( ) ; for ( int i = 0 ; i < 256 ; i ++ ) us . onNext ( i ) ; us . onComplete ( ) ; to . assertValueCount ( 256 ) . assertComplete ( ) . assertNoErrors ( ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Maybe . fromCallable ( new Callable < Boolean > ( ) @ Override public Boolean call ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; throw new IllegalArgumentException ( ) ; ) . retry ( Integer . MAX_VALUE , new Predicate < Throwable > ( ) @ Override public boolean test ( final Throwable throwable ) throws Exception return ! ( throwable instanceof IllegalArgumentException ) ; ) . test ( ) . assertFailure ( IllegalArgumentException . class ) ; assertEquals ( 3 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Maybe . fromCallable ( new Callable < Boolean > ( ) @ Override public Boolean call ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; return true ; ) . retry ( 2 , Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( true ) ; assertEquals ( 3 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Maybe . fromCallable ( new Callable < Boolean > ( ) @ Override public Boolean call ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; return true ; ) . retry ( 1 , Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( RuntimeException . class ) ; assertEquals ( 2 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 2 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Maybe . fromCallable ( new Callable < Boolean > ( ) @ Override public Boolean call ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; return true ; ) . retry ( 0 , Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( RuntimeException . class ) ; assertEquals ( 1 , numberOfSubscribeCalls . get ( ) ) ; 
Maybe . just ( 1 ) . retryUntil ( ( ) -> true ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . retryUntil ( ( ) -> false ) . test ( ) . assertResult ( 1 ) ; 
Maybe . empty ( ) . retryUntil ( ( ) -> true ) . test ( ) . assertResult ( ) ; 
Maybe . empty ( ) . retryUntil ( ( ) -> false ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . retryUntil ( ( ) -> true ) . test ( ) . assertFailure ( TestException . class ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; Maybe . defer ( ( ) -> if ( counter . getAndIncrement ( ) == 0 ) return Maybe . error ( new TestException ( ) ) ; return Maybe . just ( 1 ) ; ) . retryUntil ( ( ) -> false ) . test ( ) . assertResult ( 1 ) ; 
final TestScheduler testScheduler = new TestScheduler ( ) ; final AtomicLong atomicLong = new AtomicLong ( ) ; Maybe . timer ( 2 , TimeUnit . SECONDS , testScheduler ) . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( final Long value ) throws Exception atomicLong . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicLong . get ( ) ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 0 , atomicLong . get ( ) ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 1 , atomicLong . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Maybe . < Integer > create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onSuccess ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( 1 ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d1 = Disposable . empty ( ) ; final Disposable d2 = Disposable . empty ( ) ; Maybe . < Integer > create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > e ) throws Exception e . setDisposable ( d1 ) ; e . setCancellable ( new Cancellable ( ) @ Override public void cancel ( ) throws Exception d2 . dispose ( ) ; ) ; e . onSuccess ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( 1 ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Maybe . < Integer > create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onError ( new TestException ( ) ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Maybe . < Integer > create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onComplete ( ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertComplete ( ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Maybe . unsafeCreate ( Maybe . just ( 1 ) ) ; 
Flowable . empty ( ) . singleElement ( ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . singleElement ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . error ( new TestException ( ) ) . singleElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . singleElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . singleElement ( ) . test ( ) . assertFailure ( IllegalArgumentException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp . singleElement ( ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Observable . empty ( ) . singleElement ( ) . test ( ) . assertResult ( ) ; 
Observable . just ( 1 ) . singleElement ( ) . test ( ) . assertResult ( 1 ) ; 
Observable . error ( new TestException ( ) ) . singleElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . singleElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 2 ) . singleElement ( ) . test ( ) . assertFailure ( IllegalArgumentException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . singleElement ( ) . test ( false ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . singleElement ( ) . test ( true ) ; assertFalse ( ps . hasObservers ( ) ) ; 
Maybe . just ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Maybe . empty ( ) . test ( ) . assertResult ( ) ; 
Maybe . never ( ) . to ( TestHelper . testConsumer ( ) ) . assertSubscribed ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
Maybe . error ( new TestException ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . error ( Functions . justSupplier ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . error ( Functions . justSupplier ( ( Throwable ) null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe . wrap ( new MaybeSource < Integer > ( ) @ Override public void subscribe ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; ) . test ( ) . assertResult ( 1 ) ; 
assertSame ( Maybe . empty ( ) , Maybe . wrap ( Maybe . empty ( ) ) ) ; 
assertSame ( Maybe . empty ( ) , Maybe . empty ( ) ) ; 
assertSame ( Maybe . never ( ) , Maybe . never ( ) ) ; 
Maybe . just ( 1 ) . lift ( new MaybeOperator < Integer , Integer > ( ) @ Override public MaybeObserver < ? super Integer > apply ( MaybeObserver < ? super Integer > t ) throws Exception return t ; ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . lift ( new MaybeOperator < Integer , Integer > ( ) @ Override public MaybeObserver < ? super Integer > apply ( MaybeObserver < ? super Integer > t ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . defer ( new Supplier < Maybe < Integer > > ( ) @ Override public Maybe < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . defer ( new Supplier < Maybe < Integer > > ( ) @ Override public Maybe < Integer > get ( ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe < Integer > source = Maybe . defer ( new Supplier < Maybe < Integer > > ( ) int count ; @ Override public Maybe < Integer > get ( ) throws Exception return Maybe . just ( count ++ ) ; ) ; for ( int i = 0 ; i < 128 ; i ++ ) source . test ( ) . assertResult ( i ) ; 
Flowable . just ( 1 ) . singleElement ( ) . toFlowable ( ) . test ( ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . singleElement ( ) . toObservable ( ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . toMaybe ( ) . toSingle ( ) . test ( ) . assertResult ( 1 ) ; 
Completable . complete ( ) . toMaybe ( ) . ignoreElement ( ) . test ( ) . assertResult ( ) ; 
Maybe . unsafeCreate ( new MaybeSource < Integer > ( ) @ Override public void subscribe ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . to ( new MaybeConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Maybe < Integer > v ) return v . toFlowable ( ) ; ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . to ( new MaybeConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Maybe < Integer > v ) return v . toFlowable ( ) ; ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . compose ( new MaybeTransformer < Integer , Integer > ( ) @ Override public MaybeSource < Integer > apply ( Maybe < Integer > m ) return m . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer w ) throws Exception return w + 1 ; ) ; ) . test ( ) . assertResult ( 2 ) ; 
Maybe . just ( 1 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe . just ( 1 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertFailure ( IOException . class ) ; 
Maybe . just ( 1 ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer v ) throws Exception return v . toString ( ) ; ) . test ( ) . assertResult ( "1" ) ; 
Maybe . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertFailure ( IOException . class ) ; 
Maybe . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v == 1 ; ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v == 1 ; ) . test ( ) . assertResult ( ) ; 
Maybe . < Integer > empty ( ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v == 1 ; ) . test ( ) . assertResult ( ) ; 
Single . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertFailure ( IOException . class ) ; 
Single . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v == 1 ; ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v == 1 ; ) . test ( ) . assertResult ( ) ; 
TestObserver < Number > to = Maybe . just ( 1 ) . cast ( Number . class ) . test ( ) ; to . assertResult ( ( Number ) 1 ) ; 
String main = Thread . currentThread ( ) . getName ( ) ; TestObserver < String > to = Maybe . just ( 1 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer v ) throws Exception return v + ": " + Thread . currentThread ( ) . getName ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) ; assertNotEquals ( "1: " + main , to . values ( ) . get ( 0 ) ) ; 
Maybe . error ( new TestException ( ) ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Maybe . empty ( ) . observeOn ( Schedulers . single ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > m ) throws Exception return m . observeOn ( Schedulers . single ( ) ) ; ) ; 
String main = Thread . currentThread ( ) . getName ( ) ; TestObserver < String > to = Maybe . fromCallable ( new Callable < String > ( ) @ Override public String call ( ) throws Exception return Thread . currentThread ( ) . getName ( ) ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) ; assertNotEquals ( main , to . values ( ) . get ( 0 ) ) ; 
String main = Thread . currentThread ( ) . getName ( ) ; final String [ ] name = null ; Maybe . error ( new TestException ( ) ) . observeOn ( Schedulers . single ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception name [ 0 ] = Thread . currentThread ( ) . getName ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; assertNotEquals ( main , name [ 0 ] ) ; 
String main = Thread . currentThread ( ) . getName ( ) ; final String [ ] name = null ; Maybe . empty ( ) . observeOn ( Schedulers . single ( ) ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception name [ 0 ] = Thread . currentThread ( ) . getName ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; assertNotEquals ( main , name [ 0 ] ) ; 
Maybe . error ( new TestException ( ) ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
final int [ ] call = 0 ; Maybe . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , call [ 0 ] ) ; 
Maybe . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final int [ ] call = 0 ; Maybe . fromRunnable ( new Runnable ( ) @ Override public void run ( ) call [ 0 ] ++ ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , call [ 0 ] ) ; 
Maybe . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final Integer [ ] value = null ; Maybe . just ( 1 ) . doOnSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception value [ 0 ] = v ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , value [ 0 ] . intValue ( ) ) ; 
final Integer [ ] value = null ; Maybe . < Integer > empty ( ) . doOnSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception value [ 0 ] = v ; ) . test ( ) . assertResult ( ) ; assertNull ( value [ 0 ] ) ; 
Maybe . just ( 1 ) . doOnSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final Disposable [ ] value = null ; Maybe . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable v ) throws Exception value [ 0 ] = v ; ) . test ( ) . assertResult ( 1 ) ; assertNotNull ( value [ 0 ] ) ; 
Maybe . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final int [ ] call = 0 ; Maybe . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . to ( TestHelper . < Integer > testConsumer ( true ) ) . assertSubscribed ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; assertEquals ( 1 , call [ 0 ] ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = pp . singleElement ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertSubscribed ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe . just ( 1 ) . observeOn ( Schedulers . single ( ) ) . doOnSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( ! cdl . await ( 5 , TimeUnit . SECONDS ) ) throw new TimeoutException ( ) ; ) . toFlowable ( ) . subscribe ( ts ) ; Thread . sleep ( 250 ) ; ts . cancel ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( InterruptedException . class ) ; 
final int [ ] call = 0 ; Maybe . just ( 1 ) . doOnSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception if ( call [ 0 ] == 1 ) call [ 0 ] = - 1 ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( - 1 , call [ 0 ] ) ; 
final int [ ] call = 0 ; Maybe . error ( new TestException ( ) ) . doOnError ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception call [ 0 ] ++ ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception if ( call [ 0 ] == 1 ) call [ 0 ] = - 1 ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( - 1 , call [ 0 ] ) ; 
final int [ ] call = 0 ; Maybe . empty ( ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception if ( call [ 0 ] == 1 ) call [ 0 ] = - 1 ; ) . test ( ) . assertResult ( ) ; assertEquals ( - 1 , call [ 0 ] ) ; 
try Maybe . unsafeCreate ( new MaybeSource < Object > ( ) @ Override public void subscribe ( MaybeObserver < ? super Object > observer ) throw new NullPointerException ( "Forced failure" ) ; ) . test ( ) ; fail ( "Should have thrown!" ) ; catch ( NullPointerException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
try Maybe . unsafeCreate ( new MaybeSource < Object > ( ) @ Override public void subscribe ( MaybeObserver < ? super Object > observer ) throw new IllegalArgumentException ( "Forced failure" ) ; ) . test ( ) ; fail ( "Should have thrown!" ) ; catch ( NullPointerException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof IllegalArgumentException ) ; assertEquals ( "Forced failure" , ex . getCause ( ) . getMessage ( ) ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v * 10 ) ; ) . test ( ) . assertResult ( 10 ) ; 
Maybe . just ( 1 ) . concatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v * 10 ) ; ) . test ( ) . assertResult ( 10 ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v * 10 ) ; , new Function < Throwable , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Throwable v ) throws Exception return Maybe . just ( 100 ) ; , new Supplier < MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > get ( ) throws Exception return Maybe . just ( 200 ) ; ) . test ( ) . assertResult ( 10 ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v * 10 ) ; , new Function < Throwable , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Throwable v ) throws Exception return Maybe . just ( 100 ) ; , new Supplier < MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > get ( ) throws Exception return Maybe . just ( 200 ) ; ) . test ( ) . assertResult ( 100 ) ; 
Maybe . < Integer > empty ( ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v * 10 ) ; , new Function < Throwable , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Throwable v ) throws Exception return Maybe . just ( 100 ) ; , new Supplier < MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > get ( ) throws Exception return Maybe . just ( 200 ) ; ) . test ( ) . assertResult ( 200 ) ; 
Maybe . just ( 1 ) . ignoreElement ( ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . ignoreElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . ignoreElement ( ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . ignoreElement ( ) . toMaybe ( ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . ignoreElement ( ) . toMaybe ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . ignoreElement ( ) . toMaybe ( ) . test ( ) . assertResult ( ) ; 
Single . just ( 1 ) . toMaybe ( ) . test ( ) . assertResult ( 1 ) ; 
Single . error ( new TestException ( ) ) . toMaybe ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . complete ( ) . toMaybe ( ) . test ( ) . assertResult ( ) ; 
Completable . error ( new TestException ( ) ) . toMaybe ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . toSingle ( ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
Maybe . error ( new TestException ( ) ) . toSingle ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . ignoreElement ( ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . ignoreElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . concat ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . concat ( Maybe . empty ( ) , Maybe . empty ( ) ) . test ( ) . assertResult ( ) ; 
TestSubscriber < Integer > ts = Maybe . concat ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Maybe . concat ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . test ( 0L ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; ts . assertValue ( 1 ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; 
Maybe . concat ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Maybe . concat ( Maybe . empty ( ) , Maybe . empty ( ) , Maybe . empty ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . concat ( Maybe . just ( 1 ) , Maybe . empty ( ) , Maybe . just ( 3 ) ) . test ( ) . assertResult ( 1 , 3 ) ; 
Maybe . concat ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . empty ( ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
TestSubscriber < Integer > ts = Maybe . concat ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 2 ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
assertSame ( Flowable . empty ( ) , Maybe . concatArray ( ) ) ; 
Maybe . concatArray ( Maybe . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . concat ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Maybe . concat ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . concat ( Arrays . asList ( Maybe . empty ( ) , Maybe . empty ( ) ) ) . test ( ) . assertResult ( ) ; 
TestSubscriber < Integer > ts = Maybe . concat ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Maybe . concat ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( 0L ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; ts . assertValue ( 1 ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; 
Maybe . concat ( Collections . < Maybe < Integer > > emptyList ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . concat ( Collections . < Maybe < Integer > > singleton ( Maybe . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . concat ( Flowable . just ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . concat ( Flowable . just ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Maybe . < Integer > create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onSuccess ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; ) . test ( ) . assertResult ( 1 ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Maybe . < Integer > create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onError ( new TestException ( ) ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Maybe . < Integer > create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onComplete ( ) ; e . onSuccess ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Maybe . unsafeCreate ( Maybe . just ( 1 ) ) ; 
TestHelper . checkEnum ( MaybeToPublisher . class ) ; 
Maybe . ambArray ( null , Maybe . just ( 1 ) ) . test ( ) . assertError ( NullPointerException . class ) ; 
assertSame ( Maybe . empty ( ) , Maybe . ambArray ( ) ) ; 
assertSame ( Maybe . never ( ) , Maybe . ambArray ( Maybe . never ( ) ) ) ; 
Maybe < Integer > error = Maybe . error ( new RuntimeException ( ) ) ; Maybe . just ( 1 ) . ambWith ( error ) . test ( ) . assertValue ( 1 ) ; 
Maybe < Integer > error = Maybe . error ( new RuntimeException ( ) ) ; Maybe . amb ( Arrays . asList ( Maybe . just ( 1 ) , error ) ) . test ( ) . assertValue ( 1 ) ; 
Maybe < Integer > error = Maybe . error ( new RuntimeException ( ) ) ; Maybe . ambArray ( Maybe . just ( 1 ) , error ) . test ( ) . assertValue ( 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . ambArray ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . ambArray ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . ambArray ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . ambArray ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . ambArray ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . ambArray ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp1 . onNext ( 1 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( "2" ) ) ; pp1 . onError ( new TestException ( "1" ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailureAndMessage ( TestException . class , "2" ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . amb ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
Maybe . amb ( new Iterable < Maybe < Object > > ( ) @ Override public Iterator < Maybe < Object > > iterator ( ) return null ; ) . test ( ) . assertError ( NullPointerException . class ) ; 
Maybe . amb ( Arrays . asList ( null , Maybe . just ( 1 ) ) ) . test ( ) . assertError ( NullPointerException . class ) ; 
Maybe . amb ( Collections . < Maybe < Integer > > emptyList ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . amb ( Collections . singleton ( Maybe . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Maybe . merge ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . merge ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Maybe . merge ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Maybe . merge ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) ) . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; 
TestSubscriber < Integer > ts = Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 ) ; ts . request ( 1 ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
TestSubscriber < Integer > ts = Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . < Integer > empty ( ) , Maybe . just ( 3 ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 1 ) ; ts . assertResult ( 1 , 3 ) ; 
TestSubscriber < Integer > ts = Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . < Integer > empty ( ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
TestSubscriber < Integer > ts = Maybe . mergeArray ( Maybe . < Integer > empty ( ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 2 ) ; ts . request ( 1 ) ; ts . assertResult ( 2 , 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . subscribe ( ts ) ; ts . assertSubscribed ( ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . mergeArray ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . subscribe ( ts ) ; ts . assertSubscribed ( ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) ; TestHelper . race ( new Runnable ( ) @ Override public void run ( ) pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; , new Runnable ( ) @ Override public void run ( ) pp2 . onNext ( 1 ) ; pp2 . onComplete ( ) ; ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 1 ) ; 
assertSame ( Flowable . empty ( ) , Maybe . mergeArray ( ) ) ; 
Maybe . mergeArray ( Maybe . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . merge ( Flowable . just ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Maybe . merge ( Flowable . just ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) , 1 ) . test ( 0L ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; ts . request ( 1 ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; 
Maybe . merge ( Maybe . just ( Maybe . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . merge ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
@ SuppressWarnings ( "unchecked" ) Maybe < Integer > [ ] sources = new Maybe [ Flowable . bufferSize ( ) * 2 ] ; Arrays . fill ( sources , Maybe . just ( 1 ) ) ; Maybe . mergeArray ( sources ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( sources . length ) . assertNoErrors ( ) . assertComplete ( ) ; 
@ SuppressWarnings ( "unchecked" ) Maybe < Integer > [ ] sources = new Maybe [ Flowable . bufferSize ( ) * 2 ] ; Arrays . fill ( sources , Maybe . just ( 1 ) ) ; sources [ sources . length - 1 ] = Maybe . empty ( ) ; Maybe . mergeArray ( sources ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( sources . length - 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
@ SuppressWarnings ( "unchecked" ) Maybe < Integer > [ ] sources = new Maybe [ Flowable . bufferSize ( ) * 2 ] ; Arrays . fill ( sources , Maybe . just ( 1 ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . mergeArray ( sources ) . subscribe ( ts ) ; ts . assertSubscribed ( ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertValueCount ( sources . length ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . merge ( Maybe . error ( new TestException ( ) ) , Maybe . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . merge ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
assertTrue ( Maybe . just ( 1 ) . subscribe ( ) . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try assertTrue ( Maybe . error ( new TestException ( ) ) . subscribe ( ) . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; Throwable c = errors . get ( 0 ) . getCause ( ) ; assertTrue ( "" + c , c instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
final List < Integer > values = new ArrayList < > ( ) ; Consumer < Integer > onSuccess = new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception values . add ( e ) ; ; Maybe < Integer > source = Maybe . just ( 1 ) ; source . subscribe ( onSuccess ) ; source . subscribe ( onSuccess , Functions . emptyConsumer ( ) ) ; source . subscribe ( onSuccess , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION ) ; assertEquals ( Arrays . asList ( 1 , 1 , 1 ) , values ) ; 
final List < Throwable > values = new ArrayList < > ( ) ; Consumer < Throwable > onError = new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception values . add ( e ) ; ; TestException ex = new TestException ( ) ; Maybe < Integer > source = Maybe . error ( ex ) ; source . subscribe ( Functions . emptyConsumer ( ) , onError ) ; source . subscribe ( Functions . emptyConsumer ( ) , onError , Functions . EMPTY_ACTION ) ; assertEquals ( Arrays . asList ( ex , ex ) , values ) ; 
final List < Integer > values = new ArrayList < > ( ) ; Action onComplete = new Action ( ) @ Override public void run ( ) throws Exception values . add ( 100 ) ; ; Maybe < Integer > source = Maybe . empty ( ) ; source . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , onComplete ) ; assertEquals ( Arrays . asList ( 100 ) , values ) ; 
MaybeObserver < Integer > mo = new MaybeObserver < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Integer value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ; assertSame ( mo , Maybe . just ( 1 ) . subscribeWith ( mo ) ) ; 
final List < Object > list = new ArrayList < > ( ) ; assertTrue ( Maybe . just ( 1 ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception list . add ( v ) ; list . add ( e ) ; ) . subscribe ( ) . isDisposed ( ) ) ; assertEquals ( Arrays . asList ( 1 , null ) , list ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final List < Object > list = new ArrayList < > ( ) ; TestException ex = new TestException ( ) ; assertTrue ( Maybe . < Integer > error ( ex ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception list . add ( v ) ; list . add ( e ) ; ) . subscribe ( ) . isDisposed ( ) ) ; assertEquals ( Arrays . asList ( null , ex ) , list ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final List < Object > list = new ArrayList < > ( ) ; assertTrue ( Maybe . < Integer > empty ( ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception list . add ( v ) ; list . add ( e ) ; ) . subscribe ( ) . isDisposed ( ) ) ; assertEquals ( Arrays . asList ( null , null ) , list ) ; 
Maybe . just ( 1 ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = Maybe . < Integer > error ( new TestException ( "Outer" ) ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > list = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( list , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( list , 1 , TestException . class , "Inner" ) ; assertEquals ( 2 , list . size ( ) ) ; 
Maybe . < Integer > empty ( ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . concatArrayDelayError ( Maybe . empty ( ) , Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; Maybe . concatArrayDelayError ( Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; assertSame ( Flowable . empty ( ) , Maybe . concatArrayDelayError ( ) ) ; assertFalse ( Maybe . concatArrayDelayError ( Maybe . never ( ) ) instanceof MaybeConcatArrayDelayError ) ; 
Maybe . concatDelayError ( Arrays . asList ( Maybe . empty ( ) , Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; Maybe . concatDelayError ( Arrays . asList ( Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . concatDelayError ( Flowable . just ( Maybe . empty ( ) , Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; Maybe . concatDelayError ( Flowable . just ( Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . concatDelayError ( Flowable . just ( Maybe . empty ( ) , Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 ) ; Maybe . concatDelayError ( Flowable . just ( Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 1 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Maybe . concatArrayEager ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertEmpty ( ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Maybe . concatEager ( Arrays . asList ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertEmpty ( ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Maybe . concatEager ( Flowable . just ( pp1 . singleElement ( ) , pp2 . singleElement ( ) ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertEmpty ( ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
final ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; return exec . schedule ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception exec . shutdown ( ) ; return null ; , 200 , TimeUnit . MILLISECONDS ) ; 
Maybe . fromFuture ( Flowable . just ( 1 ) . delay ( 200 , TimeUnit . MILLISECONDS ) . toFuture ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; Maybe . fromFuture ( emptyFuture ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; Maybe . fromFuture ( Flowable . error ( new TestException ( ) ) . delay ( 200 , TimeUnit . MILLISECONDS , true ) . toFuture ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; Maybe . fromFuture ( Flowable . empty ( ) . delay ( 10 , TimeUnit . SECONDS ) . toFuture ( ) , 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
Maybe . mergeArrayDelayError ( Maybe . empty ( ) , Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; Maybe . mergeArrayDelayError ( Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . mergeDelayError ( Arrays . asList ( Maybe . empty ( ) , Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; Maybe . mergeDelayError ( Arrays . asList ( Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . mergeDelayError ( Flowable . just ( Maybe . empty ( ) , Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; Maybe . mergeDelayError ( Flowable . just ( Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . mergeDelayError ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; Maybe . mergeDelayError ( Maybe . error ( new TestException ( ) ) , Maybe . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . mergeDelayError ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . just ( 2 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; Maybe . mergeDelayError ( Maybe . error ( new TestException ( ) ) , Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; Maybe . mergeDelayError ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Maybe . mergeDelayError ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; Maybe . mergeDelayError ( Maybe . error ( new TestException ( ) ) , Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; Maybe . mergeDelayError ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; 
Maybe . sequenceEqual ( Maybe . just ( 1_000_000 ) , Maybe . just ( Integer . valueOf ( 1_000_000 ) ) ) . test ( ) . assertResult ( true ) ; Maybe . sequenceEqual ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( ) . assertResult ( false ) ; Maybe . sequenceEqual ( Maybe . just ( 1 ) , Maybe . empty ( ) ) . test ( ) . assertResult ( false ) ; Maybe . sequenceEqual ( Maybe . empty ( ) , Maybe . just ( 2 ) ) . test ( ) . assertResult ( false ) ; Maybe . sequenceEqual ( Maybe . empty ( ) , Maybe . empty ( ) ) . test ( ) . assertResult ( true ) ; Maybe . sequenceEqual ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; Maybe . sequenceEqual ( Maybe . error ( new TestException ( ) ) , Maybe . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Maybe . sequenceEqual ( Maybe . error ( new TestException ( "One" ) ) , Maybe . error ( new TestException ( "Two" ) ) ) . to ( TestHelper . < Boolean > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "One" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Two" ) ; finally RxJavaPlugins . reset ( ) ; Maybe . sequenceEqual ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , new BiPredicate < Object , Object > ( ) @ Override public boolean test ( Object t1 , Object t2 ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . timer ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 0L ) ; 
assertEquals ( 1 , Maybe . just ( 1 ) . blockingGet ( ) . intValue ( ) ) ; assertEquals ( 100 , Maybe . empty ( ) . blockingGet ( 100 ) ) ; try Maybe . error ( new TestException ( ) ) . blockingGet ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) try Maybe . error ( new TestException ( ) ) . blockingGet ( 100 ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) 
Maybe . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . test ( ) . assertResult ( ) ; Maybe . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; Maybe . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . range ( 1 , 5 ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; Maybe . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; Maybe . just ( 1 ) . flatMapObservable ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . range ( 1 , 5 ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; Maybe . just ( 1 ) . flatMapObservable ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final AtomicInteger disposeCount = new AtomicInteger ( ) ; Maybe . using ( Functions . justSupplier ( 1 ) , new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer d ) throws Exception disposeCount . set ( d ) ; ) . map ( new Function < Integer , Object > ( ) @ Override public String apply ( Integer v ) throws Exception return "" + disposeCount . get ( ) + v * 10 ; ) . test ( ) . assertResult ( "110" ) ; 
final AtomicInteger disposeCount = new AtomicInteger ( ) ; Maybe . using ( Functions . justSupplier ( 1 ) , new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer d ) throws Exception disposeCount . set ( d ) ; , false ) . map ( new Function < Integer , Object > ( ) @ Override public String apply ( Integer v ) throws Exception return "" + disposeCount . get ( ) + v * 10 ; ) . test ( ) . assertResult ( "010" ) ; assertEquals ( 1 , disposeCount . get ( ) ) ; 
Maybe . zipArray ( arrayToString , Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( ) . assertResult ( "[1, 2]" ) ; Maybe . zipArray ( arrayToString , Maybe . just ( 1 ) , Maybe . empty ( ) ) . test ( ) . assertResult ( ) ; Maybe . zipArray ( arrayToString , Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; assertSame ( Maybe . empty ( ) , Maybe . zipArray ( ArgsToString . INSTANCE ) ) ; Maybe . zipArray ( arrayToString , Maybe . just ( 1 ) ) . test ( ) . assertResult ( "[1]" ) ; 
Maybe . zip ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) , arrayToString ) . test ( ) . assertResult ( "[1, 2]" ) ; Maybe . zip ( Collections . < Maybe < Integer > > emptyList ( ) , arrayToString ) . test ( ) . assertResult ( ) ; Maybe . zip ( Collections . singletonList ( Maybe . just ( 1 ) ) , arrayToString ) . test ( ) . assertResult ( "[1]" ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "12" ) ; 
Maybe . just ( 1 ) . zipWith ( Maybe . just ( 2 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "12" ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "123" ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "1234" ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) , Maybe . just ( 5 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "12345" ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) , Maybe . just ( 5 ) , Maybe . just ( 6 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "123456" ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) , Maybe . just ( 5 ) , Maybe . just ( 6 ) , Maybe . just ( 7 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "1234567" ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) , Maybe . just ( 5 ) , Maybe . just ( 6 ) , Maybe . just ( 7 ) , Maybe . just ( 8 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "12345678" ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) , Maybe . just ( 5 ) , Maybe . just ( 6 ) , Maybe . just ( 7 ) , Maybe . just ( 8 ) , Maybe . just ( 9 ) , ArgsToString . INSTANCE ) . test ( ) . assertResult ( "123456789" ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . ambWith ( pp2 . singleElement ( ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . ambWith ( pp2 . singleElement ( ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 2 ) ; 
final List < Maybe < Integer > > maybes = Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 4 ) ) ; Maybe . zip ( maybes , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( final Object [ ] o ) throws Exception int sum = 0 ; for ( Object i : o ) sum += ( Integer ) i ; return sum ; ) . test ( ) . assertResult ( 5 ) ; 
MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage heapMemoryUsage = memoryMXBean . getHeapMemoryUsage ( ) ; return heapMemoryUsage . getUsed ( ) ; 
System . gc ( ) ; Thread . sleep ( 150 ) ; long before = usedMemoryNow ( ) ; Maybe < Object > source = Flowable . just ( ( Object ) new Object [ 10000000 ] ) . singleElement ( ) ; long middle = usedMemoryNow ( ) ; MaybeObserver < Object > observer = new MaybeObserver < Object > ( ) @ SuppressWarnings ( "unused" ) Disposable u ; @ Override public void onSubscribe ( Disposable d ) this . u = d ; @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ; source . onTerminateDetach ( ) . subscribe ( observer ) ; source = null ; System . gc ( ) ; Thread . sleep ( 250 ) ; long after = usedMemoryNow ( ) ; String log = String . format ( "%.2f MB -> %.2f MB -> %.2f MB%n" , before / 1024.0 / 1024.0 , middle / 1024.0 / 1024.0 , after / 1024.0 / 1024.0 ) ; System . out . printf ( log ) ; if ( before * 1.3 < after ) fail ( "There seems to be a memory leak: " + log ) ; assertNotNull ( observer ) ; 
Maybe . just ( 1 ) . repeat ( ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; Maybe . just ( 1 ) . repeat ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; Maybe . just ( 1 ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; Maybe . just ( 1 ) . repeatWhen ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > v ) throws Exception return v ; ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Maybe . just ( 1 ) . retry ( ) . test ( ) . assertResult ( 1 ) ; Maybe . just ( 1 ) . retry ( 5 ) . test ( ) . assertResult ( 1 ) ; Maybe . just ( 1 ) . retry ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) ; Maybe . just ( 1 ) . retry ( 5 , Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) ; Maybe . just ( 1 ) . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer a , Throwable e ) throws Exception return true ; ) . test ( ) . assertResult ( 1 ) ; Maybe . just ( 1 ) . retryUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) . test ( ) . assertResult ( 1 ) ; Maybe . just ( 1 ) . retryWhen ( new Function < Flowable < ? extends Throwable > , Publisher < Object > > ( ) @ SuppressWarnings ( "rawtypes" , "unchecked" ) @ Override public Publisher < Object > apply ( Flowable < ? extends Throwable > v ) throws Exception return ( Publisher ) v ; ) . test ( ) . assertResult ( 1 ) ; final AtomicInteger calls = new AtomicInteger ( ) ; try Maybe . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) calls . incrementAndGet ( ) ; return new TestException ( ) ; ) . retry ( 5 ) . test ( ) ; finally assertEquals ( 6 , calls . get ( ) ) ; 
Maybe . empty ( ) . onErrorResumeWith ( Maybe . just ( 1 ) ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . onErrorResumeWith ( Maybe . < Integer > empty ( ) ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Maybe . error ( new RuntimeException ( "some error" ) ) . onErrorResumeWith ( Maybe . empty ( ) ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . concatWith ( Maybe . just ( 2 ) ) . test ( ) . assertNoErrors ( ) . assertComplete ( ) . assertValues ( 1 , 2 ) ; 
Maybe . < Integer > error ( new RuntimeException ( "error" ) ) . concatWith ( Maybe . just ( 2 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "error" ) . assertNoValues ( ) ; 
Maybe . just ( 1 ) . concatWith ( Maybe . < Integer > error ( new RuntimeException ( "error" ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertValue ( 1 ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "error" ) ; 
Maybe . < Integer > empty ( ) . concatWith ( Maybe . just ( 2 ) ) . test ( ) . assertNoErrors ( ) . assertComplete ( ) . assertValues ( 2 ) ; 
Maybe . < Integer > empty ( ) . concatWith ( Maybe . < Integer > error ( new RuntimeException ( "error" ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "error" ) ; 
return value ; 
return unit ; 
return time ; 
return unit . convert ( time , this . unit ) ; 
if ( other instanceof Timed ) Timed < ? > o = ( Timed < ? > ) other ; return Objects . equals ( value , o . value ) && time == o . time && Objects . equals ( unit , o . unit ) ; return false ; 
int h = value . hashCode ( ) ; h = h * 31 + ( int ) ( ( time > > > 31 ) ^ time ) ; h = h * 31 + unit . hashCode ( ) ; return h ; 
return "Timed[time=" + time + ", unit=" + unit + ", value=" + value + "]" ; 
return RxJavaPlugins . onComputationScheduler ( COMPUTATION ) ; 
return RxJavaPlugins . onIoScheduler ( IO ) ; 
return TRAMPOLINE ; 
return RxJavaPlugins . onNewThreadScheduler ( NEW_THREAD ) ; 
return RxJavaPlugins . onSingleScheduler ( SINGLE ) ; 
return from ( executor , false , false ) ; 
computation ( ) . shutdown ( ) ; io ( ) . shutdown ( ) ; newThread ( ) . shutdown ( ) ; single ( ) . shutdown ( ) ; trampoline ( ) . shutdown ( ) ; 
computation ( ) . start ( ) ; io ( ) . start ( ) ; newThread ( ) . start ( ) ; single ( ) . start ( ) ; trampoline ( ) . start ( ) ; 
return IoHolder . DEFAULT ; 
return NewThreadHolder . DEFAULT ; 
return SingleHolder . DEFAULT ; 
return ComputationHolder . DEFAULT ; 
return String . format ( "TimedRunnable(time = %d, run = %s)" , time , run . toString ( ) ) ; 
return unit . convert ( time , TimeUnit . NANOSECONDS ) ; 
triggerActions ( time ) ; 
return new TestWorker ( ) ; 
disposed = true ; 
return disposed ; 
if ( disposed ) return EmptyDisposable . INSTANCE ; if ( useOnScheduleHook ) run = RxJavaPlugins . onSchedule ( run ) ; final TimedRunnable timedAction = new TimedRunnable ( this , 0 , run , counter ++ ) ; queue . add ( timedAction ) ; return new QueueRemove ( timedAction ) ; 
return TestScheduler . this . now ( unit ) ; 
TimedRunnable tr = getAndSet ( null ) ; if ( tr != null ) queue . remove ( tr ) ; 
return get ( ) == null ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableAmb < > ( null , sources ) ) ; 
return BUFFER_SIZE ; 
return combineLatest ( sources , combiner , bufferSize ( ) ) ; 
return combineLatestDelayError ( sources , combiner , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new Publisher [ ] source1 , source2 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new Publisher [ ] source1 , source2 , source3 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new Publisher [ ] source1 , source2 , source3 , source4 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new Publisher [ ] source1 , source2 , source3 , source4 , source5 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new Publisher [ ] source1 , source2 , source3 , source4 , source5 , source6 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new Publisher [ ] source1 , source2 , source3 , source4 , source5 , source6 , source7 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new Publisher [ ] source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( source9 , "source9 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new Publisher [ ] source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 , source9 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , false , 2 ) ; 
return concat ( sources , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return concatArray ( source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return concatArray ( source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return concatArray ( source1 , source2 , source3 , source4 ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) ) ; 
return concatDelayError ( sources , bufferSize ( ) , true ) ; 
return concatEager ( sources , bufferSize ( ) , bufferSize ( ) ) ; 
return concatEager ( sources , bufferSize ( ) , bufferSize ( ) ) ; 
return concatEagerDelayError ( sources , bufferSize ( ) , bufferSize ( ) ) ; 
return concatEagerDelayError ( sources , bufferSize ( ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; Objects . requireNonNull ( mode , "mode is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableCreate < > ( source , mode ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDefer < > ( supplier ) ) ; 
return RxJavaPlugins . onAssembly ( ( Flowable < T > ) FlowableEmpty . INSTANCE ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableError < > ( supplier ) ) ; 
Objects . requireNonNull ( throwable , "throwable is null" ) ; return error ( Functions . justSupplier ( throwable ) ) ; 
Objects . requireNonNull ( action , "action is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromAction < > ( action ) ) ; 
Objects . requireNonNull ( callable , "callable is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromCallable < > ( callable ) ) ; 
Objects . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromCompletable < > ( completableSource ) ) ; 
Objects . requireNonNull ( future , "future is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromFuture < > ( future , 0L , null ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromIterable < > ( source ) ) ; 
Objects . requireNonNull ( maybe , "maybe is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeToFlowable < > ( maybe ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; Objects . requireNonNull ( strategy , "strategy is null" ) ; Flowable < T > f = new FlowableFromObservable < > ( source ) ; switch ( strategy ) case DROP : return f . onBackpressureDrop ( ) ; case LATEST : return f . onBackpressureLatest ( ) ; case MISSING : return f ; case ERROR : return RxJavaPlugins . onAssembly ( new FlowableOnBackpressureError < > ( f ) ) ; default : return f . onBackpressureBuffer ( ) ; 
if ( publisher instanceof Flowable ) return RxJavaPlugins . onAssembly ( ( Flowable < T > ) publisher ) ; Objects . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromPublisher < > ( publisher ) ) ; 
Objects . requireNonNull ( run , "run is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromRunnable < > ( run ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new SingleToFlowable < > ( source ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromSupplier < > ( supplier ) ) ; 
Objects . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . nullSupplier ( ) , FlowableInternalHelper . simpleGenerator ( generator ) , Functions . emptyConsumer ( ) ) ; 
Objects . requireNonNull ( generator , "generator is null" ) ; return generate ( initialState , FlowableInternalHelper . simpleBiGenerator ( generator ) , Functions . emptyConsumer ( ) ) ; 
Objects . requireNonNull ( generator , "generator is null" ) ; return generate ( initialState , FlowableInternalHelper . simpleBiGenerator ( generator ) , disposeState ) ; 
return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; 
Objects . requireNonNull ( initialState , "initialState is null" ) ; Objects . requireNonNull ( generator , "generator is null" ) ; Objects . requireNonNull ( disposeState , "disposeState is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableGenerate < > ( initialState , generator , disposeState ) ) ; 
return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) ) ; 
return merge ( sources , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return fromArray ( source1 , source2 ) . flatMap ( ( Function ) Functions . identity ( ) , false , 2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return fromArray ( source1 , source2 , source3 ) . flatMap ( ( Function ) Functions . identity ( ) , false , 3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return fromArray ( source1 , source2 , source3 , source4 ) . flatMap ( ( Function ) Functions . identity ( ) , false , 4 ) ; 
return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , true ) ; 
return mergeDelayError ( sources , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return fromArray ( source1 , source2 ) . flatMap ( ( Function ) Functions . identity ( ) , true , 2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return fromArray ( source1 , source2 , source3 ) . flatMap ( ( Function ) Functions . identity ( ) , true , 3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return fromArray ( source1 , source2 , source3 , source4 ) . flatMap ( ( Function ) Functions . identity ( ) , true , 4 ) ; 
return RxJavaPlugins . onAssembly ( ( Flowable < T > ) FlowableNever . INSTANCE ) ; 
return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ( ) ) ; 
return sequenceEqual ( source1 , source2 , isEqual , bufferSize ( ) ) ; 
return fromPublisher ( sources ) . switchMap ( ( Function ) Functions . identity ( ) ) ; 
return switchOnNextDelayError ( sources , bufferSize ( ) ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; if ( onSubscribe instanceof Flowable ) throw new IllegalArgumentException ( "unsafeCreate(Flowable) should be upgraded" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromPublisher < > ( onSubscribe ) ) ; 
return using ( resourceSupplier , sourceSupplier , resourceCleanup , true ) ; 
Objects . requireNonNull ( zipper , "zipper is null" ) ; Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableZip < > ( null , sources , zipper , bufferSize ( ) , false ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 , source6 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( source9 , "source9 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 , source9 ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableAllSingle < > ( this , predicate ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableAnySingle < > ( this , predicate ) ) ; 
BlockingFirstSubscriber < T > s = new BlockingFirstSubscriber < > ( ) ; subscribe ( s ) ; T v = s . blockingGet ( ) ; if ( v != null ) return v ; throw new NoSuchElementException ( ) ; 
blockingForEach ( onNext , bufferSize ( ) ) ; 
return blockingIterable ( bufferSize ( ) ) ; 
BlockingLastSubscriber < T > s = new BlockingLastSubscriber < > ( ) ; subscribe ( s ) ; T v = s . blockingGet ( ) ; if ( v != null ) return v ; throw new NoSuchElementException ( ) ; 
return new BlockingFlowableLatest < > ( this ) ; 
return new BlockingFlowableNext < > ( this ) ; 
return singleOrError ( ) . blockingGet ( ) ; 
return subscribeWith ( new FutureSubscriber < > ( ) ) ; 
FlowableBlockingSubscribe . subscribe ( this ) ; 
FlowableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
FlowableBlockingSubscribe . subscribe ( this , onNext , onError , Functions . EMPTY_ACTION ) ; 
FlowableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; 
Objects . requireNonNull ( subscriber , "subscriber is null" ) ; FlowableBlockingSubscribe . subscribe ( this , subscriber ) ; 
return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . asSupplier ( ) ) ; 
Objects . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; Objects . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; Objects . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; 
return buffer ( boundaryIndicator , ArrayListSupplier . asSupplier ( ) ) ; 
Objects . requireNonNull ( boundaryIndicator , "boundaryIndicator is null" ) ; Objects . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableBufferExactBoundary < > ( this , boundaryIndicator , bufferSupplier ) ) ; 
return cacheWithInitialCapacity ( 16 ) ; 
Objects . requireNonNull ( clazz , "clazz is null" ) ; return map ( Functions . castFunction ( clazz ) ) ; 
Objects . requireNonNull ( initialItemSupplier , "initialItemSupplier is null" ) ; Objects . requireNonNull ( collector , "collector is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableCollectSingle < > ( this , initialItemSupplier , collector ) ) ; 
return fromPublisher ( ( ( FlowableTransformer < T , R > ) Objects . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; 
return concatMap ( mapper , 2 ) ; 
return concatMapCompletable ( mapper , 2 ) ; 
return concatMapCompletableDelayError ( mapper , true , 2 ) ; 
return concatMapDelayError ( mapper , true , 2 ) ; 
return concatMapEager ( mapper , bufferSize ( ) , bufferSize ( ) ) ; 
return concatMapIterable ( mapper , 2 ) ; 
return concatMapMaybe ( mapper , 2 ) ; 
return concatMapMaybeDelayError ( mapper , true , 2 ) ; 
return concatMapSingle ( mapper , 2 ) ; 
return concatMapSingleDelayError ( mapper , true , 2 ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return concat ( this , other ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableConcatWithSingle < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableConcatWithMaybe < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableConcatWithCompletable < > ( this , other ) ) ; 
Objects . requireNonNull ( item , "item is null" ) ; return any ( Functions . equalsWith ( item ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableCountSingle < > ( this ) ) ; 
Objects . requireNonNull ( debounceIndicator , "debounceIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDebounce < > ( this , debounceIndicator ) ) ; 
Objects . requireNonNull ( itemDelayIndicator , "itemDelayIndicator is null" ) ; return flatMap ( FlowableInternalHelper . itemDelay ( itemDelayIndicator ) ) ; 
return delaySubscription ( subscriptionIndicator ) . delay ( itemDelayIndicator ) ; 
Objects . requireNonNull ( subscriptionIndicator , "subscriptionIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDelaySubscriptionOther < > ( this , subscriptionIndicator ) ) ; 
Objects . requireNonNull ( selector , "selector is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDematerialize < > ( this , selector ) ) ; 
return distinct ( ( Function ) Functions . identity ( ) , Functions . < T > createHashSet ( ) ) ; 
return distinct ( keySelector , Functions . createHashSet ( ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; Objects . requireNonNull ( collectionSupplier , "collectionSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDistinct < > ( this , keySelector , collectionSupplier ) ) ; 
return distinctUntilChanged ( Functions . identity ( ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDistinctUntilChanged < > ( this , keySelector , ObjectHelper . equalsPredicate ( ) ) ) ; 
Objects . requireNonNull ( comparer , "comparer is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDistinctUntilChanged < > ( this , Functions . identity ( ) , comparer ) ) ; 
Objects . requireNonNull ( onFinally , "onFinally is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDoFinally < > ( this , onFinally ) ) ; 
Objects . requireNonNull ( onAfterNext , "onAfterNext is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDoAfterNext < > ( this , onAfterNext ) ) ; 
return doOnEach ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , onAfterTerminate ) ; 
return doOnLifecycle ( Functions . emptyConsumer ( ) , Functions . EMPTY_LONG_CONSUMER , onCancel ) ; 
return doOnEach ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , onComplete , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; Objects . requireNonNull ( onAfterTerminate , "onAfterTerminate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDoOnEach < > ( this , onNext , onError , onComplete , onAfterTerminate ) ) ; 
Objects . requireNonNull ( onNotification , "onNotification is null" ) ; return doOnEach ( Functions . notificationOnNext ( onNotification ) , Functions . notificationOnError ( onNotification ) , Functions . notificationOnComplete ( onNotification ) , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( subscriber , "subscriber is null" ) ; return doOnEach ( FlowableInternalHelper . subscriberOnNext ( subscriber ) , FlowableInternalHelper . subscriberOnError ( subscriber ) , FlowableInternalHelper . subscriberOnComplete ( subscriber ) , Functions . EMPTY_ACTION ) ; 
return doOnEach ( Functions . emptyConsumer ( ) , onError , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; Objects . requireNonNull ( onRequest , "onRequest is null" ) ; Objects . requireNonNull ( onCancel , "onCancel is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableDoOnLifecycle < > ( this , onSubscribe , onRequest , onCancel ) ) ; 
return doOnEach ( onNext , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; 
return doOnLifecycle ( Functions . emptyConsumer ( ) , onRequest , Functions . EMPTY_ACTION ) ; 
return doOnLifecycle ( onSubscribe , Functions . EMPTY_LONG_CONSUMER , Functions . EMPTY_ACTION ) ; 
return doOnEach ( Functions . emptyConsumer ( ) , Functions . actionConsumer ( onTerminate ) , onTerminate , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFilter < > ( this , predicate ) ) ; 
return elementAt ( 0 ) ; 
return elementAtOrError ( 0 ) ; 
return flatMap ( mapper , false , bufferSize ( ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( onNextMapper , "onNextMapper is null" ) ; Objects . requireNonNull ( onErrorMapper , "onErrorMapper is null" ) ; Objects . requireNonNull ( onCompleteSupplier , "onCompleteSupplier is null" ) ; return merge ( new FlowableMapNotification < > ( this , onNextMapper , onErrorMapper , onCompleteSupplier ) ) ; 
return flatMap ( mapper , combiner , false , bufferSize ( ) , bufferSize ( ) ) ; 
return flatMapCompletable ( mapper , false , Integer . MAX_VALUE ) ; 
return flatMapIterable ( mapper , bufferSize ( ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return flatMap ( FlowableInternalHelper . flatMapIntoIterable ( mapper ) , combiner , false , bufferSize ( ) , bufferSize ( ) ) ; 
return flatMapMaybe ( mapper , false , Integer . MAX_VALUE ) ; 
return flatMapSingle ( mapper , false , Integer . MAX_VALUE ) ; 
return subscribe ( onNext ) ; 
return forEachWhile ( onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
return forEachWhile ( onNext , onError , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; ForEachWhileSubscriber < T > s = new ForEachWhileSubscriber < > ( onNext , onError , onComplete ) ; subscribe ( s ) ; return s ; 
return groupBy ( keySelector , Functions . identity ( ) , false , bufferSize ( ) ) ; 
return groupBy ( keySelector , valueSelector , false , bufferSize ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; Objects . requireNonNull ( leftEnd , "leftEnd is null" ) ; Objects . requireNonNull ( rightEnd , "rightEnd is null" ) ; Objects . requireNonNull ( resultSelector , "resultSelector is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableGroupJoin < > ( this , other , leftEnd , rightEnd , resultSelector ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableHide < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableIgnoreElementsCompletable < > ( this ) ) ; 
return all ( Functions . alwaysFalse ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; Objects . requireNonNull ( leftEnd , "leftEnd is null" ) ; Objects . requireNonNull ( rightEnd , "rightEnd is null" ) ; Objects . requireNonNull ( resultSelector , "resultSelector is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableJoin < T , TRight , TLeftEnd , TRightEnd , R > ( this , other , leftEnd , rightEnd , resultSelector ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableLastMaybe < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableLastSingle < > ( this , null ) ) ; 
Objects . requireNonNull ( lifter , "lifter is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableLift < > ( this , lifter ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableMap < > ( this , mapper ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableMaterialize < > ( this ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return merge ( this , other ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableMergeWithSingle < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableMergeWithMaybe < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableMergeWithCompletable < > ( this , other ) ) ; 
return observeOn ( scheduler , false , bufferSize ( ) ) ; 
Objects . requireNonNull ( clazz , "clazz is null" ) ; return filter ( Functions . isInstanceOf ( clazz ) ) . cast ( clazz ) ; 
return onBackpressureBuffer ( bufferSize ( ) , false , true ) ; 
return RxJavaPlugins . onAssembly ( new FlowableOnBackpressureDrop < > ( this ) ) ; 
Objects . requireNonNull ( onDrop , "onDrop is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableOnBackpressureDrop < > ( this , onDrop ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableOnBackpressureLatest < > ( this ) ) ; 
Objects . requireNonNull ( reducer , "reducer is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableOnBackpressureReduce < > ( this , reducer ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; Objects . requireNonNull ( reducer , "reducer is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableOnBackpressureReduceWith < > ( this , supplier , reducer ) ) ; 
return onErrorComplete ( Functions . alwaysTrue ( ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableOnErrorComplete < > ( this , predicate ) ) ; 
Objects . requireNonNull ( fallbackSupplier , "fallbackSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableOnErrorNext < > ( this , fallbackSupplier ) ) ; 
Objects . requireNonNull ( fallback , "fallback is null" ) ; return onErrorResumeNext ( Functions . justFunction ( fallback ) ) ; 
Objects . requireNonNull ( itemSupplier , "itemSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableOnErrorReturn < > ( this , itemSupplier ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableDetach < > ( this ) ) ; 
return ParallelFlowable . from ( this ) ; 
return publish ( bufferSize ( ) ) ; 
return publish ( selector , bufferSize ( ) ) ; 
Objects . requireNonNull ( reducer , "reducer is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableReduceMaybe < > ( this , reducer ) ) ; 
Objects . requireNonNull ( seedSupplier , "seedSupplier is null" ) ; Objects . requireNonNull ( reducer , "reducer is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableReduceWithSingle < > ( this , seedSupplier , reducer ) ) ; 
return repeat ( Long . MAX_VALUE ) ; 
Objects . requireNonNull ( stop , "stop is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableRepeatUntil < > ( this , stop ) ) ; 
Objects . requireNonNull ( handler , "handler is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableRepeatWhen < > ( this , handler ) ) ; 
return FlowableReplay . createFrom ( this ) ; 
Objects . requireNonNull ( selector , "selector is null" ) ; return FlowableReplay . multicastSelector ( FlowableInternalHelper . replaySupplier ( this ) , selector ) ; 
return retry ( Long . MAX_VALUE , Functions . alwaysTrue ( ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableRetryBiPredicate < > ( this , predicate ) ) ; 
return retry ( Long . MAX_VALUE , predicate ) ; 
Objects . requireNonNull ( stop , "stop is null" ) ; return retry ( Long . MAX_VALUE , Functions . predicateReverseFor ( stop ) ) ; 
Objects . requireNonNull ( handler , "handler is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableRetryWhen < > ( this , handler ) ) ; 
Objects . requireNonNull ( subscriber , "subscriber is null" ) ; if ( subscriber instanceof SafeSubscriber ) subscribe ( ( SafeSubscriber < ? super T > ) subscriber ) ; else subscribe ( new SafeSubscriber < > ( subscriber ) ) ; 
Objects . requireNonNull ( sampler , "sampler is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSamplePublisher < > ( this , sampler , false ) ) ; 
Objects . requireNonNull ( accumulator , "accumulator is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableScan < > ( this , accumulator ) ) ; 
Objects . requireNonNull ( seedSupplier , "seedSupplier is null" ) ; Objects . requireNonNull ( accumulator , "accumulator is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableScanSeed < > ( this , seedSupplier , accumulator ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableSerialized < > ( this ) ) ; 
return publish ( ) . refCount ( ) ; 
return RxJavaPlugins . onAssembly ( new FlowableSingleMaybe < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableSingleSingle < > ( this , null ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSkipUntil < > ( this , other ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSkipWhile < > ( this , predicate ) ) ; 
return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( Functions . naturalComparator ( ) ) ) . flatMapIterable ( Functions . identity ( ) ) ; 
Objects . requireNonNull ( comparator , "comparator is null" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( comparator ) ) . flatMapIterable ( Functions . identity ( ) ) ; 
return concatArray ( fromIterable ( items ) , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Completable . wrap ( other ) . < T > toFlowable ( ) , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Single . wrap ( other ) . toFlowable ( ) , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Maybe . wrap ( other ) . toFlowable ( ) , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return concatArray ( other , this ) ; 
return subscribe ( Functions . emptyConsumer ( ) , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
return subscribe ( onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
return subscribe ( onNext , onError , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; LambdaSubscriber < T > ls = new LambdaSubscriber < > ( onNext , onError , onComplete , FlowableInternalHelper . RequestMax . INSTANCE ) ; subscribe ( ls ) ; return ls ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; Objects . requireNonNull ( container , "container is null" ) ; DisposableAutoReleaseSubscriber < T > subscriber = new DisposableAutoReleaseSubscriber < > ( container , onNext , onError , onComplete ) ; container . add ( subscriber ) ; subscribe ( subscriber ) ; return subscriber ; 
if ( subscriber instanceof FlowableSubscriber ) subscribe ( ( FlowableSubscriber < ? super T > ) subscriber ) ; else Objects . requireNonNull ( subscriber , "subscriber is null" ) ; subscribe ( new StrictSubscriber < > ( subscriber ) ) ; 
Objects . requireNonNull ( subscriber , "subscriber is null" ) ; try Subscriber < ? super T > flowableSubscriber = RxJavaPlugins . onSubscribe ( this , subscriber ) ; Objects . requireNonNull ( flowableSubscriber , "The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins" ) ; subscribeActual ( flowableSubscriber ) ; catch ( NullPointerException e ) throw e ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; NullPointerException npe = new NullPointerException ( "Actually not, but can't throw other exceptions due to RS" ) ; npe . initCause ( e ) ; throw npe ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return subscribeOn ( scheduler , ! ( this instanceof FlowableCreate ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchIfEmpty < > ( this , other ) ) ; 
return switchMap ( mapper , bufferSize ( ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapCompletable < > ( this , mapper , false ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapCompletable < > ( this , mapper , true ) ) ; 
return switchMapDelayError ( mapper , bufferSize ( ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapMaybe < > ( this , mapper , false ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapMaybe < > ( this , mapper , true ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapSingle < > ( this , mapper , false ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapSingle < > ( this , mapper , true ) ) ; 
Objects . requireNonNull ( stopPredicate , "stopPredicate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableTakeUntilPredicate < > ( this , stopPredicate ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableTakeUntil < > ( this , other ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableTakeWhile < > ( this , predicate ) ) ; 
return timeInterval ( TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; 
return timeInterval ( TimeUnit . MILLISECONDS , scheduler ) ; 
return timeInterval ( unit , Schedulers . computation ( ) ) ; 
Objects . requireNonNull ( unit , "unit is null" ) ; Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableTimeInterval < > ( this , unit , scheduler ) ) ; 
return timeout0 ( null , itemTimeoutIndicator , null ) ; 
Objects . requireNonNull ( fallback , "fallback is null" ) ; return timeout0 ( null , itemTimeoutIndicator , fallback ) ; 
Objects . requireNonNull ( firstTimeoutIndicator , "firstTimeoutIndicator is null" ) ; return timeout0 ( firstTimeoutIndicator , itemTimeoutIndicator , null ) ; 
Objects . requireNonNull ( firstTimeoutIndicator , "firstTimeoutIndicator is null" ) ; Objects . requireNonNull ( fallback , "fallback is null" ) ; return timeout0 ( firstTimeoutIndicator , itemTimeoutIndicator , fallback ) ; 
Objects . requireNonNull ( itemTimeoutIndicator , "itemTimeoutIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableTimeout < > ( this , firstTimeoutIndicator , itemTimeoutIndicator , fallback ) ) ; 
return timestamp ( TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; 
return timestamp ( TimeUnit . MILLISECONDS , scheduler ) ; 
return timestamp ( unit , Schedulers . computation ( ) ) ; 
Objects . requireNonNull ( unit , "unit is null" ) ; Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return map ( Functions . timestampWith ( unit , scheduler ) ) ; 
return Objects . requireNonNull ( converter , "converter is null" ) . apply ( this ) ; 
return RxJavaPlugins . onAssembly ( new FlowableToListSingle < > ( this ) ) ; 
Objects . requireNonNull ( collectionSupplier , "collectionSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableToListSingle < > ( this , collectionSupplier ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; return collect ( HashMapSupplier . asSupplier ( ) , Functions . toMapKeySelector ( keySelector ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; Objects . requireNonNull ( valueSelector , "valueSelector is null" ) ; return collect ( HashMapSupplier . asSupplier ( ) , Functions . toMapKeyValueSelector ( keySelector , valueSelector ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; Objects . requireNonNull ( valueSelector , "valueSelector is null" ) ; return collect ( mapSupplier , Functions . toMapKeyValueSelector ( keySelector , valueSelector ) ) ; 
Function < T , T > valueSelector = Functions . identity ( ) ; Supplier < Map < K , Collection < T > > > mapSupplier = HashMapSupplier . asSupplier ( ) ; Function < K , List < T > > collectionFactory = ArrayListSupplier . asFunction ( ) ; return toMultimap ( keySelector , valueSelector , mapSupplier , collectionFactory ) ; 
Supplier < Map < K , Collection < V > > > mapSupplier = HashMapSupplier . asSupplier ( ) ; Function < K , List < V > > collectionFactory = ArrayListSupplier . asFunction ( ) ; return toMultimap ( keySelector , valueSelector , mapSupplier , collectionFactory ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; Objects . requireNonNull ( valueSelector , "valueSelector is null" ) ; Objects . requireNonNull ( mapSupplier , "mapSupplier is null" ) ; Objects . requireNonNull ( collectionFactory , "collectionFactory is null" ) ; return collect ( mapSupplier , Functions . toMultimapKeyValueSelector ( keySelector , valueSelector , collectionFactory ) ) ; 
return toMultimap ( keySelector , valueSelector , mapSupplier , ArrayListSupplier . asFunction ( ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < > ( this ) ) ; 
return toSortedList ( Functions . naturalComparator ( ) ) ; 
Objects . requireNonNull ( comparator , "comparator is null" ) ; return toList ( ) . map ( Functions . listSorter ( comparator ) ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableUnsubscribeOn < > ( this , scheduler ) ) ; 
return window ( boundaryIndicator , bufferSize ( ) ) ; 
return window ( openingIndicator , closingIndicator , bufferSize ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableWithLatestFrom < T , U , R > ( this , combiner , other ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; Function < Object [ ] , R > f = Functions . toFunction ( combiner ) ; return withLatestFrom ( new Publisher [ ] source1 , source2 , f ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; Function < Object [ ] , R > f = Functions . toFunction ( combiner ) ; return withLatestFrom ( new Publisher [ ] source1 , source2 , source3 , f ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; Function < Object [ ] , R > f = Functions . toFunction ( combiner ) ; return withLatestFrom ( new Publisher [ ] source1 , source2 , source3 , source4 , f ) ; 
Objects . requireNonNull ( others , "others is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableWithLatestFromMany < > ( this , others , combiner ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableZipIterable < > ( this , other , zipper ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return zip ( this , other , zipper ) ; 
TestSubscriber < T > ts = new TestSubscriber < > ( ) ; subscribe ( ts ) ; return ts ; 
Objects . requireNonNull ( optional , "optional is null" ) ; return optional . map ( Flowable :: just ) . orElseGet ( Flowable :: empty ) ; 
Objects . requireNonNull ( stage , "stage is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromCompletionStage < > ( stage ) ) ; 
Objects . requireNonNull ( stream , "stream is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFromStream < > ( stream ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableMapOptional < > ( this , mapper ) ) ; 
Objects . requireNonNull ( collector , "collector is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableCollectWithCollectorSingle < > ( this , collector ) ) ; 
return subscribeWith ( new FlowableFirstStageSubscriber < > ( false , null ) ) ; 
return subscribeWith ( new FlowableSingleStageSubscriber < > ( false , null ) ) ; 
return subscribeWith ( new FlowableLastStageSubscriber < > ( false , null ) ) ; 
return blockingStream ( bufferSize ( ) ) ; 
return flatMapStream ( mapper , bufferSize ( ) ) ; 
return flatMapStream ( mapper , bufferSize ( ) ) ; 
if ( ! IS_DRIFT_USE_NANOTIME ) return unit . convert ( System . currentTimeMillis ( ) , TimeUnit . MILLISECONDS ) ; return unit . convert ( System . nanoTime ( ) , TimeUnit . NANOSECONDS ) ; 
return CLOCK_DRIFT_TOLERANCE_NANOSECONDS ; 
return computeNow ( unit ) ; 
$EMPTY$
$EMPTY$
return scheduleDirect ( run , 0L , TimeUnit . NANOSECONDS ) ; 
Objects . requireNonNull ( combine , "combine is null" ) ; return ( S ) new SchedulerWhen ( combine , this ) ; 
return schedule ( run , 0L , TimeUnit . NANOSECONDS ) ; 
return computeNow ( unit ) ; 
decoratedRun . run ( ) ; if ( ! sd . isDisposed ( ) ) long nextTick ; long nowNanoseconds = now ( TimeUnit . NANOSECONDS ) ; if ( nowNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS < lastNowNanoseconds || nowNanoseconds >= lastNowNanoseconds + periodInNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS ) nextTick = nowNanoseconds + periodInNanoseconds ; startInNanoseconds = nextTick - ( periodInNanoseconds * ( ++ count ) ) ; else nextTick = startInNanoseconds + ( ++ count * periodInNanoseconds ) ; lastNowNanoseconds = nowNanoseconds ; long delay = nextTick - nowNanoseconds ; sd . replace ( schedule ( this , delay , TimeUnit . NANOSECONDS ) ) ; 
return this . decoratedRun ; 
if ( ! disposed ) try run . run ( ) ; catch ( Throwable ex ) dispose ( ) ; RxJavaPlugins . onError ( ex ) ; throw ex ; 
disposed = true ; worker . dispose ( ) ; 
return disposed ; 
return run ; 
runner = Thread . currentThread ( ) ; try try decoratedRun . run ( ) ; catch ( Throwable ex ) RxJavaPlugins . onError ( ex ) ; throw ex ; finally dispose ( ) ; runner = null ; 
if ( runner == Thread . currentThread ( ) && w instanceof NewThreadWorker ) ( ( NewThreadWorker ) w ) . shutdown ( ) ; else w . dispose ( ) ; 
return w . isDisposed ( ) ; 
return this . decoratedRun ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAmb < > ( null , sources ) ) ; 
return Flowable . bufferSize ( ) ; 
return combineLatest ( sources , combiner , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new ObservableSource [ ] source1 , source2 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new ObservableSource [ ] source1 , source2 , source3 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new ObservableSource [ ] source1 , source2 , source3 , source4 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new ObservableSource [ ] source1 , source2 , source3 , source4 , source5 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new ObservableSource [ ] source1 , source2 , source3 , source4 , source5 , source6 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new ObservableSource [ ] source1 , source2 , source3 , source4 , source5 , source6 , source7 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new ObservableSource [ ] source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( source9 , "source9 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return combineLatestArray ( new ObservableSource [ ] source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 , source9 , Functions . toFunction ( combiner ) , bufferSize ( ) ) ; 
return combineLatestDelayError ( sources , combiner , bufferSize ( ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return fromIterable ( sources ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , false , bufferSize ( ) ) ; 
return concat ( sources , bufferSize ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return concatArray ( source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return concatArray ( source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return concatArray ( source1 , source2 , source3 , source4 ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return concatDelayError ( fromIterable ( sources ) ) ; 
return concatDelayError ( sources , bufferSize ( ) , true ) ; 
return concatEager ( sources , bufferSize ( ) , bufferSize ( ) ) ; 
return concatEager ( sources , bufferSize ( ) , bufferSize ( ) ) ; 
return concatEagerDelayError ( sources , bufferSize ( ) , bufferSize ( ) ) ; 
return concatEagerDelayError ( sources , bufferSize ( ) , bufferSize ( ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableCreate < > ( source ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDefer < > ( supplier ) ) ; 
return RxJavaPlugins . onAssembly ( ( Observable < T > ) ObservableEmpty . INSTANCE ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableError < > ( supplier ) ) ; 
Objects . requireNonNull ( throwable , "throwable is null" ) ; return error ( Functions . justSupplier ( throwable ) ) ; 
Objects . requireNonNull ( action , "action is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromAction < > ( action ) ) ; 
Objects . requireNonNull ( callable , "callable is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromCallable < > ( callable ) ) ; 
Objects . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromCompletable < > ( completableSource ) ) ; 
Objects . requireNonNull ( future , "future is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromFuture < > ( future , 0L , null ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromIterable < > ( source ) ) ; 
Objects . requireNonNull ( maybe , "maybe is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeToObservable < > ( maybe ) ) ; 
Objects . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromPublisher < > ( publisher ) ) ; 
Objects . requireNonNull ( run , "run is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromRunnable < > ( run ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new SingleToObservable < > ( source ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromSupplier < > ( supplier ) ) ; 
Objects . requireNonNull ( generator , "generator is null" ) ; return generate ( Functions . nullSupplier ( ) , ObservableInternalHelper . simpleGenerator ( generator ) , Functions . emptyConsumer ( ) ) ; 
Objects . requireNonNull ( generator , "generator is null" ) ; return generate ( initialState , ObservableInternalHelper . simpleBiGenerator ( generator ) , Functions . emptyConsumer ( ) ) ; 
Objects . requireNonNull ( generator , "generator is null" ) ; return generate ( initialState , ObservableInternalHelper . simpleBiGenerator ( generator ) , disposeState ) ; 
return generate ( initialState , generator , Functions . emptyConsumer ( ) ) ; 
Objects . requireNonNull ( initialState , "initialState is null" ) ; Objects . requireNonNull ( generator , "generator is null" ) ; Objects . requireNonNull ( disposeState , "disposeState is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableGenerate < > ( initialState , generator , disposeState ) ) ; 
return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE , bufferSize ( ) ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return fromArray ( source1 , source2 ) . flatMap ( ( Function ) Functions . identity ( ) , false , 2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return fromArray ( source1 , source2 , source3 ) . flatMap ( ( Function ) Functions . identity ( ) , false , 3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return fromArray ( source1 , source2 , source3 , source4 ) . flatMap ( ( Function ) Functions . identity ( ) , false , 4 ) ; 
return fromIterable ( sources ) . flatMap ( ( Function ) Functions . identity ( ) , true ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMap ( sources , Functions . identity ( ) , true , Integer . MAX_VALUE , bufferSize ( ) ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return fromArray ( source1 , source2 ) . flatMap ( ( Function ) Functions . identity ( ) , true , 2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return fromArray ( source1 , source2 , source3 ) . flatMap ( ( Function ) Functions . identity ( ) , true , 3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return fromArray ( source1 , source2 , source3 , source4 ) . flatMap ( ( Function ) Functions . identity ( ) , true , 4 ) ; 
return RxJavaPlugins . onAssembly ( ( Observable < T > ) ObservableNever . INSTANCE ) ; 
return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) , bufferSize ( ) ) ; 
return sequenceEqual ( source1 , source2 , isEqual , bufferSize ( ) ) ; 
return switchOnNext ( sources , bufferSize ( ) ) ; 
return switchOnNextDelayError ( sources , bufferSize ( ) ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; if ( onSubscribe instanceof Observable ) throw new IllegalArgumentException ( "unsafeCreate(Observable) should be upgraded" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < > ( onSubscribe ) ) ; 
return using ( resourceSupplier , sourceSupplier , resourceCleanup , true ) ; 
Objects . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < > ( source ) ) ; 
Objects . requireNonNull ( zipper , "zipper is null" ) ; Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZip < > ( null , sources , zipper , bufferSize ( ) , false ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 , source6 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( source9 , "source9 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , false , bufferSize ( ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 , source9 ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAllSingle < > ( this , predicate ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableAnySingle < > ( this , predicate ) ) ; 
BlockingFirstObserver < T > observer = new BlockingFirstObserver < > ( ) ; subscribe ( observer ) ; T v = observer . blockingGet ( ) ; if ( v != null ) return v ; throw new NoSuchElementException ( ) ; 
blockingForEach ( onNext , bufferSize ( ) ) ; 
return blockingIterable ( bufferSize ( ) ) ; 
BlockingLastObserver < T > observer = new BlockingLastObserver < > ( ) ; subscribe ( observer ) ; T v = observer . blockingGet ( ) ; if ( v != null ) return v ; throw new NoSuchElementException ( ) ; 
return new BlockingObservableLatest < > ( this ) ; 
return new BlockingObservableNext < > ( this ) ; 
T v = singleElement ( ) . blockingGet ( ) ; if ( v == null ) throw new NoSuchElementException ( ) ; return v ; 
return subscribeWith ( new FutureObserver < > ( ) ) ; 
ObservableBlockingSubscribe . subscribe ( this ) ; 
ObservableBlockingSubscribe . subscribe ( this , onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
ObservableBlockingSubscribe . subscribe ( this , onNext , onError , Functions . EMPTY_ACTION ) ; 
ObservableBlockingSubscribe . subscribe ( this , onNext , onError , onComplete ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; ObservableBlockingSubscribe . subscribe ( this , observer ) ; 
return buffer ( openingIndicator , closingIndicator , ArrayListSupplier . asSupplier ( ) ) ; 
Objects . requireNonNull ( openingIndicator , "openingIndicator is null" ) ; Objects . requireNonNull ( closingIndicator , "closingIndicator is null" ) ; Objects . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferBoundary < T , U , TOpening , TClosing > ( this , openingIndicator , closingIndicator , bufferSupplier ) ) ; 
return buffer ( boundaryIndicator , ArrayListSupplier . asSupplier ( ) ) ; 
Objects . requireNonNull ( boundaryIndicator , "boundaryIndicator is null" ) ; Objects . requireNonNull ( bufferSupplier , "bufferSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableBufferExactBoundary < > ( this , boundaryIndicator , bufferSupplier ) ) ; 
return cacheWithInitialCapacity ( 16 ) ; 
Objects . requireNonNull ( clazz , "clazz is null" ) ; return map ( Functions . castFunction ( clazz ) ) ; 
Objects . requireNonNull ( initialItemSupplier , "initialItemSupplier is null" ) ; Objects . requireNonNull ( collector , "collector is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableCollectSingle < > ( this , initialItemSupplier , collector ) ) ; 
return wrap ( ( ( ObservableTransformer < T , R > ) Objects . requireNonNull ( composer , "composer is null" ) ) . apply ( this ) ) ; 
return concatMap ( mapper , 2 ) ; 
return concatMapDelayError ( mapper , true , bufferSize ( ) ) ; 
return concatMapEager ( mapper , Integer . MAX_VALUE , bufferSize ( ) ) ; 
return concatMapCompletable ( mapper , 2 ) ; 
return concatMapCompletableDelayError ( mapper , true , 2 ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlattenIterable < > ( this , mapper ) ) ; 
return concatMapMaybe ( mapper , 2 ) ; 
return concatMapMaybeDelayError ( mapper , true , 2 ) ; 
return concatMapSingle ( mapper , 2 ) ; 
return concatMapSingleDelayError ( mapper , true , 2 ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return concat ( this , other ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatWithSingle < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatWithMaybe < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatWithCompletable < > ( this , other ) ) ; 
Objects . requireNonNull ( item , "item is null" ) ; return any ( Functions . equalsWith ( item ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableCountSingle < > ( this ) ) ; 
Objects . requireNonNull ( debounceIndicator , "debounceIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDebounce < > ( this , debounceIndicator ) ) ; 
Objects . requireNonNull ( itemDelayIndicator , "itemDelayIndicator is null" ) ; return flatMap ( ObservableInternalHelper . itemDelay ( itemDelayIndicator ) ) ; 
return delaySubscription ( subscriptionIndicator ) . delay ( itemDelayIndicator ) ; 
Objects . requireNonNull ( subscriptionIndicator , "subscriptionIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDelaySubscriptionOther < > ( this , subscriptionIndicator ) ) ; 
Objects . requireNonNull ( selector , "selector is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDematerialize < > ( this , selector ) ) ; 
return distinct ( Functions . identity ( ) , Functions . createHashSet ( ) ) ; 
return distinct ( keySelector , Functions . createHashSet ( ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; Objects . requireNonNull ( collectionSupplier , "collectionSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDistinct < > ( this , keySelector , collectionSupplier ) ) ; 
return distinctUntilChanged ( Functions . identity ( ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDistinctUntilChanged < > ( this , keySelector , ObjectHelper . equalsPredicate ( ) ) ) ; 
Objects . requireNonNull ( comparer , "comparer is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDistinctUntilChanged < > ( this , Functions . identity ( ) , comparer ) ) ; 
Objects . requireNonNull ( onAfterNext , "onAfterNext is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDoAfterNext < > ( this , onAfterNext ) ) ; 
Objects . requireNonNull ( onAfterTerminate , "onAfterTerminate is null" ) ; return doOnEach ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , onAfterTerminate ) ; 
Objects . requireNonNull ( onFinally , "onFinally is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDoFinally < > ( this , onFinally ) ) ; 
return doOnLifecycle ( Functions . emptyConsumer ( ) , onDispose ) ; 
return doOnEach ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , onComplete , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; Objects . requireNonNull ( onAfterTerminate , "onAfterTerminate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDoOnEach < > ( this , onNext , onError , onComplete , onAfterTerminate ) ) ; 
Objects . requireNonNull ( onNotification , "onNotification is null" ) ; return doOnEach ( Functions . notificationOnNext ( onNotification ) , Functions . notificationOnError ( onNotification ) , Functions . notificationOnComplete ( onNotification ) , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; return doOnEach ( ObservableInternalHelper . observerOnNext ( observer ) , ObservableInternalHelper . observerOnError ( observer ) , ObservableInternalHelper . observerOnComplete ( observer ) , Functions . EMPTY_ACTION ) ; 
return doOnEach ( Functions . emptyConsumer ( ) , onError , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; Objects . requireNonNull ( onDispose , "onDispose is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableDoOnLifecycle < > ( this , onSubscribe , onDispose ) ) ; 
return doOnEach ( onNext , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; 
return doOnLifecycle ( onSubscribe , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onTerminate , "onTerminate is null" ) ; return doOnEach ( Functions . emptyConsumer ( ) , Functions . actionConsumer ( onTerminate ) , onTerminate , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFilter < > ( this , predicate ) ) ; 
return elementAt ( 0L ) ; 
return elementAtOrError ( 0L ) ; 
return flatMap ( mapper , false ) ; 
Objects . requireNonNull ( onNextMapper , "onNextMapper is null" ) ; Objects . requireNonNull ( onErrorMapper , "onErrorMapper is null" ) ; Objects . requireNonNull ( onCompleteSupplier , "onCompleteSupplier is null" ) ; return merge ( new ObservableMapNotification < > ( this , onNextMapper , onErrorMapper , onCompleteSupplier ) ) ; 
return flatMap ( mapper , combiner , false , bufferSize ( ) , bufferSize ( ) ) ; 
return flatMapCompletable ( mapper , false ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlattenIterable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return flatMap ( ObservableInternalHelper . flatMapIntoIterable ( mapper ) , combiner , false , bufferSize ( ) , bufferSize ( ) ) ; 
return flatMapMaybe ( mapper , false ) ; 
return flatMapSingle ( mapper , false ) ; 
return subscribe ( onNext ) ; 
return forEachWhile ( onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
return forEachWhile ( onNext , onError , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; ForEachWhileObserver < T > o = new ForEachWhileObserver < > ( onNext , onError , onComplete ) ; subscribe ( o ) ; return o ; 
return groupBy ( keySelector , ( Function ) Functions . identity ( ) , false , bufferSize ( ) ) ; 
return groupBy ( keySelector , valueSelector , false , bufferSize ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; Objects . requireNonNull ( leftEnd , "leftEnd is null" ) ; Objects . requireNonNull ( rightEnd , "rightEnd is null" ) ; Objects . requireNonNull ( resultSelector , "resultSelector is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableGroupJoin < > ( this , other , leftEnd , rightEnd , resultSelector ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableHide < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableIgnoreElementsCompletable < > ( this ) ) ; 
return all ( Functions . alwaysFalse ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; Objects . requireNonNull ( leftEnd , "leftEnd is null" ) ; Objects . requireNonNull ( rightEnd , "rightEnd is null" ) ; Objects . requireNonNull ( resultSelector , "resultSelector is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableJoin < T , TRight , TLeftEnd , TRightEnd , R > ( this , other , leftEnd , rightEnd , resultSelector ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableLastMaybe < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableLastSingle < > ( this , null ) ) ; 
Objects . requireNonNull ( lifter , "lifter is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableLift < > ( this , lifter ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableMap < > ( this , mapper ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableMaterialize < > ( this ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return merge ( this , other ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableMergeWithSingle < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableMergeWithMaybe < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableMergeWithCompletable < > ( this , other ) ) ; 
return observeOn ( scheduler , false , bufferSize ( ) ) ; 
Objects . requireNonNull ( clazz , "clazz is null" ) ; return filter ( Functions . isInstanceOf ( clazz ) ) . cast ( clazz ) ; 
return onErrorComplete ( Functions . alwaysTrue ( ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableOnErrorComplete < > ( this , predicate ) ) ; 
Objects . requireNonNull ( fallbackSupplier , "fallbackSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableOnErrorNext < > ( this , fallbackSupplier ) ) ; 
Objects . requireNonNull ( fallback , "fallback is null" ) ; return onErrorResumeNext ( Functions . justFunction ( fallback ) ) ; 
Objects . requireNonNull ( itemSupplier , "itemSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableOnErrorReturn < > ( this , itemSupplier ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableDetach < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservablePublish < > ( this ) ) ; 
Objects . requireNonNull ( selector , "selector is null" ) ; return RxJavaPlugins . onAssembly ( new ObservablePublishSelector < > ( this , selector ) ) ; 
Objects . requireNonNull ( reducer , "reducer is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableReduceMaybe < > ( this , reducer ) ) ; 
Objects . requireNonNull ( seedSupplier , "seedSupplier is null" ) ; Objects . requireNonNull ( reducer , "reducer is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableReduceWithSingle < > ( this , seedSupplier , reducer ) ) ; 
return repeat ( Long . MAX_VALUE ) ; 
Objects . requireNonNull ( stop , "stop is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableRepeatUntil < > ( this , stop ) ) ; 
Objects . requireNonNull ( handler , "handler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableRepeatWhen < > ( this , handler ) ) ; 
return ObservableReplay . createFrom ( this ) ; 
Objects . requireNonNull ( selector , "selector is null" ) ; return ObservableReplay . multicastSelector ( ObservableInternalHelper . replaySupplier ( this ) , selector ) ; 
return retry ( Long . MAX_VALUE , Functions . alwaysTrue ( ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableRetryBiPredicate < > ( this , predicate ) ) ; 
return retry ( Long . MAX_VALUE , predicate ) ; 
Objects . requireNonNull ( stop , "stop is null" ) ; return retry ( Long . MAX_VALUE , Functions . predicateReverseFor ( stop ) ) ; 
Objects . requireNonNull ( handler , "handler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableRetryWhen < > ( this , handler ) ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; if ( observer instanceof SafeObserver ) subscribe ( observer ) ; else subscribe ( new SafeObserver < > ( observer ) ) ; 
Objects . requireNonNull ( sampler , "sampler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSampleWithObservable < > ( this , sampler , false ) ) ; 
Objects . requireNonNull ( accumulator , "accumulator is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableScan < > ( this , accumulator ) ) ; 
Objects . requireNonNull ( seedSupplier , "seedSupplier is null" ) ; Objects . requireNonNull ( accumulator , "accumulator is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableScanSeed < > ( this , seedSupplier , accumulator ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableSerialized < > ( this ) ) ; 
return publish ( ) . refCount ( ) ; 
