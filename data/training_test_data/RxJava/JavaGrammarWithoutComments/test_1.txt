return Schedulers . io ( ) ; 
Flowable < Integer > f1 = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) ; Flowable < Integer > f2 = Flowable . just ( 6 , 7 , 8 , 9 , 10 ) ; Flowable < String > f = Flowable . merge ( f1 , f2 ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) assertTrue ( Thread . currentThread ( ) . getName ( ) . startsWith ( "RxCachedThreadScheduler" ) ) ; return "Value_" + t + "_Thread_" + Thread . currentThread ( ) . getName ( ) ; ) ; f . subscribeOn ( Schedulers . io ( ) ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String t ) System . out . println ( "t: " + t ) ; ) ; 
SchedulerTestHelper . handledErrorIsNotDeliveredToThreadHandler ( getScheduler ( ) ) ; 
Worker w = Schedulers . io ( ) . createWorker ( ) ; try ExecutorSchedulerTest . cancelledRetention ( w , false ) ; finally w . dispose ( ) ; w = Schedulers . io ( ) . createWorker ( ) ; try ExecutorSchedulerTest . cancelledRetention ( w , true ) ; finally w . dispose ( ) ; 
Worker w = Schedulers . io ( ) . createWorker ( ) ; assertFalse ( ( ( Disposable ) w ) . isDisposed ( ) ) ; w . dispose ( ) ; assertTrue ( ( ( Disposable ) w ) . isDisposed ( ) ) ; 
final int [ ] calls = 0 ; Runnable r = new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; ; IoScheduler s = new IoScheduler ( ) ; s . shutdown ( ) ; s . shutdown ( ) ; s . scheduleDirect ( r ) ; s . scheduleDirect ( r , 1 , TimeUnit . SECONDS ) ; s . schedulePeriodicallyDirect ( r , 1 , 1 , TimeUnit . SECONDS ) ; Worker w = s . createWorker ( ) ; w . dispose ( ) ; assertEquals ( Disposable . disposed ( ) , w . schedule ( r ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedule ( r , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedulePeriodically ( r , 1 , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
return Schedulers . from ( executor ) ; 
SchedulerTestHelper . handledErrorIsNotDeliveredToThreadHandler ( getScheduler ( ) ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; Scheduler s = Schedulers . from ( exec ) ; try Scheduler . Worker w = s . createWorker ( ) ; try cancelledRetention ( w , false ) ; finally w . dispose ( ) ; w = s . createWorker ( ) ; try cancelledRetention ( w , true ) ; finally w . dispose ( ) ; finally exec . shutdownNow ( ) ; 
queue . offer ( command ) ; 
Runnable r = queue . poll ( ) ; if ( r != null ) r . run ( ) ; 
Runnable r ; while ( ( r = queue . poll ( ) ) != null ) r . run ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Runnable task = new Runnable ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ; TestExecutor exec = new TestExecutor ( ) ; Scheduler custom = Schedulers . from ( exec ) ; Worker w = custom . createWorker ( ) ; try Disposable d1 = w . schedule ( task ) ; Disposable d2 = w . schedule ( task ) ; Disposable d3 = w . schedule ( task ) ; d1 . dispose ( ) ; d2 . dispose ( ) ; d3 . dispose ( ) ; exec . executeAll ( ) ; assertEquals ( 0 , calls . get ( ) ) ; finally w . dispose ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Runnable task = new Runnable ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ; TestExecutor exec = new TestExecutor ( ) ; Scheduler custom = Schedulers . from ( exec ) ; Worker w = custom . createWorker ( ) ; try w . schedule ( task ) ; w . schedule ( task ) ; w . schedule ( task ) ; finally w . dispose ( ) ; exec . executeAll ( ) ; assertEquals ( 0 , calls . get ( ) ) ; 
Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) r . run ( ) ; ) ; final CountDownLatch cdl = new CountDownLatch ( 5 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . scheduleDirect ( r ) ; s . scheduleDirect ( r , 50 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodicallyDirect ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; exec . shutdown ( ) ; Scheduler s = Schedulers . from ( exec ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try assertSame ( EmptyDisposable . INSTANCE , s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ) ; assertSame ( EmptyDisposable . INSTANCE , s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 10 , TimeUnit . MILLISECONDS ) ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedulePeriodicallyDirect ( Functions . EMPTY_RUNNABLE , 10 , 10 , TimeUnit . MILLISECONDS ) ) ; TestHelper . assertUndeliverable ( errors , 0 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 2 , RejectedExecutionException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; exec . shutdown ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Worker s = Schedulers . from ( exec ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedule ( Functions . EMPTY_RUNNABLE ) ) ; s = Schedulers . from ( exec ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedule ( Functions . EMPTY_RUNNABLE , 10 , TimeUnit . MILLISECONDS ) ) ; s = Schedulers . from ( exec ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedulePeriodically ( Functions . EMPTY_RUNNABLE , 10 , 10 , TimeUnit . MILLISECONDS ) ) ; TestHelper . assertUndeliverable ( errors , 0 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 2 , RejectedExecutionException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try Scheduler s = Schedulers . from ( exec ) ; final CountDownLatch cdl = new CountDownLatch ( 8 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . scheduleDirect ( r ) ; s . scheduleDirect ( r , 10 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodicallyDirect ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; Worker s = Schedulers . from ( exec ) . createWorker ( ) ; assertFalse ( s . isDisposed ( ) ) ; try final CountDownLatch cdl = new CountDownLatch ( 8 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . schedule ( r ) ; s . schedule ( r , 10 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodically ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; finally s . dispose ( ) ; exec . shutdown ( ) ; assertTrue ( s . isDisposed ( ) ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; final Scheduler s = Schedulers . from ( exec ) ; try for ( int i = 0 ; i < 500 ; i ++ ) final Worker w = s . createWorker ( ) ; final AtomicInteger c = new AtomicInteger ( 2 ) ; w . schedule ( new Runnable ( ) @ Override public void run ( ) c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) ) ; c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) w . dispose ( ) ; finally exec . shutdownNow ( ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) r . run ( ) ; ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; assertTrue ( d . isDisposed ( ) ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( executor ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; ) ; Disposable d = s . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) throw new IllegalStateException ( ) ; ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MILLISECONDS ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
ExecutorService executorScheduler = Executors . newScheduledThreadPool ( 1 , new RxThreadFactory ( "TestCustomPoolTimed" ) ) ; try final Scheduler s = Schedulers . from ( executorScheduler ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MILLISECONDS ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; finally executorScheduler . shutdownNow ( ) ; 
Scheduler scheduler = getScheduler ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Runnable countDownRunnable = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; Disposable disposable = scheduler . scheduleDirect ( countDownRunnable , 100 , TimeUnit . MILLISECONDS ) ; SchedulerRunnableIntrospection wrapper = ( SchedulerRunnableIntrospection ) disposable ; assertSame ( countDownRunnable , wrapper . getWrappedRunnable ( ) ) ; disposable . dispose ( ) ; assertSame ( Functions . EMPTY_RUNNABLE , wrapper . getWrappedRunnable ( ) ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try Scheduler s = Schedulers . from ( r -> exec . execute ( r ) , true ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) SequentialDisposable sd = new SequentialDisposable ( ) ; TestHelper . race ( ( ) -> sd . update ( s . scheduleDirect ( ( ) -> ) ) , ( ) -> sd . dispose ( ) ) ; finally exec . shutdown ( ) ; 
try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) AtomicReference < Runnable > runRef = new AtomicReference < > ( ) ; Scheduler s = Schedulers . from ( r -> runRef . set ( r ) ; , true ) ; Disposable d = s . scheduleDirect ( ( ) -> ) ; TestHelper . race ( ( ) -> runRef . get ( ) . run ( ) , ( ) -> d . dispose ( ) ) ; finally Thread . interrupted ( ) ; 
return Schedulers . from ( executor , true ) ; 
SchedulerTestHelper . handledErrorIsNotDeliveredToThreadHandler ( getScheduler ( ) ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; Scheduler s = Schedulers . from ( exec , true ) ; try Scheduler . Worker w = s . createWorker ( ) ; try ExecutorSchedulerTest . cancelledRetention ( w , false ) ; finally w . dispose ( ) ; w = s . createWorker ( ) ; try ExecutorSchedulerTest . cancelledRetention ( w , true ) ; finally w . dispose ( ) ; finally exec . shutdownNow ( ) ; 
queue . offer ( command ) ; 
Runnable r = queue . poll ( ) ; if ( r != null ) r . run ( ) ; 
Runnable r ; while ( ( r = queue . poll ( ) ) != null ) r . run ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Runnable task = new Runnable ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ; TestExecutor exec = new TestExecutor ( ) ; Scheduler custom = Schedulers . from ( exec , true ) ; Worker w = custom . createWorker ( ) ; try Disposable d1 = w . schedule ( task ) ; Disposable d2 = w . schedule ( task ) ; Disposable d3 = w . schedule ( task ) ; d1 . dispose ( ) ; d2 . dispose ( ) ; d3 . dispose ( ) ; exec . executeAll ( ) ; assertEquals ( 0 , calls . get ( ) ) ; finally w . dispose ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Runnable task = new Runnable ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ; TestExecutor exec = new TestExecutor ( ) ; Scheduler custom = Schedulers . from ( exec , true ) ; Worker w = custom . createWorker ( ) ; try w . schedule ( task ) ; w . schedule ( task ) ; w . schedule ( task ) ; finally w . dispose ( ) ; exec . executeAll ( ) ; assertEquals ( 0 , calls . get ( ) ) ; 
Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) r . run ( ) ; , true ) ; final CountDownLatch cdl = new CountDownLatch ( 5 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . scheduleDirect ( r ) ; s . scheduleDirect ( r , 50 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodicallyDirect ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; exec . shutdown ( ) ; Scheduler s = Schedulers . from ( exec , true ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try assertSame ( EmptyDisposable . INSTANCE , s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ) ; assertSame ( EmptyDisposable . INSTANCE , s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 10 , TimeUnit . MILLISECONDS ) ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedulePeriodicallyDirect ( Functions . EMPTY_RUNNABLE , 10 , 10 , TimeUnit . MILLISECONDS ) ) ; TestHelper . assertUndeliverable ( errors , 0 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 2 , RejectedExecutionException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; exec . shutdown ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Worker s = Schedulers . from ( exec , true ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedule ( Functions . EMPTY_RUNNABLE ) ) ; s = Schedulers . from ( exec , true ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedule ( Functions . EMPTY_RUNNABLE , 10 , TimeUnit . MILLISECONDS ) ) ; s = Schedulers . from ( exec , true ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedulePeriodically ( Functions . EMPTY_RUNNABLE , 10 , 10 , TimeUnit . MILLISECONDS ) ) ; TestHelper . assertUndeliverable ( errors , 0 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 2 , RejectedExecutionException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try Scheduler s = Schedulers . from ( exec , true ) ; final CountDownLatch cdl = new CountDownLatch ( 8 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . scheduleDirect ( r ) ; s . scheduleDirect ( r , 10 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodicallyDirect ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; Worker s = Schedulers . from ( exec , true ) . createWorker ( ) ; assertFalse ( s . isDisposed ( ) ) ; try final CountDownLatch cdl = new CountDownLatch ( 8 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . schedule ( r ) ; s . schedule ( r , 10 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodically ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; finally s . dispose ( ) ; exec . shutdown ( ) ; assertTrue ( s . isDisposed ( ) ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; final Scheduler s = Schedulers . from ( exec , true ) ; try for ( int i = 0 ; i < 500 ; i ++ ) final Worker w = s . createWorker ( ) ; final AtomicInteger c = new AtomicInteger ( 2 ) ; w . schedule ( new Runnable ( ) @ Override public void run ( ) c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) ) ; c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) w . dispose ( ) ; finally exec . shutdownNow ( ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) r . run ( ) ; , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; assertTrue ( d . isDisposed ( ) ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( executor , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; , true ) ; Disposable d = s . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) throw new IllegalStateException ( ) ; ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MILLISECONDS ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
ExecutorService executorScheduler = Executors . newScheduledThreadPool ( 1 , new RxThreadFactory ( "TestCustomPoolTimed" ) ) ; try final Scheduler s = Schedulers . from ( executorScheduler , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MILLISECONDS ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; finally executorScheduler . shutdownNow ( ) ; 
Scheduler scheduler = getScheduler ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Runnable countDownRunnable = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; Disposable disposable = scheduler . scheduleDirect ( countDownRunnable , 100 , TimeUnit . MILLISECONDS ) ; SchedulerRunnableIntrospection wrapper = ( SchedulerRunnableIntrospection ) disposable ; assertSame ( countDownRunnable , wrapper . getWrappedRunnable ( ) ) ; disposable . dispose ( ) ; assertSame ( Functions . EMPTY_RUNNABLE , wrapper . getWrappedRunnable ( ) ) ; 
Scheduler scheduler = getScheduler ( ) ; final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = scheduler . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertTrue ( "Interruption did not propagate" , isInterrupted . get ( ) ) ; 
Scheduler scheduler = getScheduler ( ) ; Worker worker = scheduler . createWorker ( ) ; try final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = worker . schedule ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertTrue ( "Interruption did not propagate" , isInterrupted . get ( ) ) ; finally worker . dispose ( ) ; 
ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 ) ; try Scheduler scheduler = Schedulers . from ( exec , true ) ; final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = scheduler . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertTrue ( "Interruption did not propagate" , isInterrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 ) ; try Scheduler scheduler = Schedulers . from ( exec , true ) ; Worker worker = scheduler . createWorker ( ) ; try final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = worker . schedule ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertTrue ( "Interruption did not propagate" , isInterrupted . get ( ) ) ; finally worker . dispose ( ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try Scheduler scheduler = Schedulers . from ( exec , false ) ; final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = scheduler . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertFalse ( "Interruption happened" , isInterrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try Scheduler scheduler = Schedulers . from ( exec , false ) ; Worker worker = scheduler . createWorker ( ) ; try final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = worker . schedule ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertFalse ( "Interruption happened" , isInterrupted . get ( ) ) ; finally worker . dispose ( ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 ) ; try Scheduler scheduler = Schedulers . from ( exec , false ) ; final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = scheduler . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertFalse ( "Interruption happened" , isInterrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 ) ; try Scheduler scheduler = Schedulers . from ( exec , false ) ; Worker worker = scheduler . createWorker ( ) ; try final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = worker . schedule ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertFalse ( "Interruption happened" , isInterrupted . get ( ) ) ; finally worker . dispose ( ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try Scheduler scheduler = Schedulers . from ( exec , false ) ; final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = scheduler . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; , 1 , TimeUnit . MILLISECONDS ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertFalse ( "Interruption happened" , isInterrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try Scheduler scheduler = Schedulers . from ( exec , false ) ; Worker worker = scheduler . createWorker ( ) ; try final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = worker . schedule ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; , 1 , TimeUnit . MILLISECONDS ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertFalse ( "Interruption happened" , isInterrupted . get ( ) ) ; finally worker . dispose ( ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 ) ; try Scheduler scheduler = Schedulers . from ( exec , false ) ; final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = scheduler . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; , 1 , TimeUnit . MILLISECONDS ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertFalse ( "Interruption happened" , isInterrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 ) ; try Scheduler scheduler = Schedulers . from ( exec , false ) ; Worker worker = scheduler . createWorker ( ) ; try final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; Disposable d = worker . schedule ( new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) try Thread . sleep ( 1000 ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; , 1 , TimeUnit . MILLISECONDS ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) Thread . sleep ( 500 ) ; d . dispose ( ) ; int i = 20 ; while ( i -- > 0 && ! isInterrupted . get ( ) ) Thread . sleep ( 50 ) ; assertFalse ( "Interruption happened" , isInterrupted . get ( ) ) ; finally worker . dispose ( ) ; finally exec . shutdown ( ) ; 
Thread . UncaughtExceptionHandler originalHandler = Thread . getDefaultUncaughtExceptionHandler ( ) ; try CapturingUncaughtExceptionHandler handler = new CapturingUncaughtExceptionHandler ( ) ; CapturingObserver < Object > observer = new CapturingObserver < > ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; IllegalStateException error = new IllegalStateException ( "Should be delivered to handler" ) ; Flowable . error ( error ) . subscribeOn ( scheduler ) . subscribe ( observer ) ; if ( ! observer . completed . await ( 3 , TimeUnit . SECONDS ) ) fail ( "timed out" ) ; if ( handler . count != 0 ) handler . caught . printStackTrace ( ) ; assertEquals ( "Handler should not have received anything: " + handler . caught , 0 , handler . count ) ; assertEquals ( "Observer should have received an error" , 1 , observer . errorCount ) ; assertEquals ( "Observer should not have received a next value" , 0 , observer . nextCount ) ; Throwable cause = observer . error ; while ( cause != null ) if ( error . equals ( cause ) ) break ; if ( cause == cause . getCause ( ) ) break ; cause = cause . getCause ( ) ; assertEquals ( "Our error should have been delivered to the observer" , error , cause ) ; finally Thread . setDefaultUncaughtExceptionHandler ( originalHandler ) ; 
count ++ ; caught = e ; completed . countDown ( ) ; 
$EMPTY$
errorCount ++ ; error = e ; completed . countDown ( ) ; 
Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Runnable firstStepStart = mock ( Runnable . class ) ; final Runnable firstStepEnd = mock ( Runnable . class ) ; final Runnable secondStepStart = mock ( Runnable . class ) ; final Runnable secondStepEnd = mock ( Runnable . class ) ; final Runnable thirdStepStart = mock ( Runnable . class ) ; final Runnable thirdStepEnd = mock ( Runnable . class ) ; final Runnable firstAction = new Runnable ( ) @ Override public void run ( ) firstStepStart . run ( ) ; firstStepEnd . run ( ) ; latch . countDown ( ) ; ; final Runnable secondAction = new Runnable ( ) @ Override public void run ( ) secondStepStart . run ( ) ; inner . schedule ( firstAction ) ; secondStepEnd . run ( ) ; ; final Runnable thirdAction = new Runnable ( ) @ Override public void run ( ) thirdStepStart . run ( ) ; inner . schedule ( secondAction ) ; thirdStepEnd . run ( ) ; ; InOrder inOrder = inOrder ( firstStepStart , firstStepEnd , secondStepStart , secondStepEnd , thirdStepStart , thirdStepEnd ) ; inner . schedule ( thirdAction ) ; latch . await ( ) ; inOrder . verify ( thirdStepStart , times ( 1 ) ) . run ( ) ; inOrder . verify ( thirdStepEnd , times ( 1 ) ) . run ( ) ; inOrder . verify ( secondStepStart , times ( 1 ) ) . run ( ) ; inOrder . verify ( secondStepEnd , times ( 1 ) ) . run ( ) ; inOrder . verify ( firstStepStart , times ( 1 ) ) . run ( ) ; inOrder . verify ( firstStepEnd , times ( 1 ) ) . run ( ) ; finally inner . dispose ( ) ; 
Flowable < Integer > ids = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) . subscribeOn ( getScheduler ( ) ) ; Flowable < String > m = ids . flatMap ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer id ) return Flowable . fromIterable ( Arrays . asList ( "a-" + id , "b-" + id ) ) . subscribeOn ( getScheduler ( ) ) . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) return "names=>" + s ; ) ; ) ; List < String > strings = m . toList ( ) . blockingGet ( ) ; assertEquals ( 4 , strings . size ( ) ) ; assertTrue ( strings . contains ( "names=>a-1" ) ) ; assertTrue ( strings . contains ( "names=>a-2" ) ) ; assertTrue ( strings . contains ( "names=>b-1" ) ) ; assertTrue ( strings . contains ( "names=>b-2" ) ) ; 
final Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try final CountDownLatch latch = new CountDownLatch ( 2 ) ; final Runnable first = mock ( Runnable . class ) ; final Runnable second = mock ( Runnable . class ) ; doAnswer ( new Answer ( ) @ Override public Object answer ( InvocationOnMock invocation ) throws Throwable try return invocation . getMock ( ) ; finally latch . countDown ( ) ; ) . when ( first ) . run ( ) ; doAnswer ( new Answer ( ) @ Override public Object answer ( InvocationOnMock invocation ) throws Throwable try return invocation . getMock ( ) ; finally latch . countDown ( ) ; ) . when ( second ) . run ( ) ; inner . schedule ( first ) ; inner . schedule ( second ) ; latch . await ( ) ; verify ( first , times ( 1 ) ) . run ( ) ; verify ( second , times ( 1 ) ) . run ( ) ; finally inner . dispose ( ) ; 
Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Runnable first = mock ( Runnable . class ) ; final Runnable second = mock ( Runnable . class ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) inner . schedule ( first , 30 , TimeUnit . MILLISECONDS ) ; inner . schedule ( second , 10 , TimeUnit . MILLISECONDS ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) latch . countDown ( ) ; , 40 , TimeUnit . MILLISECONDS ) ; ) ; latch . await ( ) ; InOrder inOrder = inOrder ( first , second ) ; inOrder . verify ( second , times ( 1 ) ) . run ( ) ; inOrder . verify ( first , times ( 1 ) ) . run ( ) ; finally inner . dispose ( ) ; 
Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Runnable first = mock ( Runnable . class ) ; final Runnable second = mock ( Runnable . class ) ; final Runnable third = mock ( Runnable . class ) ; final Runnable fourth = mock ( Runnable . class ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) inner . schedule ( first ) ; inner . schedule ( second , 300 , TimeUnit . MILLISECONDS ) ; inner . schedule ( third , 100 , TimeUnit . MILLISECONDS ) ; inner . schedule ( fourth ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) latch . countDown ( ) ; , 400 , TimeUnit . MILLISECONDS ) ; ) ; latch . await ( ) ; InOrder inOrder = inOrder ( first , second , third , fourth ) ; inOrder . verify ( first , times ( 1 ) ) . run ( ) ; inOrder . verify ( fourth , times ( 1 ) ) . run ( ) ; inOrder . verify ( third , times ( 1 ) ) . run ( ) ; inOrder . verify ( second , times ( 1 ) ) . run ( ) ; finally inner . dispose ( ) ; 
final Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try final AtomicInteger i = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) if ( i . incrementAndGet ( ) < 100 ) inner . schedule ( this ) ; else latch . countDown ( ) ; ) ; latch . await ( ) ; assertEquals ( 100 , i . get ( ) ) ; finally inner . dispose ( ) ; 
Scheduler scheduler = getScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try final AtomicInteger i = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; inner . schedule ( new Runnable ( ) int state ; @ Override public void run ( ) i . set ( state ) ; if ( state ++ < 100 ) inner . schedule ( this , 1 , TimeUnit . MILLISECONDS ) ; else latch . countDown ( ) ; ) ; latch . await ( ) ; assertEquals ( 100 , i . get ( ) ) ; finally inner . dispose ( ) ; 
Flowable < Integer > obs = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) final Scheduler . Worker inner = getScheduler ( ) . createWorker ( ) ; AsyncSubscription as = new AsyncSubscription ( ) ; subscriber . onSubscribe ( as ) ; as . setResource ( inner ) ; inner . schedule ( new Runnable ( ) int i ; @ Override public void run ( ) if ( i > 42 ) try subscriber . onComplete ( ) ; finally inner . dispose ( ) ; return ; subscriber . onNext ( i ++ ) ; inner . schedule ( this ) ; ) ; ) ; final AtomicInteger lastValue = new AtomicInteger ( ) ; obs . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) System . out . println ( "Value: " + v ) ; lastValue . set ( v ) ; ) ; assertEquals ( 42 , lastValue . get ( ) ) ; 
final int count = 10 ; final CountDownLatch latch = new CountDownLatch ( count ) ; Flowable < String > f = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < count ; i ++ ) final int v = i ; new Thread ( new Runnable ( ) @ Override public void run ( ) subscriber . onNext ( "v: " + v ) ; latch . countDown ( ) ; ) . start ( ) ; ) ; ConcurrentObserverValidator < String > observer = new ConcurrentObserverValidator < > ( ) ; f . subscribe ( observer ) ; if ( ! observer . completed . await ( 3000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out" ) ; if ( observer . error . get ( ) == null ) fail ( "We expected error messages due to concurrency" ) ; 
final Scheduler scheduler = getScheduler ( ) ; Flowable < String > f = Flowable . fromArray ( "one" , "two" , "three" , "four" , "five" , "six" , "seven" , "eight" , "nine" , "ten" ) ; ConcurrentObserverValidator < String > observer = new ConcurrentObserverValidator < > ( ) ; f . observeOn ( scheduler ) . subscribe ( observer ) ; if ( ! observer . completed . await ( 3000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out" ) ; if ( observer . error . get ( ) != null ) observer . error . get ( ) . printStackTrace ( ) ; fail ( "Error: " + observer . error . get ( ) . getMessage ( ) ) ; 
final Scheduler scheduler = getScheduler ( ) ; Flowable < String > f = Flowable . fromArray ( "one" , "two" , "three" , "four" , "five" , "six" , "seven" , "eight" , "nine" , "ten" ) . flatMap ( new Function < String , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final String v ) return Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "value_after_map-" + v ) ; subscriber . onComplete ( ) ; ) . subscribeOn ( scheduler ) ; ) ; ConcurrentObserverValidator < String > observer = new ConcurrentObserverValidator < > ( ) ; f . subscribe ( observer ) ; if ( ! observer . completed . await ( 3000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out" ) ; if ( observer . error . get ( ) != null ) observer . error . get ( ) . printStackTrace ( ) ; fail ( "Error: " + observer . error . get ( ) . getMessage ( ) ) ; 
completed . countDown ( ) ; 
error . set ( e ) ; completed . countDown ( ) ; 
Scheduler s = getScheduler ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; s . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; 
Scheduler s = getScheduler ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; s . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; , 50 , TimeUnit . MILLISECONDS ) ; assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; 
Scheduler s = getScheduler ( ) ; if ( s instanceof TrampolineScheduler ) return ; final CountDownLatch cdl = new CountDownLatch ( 5 ) ; Disposable d = s . schedulePeriodicallyDirect ( new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
Scheduler s = getScheduler ( ) ; if ( s instanceof TrampolineScheduler ) return ; for ( int initial = 0 ; initial < 2 ; initial ++ ) final CountDownLatch cdl = new CountDownLatch ( 1 ) ; final SequentialDisposable sd = new SequentialDisposable ( ) ; try sd . replace ( s . schedulePeriodicallyDirect ( new Runnable ( ) int count ; @ Override public void run ( ) if ( ++ count == 10 ) sd . dispose ( ) ; cdl . countDown ( ) ; , initial , 0 , TimeUnit . MILLISECONDS ) ) ; assertTrue ( "" + initial , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally sd . dispose ( ) ; 
Scheduler s = getScheduler ( ) ; if ( s instanceof TrampolineScheduler ) return ; for ( int initial = 0 ; initial < 2 ; initial ++ ) final CountDownLatch cdl = new CountDownLatch ( 1 ) ; final SequentialDisposable sd = new SequentialDisposable ( ) ; Scheduler . Worker w = s . createWorker ( ) ; try sd . replace ( w . schedulePeriodically ( new Runnable ( ) int count ; @ Override public void run ( ) if ( ++ count == 10 ) sd . dispose ( ) ; cdl . countDown ( ) ; , initial , 0 , TimeUnit . MILLISECONDS ) ) ; assertTrue ( "" + initial , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally sd . dispose ( ) ; w . dispose ( ) ; 
try final CountDownLatch decoratedCalled = new CountDownLatch ( 1 ) ; RxJavaPlugins . setScheduleHandler ( new Function < Runnable , Runnable > ( ) @ Override public Runnable apply ( final Runnable actual ) throws Exception return new Runnable ( ) @ Override public void run ( ) decoratedCalled . countDown ( ) ; actual . run ( ) ; ; ) ; scheduleCall . run ( ) ; assertTrue ( decoratedCalled . await ( 5 , TimeUnit . SECONDS ) ) ; finally RxJavaPlugins . reset ( ) ; 
assertRunnableDecorated ( new Runnable ( ) @ Override public void run ( ) getScheduler ( ) . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; ) ; 
assertRunnableDecorated ( new Runnable ( ) @ Override public void run ( ) getScheduler ( ) . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MILLISECONDS ) ; ) ; 
final Scheduler scheduler = getScheduler ( ) ; if ( scheduler instanceof TrampolineScheduler ) return ; final AtomicReference < Disposable > disposable = new AtomicReference < > ( ) ; try assertRunnableDecorated ( new Runnable ( ) @ Override public void run ( ) disposable . set ( scheduler . schedulePeriodicallyDirect ( Functions . EMPTY_RUNNABLE , 1 , 10000 , TimeUnit . MILLISECONDS ) ) ; ) ; finally disposable . get ( ) . dispose ( ) ; 
Scheduler s = getScheduler ( ) ; if ( s instanceof TrampolineScheduler ) return ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Runnable countDownRunnable = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; Disposable disposable = s . schedulePeriodicallyDirect ( countDownRunnable , 100 , 100 , TimeUnit . MILLISECONDS ) ; SchedulerRunnableIntrospection wrapper = ( SchedulerRunnableIntrospection ) disposable ; assertSame ( countDownRunnable , wrapper . getWrappedRunnable ( ) ) ; assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; disposable . dispose ( ) ; 
Scheduler scheduler = getScheduler ( ) ; if ( scheduler instanceof TrampolineScheduler ) return ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Runnable countDownRunnable = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; Disposable disposable = scheduler . scheduleDirect ( countDownRunnable , 100 , TimeUnit . MILLISECONDS ) ; SchedulerRunnableIntrospection wrapper = ( SchedulerRunnableIntrospection ) disposable ; assertSame ( countDownRunnable , wrapper . getWrappedRunnable ( ) ) ; disposable . dispose ( ) ; 
try getScheduler ( ) . scheduleDirect ( null ) ; fail ( ) ; catch ( NullPointerException npe ) assertEquals ( "run is null" , npe . getMessage ( ) ) ; 
try getScheduler ( ) . scheduleDirect ( null , 10 , TimeUnit . MILLISECONDS ) ; fail ( ) ; catch ( NullPointerException npe ) assertEquals ( "run is null" , npe . getMessage ( ) ) ; 
try getScheduler ( ) . schedulePeriodicallyDirect ( null , 5 , 10 , TimeUnit . MILLISECONDS ) ; fail ( ) ; catch ( NullPointerException npe ) assertEquals ( "run is null" , npe . getMessage ( ) ) ; 
CountDownLatch waitForBody = new CountDownLatch ( 1 ) ; CountDownLatch waitForPrint = new CountDownLatch ( 1 ) ; try Disposable d = onSchedule . apply ( ( ) -> waitForBody . countDown ( ) ; try waitForPrint . await ( ) ; catch ( InterruptedException ex ) ex . printStackTrace ( ) ; ) ; waitForBody . await ( ) ; assertNotEquals ( "" , d . toString ( ) ) ; catch ( Throwable ex ) throw new AssertionError ( ex ) ; finally waitForPrint . countDown ( ) ; 
if ( getScheduler ( ) instanceof TrampolineScheduler ) return ; schedulePrint ( r -> getScheduler ( ) . scheduleDirect ( r ) ) ; 
if ( getScheduler ( ) instanceof TrampolineScheduler ) return ; Worker worker = getScheduler ( ) . createWorker ( ) ; try schedulePrint ( worker :: schedule ) ; finally worker . dispose ( ) ; 
return Schedulers . newThread ( ) ; 
SchedulerTestHelper . handledErrorIsNotDeliveredToThreadHandler ( getScheduler ( ) ) ; 
final int [ ] calls = 0 ; Runnable r = new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; ; Scheduler s = getScheduler ( ) ; Worker w = s . createWorker ( ) ; w . dispose ( ) ; assertTrue ( w . isDisposed ( ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedule ( r ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedule ( r , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedulePeriodically ( r , 1 , 1 , TimeUnit . SECONDS ) ) ; NewThreadWorker actual = ( NewThreadWorker ) w ; CompositeDisposable cd = new CompositeDisposable ( ) ; actual . scheduleActual ( r , 1 , TimeUnit . SECONDS , cd ) ; assertEquals ( 0 , cd . size ( ) ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
Scheduler s = getScheduler ( ) ; NewThreadWorker w = ( NewThreadWorker ) s . createWorker ( ) ; w . dispose ( ) ; w . scheduleActual ( new Runnable ( ) @ Override public void run ( ) , 0 , TimeUnit . MILLISECONDS , null ) ; 
return Schedulers . from ( executor , false , true ) ; 
SchedulerTestHelper . handledErrorIsNotDeliveredToThreadHandler ( getScheduler ( ) ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; Scheduler s = Schedulers . from ( exec , false , true ) ; try Scheduler . Worker w = s . createWorker ( ) ; try ExecutorSchedulerTest . cancelledRetention ( w , false ) ; finally w . dispose ( ) ; w = s . createWorker ( ) ; try ExecutorSchedulerTest . cancelledRetention ( w , true ) ; finally w . dispose ( ) ; finally exec . shutdownNow ( ) ; 
queue . offer ( command ) ; 
Runnable r = queue . poll ( ) ; if ( r != null ) r . run ( ) ; 
Runnable r ; while ( ( r = queue . poll ( ) ) != null ) r . run ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Runnable task = new Runnable ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ; TestExecutor exec = new TestExecutor ( ) ; Scheduler custom = Schedulers . from ( exec , false , true ) ; Worker w = custom . createWorker ( ) ; try Disposable d1 = w . schedule ( task ) ; Disposable d2 = w . schedule ( task ) ; Disposable d3 = w . schedule ( task ) ; d1 . dispose ( ) ; d2 . dispose ( ) ; d3 . dispose ( ) ; exec . executeAll ( ) ; assertEquals ( 0 , calls . get ( ) ) ; finally w . dispose ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Runnable task = new Runnable ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ; TestExecutor exec = new TestExecutor ( ) ; Scheduler custom = Schedulers . from ( exec , false , true ) ; Worker w = custom . createWorker ( ) ; try w . schedule ( task ) ; w . schedule ( task ) ; w . schedule ( task ) ; finally w . dispose ( ) ; exec . executeAll ( ) ; assertEquals ( 0 , calls . get ( ) ) ; 
Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) r . run ( ) ; , false , true ) ; final CountDownLatch cdl = new CountDownLatch ( 5 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . scheduleDirect ( r ) ; s . scheduleDirect ( r , 50 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodicallyDirect ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; exec . shutdown ( ) ; Scheduler s = Schedulers . from ( exec , false , true ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try assertSame ( EmptyDisposable . INSTANCE , s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ) ; assertSame ( EmptyDisposable . INSTANCE , s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 10 , TimeUnit . MILLISECONDS ) ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedulePeriodicallyDirect ( Functions . EMPTY_RUNNABLE , 10 , 10 , TimeUnit . MILLISECONDS ) ) ; TestHelper . assertUndeliverable ( errors , 0 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 2 , RejectedExecutionException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; exec . shutdown ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Worker s = Schedulers . from ( exec , false , true ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedule ( Functions . EMPTY_RUNNABLE ) ) ; s = Schedulers . from ( exec , false , true ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedule ( Functions . EMPTY_RUNNABLE , 10 , TimeUnit . MILLISECONDS ) ) ; s = Schedulers . from ( exec , false , true ) . createWorker ( ) ; assertSame ( EmptyDisposable . INSTANCE , s . schedulePeriodically ( Functions . EMPTY_RUNNABLE , 10 , 10 , TimeUnit . MILLISECONDS ) ) ; TestHelper . assertUndeliverable ( errors , 0 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , RejectedExecutionException . class ) ; TestHelper . assertUndeliverable ( errors , 2 , RejectedExecutionException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try Scheduler s = Schedulers . from ( exec , false , true ) ; final CountDownLatch cdl = new CountDownLatch ( 8 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . scheduleDirect ( r ) ; s . scheduleDirect ( r , 10 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodicallyDirect ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; Worker s = Schedulers . from ( exec , false , true ) . createWorker ( ) ; assertFalse ( s . isDisposed ( ) ) ; try final CountDownLatch cdl = new CountDownLatch ( 8 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; s . schedule ( r ) ; s . schedule ( r , 10 , TimeUnit . MILLISECONDS ) ; Disposable d = s . schedulePeriodically ( r , 10 , 10 , TimeUnit . MILLISECONDS ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; finally d . dispose ( ) ; finally s . dispose ( ) ; exec . shutdown ( ) ; assertTrue ( s . isDisposed ( ) ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; final Scheduler s = Schedulers . from ( exec , false , true ) ; try for ( int i = 0 ; i < 500 ; i ++ ) final Worker w = s . createWorker ( ) ; final AtomicInteger c = new AtomicInteger ( 2 ) ; w . schedule ( new Runnable ( ) @ Override public void run ( ) c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) ) ; c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) w . dispose ( ) ; finally exec . shutdownNow ( ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) r . run ( ) ; , false , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; assertTrue ( d . isDisposed ( ) ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; , false , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( executor , false , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; , false , true ) ; Disposable d = s . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) throw new IllegalStateException ( ) ; ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . from ( new Executor ( ) @ Override public void execute ( Runnable r ) new Thread ( r ) . start ( ) ; , false , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MILLISECONDS ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
ExecutorService executorScheduler = Executors . newScheduledThreadPool ( 1 , new RxThreadFactory ( "TestCustomPoolTimed" ) ) ; try final Scheduler s = Schedulers . from ( executorScheduler , false , true ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MILLISECONDS ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; finally executorScheduler . shutdownNow ( ) ; 
Scheduler scheduler = getScheduler ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Runnable countDownRunnable = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; Disposable disposable = scheduler . scheduleDirect ( countDownRunnable , 100 , TimeUnit . MILLISECONDS ) ; SchedulerRunnableIntrospection wrapper = ( SchedulerRunnableIntrospection ) disposable ; assertSame ( countDownRunnable , wrapper . getWrappedRunnable ( ) ) ; disposable . dispose ( ) ; assertSame ( Functions . EMPTY_RUNNABLE , wrapper . getWrappedRunnable ( ) ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try final Scheduler sch = Schedulers . from ( exec , false , true ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . publish ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Throwable return Flowable . merge ( v . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer w ) throws Throwable return w % 2 == 0 ; ) . observeOn ( sch , false , 1 ) . hide ( ) , v . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer w ) throws Throwable return w % 2 != 0 ; ) . observeOn ( sch , false , 1 ) . hide ( ) ) ; ) . test ( ) ; for ( int i = 1 ; i < 11 ; i ++ ) pp . onNext ( i ) ; pp . onComplete ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; finally exec . shutdown ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try final Scheduler sch = Schedulers . from ( exec , false , true ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . publish ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Throwable return Flowable . merge ( v . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer w ) throws Throwable return w % 2 == 0 ; ) . delay ( 0 , TimeUnit . SECONDS , sch ) . hide ( ) , v . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer w ) throws Throwable return w % 2 != 0 ; ) . delay ( 0 , TimeUnit . SECONDS , sch ) . hide ( ) ) ; ) . test ( ) ; for ( int i = 1 ; i < 11 ; i ++ ) pp . onNext ( i ) ; pp . onComplete ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; finally exec . shutdown ( ) ; 
Timed < Integer > timed = new Timed < > ( 1 , 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , timed . value ( ) . intValue ( ) ) ; assertEquals ( 5 , timed . time ( ) ) ; assertEquals ( 5000 , timed . time ( TimeUnit . MILLISECONDS ) ) ; assertSame ( TimeUnit . SECONDS , timed . unit ( ) ) ; 
Timed < Integer > t1 = new Timed < > ( 1 , 5 , TimeUnit . SECONDS ) ; assertEquals ( TimeUnit . SECONDS . hashCode ( ) + 31 * ( 5 + 31 * 1 ) , t1 . hashCode ( ) ) ; Timed < Integer > t2 = new Timed < > ( 0 , 5 , TimeUnit . SECONDS ) ; assertEquals ( TimeUnit . SECONDS . hashCode ( ) + 31 * ( 5 + 31 * 0 ) , t2 . hashCode ( ) ) ; 
Timed < Integer > t1 = new Timed < > ( 1 , 5 , TimeUnit . SECONDS ) ; Timed < Integer > t2 = new Timed < > ( 1 , 5 , TimeUnit . SECONDS ) ; Timed < Integer > t3 = new Timed < > ( 2 , 5 , TimeUnit . SECONDS ) ; Timed < Integer > t4 = new Timed < > ( 1 , 4 , TimeUnit . SECONDS ) ; Timed < Integer > t5 = new Timed < > ( 1 , 5 , TimeUnit . MINUTES ) ; assertEquals ( t1 , t1 ) ; assertEquals ( t1 , t2 ) ; assertNotEquals ( t1 , t3 ) ; assertNotEquals ( t1 , t4 ) ; assertNotEquals ( t2 , t3 ) ; assertNotEquals ( t2 , t4 ) ; assertNotEquals ( t2 , t5 ) ; assertNotEquals ( t3 , t1 ) ; assertNotEquals ( t3 , t2 ) ; assertNotEquals ( t3 , t4 ) ; assertNotEquals ( t3 , t5 ) ; assertNotEquals ( t4 , t1 ) ; assertNotEquals ( t4 , t2 ) ; assertNotEquals ( t4 , t3 ) ; assertNotEquals ( t4 , t5 ) ; assertNotEquals ( t5 , t1 ) ; assertNotEquals ( t5 , t2 ) ; assertNotEquals ( t5 , t3 ) ; assertNotEquals ( t5 , t4 ) ; assertNotEquals ( new Object ( ) , t1 ) ; assertNotEquals ( t1 , new Object ( ) ) ; 
Timed < Integer > t1 = new Timed < > ( 1 , 5 , TimeUnit . SECONDS ) ; assertEquals ( "Timed[time=5, unit=SECONDS, value=1]" , t1 . toString ( ) ) ; 
new Timed < > ( 1 , 5 , null ) ; 
tryOutSchedulers ( ) ; System . out . println ( "testShutdown >> Giving time threads to spin-up" ) ; Thread . sleep ( 500 ) ; Set < Thread > rxThreads = new HashSet < > ( ) ; for ( Thread t : Thread . getAllStackTraces ( ) . keySet ( ) ) if ( t . getName ( ) . startsWith ( "Rx" ) ) rxThreads . add ( t ) ; Schedulers . shutdown ( ) ; System . out . println ( "testShutdown >> Giving time to threads to stop" ) ; Thread . sleep ( 500 ) ; StringBuilder b = new StringBuilder ( ) ; for ( Thread t : rxThreads ) if ( t . isAlive ( ) ) b . append ( "Thread " + t + " failed to shutdown\r\n" ) ; for ( StackTraceElement ste : t . getStackTrace ( ) ) b . append ( "  " ) . append ( ste ) . append ( "\r\n" ) ; if ( b . length ( ) > 0 ) System . out . print ( b ) ; System . out . println ( "testShutdown >> Restarting schedulers..." ) ; Schedulers . start ( ) ; fail ( "Rx Threads were still alive:\r\n" + b ) ; System . out . println ( "testShutdown >> Restarting schedulers..." ) ; Schedulers . start ( ) ; tryOutSchedulers ( ) ; 
final CountDownLatch cdl = new CountDownLatch ( 4 ) ; final Runnable countAction = new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; ; CompositeDisposable cd = new CompositeDisposable ( ) ; try Worker w1 = Schedulers . computation ( ) . createWorker ( ) ; cd . add ( w1 ) ; w1 . schedule ( countAction ) ; Worker w2 = Schedulers . io ( ) . createWorker ( ) ; cd . add ( w2 ) ; w2 . schedule ( countAction ) ; Worker w3 = Schedulers . newThread ( ) . createWorker ( ) ; cd . add ( w3 ) ; w3 . schedule ( countAction ) ; Worker w4 = Schedulers . single ( ) . createWorker ( ) ; cd . add ( w4 ) ; w4 . schedule ( countAction ) ; if ( ! cdl . await ( 3 , TimeUnit . SECONDS ) ) fail ( "countAction was not run by every worker" ) ; finally cd . dispose ( ) ; 
tryOutSchedulers ( ) ; System . out . println ( "testStartIdempotence >> giving some time" ) ; Thread . sleep ( 500 ) ; Set < Thread > rxThreadsBefore = new HashSet < > ( ) ; for ( Thread t : Thread . getAllStackTraces ( ) . keySet ( ) ) if ( t . getName ( ) . startsWith ( "Rx" ) ) rxThreadsBefore . add ( t ) ; System . out . println ( "testStartIdempotence >> " + t ) ; System . out . println ( "testStartIdempotence >> trying to start again" ) ; Schedulers . start ( ) ; System . out . println ( "testStartIdempotence >> giving some time again" ) ; Thread . sleep ( 500 ) ; Set < Thread > rxThreadsAfter = new HashSet < > ( ) ; for ( Thread t : Thread . getAllStackTraces ( ) . keySet ( ) ) if ( t . getName ( ) . startsWith ( "Rx" ) ) rxThreadsAfter . add ( t ) ; System . out . println ( "testStartIdempotence >>>> " + t ) ; rxThreadsAfter . removeAll ( rxThreadsBefore ) ; Assert . assertTrue ( "Some new threads appeared: " + rxThreadsAfter , rxThreadsAfter . isEmpty ( ) ) ; 
final Function < Long , Void > calledOp = mock ( Function . class ) ; final TestScheduler scheduler = new TestScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try inner . schedulePeriodically ( new Runnable ( ) @ Override public void run ( ) System . out . println ( scheduler . now ( TimeUnit . MILLISECONDS ) ) ; try calledOp . apply ( scheduler . now ( TimeUnit . MILLISECONDS ) ) ; catch ( Throwable ex ) ExceptionHelper . wrapOrThrow ( ex ) ; , 1 , 2 , TimeUnit . SECONDS ) ; verify ( calledOp , never ( ) ) . apply ( anyLong ( ) ) ; InOrder inOrder = Mockito . inOrder ( calledOp ) ; scheduler . advanceTimeBy ( 999L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( calledOp , never ( ) ) . apply ( anyLong ( ) ) ; scheduler . advanceTimeBy ( 1L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( calledOp , times ( 1 ) ) . apply ( 1000L ) ; scheduler . advanceTimeBy ( 1999L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( calledOp , never ( ) ) . apply ( 3000L ) ; scheduler . advanceTimeBy ( 1L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( calledOp , times ( 1 ) ) . apply ( 3000L ) ; scheduler . advanceTimeBy ( 5L , TimeUnit . SECONDS ) ; inOrder . verify ( calledOp , times ( 1 ) ) . apply ( 5000L ) ; inOrder . verify ( calledOp , times ( 1 ) ) . apply ( 7000L ) ; inner . dispose ( ) ; scheduler . advanceTimeBy ( 11L , TimeUnit . SECONDS ) ; inOrder . verify ( calledOp , never ( ) ) . apply ( anyLong ( ) ) ; finally inner . dispose ( ) ; 
final Function < Long , Void > calledOp = mock ( Function . class ) ; final TestScheduler scheduler = new TestScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try final Disposable subscription = inner . schedulePeriodically ( new Runnable ( ) @ Override public void run ( ) System . out . println ( scheduler . now ( TimeUnit . MILLISECONDS ) ) ; try calledOp . apply ( scheduler . now ( TimeUnit . MILLISECONDS ) ) ; catch ( Throwable ex ) ExceptionHelper . wrapOrThrow ( ex ) ; , 1 , 2 , TimeUnit . SECONDS ) ; verify ( calledOp , never ( ) ) . apply ( anyLong ( ) ) ; InOrder inOrder = Mockito . inOrder ( calledOp ) ; scheduler . advanceTimeBy ( 999L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( calledOp , never ( ) ) . apply ( anyLong ( ) ) ; scheduler . advanceTimeBy ( 1L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( calledOp , times ( 1 ) ) . apply ( 1000L ) ; scheduler . advanceTimeBy ( 1999L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( calledOp , never ( ) ) . apply ( 3000L ) ; scheduler . advanceTimeBy ( 1L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( calledOp , times ( 1 ) ) . apply ( 3000L ) ; scheduler . advanceTimeBy ( 5L , TimeUnit . SECONDS ) ; inOrder . verify ( calledOp , times ( 1 ) ) . apply ( 5000L ) ; inOrder . verify ( calledOp , times ( 1 ) ) . apply ( 7000L ) ; subscription . dispose ( ) ; scheduler . advanceTimeBy ( 11L , TimeUnit . SECONDS ) ; inOrder . verify ( calledOp , never ( ) ) . apply ( anyLong ( ) ) ; finally inner . dispose ( ) ; 
TestScheduler s = new TestScheduler ( ) ; final Scheduler . Worker inner = s . createWorker ( ) ; final AtomicInteger counter = new AtomicInteger ( 0 ) ; try inner . schedule ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; System . out . println ( "counter: " + counter . get ( ) ) ; inner . schedule ( this ) ; ) ; inner . dispose ( ) ; assertEquals ( 0 , counter . get ( ) ) ; finally inner . dispose ( ) ; 
TestScheduler s = new TestScheduler ( ) ; final Scheduler . Worker inner = s . createWorker ( ) ; try final AtomicInteger counter = new AtomicInteger ( 0 ) ; final Disposable subscription = inner . schedule ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; System . out . println ( "counter: " + counter . get ( ) ) ; inner . schedule ( this ) ; ) ; subscription . dispose ( ) ; assertEquals ( 0 , counter . get ( ) ) ; finally inner . dispose ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; final Scheduler . Worker inner = scheduler . createWorker ( ) ; try final Runnable calledOp = mock ( Runnable . class ) ; Flowable < Object > poller ; poller = Flowable . unsafeCreate ( new Publisher < Object > ( ) @ Override public void subscribe ( final Subscriber < ? super Object > aSubscriber ) final BooleanSubscription bs = new BooleanSubscription ( ) ; aSubscriber . onSubscribe ( bs ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) if ( ! bs . isCancelled ( ) ) calledOp . run ( ) ; inner . schedule ( this , 5 , TimeUnit . SECONDS ) ; ) ; ) ; InOrder inOrder = Mockito . inOrder ( calledOp ) ; Disposable sub ; sub = poller . subscribe ( ) ; scheduler . advanceTimeTo ( 6 , TimeUnit . SECONDS ) ; inOrder . verify ( calledOp , times ( 2 ) ) . run ( ) ; sub . dispose ( ) ; scheduler . advanceTimeTo ( 11 , TimeUnit . SECONDS ) ; inOrder . verify ( calledOp , never ( ) ) . run ( ) ; sub = poller . subscribe ( ) ; scheduler . advanceTimeTo ( 12 , TimeUnit . SECONDS ) ; inOrder . verify ( calledOp , times ( 1 ) ) . run ( ) ; finally inner . dispose ( ) ; 
TimedRunnable r = new TimedRunnable ( ( TestWorker ) new TestScheduler ( ) . createWorker ( ) , 5 , new Runnable ( ) @ Override public void run ( ) @ Override public String toString ( ) return "Runnable" ; , 1 ) ; assertEquals ( "TimedRunnable(time = 5, run = Runnable)" , r . toString ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Worker w = scheduler . createWorker ( ) ; w . dispose ( ) ; assertTrue ( w . isDisposed ( ) ) ; 
TestScheduler ts = new TestScheduler ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 5 , ts . now ( TimeUnit . SECONDS ) ) ; assertEquals ( 5000 , ts . now ( TimeUnit . MILLISECONDS ) ) ; 
AtomicInteger run = new AtomicInteger ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; RxJavaPlugins . setScheduleHandler ( r -> counter . getAndIncrement ( ) ; return r ; ) ; try Runnable r = ( ) -> run . getAndIncrement ( ) ; TestScheduler ts = new TestScheduler ( true ) ; ts . createWorker ( ) . schedule ( r ) ; ts . createWorker ( ) . schedule ( r , 1 , TimeUnit . SECONDS ) ; ts . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 2 , run . get ( ) ) ; assertEquals ( 2 , counter . get ( ) ) ; ts = new TestScheduler ( ) ; ts . createWorker ( ) . schedule ( r ) ; ts . createWorker ( ) . schedule ( r , 1 , TimeUnit . SECONDS ) ; ts . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 4 , run . get ( ) ) ; assertEquals ( 2 , counter . get ( ) ) ; finally RxJavaPlugins . setScheduleHandler ( null ) ; 
AtomicInteger run = new AtomicInteger ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; RxJavaPlugins . setScheduleHandler ( r -> counter . getAndIncrement ( ) ; return r ; ) ; try Runnable r = ( ) -> run . getAndIncrement ( ) ; TestScheduler ts = new TestScheduler ( 1 , TimeUnit . HOURS , true ) ; ts . createWorker ( ) . schedule ( r ) ; ts . createWorker ( ) . schedule ( r , 1 , TimeUnit . SECONDS ) ; ts . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 2 , run . get ( ) ) ; assertEquals ( 2 , counter . get ( ) ) ; ts = new TestScheduler ( 1 , TimeUnit . HOURS ) ; ts . createWorker ( ) . schedule ( r ) ; ts . createWorker ( ) . schedule ( r , 1 , TimeUnit . SECONDS ) ; ts . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 4 , run . get ( ) ) ; assertEquals ( 2 , counter . get ( ) ) ; finally RxJavaPlugins . setScheduleHandler ( null ) ; 
AtomicInteger run = new AtomicInteger ( ) ; Runnable r = ( ) -> run . getAndIncrement ( ) ; TestScheduler ts = new TestScheduler ( 1 , TimeUnit . HOURS , true ) ; Disposable d = ts . createWorker ( ) . schedule ( r ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; ts . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 0 , run . get ( ) ) ; 
final int [ ] count = 0 ; TestScheduler scheduler = new TestScheduler ( ) ; Disposable d = scheduler . schedulePeriodicallyDirect ( new Runnable ( ) @ Override public void run ( ) count [ 0 ] ++ ; , 100 , 100 , TimeUnit . MILLISECONDS ) ; assertEquals ( 0 , count [ 0 ] ) ; assertFalse ( d . isDisposed ( ) ) ; scheduler . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , count [ 0 ] ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; scheduler . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , count [ 0 ] ) ; 
TestHelper . withErrorTracking ( errors -> TestScheduler scheduler = new TestScheduler ( ) ; try scheduler . schedulePeriodicallyDirect ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , 100 , 100 , TimeUnit . MILLISECONDS ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
final int [ ] count = 0 ; TestScheduler scheduler = new TestScheduler ( ) ; Disposable d = scheduler . schedulePeriodicallyDirect ( new Runnable ( ) @ Override public void run ( ) count [ 0 ] ++ ; , 100 , 100 , TimeUnit . MILLISECONDS ) ; d . dispose ( ) ; assertEquals ( 0 , count [ 0 ] ) ; assertTrue ( d . isDisposed ( ) ) ; scheduler . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; assertEquals ( 0 , count [ 0 ] ) ; assertTrue ( d . isDisposed ( ) ) ; 
final int [ ] count = 0 ; TestScheduler scheduler = new TestScheduler ( ) ; scheduler . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) count [ 0 ] ++ ; , 100 , TimeUnit . MILLISECONDS ) ; assertEquals ( 0 , count [ 0 ] ) ; scheduler . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , count [ 0 ] ) ; 
final int [ ] count = 0 ; TestScheduler scheduler = new TestScheduler ( ) ; final SequentialDisposable sd = new SequentialDisposable ( ) ; Disposable d = scheduler . schedulePeriodicallyDirect ( new Runnable ( ) @ Override public void run ( ) count [ 0 ] ++ ; sd . dispose ( ) ; , 100 , 100 , TimeUnit . MILLISECONDS ) ; sd . set ( d ) ; assertEquals ( 0 , count [ 0 ] ) ; assertFalse ( d . isDisposed ( ) ) ; scheduler . advanceTimeBy ( 400 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , count [ 0 ] ) ; assertTrue ( d . isDisposed ( ) ) ; 
final int [ ] count = 0 ; TestScheduler scheduler = new TestScheduler ( ) ; Worker worker = scheduler . createWorker ( ) ; try final SequentialDisposable sd = new SequentialDisposable ( ) ; Disposable d = worker . schedulePeriodically ( new Runnable ( ) @ Override public void run ( ) count [ 0 ] ++ ; sd . dispose ( ) ; , 100 , 100 , TimeUnit . MILLISECONDS ) ; sd . set ( d ) ; assertEquals ( 0 , count [ 0 ] ) ; assertFalse ( d . isDisposed ( ) ) ; scheduler . advanceTimeBy ( 400 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , count [ 0 ] ) ; assertTrue ( d . isDisposed ( ) ) ; finally worker . dispose ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Disposable d = scheduler . schedulePeriodicallyDirect ( Functions . EMPTY_RUNNABLE , 1 , 1 , TimeUnit . MILLISECONDS ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) d . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; 
final Scheduler scheduler = Schedulers . io ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) final Disposable d = scheduler . schedulePeriodicallyDirect ( Functions . EMPTY_RUNNABLE , 0 , 0 , TimeUnit . MILLISECONDS ) ; Thread . sleep ( 1 ) ; d . dispose ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try Schedulers . io ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ; Thread . sleep ( 250 ) ; assertTrue ( list . size ( ) >= 1 ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class , null ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkUtilityClass ( Schedulers . class ) ; 
Scheduler s = new Scheduler ( ) @ NonNull @ Override public Worker createWorker ( ) return new Worker ( ) @ NonNull @ Override public Disposable schedule ( @ NonNull Runnable run , long delay , @ NonNull TimeUnit unit ) return EmptyDisposable . INSTANCE ; @ Override public void dispose ( ) @ Override public boolean isDisposed ( ) return false ; ; ; assertSame ( EmptyDisposable . INSTANCE , s . schedulePeriodicallyDirect ( Functions . EMPTY_RUNNABLE , 1 , 1 , TimeUnit . MILLISECONDS ) ) ; 
return new Worker ( ) @ NonNull @ Override public Disposable schedule ( @ NonNull Runnable run , long delay , @ NonNull TimeUnit unit ) return EmptyDisposable . INSTANCE ; @ Override public void dispose ( ) @ Override public boolean isDisposed ( ) return false ; ; 
assertNotNull ( new Schedulers . ComputationHolder ( ) ) ; assertNotNull ( new Schedulers . IoHolder ( ) ) ; assertNotNull ( new Schedulers . NewThreadHolder ( ) ) ; assertNotNull ( new Schedulers . SingleHolder ( ) ) ; 
CustomScheduler scheduler = new CustomScheduler ( ) ; Disposable d = scheduler . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MINUTES ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Runnable runnable = new Runnable ( ) @ Override public void run ( ) ; SchedulerRunnableIntrospection wrapper = ( SchedulerRunnableIntrospection ) scheduler . schedulePeriodicallyDirect ( runnable , 100 , 100 , TimeUnit . MILLISECONDS ) ; assertSame ( runnable , wrapper . getWrappedRunnable ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Runnable runnable = new Runnable ( ) @ Override public void run ( ) ; SchedulerRunnableIntrospection wrapper = ( SchedulerRunnableIntrospection ) scheduler . scheduleDirect ( runnable , 100 , TimeUnit . MILLISECONDS ) ; assertSame ( runnable , wrapper . getWrappedRunnable ( ) ) ; 
final Runnable runnable = new Runnable ( ) @ Override public void run ( ) ; Scheduler scheduler = new Scheduler ( ) @ Override public Worker createWorker ( ) return new Worker ( ) @ Override public Disposable schedule ( Runnable run , long delay , TimeUnit unit ) SchedulerRunnableIntrospection outerWrapper = ( SchedulerRunnableIntrospection ) run ; SchedulerRunnableIntrospection innerWrapper = ( SchedulerRunnableIntrospection ) outerWrapper . getWrappedRunnable ( ) ; assertSame ( runnable , innerWrapper . getWrappedRunnable ( ) ) ; return ( Disposable ) innerWrapper ; @ Override public void dispose ( ) @ Override public boolean isDisposed ( ) return false ; ; ; scheduler . schedulePeriodicallyDirect ( runnable , 100 , 100 , TimeUnit . MILLISECONDS ) ; 
return Schedulers . computation ( ) ; 
final int NUM = 1000000 ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final HashMap < String , Integer > map = new HashMap < > ( ) ; final Scheduler . Worker inner = Schedulers . computation ( ) . createWorker ( ) ; try inner . schedule ( new Runnable ( ) private HashMap < String , Integer > statefulMap = map ; int nonThreadSafeCounter ; @ Override public void run ( ) Integer i = statefulMap . get ( "a" ) ; if ( i == null ) i = 1 ; statefulMap . put ( "a" , i ) ; statefulMap . put ( "b" , i ) ; else i ++ ; statefulMap . put ( "a" , i ) ; statefulMap . put ( "b" , i ) ; nonThreadSafeCounter ++ ; statefulMap . put ( "nonThreadSafeCounter" , nonThreadSafeCounter ) ; if ( i < NUM ) inner . schedule ( this ) ; else latch . countDown ( ) ; ) ; try latch . await ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; System . out . println ( "Count A: " + map . get ( "a" ) ) ; System . out . println ( "Count B: " + map . get ( "b" ) ) ; System . out . println ( "nonThreadSafeCounter: " + map . get ( "nonThreadSafeCounter" ) ) ; assertEquals ( NUM , map . get ( "a" ) . intValue ( ) ) ; assertEquals ( NUM , map . get ( "b" ) . intValue ( ) ) ; assertEquals ( NUM , map . get ( "nonThreadSafeCounter" ) . intValue ( ) ) ; finally inner . dispose ( ) ; 
Flowable < Integer > f1 = Flowable . < Integer > just ( 1 , 2 , 3 , 4 , 5 ) ; Flowable < Integer > f2 = Flowable . < Integer > just ( 6 , 7 , 8 , 9 , 10 ) ; Flowable < String > f = Flowable . < Integer > merge ( f1 , f2 ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) assertTrue ( Thread . currentThread ( ) . getName ( ) . startsWith ( "RxComputationThreadPool" ) ) ; return "Value_" + t + "_Thread_" + Thread . currentThread ( ) . getName ( ) ; ) ; f . subscribeOn ( Schedulers . computation ( ) ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String t ) System . out . println ( "t: " + t ) ; ) ; 
final String currentThreadName = Thread . currentThread ( ) . getName ( ) ; Flowable < Integer > f1 = Flowable . < Integer > just ( 1 , 2 , 3 , 4 , 5 ) ; Flowable < Integer > f2 = Flowable . < Integer > just ( 6 , 7 , 8 , 9 , 10 ) ; Flowable < String > f = Flowable . < Integer > merge ( f1 , f2 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) assertNotEquals ( Thread . currentThread ( ) . getName ( ) , currentThreadName ) ; assertTrue ( Thread . currentThread ( ) . getName ( ) . startsWith ( "RxComputationThreadPool" ) ) ; return "Value_" + t + "_Thread_" + Thread . currentThread ( ) . getName ( ) ; ) ; f . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String t ) System . out . println ( "t: " + t ) ; ) ; 
SchedulerTestHelper . handledErrorIsNotDeliveredToThreadHandler ( getScheduler ( ) ) ; 
Worker w = Schedulers . computation ( ) . createWorker ( ) ; try ExecutorSchedulerTest . cancelledRetention ( w , false ) ; finally w . dispose ( ) ; w = Schedulers . computation ( ) . createWorker ( ) ; try ExecutorSchedulerTest . cancelledRetention ( w , true ) ; finally w . dispose ( ) ; 
final int [ ] calls = 0 ; Runnable r = new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; ; Scheduler s = new ComputationScheduler ( ) ; s . shutdown ( ) ; s . shutdown ( ) ; assertEquals ( Disposable . disposed ( ) , s . scheduleDirect ( r ) ) ; assertEquals ( Disposable . disposed ( ) , s . scheduleDirect ( r , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( Disposable . disposed ( ) , s . schedulePeriodicallyDirect ( r , 1 , 1 , TimeUnit . SECONDS ) ) ; Worker w = s . createWorker ( ) ; w . dispose ( ) ; assertTrue ( w . isDisposed ( ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedule ( r ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedule ( r , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedulePeriodically ( r , 1 , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
CountDownLatch latch = new CountDownLatch ( 1 ) ; Scheduler computationScheduler = new ComputationScheduler ( new ThreadFactory ( ) @ Override public Thread newThread ( Runnable r ) Thread t = new Thread ( r ) ; t . setUncaughtExceptionHandler ( ( thread , throwable ) -> latch . countDown ( ) ; ) ; return t ; ) ; RxJavaPlugins . setErrorHandler ( h -> latch . countDown ( ) ; ) ; try Observable . create ( s -> s . onNext ( 1 ) ; throw new OutOfMemoryError ( ) ; ) . subscribeOn ( computationScheduler ) . subscribe ( v -> , e -> latch . countDown ( ) ; ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; finally RxJavaPlugins . reset ( ) ; computationScheduler . shutdown ( ) ; 
CountDownLatch latch = new CountDownLatch ( 1 ) ; Scheduler computationScheduler = new ComputationScheduler ( new ThreadFactory ( ) @ Override public Thread newThread ( Runnable r ) Thread t = new Thread ( r ) ; t . setUncaughtExceptionHandler ( ( thread , throwable ) -> latch . countDown ( ) ; ) ; return t ; ) ; RxJavaPlugins . setErrorHandler ( h -> latch . countDown ( ) ; ) ; try Flowable . interval ( 500 , TimeUnit . MILLISECONDS , computationScheduler ) . subscribe ( v -> throw new OutOfMemoryError ( ) ; , e -> latch . countDown ( ) ; ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; finally RxJavaPlugins . reset ( ) ; computationScheduler . shutdown ( ) ; 
AtomicInteger repeatCount = new AtomicInteger ( ) ; Schedulers . computation ( ) . schedulePeriodicallyDirect ( new Runnable ( ) @ Override public void run ( ) repeatCount . incrementAndGet ( ) ; throw new OutOfMemoryError ( ) ; , 0 , 1 , TimeUnit . MILLISECONDS ) ; Thread . sleep ( 200 ) ; assertEquals ( 1 , repeatCount . get ( ) ) ; 
AtomicInteger repeatCount = new AtomicInteger ( ) ; Schedulers . computation ( ) . schedulePeriodicallyDirect ( new Runnable ( ) @ Override public void run ( ) repeatCount . incrementAndGet ( ) ; throw new OutOfMemoryError ( ) ; , 0 , 1 , TimeUnit . NANOSECONDS ) ; Thread . sleep ( 200 ) ; assertEquals ( 1 , repeatCount . get ( ) ) ; 
final Worker w = Schedulers . computation ( ) . createWorker ( ) ; return new Worker ( ) @ Override public void dispose ( ) w . dispose ( ) ; @ Override public boolean isDisposed ( ) return w . isDisposed ( ) ; @ NonNull @ Override public Disposable schedule ( @ NonNull Runnable action ) return w . schedule ( action ) ; @ NonNull @ Override public Disposable schedule ( @ NonNull Runnable action , long delayTime , @ NonNull TimeUnit unit ) return w . schedule ( action , delayTime , unit ) ; @ Override public long now ( TimeUnit unit ) return super . now ( unit ) + unit . convert ( drift , TimeUnit . NANOSECONDS ) ; ; 
return super . now ( unit ) + unit . convert ( drift , TimeUnit . NANOSECONDS ) ; 
CustomDriftScheduler s = new CustomDriftScheduler ( ) ; Scheduler . Worker w = s . createWorker ( ) ; try final List < Long > times = new ArrayList < > ( ) ; Disposable d = w . schedulePeriodically ( new Runnable ( ) @ Override public void run ( ) times . add ( System . currentTimeMillis ( ) ) ; , 100 , 100 , TimeUnit . MILLISECONDS ) ; Thread . sleep ( 150 ) ; s . drift = - TimeUnit . SECONDS . toNanos ( 1 ) - Scheduler . clockDriftTolerance ( ) ; Thread . sleep ( 400 ) ; d . dispose ( ) ; Thread . sleep ( 150 ) ; System . out . println ( "Runs: " + times . size ( ) ) ; for ( int i = 0 ; i < times . size ( ) - 1 ; i ++ ) long diff = times . get ( i + 1 ) - times . get ( i ) ; System . out . println ( "Diff #" + i + ": " + diff ) ; assertTrue ( "" + i + ":" + diff , diff < 150 && diff > 50 ) ; assertTrue ( "Too few invocations: " + times . size ( ) , times . size ( ) > 2 ) ; finally w . dispose ( ) ; 
CustomDriftScheduler s = new CustomDriftScheduler ( ) ; Scheduler . Worker w = s . createWorker ( ) ; try final List < Long > times = new ArrayList < > ( ) ; Disposable d = w . schedulePeriodically ( new Runnable ( ) @ Override public void run ( ) times . add ( System . currentTimeMillis ( ) ) ; , 100 , 100 , TimeUnit . MILLISECONDS ) ; Thread . sleep ( 150 ) ; s . drift = TimeUnit . SECONDS . toNanos ( 1 ) + Scheduler . clockDriftTolerance ( ) ; Thread . sleep ( 400 ) ; d . dispose ( ) ; Thread . sleep ( 150 ) ; System . out . println ( "Runs: " + times . size ( ) ) ; assertTrue ( times . size ( ) > 2 ) ; for ( int i = 0 ; i < times . size ( ) - 1 ; i ++ ) long diff = times . get ( i + 1 ) - times . get ( i ) ; System . out . println ( "Diff #" + i + ": " + diff ) ; assertTrue ( "Diff out of range: " + diff , diff < 250 && diff > 50 ) ; finally w . dispose ( ) ; 
return Schedulers . trampoline ( ) ; 
final String currentThreadName = Thread . currentThread ( ) . getName ( ) ; Flowable < Integer > f1 = Flowable . < Integer > just ( 1 , 2 , 3 , 4 , 5 ) ; Flowable < Integer > f2 = Flowable . < Integer > just ( 6 , 7 , 8 , 9 , 10 ) ; Flowable < String > f = Flowable . < Integer > merge ( f1 , f2 ) . subscribeOn ( Schedulers . trampoline ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) assertEquals ( Thread . currentThread ( ) . getName ( ) , currentThreadName ) ; return "Value_" + t + "_Thread_" + Thread . currentThread ( ) . getName ( ) ; ) ; f . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String t ) System . out . println ( "t: " + t ) ; ) ; 
final ArrayList < String > workDone = new ArrayList < > ( ) ; final CompositeDisposable workers = new CompositeDisposable ( ) ; Worker worker = Schedulers . trampoline ( ) . createWorker ( ) ; try workers . add ( worker ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) workers . add ( doWorkOnNewTrampoline ( "A" , workDone ) ) ; ) ; final Worker worker2 = Schedulers . trampoline ( ) . createWorker ( ) ; workers . add ( worker2 ) ; worker2 . schedule ( new Runnable ( ) @ Override public void run ( ) workers . add ( doWorkOnNewTrampoline ( "B" , workDone ) ) ; worker2 . dispose ( ) ; ) ; assertEquals ( 6 , workDone . size ( ) ) ; assertEquals ( Arrays . asList ( "A.1" , "A.B.1" , "A.B.2" , "B.1" , "B.B.1" , "B.B.2" ) , workDone ) ; finally workers . dispose ( ) ; 
final Worker trampolineWorker = Schedulers . trampoline ( ) . createWorker ( ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; final TestSubscriber < Disposable > ts = new TestSubscriber < > ( subscriber ) ; Flowable . range ( 0 , 50 ) . flatMap ( new Function < Integer , Publisher < Disposable > > ( ) @ Override public Publisher < Disposable > apply ( Integer count ) return Flowable . interval ( 1 , TimeUnit . MICROSECONDS ) . map ( new Function < Long , Disposable > ( ) @ Override public Disposable apply ( Long ount1 ) return trampolineWorker . schedule ( Functions . EMPTY_RUNNABLE ) ; ) . take ( 100 ) ; ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
Worker worker = Schedulers . trampoline ( ) . createWorker ( ) ; worker . schedule ( new Runnable ( ) @ Override public void run ( ) String msg = key + ".1" ; workDone . add ( msg ) ; System . out . println ( msg ) ; Worker worker3 = Schedulers . trampoline ( ) . createWorker ( ) ; worker3 . schedule ( createPrintAction ( key + ".B.1" , workDone ) ) ; worker3 . schedule ( createPrintAction ( key + ".B.2" , workDone ) ) ; ) ; return worker ; 
return new Runnable ( ) @ Override public void run ( ) System . out . println ( message ) ; workDone . add ( message ) ; ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingFirst ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingLast ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingIterable ( ) . iterator ( ) . next ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingSubscribe ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingSingle ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingForEach ( Functions . emptyConsumer ( ) ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingLatest ( ) . iterator ( ) . hasNext ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingNext ( ) . iterator ( ) . hasNext ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . toFuture ( ) . get ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingFirst ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingLast ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingIterable ( ) . iterator ( ) . next ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingSubscribe ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingSingle ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingForEach ( Functions . emptyConsumer ( ) ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingLatest ( ) . iterator ( ) . hasNext ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingNext ( ) . iterator ( ) . hasNext ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . toFuture ( ) . get ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Observable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingFirst ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Single . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Single . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingGet ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Maybe . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Maybe . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingGet ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Completable . complete ( ) . subscribeOn ( Schedulers . single ( ) ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception Completable . complete ( ) . delay ( 10 , TimeUnit . SECONDS ) . blockingAwait ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Completable . complete ( ) . subscribeOn ( Schedulers . single ( ) ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception Completable . complete ( ) . delay ( 10 , TimeUnit . SECONDS ) . blockingAwait ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return Observable . just ( 2 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . blockingFirst ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 ) ; finally RxJavaPlugins . reset ( ) ; 
try RxJavaPlugins . setOnBeforeBlocking ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return true ; ) ; RxJavaPlugins . setFailOnNonBlockingScheduler ( true ) ; Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception Flowable . just ( 1 ) . delay ( 10 , TimeUnit . SECONDS ) . blockingLast ( ) ; return v ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return Flowable . just ( 2 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . blockingLast ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 ) ; 
final AtomicInteger countReceived = new AtomicInteger ( ) ; final AtomicInteger countGenerated = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Flowable . interval ( 50 , TimeUnit . MILLISECONDS ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long aLong ) countGenerated . incrementAndGet ( ) ; return aLong ; ) . subscribeOn ( getScheduler ( ) ) . observeOn ( getScheduler ( ) ) . subscribe ( new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "--- completed" ) ; @ Override public void onError ( Throwable e ) System . out . println ( "--- onError" ) ; @ Override public void onNext ( Long args ) if ( countReceived . incrementAndGet ( ) == 2 ) cancel ( ) ; latch . countDown ( ) ; System . out . println ( "==> Received " + args ) ; ) ; latch . await ( 1000 , TimeUnit . MILLISECONDS ) ; System . out . println ( "----------- it thinks it is finished ------------------ " ) ; int timeout = 10 ; while ( timeout -- > 0 && countGenerated . get ( ) != 2 ) Thread . sleep ( 100 ) ; assertEquals ( 2 , countGenerated . get ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final CountDownLatch unsubscribeLatch = new CountDownLatch ( 1 ) ; final AtomicInteger counter = new AtomicInteger ( ) ; final Worker inner = getScheduler ( ) . createWorker ( ) ; try inner . schedule ( new Runnable ( ) @ Override public void run ( ) inner . schedule ( new Runnable ( ) int i ; @ Override public void run ( ) System . out . println ( "Run: " + i ++ ) ; if ( i == 10 ) latch . countDown ( ) ; try unsubscribeLatch . await ( ) ; catch ( InterruptedException e ) counter . incrementAndGet ( ) ; inner . schedule ( this ) ; ) ; ) ; latch . await ( ) ; inner . dispose ( ) ; unsubscribeLatch . countDown ( ) ; Thread . sleep ( 200 ) ; assertEquals ( 10 , counter . get ( ) ) ; finally inner . dispose ( ) ; 
final CountDownLatch unsubscribeLatch = new CountDownLatch ( 1 ) ; final AtomicInteger counter = new AtomicInteger ( ) ; final Worker inner = getScheduler ( ) . createWorker ( ) ; try inner . schedule ( new Runnable ( ) @ Override public void run ( ) inner . schedule ( new Runnable ( ) int i ; @ Override public void run ( ) System . out . println ( "Run: " + i ++ ) ; if ( i == 10 ) inner . dispose ( ) ; counter . incrementAndGet ( ) ; inner . schedule ( this ) ; ) ; ) ; unsubscribeLatch . countDown ( ) ; Thread . sleep ( 200 ) ; assertEquals ( 10 , counter . get ( ) ) ; finally inner . dispose ( ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final CountDownLatch unsubscribeLatch = new CountDownLatch ( 1 ) ; final AtomicInteger counter = new AtomicInteger ( ) ; final Worker inner = getScheduler ( ) . createWorker ( ) ; try inner . schedule ( new Runnable ( ) @ Override public void run ( ) inner . schedule ( new Runnable ( ) long i = 1L ; @ Override public void run ( ) if ( i ++ == 10 ) latch . countDown ( ) ; try unsubscribeLatch . await ( ) ; catch ( InterruptedException e ) counter . incrementAndGet ( ) ; inner . schedule ( this , 10 , TimeUnit . MILLISECONDS ) ; , 10 , TimeUnit . MILLISECONDS ) ; ) ; latch . await ( ) ; inner . dispose ( ) ; unsubscribeLatch . countDown ( ) ; Thread . sleep ( 200 ) ; assertEquals ( 10 , counter . get ( ) ) ; finally inner . dispose ( ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Worker inner = getScheduler ( ) . createWorker ( ) ; try inner . schedule ( new Runnable ( ) int i ; @ Override public void run ( ) i ++ ; if ( i % 100000 == 0 ) System . out . println ( i + "  Total Memory: " + Runtime . getRuntime ( ) . totalMemory ( ) + "  Free: " + Runtime . getRuntime ( ) . freeMemory ( ) ) ; if ( i < 1000000L ) inner . schedule ( this ) ; else latch . countDown ( ) ; ) ; latch . await ( ) ; finally inner . dispose ( ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Worker inner = getScheduler ( ) . createWorker ( ) ; try inner . schedule ( new Runnable ( ) private long i ; @ Override public void run ( ) i ++ ; if ( i % 100000 == 0 ) System . out . println ( i + "  Total Memory: " + Runtime . getRuntime ( ) . totalMemory ( ) + "  Free: " + Runtime . getRuntime ( ) . freeMemory ( ) ) ; if ( i < 1000000L ) inner . schedule ( this ) ; else latch . countDown ( ) ; ) ; latch . await ( ) ; finally inner . dispose ( ) ; 
final CountDownLatch latch = new CountDownLatch ( 10 ) ; final CountDownLatch completionLatch = new CountDownLatch ( 1 ) ; final Worker inner = getScheduler ( ) . createWorker ( ) ; try Flowable < Integer > obs = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) inner . schedule ( new Runnable ( ) @ Override public void run ( ) subscriber . onNext ( 42 ) ; latch . countDown ( ) ; inner . schedule ( this ) ; ) ; subscriber . onSubscribe ( new Subscription ( ) @ Override public void cancel ( ) inner . dispose ( ) ; subscriber . onComplete ( ) ; completionLatch . countDown ( ) ; @ Override public void request ( long n ) ) ; ) ; final AtomicInteger count = new AtomicInteger ( ) ; final AtomicBoolean completed = new AtomicBoolean ( false ) ; ResourceSubscriber < Integer > s = new ResourceSubscriber < Integer > ( ) @ Override public void onComplete ( ) System . out . println ( "Completed" ) ; completed . set ( true ) ; @ Override public void onError ( Throwable e ) System . out . println ( "Error" ) ; @ Override public void onNext ( Integer args ) count . incrementAndGet ( ) ; System . out . println ( args ) ; ; obs . subscribe ( s ) ; if ( ! latch . await ( 5000 , TimeUnit . MILLISECONDS ) ) fail ( "Timed out waiting on onNext latch" ) ; s . dispose ( ) ; System . out . println ( "unsubscribe" ) ; if ( ! completionLatch . await ( 5000 , TimeUnit . MILLISECONDS ) ) fail ( "Timed out waiting on completion latch" ) ; assertTrue ( count . get ( ) >= 10 ) ; assertTrue ( completed . get ( ) ) ; finally inner . dispose ( ) ; 
final Scheduler scheduler = getScheduler ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > f1 = Flowable . < Integer > just ( 1 , 2 , 3 , 4 , 5 ) ; f1 . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) System . out . println ( "Thread: " + Thread . currentThread ( ) . getName ( ) ) ; System . out . println ( "t: " + t ) ; count . incrementAndGet ( ) ; ) ; assertEquals ( 5 , count . get ( ) ) ; count . set ( 0 ) ; final String currentThreadName = Thread . currentThread ( ) . getName ( ) ; final CountDownLatch latch = new CountDownLatch ( 5 ) ; final CountDownLatch first = new CountDownLatch ( 1 ) ; f1 . subscribeOn ( scheduler ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) try first . await ( 1000 , TimeUnit . SECONDS ) ; catch ( InterruptedException e ) throw new RuntimeException ( "The latch should have released if we are async." , e ) ; assertNotEquals ( Thread . currentThread ( ) . getName ( ) , currentThreadName ) ; System . out . println ( "Thread: " + Thread . currentThread ( ) . getName ( ) ) ; System . out . println ( "t: " + t ) ; count . incrementAndGet ( ) ; latch . countDown ( ) ; ) ; assertEquals ( 0 , count . get ( ) ) ; first . countDown ( ) ; latch . await ( ) ; assertEquals ( 5 , count . get ( ) ) ; 
Notification < Integer > notification = Notification . createOnError ( new TestException ( ) ) ; assertNull ( notification . getValue ( ) ) ; assertTrue ( notification . getError ( ) . toString ( ) , notification . getError ( ) instanceof TestException ) ; 
Notification < Integer > notification = Notification . createOnComplete ( ) ; assertNull ( notification . getValue ( ) ) ; assertNull ( notification . getError ( ) ) ; assertTrue ( notification . isOnComplete ( ) ) ; 
Notification < Integer > n1 = Notification . createOnNext ( 0 ) ; assertNotEquals ( 0 , n1 ) ; assertNotEquals ( n1 , 0 ) ; Notification < Integer > n2 = Notification . createOnError ( new TestException ( ) ) ; assertNotEquals ( 0 , n2 ) ; assertNotEquals ( n2 , 0 ) ; Notification < Integer > n3 = Notification . createOnComplete ( ) ; assertNotEquals ( 0 , n3 ) ; assertNotEquals ( n3 , 0 ) ; 
Notification < Integer > n1 = Notification . createOnNext ( 0 ) ; Notification < Integer > n2 = Notification . createOnNext ( 0 ) ; assertEquals ( n1 , n2 ) ; assertEquals ( n2 , n1 ) ; 
Notification < Integer > n1 = Notification . createOnNext ( 1337 ) ; assertEquals ( Integer . valueOf ( 1337 ) . hashCode ( ) , n1 . hashCode ( ) ) ; assertEquals ( 0 , Notification . createOnComplete ( ) . hashCode ( ) ) ; 
assertEquals ( "OnNextNotification[1]" , Notification . createOnNext ( 1 ) . toString ( ) ) ; assertEquals ( "OnErrorNotification[io.reactivex.rxjava3.exceptions.TestException]" , Notification . createOnError ( new TestException ( ) ) . toString ( ) ) ; assertEquals ( "OnCompleteNotification" , Notification . createOnComplete ( ) . toString ( ) ) ; 
Throwable caughtThrowable = null ; for ( int i = 0 ; i < retryCount ; i ++ ) try base . evaluate ( ) ; return ; catch ( Throwable t ) caughtThrowable = t ; System . err . println ( description . getDisplayName ( ) + ": run " + ( i + 1 ) + " failed" ) ; int n = sleep ; if ( backoff && i != 0 ) n = n * ( 2 << i ) ; Thread . sleep ( n ) ; System . err . println ( description . getDisplayName ( ) + ": giving up after " + retryCount + " failures" ) ; throw caughtThrowable ; 
return statement ( base , description ) ; 
return new RetryStatement ( base , description ) ; 
TestHelper . withErrorTracking ( errors -> Scheduler . Worker worker = Schedulers . single ( ) . createWorker ( ) ; DisposeTask task = new DisposeTask ( ( ) -> throw new TestException ( ) ; , worker ) ; try task . run ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; assertTrue ( worker . isDisposed ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Scheduler . Worker worker = Schedulers . single ( ) . createWorker ( ) ; PeriodicDirectTask task = new PeriodicDirectTask ( ( ) -> throw new TestException ( ) ; , worker ) ; try task . run ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; assertTrue ( worker . isDisposed ( ) ) ; task . run ( ) ; finally RxJavaPlugins . reset ( ) ; 
cb . await ( ) ; try long before = System . currentTimeMillis ( ) ; Thread . sleep ( 5000 ) ; throw new IllegalStateException ( "Was not interrupted in time?! " + ( System . currentTimeMillis ( ) - before ) ) ; catch ( InterruptedException ex ) 
long before = System . currentTimeMillis ( ) ; Thread . sleep ( 50 ) ; if ( System . currentTimeMillis ( ) - before > 100 ) ts . cancel ( ) ; throw new IllegalStateException ( "Overslept?" + ( System . currentTimeMillis ( ) - before ) ) ; 
long before = System . currentTimeMillis ( ) ; Thread . sleep ( 50 ) ; if ( System . currentTimeMillis ( ) - before > 100 ) to . dispose ( ) ; throw new IllegalStateException ( "Overslept?" + ( System . currentTimeMillis ( ) - before ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriber < Integer > ts = Flowable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Flowable . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( ts ) ; ts . cancel ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; ts . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriber < Integer > ts = Flowable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( ts ) ; ts . cancel ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; ts . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriber < Integer > ts = Flowable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( ts ) ; ts . cancel ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; ts . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Void > to = Flowable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception sleep ( ) ; return Completable . error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriber < Void > ts = Flowable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception sleep ( ) ; return Completable . error ( new TestException ( ) ) ; ) . < Void > toFlowable ( ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( ts ) ; ts . cancel ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; ts . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Observable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Observable . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Observable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Observable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Void > to = Observable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception sleep ( ) ; return Completable . error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Void > to = Observable . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception sleep ( ) ; return Completable . error ( new TestException ( ) ) ; ) . < Void > toObservable ( ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Single . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Single . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Void > to = Single . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception sleep ( ) ; return Completable . error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Single . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception sleep ( ) ; return Completable . error ( new TestException ( ) ) ; ) . toSingleDefault ( 0 ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriber < Integer > ts = Single . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Flowable . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( ts ) ; ts . cancel ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; ts . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Single . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; , ( a , b ) -> a + b ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Single . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapObservable ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Observable . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Single . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; , new Function < Throwable , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Throwable v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Single . < Integer > error ( new TestException ( ) ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; , new Function < Throwable , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Throwable v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; ) . toSingle ( ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Single . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriber < Integer > ts = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Flowable . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( ts ) ; ts . cancel ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; ts . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapObservable ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Observable . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; , new Function < Throwable , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Throwable v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; , new Supplier < Maybe < Integer > > ( ) @ Override public Maybe < Integer > get ( ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . < Integer > error ( new TestException ( ) ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; , new Function < Throwable , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Throwable v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; , new Supplier < Maybe < Integer > > ( ) @ Override public Maybe < Integer > get ( ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . < Integer > empty ( ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; , new Function < Throwable , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Throwable v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; , new Supplier < Maybe < Integer > > ( ) @ Override public Maybe < Integer > get ( ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMap ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception sleep ( ) ; return Maybe . < Integer > error ( new TestException ( ) ) ; , ( a , b ) -> a + b ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Void > to = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception sleep ( ) ; return Completable . error ( new TestException ( ) ) ; ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Void > to = Maybe . just ( 1 ) . subscribeOn ( Schedulers . io ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception sleep ( ) ; return Completable . error ( new TestException ( ) ) ; ) . < Void > toMaybe ( ) . test ( ) ; cb . await ( ) ; beforeCancelSleep ( to ) ; to . dispose ( ) ; Thread . sleep ( SLEEP_AFTER_CANCEL ) ; to . assertEmpty ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
try Flowable . just ( 1 ) . to ( new FlowableConverter < Integer , Integer > ( ) @ Override public Integer apply ( Flowable < Integer > v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
throw new TestException ( "Forced failure" ) ; 
try Observable . just ( 1 ) . to ( new ObservableConverter < Integer , Integer > ( ) @ Override public Integer apply ( Observable < Integer > v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
throw new TestException ( "Forced failure" ) ; 
try Single . just ( 1 ) . to ( new SingleConverter < Integer , Integer > ( ) @ Override public Integer apply ( Single < Integer > v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
throw new TestException ( "Forced failure" ) ; 
try Maybe . just ( 1 ) . to ( new MaybeConverter < Integer , Integer > ( ) @ Override public Integer apply ( Maybe < Integer > v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
throw new TestException ( "Forced failure" ) ; 
try Completable . complete ( ) . to ( new CompletableConverter < Completable > ( ) @ Override public Completable apply ( Completable v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
throw new TestException ( "Forced failure" ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Observable . just ( a ) . to ( ( ObservableConverter ) ConverterTest . testObservableConverterCreator ( ) ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Single . just ( a ) . to ( ( SingleConverter ) ConverterTest . < String > testSingleConverterCreator ( ) ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Maybe . just ( a ) . to ( ( MaybeConverter ) ConverterTest . < String > testMaybeConverterCreator ( ) ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Flowable . just ( a ) . to ( ( FlowableConverter ) ConverterTest . < String > testFlowableConverterCreator ( ) ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Flowable . just ( a ) . parallel ( ) . to ( ( ParallelFlowableConverter ) ConverterTest . < String > testParallelFlowableConverterCreator ( ) ) ; 
CompositeConverter converter = new CompositeConverter ( ) ; Flowable . just ( 1 ) . to ( converter ) . test ( ) . assertValue ( 1 ) ; Observable . just ( 1 ) . to ( converter ) . test ( ) . assertValue ( 1 ) ; Maybe . just ( 1 ) . to ( converter ) . test ( ) . assertValue ( 1 ) ; Single . just ( 1 ) . to ( converter ) . test ( ) . assertValue ( 1 ) ; Completable . complete ( ) . to ( converter ) . test ( ) . assertComplete ( ) ; Flowable . just ( 1 ) . parallel ( ) . to ( converter ) . test ( ) . assertValue ( 1 ) ; 
return new ObservableConverter < A < T , ? > , B < T > > ( ) @ Override public B < T > apply ( Observable < A < T , ? > > a ) return new B < T > ( ) ; ; 
return new B < T > ( ) ; 
return new SingleConverter < A < T , ? > , B < T > > ( ) @ Override public B < T > apply ( Single < A < T , ? > > a ) return new B < T > ( ) ; ; 
return new B < T > ( ) ; 
return new MaybeConverter < A < T , ? > , B < T > > ( ) @ Override public B < T > apply ( Maybe < A < T , ? > > a ) return new B < T > ( ) ; ; 
return new B < T > ( ) ; 
return new FlowableConverter < A < T , ? > , B < T > > ( ) @ Override public B < T > apply ( Flowable < A < T , ? > > a ) return new B < T > ( ) ; ; 
return new B < T > ( ) ; 
return new ParallelFlowableConverter < A < T , ? > , B < T > > ( ) @ Override public B < T > apply ( ParallelFlowable < A < T , ? > > a ) return new B < T > ( ) ; ; 
return new B < T > ( ) ; 
return upstream . sequential ( ) ; 
return upstream . toFlowable ( ) ; 
$EMPTY$
try Flowable . just ( 1 ) . compose ( new FlowableTransformer < Integer , Integer > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
try Observable . just ( 1 ) . compose ( new ObservableTransformer < Integer , Integer > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
try Single . just ( 1 ) . compose ( new SingleTransformer < Integer , Integer > ( ) @ Override public Single < Integer > apply ( Single < Integer > v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
try Maybe . just ( 1 ) . compose ( new MaybeTransformer < Integer , Integer > ( ) @ Override public Maybe < Integer > apply ( Maybe < Integer > v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
try Completable . complete ( ) . compose ( new CompletableTransformer ( ) @ Override public Completable apply ( Completable v ) throw new TestException ( "Forced failure" ) ; ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Forced failure" , ex . getMessage ( ) ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Observable . just ( a ) . compose ( TransformerTest . < String > testObservableTransformerCreator ( ) ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Single . just ( a ) . compose ( TransformerTest . < String > testSingleTransformerCreator ( ) ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Maybe . just ( a ) . compose ( TransformerTest . < String > testMaybeTransformerCreator ( ) ) ; 
A < String , Integer > a = new A < String , Integer > ( ) ; Flowable . just ( a ) . compose ( TransformerTest . < String > testFlowableTransformerCreator ( ) ) ; 
return new ObservableTransformer < A < T , ? > , B < T > > ( ) @ Override public ObservableSource < B < T > > apply ( Observable < A < T , ? > > a ) return Observable . empty ( ) ; ; 
return new SingleTransformer < A < T , ? > , B < T > > ( ) @ Override public SingleSource < B < T > > apply ( Single < A < T , ? > > a ) return Single . never ( ) ; ; 
return new MaybeTransformer < A < T , ? > , B < T > > ( ) @ Override public MaybeSource < B < T > > apply ( Maybe < A < T , ? > > a ) return Maybe . empty ( ) ; ; 
return new FlowableTransformer < A < T , ? > , B < T > > ( ) @ Override public Publisher < B < T > > apply ( Flowable < A < T , ? > > a ) return Flowable . empty ( ) ; ; 
assertEquals ( 3 , BackpressureOverflowStrategy . values ( ) . length ) ; assertNotNull ( BackpressureOverflowStrategy . valueOf ( "ERROR" ) ) ; 
assertEquals ( 5 , BackpressureStrategy . values ( ) . length ) ; assertNotNull ( BackpressureStrategy . valueOf ( "BUFFER" ) ) ; 
assertEquals ( 6 , BackpressureKind . values ( ) . length ) ; assertNotNull ( BackpressureKind . valueOf ( "FULL" ) ) ; 
Scheduler . IS_DRIFT_USE_NANOTIME = false ; 
assertFalse ( Scheduler . IS_DRIFT_USE_NANOTIME ) ; assertFalse ( Boolean . getBoolean ( DRIFT_USE_NANOTIME ) ) ; 
TimeUnit unit = TimeUnit . MILLISECONDS ; assertTrue ( isInRange ( System . currentTimeMillis ( ) , Scheduler . computeNow ( unit ) , unit , 250 , TimeUnit . MILLISECONDS ) ) ; 
TimeUnit unit = TimeUnit . NANOSECONDS ; Scheduler . IS_DRIFT_USE_NANOTIME = true ; assertFalse ( isInRange ( System . currentTimeMillis ( ) , Scheduler . computeNow ( unit ) , unit , 250 , TimeUnit . MILLISECONDS ) ) ; assertTrue ( isInRange ( System . nanoTime ( ) , Scheduler . computeNow ( unit ) , TimeUnit . NANOSECONDS , 250 , TimeUnit . MILLISECONDS ) ) ; 
assertEquals ( 100_000_000L , Scheduler . computeClockDrift ( 100 , "milliseconds" ) ) ; assertEquals ( 2_000_000_000L , Scheduler . computeClockDrift ( 2 , "seconds" ) ) ; assertEquals ( 180_000_000_000L , Scheduler . computeClockDrift ( 3 , "minutes" ) ) ; assertEquals ( 240_000_000_000L , Scheduler . computeClockDrift ( 4 , "random" ) ) ; assertEquals ( 300_000_000_000L , Scheduler . computeClockDrift ( 5 , null ) ) ; 
TestObservable t = new TestObservable ( ) ; Flowable < String > st = Flowable . unsafeCreate ( t ) ; Subscriber < String > w = TestHelper . mockSubscriber ( ) ; st . subscribe ( new SafeSubscriber < > ( new TestSubscriber < > ( w ) ) ) ; t . sendOnNext ( "one" ) ; t . sendOnError ( new RuntimeException ( "bad" ) ) ; t . sendOnNext ( "two" ) ; verify ( w , times ( 1 ) ) . onNext ( "one" ) ; verify ( w , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , Mockito . never ( ) ) . onNext ( "two" ) ; 
TestObservable t = new TestObservable ( ) ; Flowable < String > st = Flowable . unsafeCreate ( t ) ; Subscriber < String > w = TestHelper . mockSubscriber ( ) ; st . subscribe ( new SafeSubscriber < > ( new TestSubscriber < > ( w ) ) ) ; t . sendOnNext ( "one" ) ; t . sendOnError ( new RuntimeException ( "bad" ) ) ; t . sendOnCompleted ( ) ; verify ( w , times ( 1 ) ) . onNext ( "one" ) ; verify ( w , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , Mockito . never ( ) ) . onComplete ( ) ; 
TestObservable t = new TestObservable ( ) ; Flowable < String > st = Flowable . unsafeCreate ( t ) ; Subscriber < String > w = TestHelper . mockSubscriber ( ) ; st . subscribe ( new SafeSubscriber < > ( new TestSubscriber < > ( w ) ) ) ; t . sendOnNext ( "one" ) ; t . sendOnCompleted ( ) ; t . sendOnNext ( "two" ) ; verify ( w , times ( 1 ) ) . onNext ( "one" ) ; verify ( w , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestObservable t = new TestObservable ( ) ; Flowable < String > st = Flowable . unsafeCreate ( t ) ; Subscriber < String > w = TestHelper . mockSubscriber ( ) ; st . subscribe ( new SafeSubscriber < > ( new TestSubscriber < > ( w ) ) ) ; t . sendOnNext ( "one" ) ; t . sendOnCompleted ( ) ; t . sendOnError ( new RuntimeException ( "bad" ) ) ; verify ( w , times ( 1 ) ) . onNext ( "one" ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
subscriber . onComplete ( ) ; 
subscriber . onNext ( value ) ; 
subscriber . onError ( e ) ; 
this . subscriber = subscriber ; subscriber . onSubscribe ( new Subscription ( ) @ Override public void cancel ( ) System . out . println ( "==> SynchronizeTest unsubscribe that does nothing!" ) ; @ Override public void request ( long n ) ) ; 
System . out . println ( "==> SynchronizeTest unsubscribe that does nothing!" ) ; 
AtomicReference < Throwable > onError = new AtomicReference < > ( ) ; try OBSERVER_ONNEXT_FAIL ( onError ) . onNext ( "one" ) ; fail ( "expects exception to be thrown" ) ; catch ( Exception e ) assertNull ( onError . get ( ) ) ; assertTrue ( e instanceof SafeSubscriberTestException ) ; assertEquals ( "onNextFail" , e . getMessage ( ) ) ; 
AtomicReference < Throwable > onError = new AtomicReference < > ( ) ; try SafeSubscriber < String > safeObserver = new SafeSubscriber < > ( OBSERVER_ONNEXT_FAIL ( onError ) ) ; safeObserver . onSubscribe ( new BooleanSubscription ( ) ) ; safeObserver . onNext ( "one" ) ; assertNotNull ( onError . get ( ) ) ; assertTrue ( onError . get ( ) instanceof SafeSubscriberTestException ) ; assertEquals ( "onNextFail" , onError . get ( ) . getMessage ( ) ) ; catch ( Exception e ) fail ( "expects exception to be passed to onError" ) ; 
AtomicReference < Throwable > onError = new AtomicReference < > ( ) ; try OBSERVER_ONCOMPLETED_FAIL ( onError ) . onComplete ( ) ; fail ( "expects exception to be thrown" ) ; catch ( Exception e ) assertNull ( onError . get ( ) ) ; assertTrue ( e instanceof SafeSubscriberTestException ) ; assertEquals ( "onCompleteFail" , e . getMessage ( ) ) ; 
try subscriberOnErrorFail ( ) . onError ( new SafeSubscriberTestException ( "error!" ) ) ; fail ( "expects exception to be thrown" ) ; catch ( Exception e ) assertTrue ( e instanceof SafeSubscriberTestException ) ; assertEquals ( "onErrorFail" , e . getMessage ( ) ) ; 
try OBSERVER_ONNEXT_ONERROR_FAIL ( ) . onNext ( "one" ) ; fail ( "expects exception to be thrown" ) ; catch ( Exception e ) e . printStackTrace ( ) ; assertTrue ( e instanceof SafeSubscriberTestException ) ; assertEquals ( "onNextFail" , e . getMessage ( ) ) ; 
return new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) onError . set ( e ) ; @ Override public void onNext ( String args ) throw new SafeSubscriberTestException ( "onNextFail" ) ; ; 
$EMPTY$
onError . set ( e ) ; 
return new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new SafeSubscriberTestException ( "onErrorFail" ) ; @ Override public void onNext ( String args ) throw new SafeSubscriberTestException ( "onNextFail" ) ; ; 
return new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new SafeSubscriberTestException ( "onErrorFail" ) ; @ Override public void onNext ( String args ) ; 
return new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) throw new SafeSubscriberTestException ( "onCompleteFail" ) ; @ Override public void onError ( Throwable e ) onError . set ( e ) ; @ Override public void onNext ( String args ) ; 
Subscriber < Integer > actual = new DefaultSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ; SafeSubscriber < Integer > s = new SafeSubscriber < > ( actual ) ; assertSame ( actual , s . downstream ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; SafeSubscriber < Integer > so = new SafeSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; ts . dispose ( ) ; assertTrue ( bs . isCancelled ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; SafeSubscriber < Integer > so = new SafeSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; so . onComplete ( ) ; so . onNext ( 1 ) ; so . onError ( new TestException ( ) ) ; so . onComplete ( ) ; ts . assertResult ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; SafeSubscriber < Integer > so = new SafeSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; so . onNext ( null ) ; ts . assertFailure ( NullPointerException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; SafeSubscriber < Integer > so = new SafeSubscriber < > ( ts ) ; so . onNext ( 1 ) ; ts . assertFailureAndMessage ( NullPointerException . class , "Subscription not set!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; SafeSubscriber < Integer > so = new SafeSubscriber < > ( ts ) ; so . onError ( new TestException ( ) ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , TestException . class ) ; TestHelper . assertError ( ts , 1 , NullPointerException . class , "Subscription not set!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; SafeSubscriber < Integer > so = new SafeSubscriber < > ( ts ) ; so . onComplete ( ) ; ts . assertFailureAndMessage ( NullPointerException . class , "Subscription not set!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; SafeSubscriber < Integer > so = new SafeSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; so . onNext ( 1 ) ; so . onComplete ( ) ; ts . assertResult ( 1 ) ; 
if ( crashOnSubscribe ) throw new TestException ( "onSubscribe()" ) ; 
if ( -- crashOnNext == 0 ) throw new TestException ( "onNext(" + value + ")" ) ; 
return new SafeSubscriber < > ( this ) ; 
if ( ! clazz . isInstance ( error ) ) throw new AssertionError ( "Different error: " + error ) ; return this ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , true , false , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onNext ( 1 ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "onNext(1)" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "onError(io.reactivex.rxjava3.exceptions.TestException: onNext(1))" ) ; finally RxJavaPlugins . reset ( ) ; 
CrashDummy cd = new CrashDummy ( false , 1 , false , false , true , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onNext ( 1 ) ; cd . assertError ( CompositeException . class ) ; cd . assertInnerError ( 0 , TestException . class , "onNext(1)" ) ; cd . assertInnerError ( 1 , TestException . class , "cancel()" ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , false , false , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onSubscribe ( cd ) ; TestHelper . assertError ( list , 0 , IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , false , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class , "onSubscribe()" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , false , true , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "onSubscribe()" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "cancel()" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , false , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onNext ( 1 ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "onSubscribe()" ) ; finally RxJavaPlugins . reset ( ) ; 
CrashDummy cd = new CrashDummy ( false , 1 , false , false , true , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onNext ( null ) ; cd . assertInnerError ( 0 , NullPointerException . class ) ; cd . assertInnerError ( 1 , TestException . class , "cancel()" ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , true , false , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onNext ( 1 ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "onError(java.lang.NullPointerException: Subscription not set!)" ) ; finally RxJavaPlugins . reset ( ) ; 
CrashDummy cd = new CrashDummy ( false , 1 , false , false , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onError ( null ) ; cd . assertError ( NullPointerException . class ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , false , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onError ( new TestException ( ) ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class ) ; TestHelper . assertError ( ce , 1 , NullPointerException . class , "Subscription not set!" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , true , false , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onError ( new TestException ( ) ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class ) ; TestHelper . assertError ( ce , 1 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 2 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , false , true , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onComplete ( ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class , "onComplete()" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , true , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onComplete ( ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "onSubscribe()" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , true , true , false , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onComplete ( ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , false , false , false , true ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . request ( 1 ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , false , false , true , false ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . cancel ( ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , false , false , true , true ) ; SafeSubscriber < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . request ( 1 ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "request()" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "cancel()" ) ; finally RxJavaPlugins . reset ( ) ; 
super . onStart ( ) ; start ++ ; 
errors . add ( e ) ; dispose ( ) ; 
complete ++ ; dispose ( ) ; 
TestResourceSubscriber < Integer > ro = new TestResourceSubscriber < > ( ) ; ro . add ( null ) ; 
TestResourceSubscriber < Integer > ro = new TestResourceSubscriber < > ( ) ; assertFalse ( ro . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; ro . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; ro . dispose ( ) ; assertTrue ( ro . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; ro . dispose ( ) ; assertTrue ( ro . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceSubscriber < Integer > ro = new TestResourceSubscriber < > ( ) ; assertFalse ( ro . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; ro . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; ro . onComplete ( ) ; assertTrue ( ro . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceSubscriber < Integer > ro = new TestResourceSubscriber < > ( ) ; assertFalse ( ro . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; ro . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; ro . onError ( new TestException ( ) ) ; assertTrue ( ro . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceSubscriber < Integer > tc = new TestResourceSubscriber < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; assertTrue ( tc . values . isEmpty ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; Flowable . just ( 1 ) . subscribe ( tc ) ; assertTrue ( tc . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( 1 , tc . values . get ( 0 ) . intValue ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestResourceSubscriber < Integer > tc = new TestResourceSubscriber < > ( ) ; tc . onSubscribe ( new BooleanSubscription ( ) ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; tc . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; assertEquals ( 1 , tc . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( tc . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestResourceSubscriber < Integer > tc = new TestResourceSubscriber < > ( ) ; tc . dispose ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; tc . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; assertEquals ( 0 , tc . start ) ; 
TestResourceSubscriber < Integer > tc = new TestResourceSubscriber < Integer > ( ) @ Override protected void onStart ( ) start ++ ; ; Flowable . just ( 1 ) . subscribe ( tc ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( Collections . emptyList ( ) , tc . values ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; assertEquals ( 0 , tc . complete ) ; tc . requestMore ( 1 ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( 1 , tc . values . get ( 0 ) . intValue ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; assertEquals ( 1 , tc . complete ) ; 
start ++ ; 
events . add ( t ) ; 
events . add ( t ) ; 
events . add ( "Done" ) ; 
RequestEarly sub = new RequestEarly ( ) ; Flowable . range ( 1 , 10 ) . subscribe ( sub ) ; assertEquals ( Arrays . < Object > asList ( 1 , 2 , 3 , 4 , 5 ) , sub . events ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; oi . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertValueCount ( 2 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
assertThrows ( AssertionError . class , ( ) -> Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; oi . subscribe ( ts ) ; ts . assertValues ( 1 ) ; ts . assertValueCount ( 2 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; ) ; 
assertThrows ( AssertionError . class , ( ) -> Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; oi . subscribe ( ts ) ; ts . assertValues ( 1 , 3 ) ; ts . assertValueCount ( 2 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; ) ; 
assertThrows ( AssertionError . class , ( ) -> PublishProcessor < Integer > p = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; p . subscribe ( ts ) ; p . onNext ( 1 ) ; p . onNext ( 2 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertValueCount ( 2 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; Subscriber < Integer > mockSubscriber = TestHelper . mockSubscriber ( ) ; oi . subscribe ( new TestSubscriber < > ( mockSubscriber ) ) ; InOrder inOrder = inOrder ( mockSubscriber ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ) . take ( 2 ) ; Subscriber < Integer > mockSubscriber = TestHelper . mockSubscriber ( ) ; oi . subscribe ( new TestSubscriber < > ( mockSubscriber ) ) ; InOrder inOrder = inOrder ( mockSubscriber ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
RuntimeException e = new RuntimeException ( "Oops" ) ; TestSubscriber < Object > subscriber = new TestSubscriber < > ( ) ; Flowable . error ( e ) . subscribe ( subscriber ) ; subscriber . assertError ( e ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . subscribe ( ts ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; final AtomicBoolean unsub = new AtomicBoolean ( false ) ; Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) unsub . set ( true ) ; ) . delay ( 1000 , TimeUnit . MILLISECONDS ) . subscribe ( ts ) ; ts . awaitDone ( 100 , TimeUnit . MILLISECONDS ) ; ts . dispose ( ) ; assertTrue ( unsub . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( null ) ; ts . onComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( null ) ; ts . onComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( null , 0L ) ; ts . onComplete ( ) ; 
TestSubscriber < Integer > ts0 = new TestSubscriber < > ( ) ; ts0 . onSubscribe ( EmptySubscription . INSTANCE ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ts0 ) ; ts . onComplete ( ) ; ts0 . assertComplete ( ) ; ts0 . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ts1 ) ; ts2 . onComplete ( ) ; ts1 . assertComplete ( ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ts1 , 0L ) ; ts2 . onComplete ( ) ; ts1 . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; assertFalse ( ts . isCancelled ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNoErrors ( ) ; catch ( AssertionError ex ) return ; fail ( "Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; try ts . assertComplete ( ) ; catch ( AssertionError ex ) return ; fail ( "Not completed and no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onComplete ( ) ; ts . onComplete ( ) ; try ts . assertComplete ( ) ; catch ( AssertionError ex ) return ; fail ( "Multiple completions and no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onComplete ( ) ; try ts . assertNotComplete ( ) ; catch ( AssertionError ex ) return ; fail ( "Completed and no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onComplete ( ) ; ts . onComplete ( ) ; try ts . assertNotComplete ( ) ; catch ( AssertionError ex ) return ; fail ( "Multiple completions and no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNoErrors ( ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; if ( ce . size ( ) != 2 ) ce . printStackTrace ( ) ; assertEquals ( 2 , ce . size ( ) ) ; return ; fail ( "Multiple Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( TestException . class ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; assertEquals ( 2 , ce . size ( ) ) ; return ; fail ( "Multiple Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( new TestException ( ) ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; assertEquals ( 2 , ce . size ( ) ) ; return ; fail ( "Multiple Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; assertEquals ( 2 , ce . size ( ) ) ; return ; fail ( "Multiple Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( new TestException ( ) ) ; catch ( AssertionError ex ) return ; fail ( "Different Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onError ( new RuntimeException ( ) ) ; try ts . assertError ( new TestException ( ) ) ; catch ( AssertionError ex ) return ; fail ( "Different Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onError ( new RuntimeException ( ) ) ; try ts . assertError ( TestException . class ) ; catch ( AssertionError ex ) return ; fail ( "Different Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onError ( new RuntimeException ( ) ) ; try ts . assertError ( Functions . < Throwable > alwaysFalse ( ) ) ; catch ( AssertionError ex ) return ; fail ( "Different Error present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onError ( new RuntimeException ( ) ) ; try ts . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable throwable ) throws Exception throw new TestException ( ) ; ) ; catch ( TestException ex ) return ; fail ( "Error in predicate but not thrown!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; try ts . assertError ( TestException . class ) ; catch ( AssertionError ex ) return ; fail ( "No present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; try ts . assertError ( new TestException ( ) ) ; catch ( AssertionError ex ) return ; fail ( "No present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; try ts . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; catch ( AssertionError ex ) return ; fail ( "No present but no assertion error!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final Thread t0 = Thread . currentThread ( ) ; Worker w = Schedulers . computation ( ) . createWorker ( ) ; try w . schedule ( new Runnable ( ) @ Override public void run ( ) t0 . interrupt ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; try if ( ts . await ( 5 , TimeUnit . SECONDS ) ) fail ( "Did not interrupt wait!" ) ; catch ( InterruptedException expected ) finally w . dispose ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final Thread t0 = Thread . currentThread ( ) ; Worker w = Schedulers . computation ( ) . createWorker ( ) ; try w . schedule ( new Runnable ( ) @ Override public void run ( ) t0 . interrupt ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; try if ( ts . await ( 5 , TimeUnit . SECONDS ) ) fail ( "Did not interrupt wait!" ) ; catch ( InterruptedException expected ) finally Thread . interrupted ( ) ; w . dispose ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final Thread t0 = Thread . currentThread ( ) ; Worker w = Schedulers . computation ( ) . createWorker ( ) ; try w . schedule ( new Runnable ( ) @ Override public void run ( ) t0 . interrupt ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; try ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException allowed ) assertTrue ( allowed . toString ( ) , allowed . getCause ( ) instanceof InterruptedException ) ; ts . dispose ( ) ; if ( ! ts . isCancelled ( ) ) fail ( "Did not unsubscribe!" ) ; finally w . dispose ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onComplete ( ) ; try ts . assertNotComplete ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNoErrors ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onComplete ( ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNotComplete ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) try ts . assertNoErrors ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNoErrors ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; assertEquals ( 2 , ce . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onNext ( 1 ) ; try ts . assertNoValues ( ) ; throw new RuntimeException ( "Failed to report there were values!" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onNext ( 1 ) ; ts . onNext ( 2 ) ; try ts . assertValueCount ( 3 ) ; throw new RuntimeException ( "Failed to report there were values!" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts0 = new TestSubscriber < Integer > ( ) @ Override public void onComplete ( ) throw new TestException ( ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ts0 ) ; try ts . onComplete ( ) ; catch ( TestException ex ) ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; 
TestSubscriber < Integer > ts0 = new TestSubscriber < Integer > ( ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ts0 ) ; try ts . onError ( new RuntimeException ( ) ) ; catch ( TestException ex ) ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; 
TestSubscriber < Integer > ts1 = TestSubscriber . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ts1 ) ; assertFalse ( ts . hasSubscription ( ) ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; assertTrue ( ts . hasSubscription ( ) ) ; assertFalse ( ts . isDisposed ( ) ) ; ts . onNext ( 1 ) ; ts . onError ( new TestException ( ) ) ; ts . onComplete ( ) ; ts1 . assertValue ( 1 ) . assertError ( TestException . class ) . assertComplete ( ) ; ts . dispose ( ) ; assertTrue ( ts . isDisposed ( ) ) ; try ts . assertNoValues ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertValueCount ( 0 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) ts . assertValueSequence ( Collections . singletonList ( 1 ) ) ; try ts . assertValueSequence ( Collections . singletonList ( 2 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; try ts . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertError ( new TestException ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertSubscribed ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertSubscribed ( ) ; ts . assertNoErrors ( ) ; TestException ex = new TestException ( "Forced failure" ) ; ts . onError ( ex ) ; ts . assertError ( ex ) ; ts . assertError ( TestException . class ) ; ts . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; ts . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable t ) return t . getMessage ( ) != null && t . getMessage ( ) . contains ( "Forced" ) ; ) ; try ts . assertError ( new RuntimeException ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertError ( IOException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertNoErrors ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertError ( Functions . < Throwable > alwaysFalse ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) ts . assertValueCount ( 0 ) ; ts . assertNoValues ( ) ; 
assertEquals ( 1 , TestSubscriber . EmptySubscriber . values ( ) . length ) ; assertNotNull ( TestSubscriber . EmptySubscriber . valueOf ( "INSTANCE" ) ) ; 
assertEquals ( "null" , TestSubscriber . valueAndClass ( null ) ) ; assertEquals ( "1 (class: Integer)" , TestSubscriber . valueAndClass ( 1 ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onError ( new TestException ( "Forced failure" ) ) ; ts . assertFailure ( TestException . class ) ; ts . onNext ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onComplete ( ) ; ts . assertResult ( ) ; try ts . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) ts . onNext ( 1 ) ; ts . assertResult ( 1 ) ; try ts . assertResult ( 2 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertResult ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; assertFalse ( ts . await ( 100 , TimeUnit . MILLISECONDS ) ) ; ts . awaitDone ( 100 , TimeUnit . MILLISECONDS ) ; assertTrue ( ts . isDisposed ( ) ) ; assertFalse ( ts . await ( 100 , TimeUnit . MILLISECONDS ) ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . onComplete ( ) ; assertTrue ( ts . await ( 100 , TimeUnit . MILLISECONDS ) ) ; ts . await ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; assertTrue ( ts . await ( 5 , TimeUnit . SECONDS ) ) ; final TestSubscriber < Integer > ts1 = TestSubscriber . create ( ) ; ts1 . onSubscribe ( new BooleanSubscription ( ) ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) ts1 . onComplete ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; ts1 . await ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertNoValues ( ) ; assertEquals ( Collections . emptyList ( ) , ts . values ( ) ) ; ts . onNext ( 1 ) ; assertEquals ( Collections . singletonList ( 1 ) , ts . values ( ) ) ; ts . cancel ( ) ; assertTrue ( ts . isCancelled ( ) ) ; assertTrue ( ts . isDisposed ( ) ) ; ts . assertValue ( 1 ) ; ts . onComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertNotComplete ( ) ; ts . onComplete ( ) ; try ts . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) ts . assertComplete ( ) ; ts . onComplete ( ) ; try ts . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) try ts . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) try ts . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . assertValue ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) ts . onNext ( 1 ) ; ts . assertValue ( 1 ) ; try ts . assertValue ( 2 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) ts . onNext ( 2 ) ; try ts . assertValue ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onNext ( 1 ) ; ts . assertError ( IllegalStateException . class ) ; ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onNext ( null ) ; ts . assertFailure ( NullPointerException . class , ( Integer ) null ) ; 
final TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; try ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException allowed ) assertTrue ( allowed . toString ( ) , allowed . getCause ( ) instanceof InterruptedException ) ; Thread . currentThread ( ) . interrupt ( ) ; try ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException allowed ) assertTrue ( allowed . toString ( ) , allowed . getCause ( ) instanceof InterruptedException ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertNotComplete ( ) . assertNoErrors ( ) ; ts . onError ( new TestException ( ) ) ; ts . assertError ( TestException . class ) ; ts . onError ( new IOException ( ) ) ; try ts . assertNoErrors ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onError ( new TestException ( ) ) ; ts . onComplete ( ) ; try ts . assertComplete ( ) . assertNoErrors ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertError ( Throwable . class ) . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( null ) ; ts . assertError ( NullPointerException . class ) ; ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; ts . onSubscribe ( bs1 ) ; assertTrue ( bs1 . isCancelled ( ) ) ; ts . assertError ( IllegalStateException . class ) ; ts = TestSubscriber . create ( ) ; ts . dispose ( ) ; bs1 = new BooleanSubscription ( ) ; ts . onSubscribe ( bs1 ) ; assertTrue ( bs1 . isCancelled ( ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onNext ( 1 ) ; ts . onNext ( 2 ) ; try ts . assertValueSequence ( Collections . < Integer > emptyList ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertValueSequence ( Collections . singletonList ( 1 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) ts . assertValueSequence ( Arrays . asList ( 1 , 2 ) ) ; try ts . assertValueSequence ( Arrays . asList ( 1 , 2 , 3 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; try ts . assertEmpty ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertEmpty ( ) ; ts . onNext ( 1 ) ; try ts . assertEmpty ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; TestException e = new TestException ( ) ; ts . onError ( e ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) try ts . assertError ( e ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) ts . onComplete ( ) ; ts . assertComplete ( ) ; ts . onComplete ( ) ; try ts . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onComplete ( ) ; ts . assertError ( IllegalStateException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . onComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( TestException ex ) assertTrue ( ts . await ( 1 , TimeUnit . SECONDS ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . onError ( new IOException ( ) ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( TestException ex ) assertTrue ( ts . await ( 1 , TimeUnit . SECONDS ) ) ; 
assertThrows ( AssertionError . class , ( ) -> TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . empty ( ) . subscribe ( ts ) ; ts . assertValue ( new Predicate < Object > ( ) @ Override public boolean test ( final Object o ) throws Exception return false ; ) ; ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . subscribe ( ts ) ; ts . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; 
assertEquals ( message , assertThrows ( clazz , run ) . getMessage ( ) ) ; 
assertThrowsWithMessage ( "Value 1 (class: Integer) at position 0 did not pass the predicate (latch = 0, values = 1, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . subscribe ( ts ) ; ts . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o != 1 ; ) ; ) ; 
assertThrowsWithMessage ( "The first value passed the predicate but this consumer received more than one value (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
assertThrowsWithMessage ( "No values (latch = 0, values = 0, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . empty ( ) . subscribe ( ts ) ; ts . assertValueAt ( 0 , new Predicate < Object > ( ) @ Override public boolean test ( final Object o ) throws Exception return false ; ) ; ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValueAt ( 1 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 2 ; ) ; 
assertThrowsWithMessage ( "Value 3 (class: Integer) at position 2 did not pass the predicate (latch = 0, values = 3, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 , 3 ) . subscribe ( ts ) ; ts . assertValueAt ( 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o != 3 ; ) ; ) ; 
assertThrowsWithMessage ( "Index 2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValueAt ( 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
assertThrowsWithMessage ( "Index 2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValueAt ( 2 , 3 ) ; ) ; 
assertThrowsWithMessage ( "Index -2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValueAt ( - 2 , 3 ) ; ) ; 
assertThrowsWithMessage ( "Index -2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValueAt ( - 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
Flowable . range ( 1 , 5 ) . test ( 0 ) . requestMore ( 1 ) . assertValue ( 1 ) . requestMore ( 2 ) . assertValues ( 1 , 2 , 3 ) . requestMore ( 3 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
try for ( int i = 1 ; i < 3 ; i ++ ) Flowable . just ( i ) . test ( ) . withTag ( "testing with item=" + i ) . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "testing with item=2" ) ) ; 
Thread . interrupted ( ) ; TestSubscriber < Object > ts = Flowable . never ( ) . test ( ) ; assertFalse ( ts . await ( 1 , TimeUnit . MILLISECONDS ) ) ; try ts . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "timeout!" ) ) ; 
try Flowable . never ( ) . test ( ) . awaitDone ( 1 , TimeUnit . MILLISECONDS ) . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "timeout!" ) ) ; 
TestSubscriber < Object > ts = Flowable . never ( ) . test ( ) ; assertFalse ( ts . await ( 1 , TimeUnit . MILLISECONDS ) ) ; try ts . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "timeout!" ) ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; ts . cancel ( ) ; try ts . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( Throwable ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "disposed!" ) ) ; 
Flowable . range ( 1 , 10 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . test ( 5 ) . awaitCount ( 5 ) . assertValues ( 1 , 2 , 3 , 4 , 5 ) . requestMore ( 5 ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 4 ) . test ( ) . awaitCount ( 5 ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
try Flowable . just ( 1 ) . test ( ) . assertValueAt ( 0 , new Predicate < Integer > ( ) @ Override public boolean test ( Integer t ) throws Exception throw new IllegalArgumentException ( ) ; ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertValuesOnly ( ) ; ts . onNext ( 5 ) ; ts . assertValuesOnly ( 5 ) ; ts . onNext ( - 1 ) ; ts . assertValuesOnly ( 5 , - 1 ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertValuesOnly ( ) ; ts . onNext ( 5 ) ; ts . assertValuesOnly ( 5 ) ; ts . onNext ( - 1 ) ; try ts . assertValuesOnly ( 5 ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onComplete ( ) ; try ts . assertValuesOnly ( ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertValuesOnly ( ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onError ( null ) ; ts . assertFailure ( NullPointerException . class ) ; 
return timeout ; 
TestSubscriberImpl < Integer > ts = new TestSubscriberImpl < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . awaitCount ( 1 ) ; assertTrue ( ts . isTimeout ( ) ) ; 
try TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; ts . awaitCount ( 1 ) ; finally Thread . interrupted ( ) ; 
request ( 1 ) ; start ++ ; 
errors . add ( e ) ; 
completions ++ ; 
TestDisposableSubscriber < Integer > tc = new TestDisposableSubscriber < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; assertTrue ( tc . values . isEmpty ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; Flowable . just ( 1 ) . subscribe ( tc ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( 1 , tc . values . get ( 0 ) . intValue ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestDisposableSubscriber < Integer > tc = new TestDisposableSubscriber < > ( ) ; tc . onSubscribe ( new BooleanSubscription ( ) ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; tc . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; assertEquals ( 1 , tc . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( tc . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestDisposableSubscriber < Integer > tc = new TestDisposableSubscriber < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; tc . dispose ( ) ; assertTrue ( tc . isDisposed ( ) ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; tc . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; assertEquals ( 0 , tc . start ) ; 
$EMPTY$
events . add ( t ) ; 
events . add ( t ) ; 
events . add ( "Done" ) ; 
RequestEarly sub = new RequestEarly ( ) ; Flowable . range ( 1 , 10 ) . subscribe ( sub ) ; assertEquals ( Collections . emptyList ( ) , sub . events ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; 
return new SerializedSubscriber < > ( subscriber ) ; 
TestSingleThreadedPublisher onSubscribe = new TestSingleThreadedPublisher ( "one" , "two" , "three" ) ; Flowable < String > w = Flowable . unsafeCreate ( onSubscribe ) ; Subscriber < String > aw = serializedSubscriber ( subscriber ) ; w . subscribe ( aw ) ; onSubscribe . waitToFinish ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" ) ; Flowable < String > w = Flowable . unsafeCreate ( onSubscribe ) ; BusySubscriber busySubscriber = new BusySubscriber ( ) ; Subscriber < String > aw = serializedSubscriber ( busySubscriber ) ; w . subscribe ( aw ) ; onSubscribe . waitToFinish ( ) ; assertEquals ( 3 , busySubscriber . onNextCount . get ( ) ) ; assertFalse ( busySubscriber . onError ) ; assertTrue ( busySubscriber . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busySubscriber . maxConcurrentThreads . get ( ) ) ; 
TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" , null ) ; Flowable < String > w = Flowable . unsafeCreate ( onSubscribe ) ; BusySubscriber busySubscriber = new BusySubscriber ( ) ; Subscriber < String > aw = serializedSubscriber ( busySubscriber ) ; w . subscribe ( aw ) ; onSubscribe . waitToFinish ( ) ; busySubscriber . terminalEvent . await ( ) ; System . out . println ( "OnSubscribe maxConcurrentThreads: " + onSubscribe . maxConcurrentThreads . get ( ) + "  Subscriber maxConcurrentThreads: " + busySubscriber . maxConcurrentThreads . get ( ) ) ; assertTrue ( busySubscriber . onNextCount . get ( ) < 4 ) ; assertTrue ( busySubscriber . onError ) ; assertFalse ( busySubscriber . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busySubscriber . maxConcurrentThreads . get ( ) ) ; 
int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" , null , "four" , "five" , "six" , "seven" , "eight" , "nine" ) ; Flowable < String > w = Flowable . unsafeCreate ( onSubscribe ) ; BusySubscriber busySubscriber = new BusySubscriber ( ) ; Subscriber < String > aw = serializedSubscriber ( busySubscriber ) ; w . subscribe ( aw ) ; onSubscribe . waitToFinish ( ) ; System . out . println ( "OnSubscribe maxConcurrentThreads: " + onSubscribe . maxConcurrentThreads . get ( ) + "  Subscriber maxConcurrentThreads: " + busySubscriber . maxConcurrentThreads . get ( ) ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busySubscriber . maxConcurrentThreads . get ( ) ) ; System . out . println ( "onNext count: " + busySubscriber . onNextCount . get ( ) ) ; assertFalse ( busySubscriber . onComplete ) ; assertTrue ( busySubscriber . onError ) ; assertTrue ( busySubscriber . onNextCount . get ( ) < 9 ) ; 
ExecutorService tp = Executors . newFixedThreadPool ( 20 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestConcurrencySubscriber tw = new TestConcurrencySubscriber ( ) ; Subscriber < String > w = serializedSubscriber ( new SafeSubscriber < > ( tw ) ) ; Future < ? > f1 = tp . submit ( new OnNextThread ( w , 12000 ) ) ; Future < ? > f2 = tp . submit ( new OnNextThread ( w , 5000 ) ) ; Future < ? > f3 = tp . submit ( new OnNextThread ( w , 75000 ) ) ; Future < ? > f4 = tp . submit ( new OnNextThread ( w , 13500 ) ) ; Future < ? > f5 = tp . submit ( new OnNextThread ( w , 22000 ) ) ; Future < ? > f6 = tp . submit ( new OnNextThread ( w , 15000 ) ) ; Future < ? > f7 = tp . submit ( new OnNextThread ( w , 7500 ) ) ; Future < ? > f8 = tp . submit ( new OnNextThread ( w , 23500 ) ) ; Future < ? > f10 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f1 , f2 , f3 , f4 ) ) ; try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) Future < ? > f11 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f4 , f6 , f7 ) ) ; Future < ? > f12 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f4 , f6 , f7 ) ) ; Future < ? > f13 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f4 , f6 , f7 ) ) ; Future < ? > f14 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f4 , f6 , f7 ) ) ; Future < ? > f15 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onError , f1 , f2 , f3 , f4 ) ) ; Future < ? > f16 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onError , f1 , f2 , f3 , f4 ) ) ; Future < ? > f17 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onError , f1 , f2 , f3 , f4 ) ) ; Future < ? > f18 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onError , f1 , f2 , f3 , f4 ) ) ; waitOnThreads ( f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f10 , f11 , f12 , f13 , f14 , f15 , f16 , f17 , f18 ) ; @ SuppressWarnings ( "unused" ) int numNextEvents = tw . assertEvents ( null ) ; for ( int i = 0 ; i < errors . size ( ) ; i ++ ) TestHelper . assertUndeliverable ( errors , i , RuntimeException . class ) ; catch ( Throwable e ) fail ( "Concurrency test failed: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; finally tp . shutdown ( ) ; try tp . awaitTermination ( 5000 , TimeUnit . MILLISECONDS ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService tp = Executors . newFixedThreadPool ( 20 ) ; try TestConcurrencySubscriber tw = new TestConcurrencySubscriber ( ) ; Subscriber < String > w = serializedSubscriber ( new SafeSubscriber < > ( tw ) ) ; w . onSubscribe ( new BooleanSubscription ( ) ) ; Future < ? > f1 = tp . submit ( new OnNextThread ( w , 12000 ) ) ; Future < ? > f2 = tp . submit ( new OnNextThread ( w , 5000 ) ) ; Future < ? > f3 = tp . submit ( new OnNextThread ( w , 75000 ) ) ; Future < ? > f4 = tp . submit ( new OnNextThread ( w , 13500 ) ) ; Future < ? > f5 = tp . submit ( new OnNextThread ( w , 22000 ) ) ; Future < ? > f6 = tp . submit ( new OnNextThread ( w , 15000 ) ) ; Future < ? > f7 = tp . submit ( new OnNextThread ( w , 7500 ) ) ; Future < ? > f8 = tp . submit ( new OnNextThread ( w , 23500 ) ) ; Future < ? > f10 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 ) ) ; try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) waitOnThreads ( f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f10 ) ; int numNextEvents = tw . assertEvents ( null ) ; assertEquals ( 173500 , numNextEvents ) ; catch ( Throwable e ) fail ( "Concurrency test failed: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; finally tp . shutdown ( ) ; try tp . awaitTermination ( 25000 , TimeUnit . MILLISECONDS ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; 
ExecutorService tp1 = Executors . newFixedThreadPool ( 1 ) ; ExecutorService tp2 = Executors . newFixedThreadPool ( 1 ) ; try int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) final CountDownLatch firstOnNext = new CountDownLatch ( 1 ) ; final CountDownLatch onNextCount = new CountDownLatch ( 2 ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final CountDownLatch running = new CountDownLatch ( 2 ) ; TestSubscriberEx < String > ts = new TestSubscriberEx < > ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String t ) firstOnNext . countDown ( ) ; try latch . await ( ) ; catch ( InterruptedException e ) ) ; Subscriber < String > subscriber = serializedSubscriber ( ts ) ; Future < ? > f1 = tp1 . submit ( new OnNextThread ( subscriber , 1 , onNextCount , running ) ) ; Future < ? > f2 = tp2 . submit ( new OnNextThread ( subscriber , 1 , onNextCount , running ) ) ; running . await ( ) ; firstOnNext . await ( ) ; Thread t1 = ts . lastThread ( ) ; System . out . println ( "first onNext on thread: " + t1 ) ; latch . countDown ( ) ; waitOnThreads ( f1 , f2 ) ; assertEquals ( 2 , ts . values ( ) . size ( ) ) ; Thread t2 = ts . lastThread ( ) ; System . out . println ( "second onNext on thread: " + t2 ) ; assertSame ( t1 , t2 ) ; System . out . println ( ts . values ( ) ) ; subscriber . onComplete ( ) ; System . out . println ( ts . values ( ) ) ; finally tp1 . shutdown ( ) ; tp2 . shutdown ( ) ; 
$EMPTY$
$EMPTY$
firstOnNext . countDown ( ) ; try latch . await ( ) ; catch ( InterruptedException e ) 
TestSubscriber < String > ts = new TestSubscriber < > ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String t ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) ) ; final Subscriber < String > subscriber = serializedSubscriber ( ts ) ; AtomicInteger p1 = new AtomicInteger ( ) ; AtomicInteger p2 = new AtomicInteger ( ) ; subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ResourceSubscriber < String > as1 = new ResourceSubscriber < String > ( ) @ Override public void onNext ( String t ) subscriber . onNext ( t ) ; @ Override public void onError ( Throwable t ) RxJavaPlugins . onError ( t ) ; @ Override public void onComplete ( ) ; ResourceSubscriber < String > as2 = new ResourceSubscriber < String > ( ) @ Override public void onNext ( String t ) subscriber . onNext ( t ) ; @ Override public void onError ( Throwable t ) RxJavaPlugins . onError ( t ) ; @ Override public void onComplete ( ) ; infinite ( p1 ) . subscribe ( as1 ) ; infinite ( p2 ) . subscribe ( as2 ) ; Thread . sleep ( 100 ) ; System . out . println ( "p1: " + p1 . get ( ) + " p2: " + p2 . get ( ) + " => should be close to each other unless we have thread starvation" ) ; assertEquals ( p1 . get ( ) , p2 . get ( ) , 10000 ) ; as1 . dispose ( ) ; as2 . dispose ( ) ; 
$EMPTY$
$EMPTY$
try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) 
return Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > s ) BooleanSubscription bs = new BooleanSubscription ( ) ; s . onSubscribe ( bs ) ; while ( ! bs . isCancelled ( ) ) s . onNext ( "onNext" ) ; produced . incrementAndGet ( ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) ; 
BooleanSubscription bs = new BooleanSubscription ( ) ; s . onSubscribe ( bs ) ; while ( ! bs . isCancelled ( ) ) s . onNext ( "onNext" ) ; produced . incrementAndGet ( ) ; 
if ( running != null ) running . countDown ( ) ; for ( int i = 0 ; i < numStringsToSend ; i ++ ) subscriber . onNext ( Thread . currentThread ( ) . getId ( ) + "-" + i ) ; if ( latch != null ) latch . countDown ( ) ; produced . incrementAndGet ( ) ; 
if ( waitOnThese != null ) for ( Future < ? > f : waitOnThese ) try f . get ( ) ; catch ( Throwable e ) System . err . println ( "Error while waiting on future in CompletionThread" ) ; if ( event == TestConcurrencySubscriberEvent . onError ) subscriber . onError ( new RuntimeException ( "mocked exception" ) ) ; else if ( event == TestConcurrencySubscriberEvent . onComplete ) subscriber . onComplete ( ) ; else throw new IllegalArgumentException ( "Expecting either onError or onComplete" ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; System . out . println ( "TestSingleThreadedObservable subscribed to ..." ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestSingleThreadedObservable thread" ) ; for ( String s : values ) System . out . println ( "TestSingleThreadedObservable onNext: " + s ) ; subscriber . onNext ( s ) ; subscriber . onComplete ( ) ; catch ( Throwable e ) throw new RuntimeException ( e ) ; ) ; System . out . println ( "starting TestSingleThreadedObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestSingleThreadedObservable thread" ) ; 
try t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; 
try t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; 
int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; if ( concurrentThreads > 1 ) new RuntimeException ( "should not be greater than 1" ) . printStackTrace ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Subscriber < Integer > > serial = new AtomicReference < > ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer v ) serial . get ( ) . onError ( new TestException ( ) ) ; serial . get ( ) . onError ( new TestException ( ) ) ; super . onNext ( v ) ; ; SerializedSubscriber < Integer > sobs = new SerializedSubscriber < > ( ts ) ; sobs . onSubscribe ( new BooleanSubscription ( ) ) ; serial . set ( sobs ) ; sobs . onNext ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertError ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final AtomicReference < Subscriber < Integer > > serial = new AtomicReference < > ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer v ) serial . get ( ) . onComplete ( ) ; serial . get ( ) . onComplete ( ) ; super . onNext ( v ) ; ; SerializedSubscriber < Integer > sobs = new SerializedSubscriber < > ( ts ) ; sobs . onSubscribe ( new BooleanSubscription ( ) ) ; serial . set ( sobs ) ; sobs . onNext ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; ts . cancel ( ) ; assertTrue ( bs . isCancelled ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) so . onComplete ( ) ; ; TestHelper . race ( r , r ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( ts . values ( ) . size ( ) <= 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertError ( ex ) . assertNotComplete ( ) ; assertTrue ( ts . values ( ) . size ( ) <= 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts , true ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertError ( ex ) . assertNotComplete ( ) ; assertTrue ( ts . values ( ) . size ( ) <= 1 ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts ) ; so . onSubscribe ( new BooleanSubscription ( ) ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , "Subscription already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( ts . completions ( ) != 0 ) ts . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; else ts . assertFailure ( TestException . class ) . assertError ( ex ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts ) ; so . onSubscribe ( new BooleanSubscription ( ) ) ; so . onNext ( null ) ; ts . assertFailureAndMessage ( NullPointerException . class , ExceptionHelper . nullWarning ( "onNext called with a null value." ) ) ; 
AtomicReference < SerializedSubscriber < Integer > > ssRef = new AtomicReference < > ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ssRef . get ( ) . onNext ( 2 ) ; ssRef . get ( ) . onError ( new TestException ( ) ) ; ; final SerializedSubscriber < Integer > so = new SerializedSubscriber < > ( ts , true ) ; ssRef . set ( so ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; so . onSubscribe ( bs ) ; so . onNext ( 1 ) ; ts . assertFailure ( TestException . class , 1 , 2 ) ; 
SpscArrayQueue < Object > q = new SpscArrayQueue < > ( 16 ) ; q . offer ( null ) ; 
SpscLinkedArrayQueue < Object > q = new SpscLinkedArrayQueue < > ( 16 ) ; q . offer ( null ) ; 
MpscLinkedQueue < Object > q = new MpscLinkedQueue < > ( ) ; q . offer ( null ) ; 
SpscArrayQueue < Object > q = new SpscArrayQueue < > ( 16 ) ; q . offer ( 1 , 2 ) ; assertEquals ( 1 , q . poll ( ) ) ; assertEquals ( 2 , q . poll ( ) ) ; assertNull ( q . poll ( ) ) ; 
SpscLinkedArrayQueue < Object > q = new SpscLinkedArrayQueue < > ( 16 ) ; q . offer ( 1 , 2 ) ; assertEquals ( 1 , q . poll ( ) ) ; assertEquals ( 2 , q . poll ( ) ) ; assertNull ( q . poll ( ) ) ; 
MpscLinkedQueue < Object > q = new MpscLinkedQueue < > ( ) ; q . offer ( 1 , 2 ) ; assertEquals ( 1 , q . poll ( ) ) ; assertEquals ( 2 , q . poll ( ) ) ; assertNull ( q . poll ( ) ) ; 
SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 8 ) ; assertTrue ( q . offer ( 1 , 2 ) ) ; assertTrue ( q . offer ( 3 , 4 ) ) ; assertTrue ( q . offer ( 5 , 6 ) ) ; assertTrue ( q . offer ( 7 ) ) ; assertFalse ( q . offer ( 8 , 9 ) ) ; assertFalse ( q . offer ( 9 , 10 ) ) ; 
SpscLinkedArrayQueue < Integer > q = new SpscLinkedArrayQueue < > ( 8 ) ; assertTrue ( q . offer ( 1 , 2 ) ) ; assertTrue ( q . offer ( 3 , 4 ) ) ; assertTrue ( q . offer ( 5 , 6 ) ) ; assertTrue ( q . offer ( 7 , 8 ) ) ; for ( int i = 0 ; i < 8 ; i ++ ) assertEquals ( i + 1 , q . peek ( ) . intValue ( ) ) ; assertEquals ( i + 1 , q . poll ( ) . intValue ( ) ) ; assertNull ( q . peek ( ) ) ; assertNull ( q . poll ( ) ) ; 
final MpscLinkedQueue < Integer > q = new MpscLinkedQueue < > ( ) ; final AtomicInteger c = new AtomicInteger ( 3 ) ; Thread t1 = new Thread ( new Runnable ( ) int i ; @ Override public void run ( ) c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) while ( i ++ < 10000 ) q . offer ( i ) ; ) ; t1 . start ( ) ; Thread t2 = new Thread ( new Runnable ( ) int i = 10000 ; @ Override public void run ( ) c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) while ( i ++ < 10000 ) q . offer ( i ) ; ) ; t2 . start ( ) ; Runnable r3 = new Runnable ( ) int i = 20000 ; @ Override public void run ( ) c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) while ( -- i > 0 ) q . poll ( ) ; ; r3 . run ( ) ; t1 . join ( ) ; t2 . join ( ) ; 
SpscLinkedArrayQueue < Integer > q = new SpscLinkedArrayQueue < > ( 16 ) ; AtomicReferenceArray < Object > ara = q . producerBuffer ; for ( int i = 0 ; i < 20 ; i ++ ) q . offer ( i ) ; assertNotNull ( ara . get ( 16 ) ) ; for ( int i = 0 ; i < 20 ; i ++ ) assertEquals ( i , q . poll ( ) . intValue ( ) ) ; assertNull ( ara . get ( 16 ) ) ; 
try RxJavaPlugins . setErrorHandler ( throwable -> if ( ! ( throwable instanceof UndeliverableException ) ) throwable . printStackTrace ( ) ; Thread currentThread = Thread . currentThread ( ) ; currentThread . getUncaughtExceptionHandler ( ) . uncaughtException ( currentThread , throwable ) ; ) ; base . evaluate ( ) ; finally RxJavaPlugins . setErrorHandler ( null ) ; 
if ( description != null && description . getAnnotation ( SuppressUndeliverable . class ) != null ) return new SuppressUndeliverableRuleStatement ( base ) ; else return base ; 
Observable < Integer > oi = Observable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestObserverEx < Integer > subscriber = new TestObserverEx < > ( ) ; oi . subscribe ( subscriber ) ; subscriber . assertValues ( 1 , 2 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertTerminated ( ) ; 
assertThrows ( AssertionError . class , ( ) -> Observable < Integer > oi = Observable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestObserverEx < Integer > subscriber = new TestObserverEx < > ( ) ; oi . subscribe ( subscriber ) ; subscriber . assertValue ( 1 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertTerminated ( ) ; ) ; 
assertThrows ( AssertionError . class , ( ) -> Observable < Integer > oi = Observable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestObserverEx < Integer > subscriber = new TestObserverEx < > ( ) ; oi . subscribe ( subscriber ) ; subscriber . assertValues ( 1 , 3 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertTerminated ( ) ; ) ; 
Observable < Integer > oi = Observable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestObserverEx < Integer > subscriber = new TestObserverEx < > ( ) ; oi . subscribe ( subscriber ) ; subscriber . assertNever ( 3 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertTerminated ( ) ; 
assertThrows ( AssertionError . class , ( ) -> Observable < Integer > oi = Observable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestObserverEx < Integer > subscriber = new TestObserverEx < > ( ) ; oi . subscribe ( subscriber ) ; subscriber . assertValues ( 1 , 2 ) ; subscriber . assertNever ( 2 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertTerminated ( ) ; ) ; 
assertThrows ( AssertionError . class , ( ) -> TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 , 2 ) . subscribe ( to ) ; to . assertValues ( 1 , 2 ) ; to . assertNever ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 2 , 3 ) . subscribe ( to ) ; to . assertNever ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; 
assertThrows ( AssertionError . class , ( ) -> PublishSubject < Integer > p = PublishSubject . create ( ) ; TestObserverEx < Integer > subscriber = new TestObserverEx < > ( ) ; p . subscribe ( subscriber ) ; p . onNext ( 1 ) ; p . onNext ( 2 ) ; subscriber . assertValues ( 1 , 2 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertTerminated ( ) ; ) ; 
Observable < Integer > oi = Observable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; Observer < Integer > mockSubscriber = TestHelper . mockObserver ( ) ; oi . subscribe ( new TestObserverEx < > ( mockSubscriber ) ) ; InOrder inOrder = inOrder ( mockSubscriber ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > oi = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ) . take ( 2 ) ; Observer < Integer > mockSubscriber = TestHelper . mockObserver ( ) ; oi . subscribe ( new TestObserverEx < > ( mockSubscriber ) ) ; InOrder inOrder = inOrder ( mockSubscriber ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable . error ( new RuntimeException ( ) ) . subscribe ( new TestObserverEx < > ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onNext ( 1 ) ; try to . assertValue ( ( Integer ) null ) ; catch ( AssertionError ex ) return ; fail ( "Null element check assertion didn't happen!" ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onNext ( null ) ; try to . assertValue ( 1 ) ; catch ( AssertionError ex ) return ; fail ( "Null element check assertion didn't happen!" ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onError ( new TestException ( ) ) ; to . onError ( new TestException ( ) ) ; try to . assertTerminated ( ) ; catch ( AssertionError ex ) return ; fail ( "Failed to report multiple onError terminal events!" ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onComplete ( ) ; to . onComplete ( ) ; try to . assertTerminated ( ) ; catch ( AssertionError ex ) return ; fail ( "Failed to report multiple onComplete terminal events!" ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onError ( new TestException ( ) ) ; to . onComplete ( ) ; try to . assertTerminated ( ) ; catch ( AssertionError ex ) return ; fail ( "Failed to report multiple kinds of events!" ) ; 
TestObserverEx < Integer > to1 = new TestObserverEx < > ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( to1 ) ; to . assertNotSubscribed ( ) ; assertFalse ( to . hasSubscription ( ) ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . assertNotSubscribed ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) assertTrue ( to . hasSubscription ( ) ) ; assertFalse ( to . isDisposed ( ) ) ; to . onNext ( 1 ) ; to . onError ( new TestException ( ) ) ; to . onComplete ( ) ; to1 . assertValue ( 1 ) . assertError ( TestException . class ) . assertComplete ( ) ; to . dispose ( ) ; assertTrue ( to . isDisposed ( ) ) ; assertSame ( Thread . currentThread ( ) , to . lastThread ( ) ) ; try to . assertNoValues ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertValueCount ( 0 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) to . assertValueSequence ( Collections . singletonList ( 1 ) ) ; try to . assertValueSequence ( Collections . singletonList ( 2 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; try to . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertError ( new TestException ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertErrorMessage ( "" ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertSubscribed ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertTerminated ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) to . onSubscribe ( Disposable . empty ( ) ) ; to . assertSubscribed ( ) ; to . assertNoErrors ( ) ; TestException ex = new TestException ( "Forced failure" ) ; to . onError ( ex ) ; to . assertError ( ex ) ; to . assertError ( TestException . class ) ; to . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable t ) throws Exception return t . getMessage ( ) != null && t . getMessage ( ) . contains ( "Forced" ) ; ) ; to . assertErrorMessage ( "Forced failure" ) ; try to . assertErrorMessage ( "" ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertError ( new RuntimeException ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertError ( IOException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertError ( Functions . < Throwable > alwaysFalse ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertNoErrors ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) to . assertTerminated ( ) ; to . assertValueCount ( 0 ) ; to . assertNoValues ( ) ; 
assertEquals ( 1 , TestObserverEx . EmptyObserver . values ( ) . length ) ; assertNotNull ( TestObserverEx . EmptyObserver . valueOf ( "INSTANCE" ) ) ; 
assertEquals ( "null" , TestObserver . valueAndClass ( null ) ) ; assertEquals ( "1 (class: Integer)" , TestObserver . valueAndClass ( 1 ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onError ( new TestException ( "Forced failure" ) ) ; to . assertFailure ( TestException . class ) ; to . assertFailure ( Functions . < Throwable > alwaysTrue ( ) ) ; to . assertFailureAndMessage ( TestException . class , "Forced failure" ) ; to . onNext ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; to . assertFailure ( Functions . < Throwable > alwaysTrue ( ) , 1 ) ; to . assertFailureAndMessage ( TestException . class , "Forced failure" , 1 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertNotFuseable ( ) ; try to . assertFuseable ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertFusionMode ( QueueFuseable . SYNC ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; to . onSubscribe ( new ScalarDisposable < > ( to , 1 ) ) ; to . assertFuseable ( ) ; to . assertFusionMode ( QueueFuseable . SYNC ) ; try to . assertFusionMode ( QueueFuseable . NONE ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertNotFuseable ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . assertNotTerminated ( ) ; to . onError ( null ) ; try to . assertNotTerminated ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onComplete ( ) ; to . assertResult ( ) ; try to . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) to . onNext ( 1 ) ; to . assertResult ( 1 ) ; try to . assertResult ( 2 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertResult ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( to . await ( 100 , TimeUnit . MILLISECONDS ) ) ; to . awaitDone ( 100 , TimeUnit . MILLISECONDS ) ; assertTrue ( to . isDisposed ( ) ) ; to . assertNotTerminated ( ) ; to . onComplete ( ) ; assertTrue ( to . await ( 100 , TimeUnit . MILLISECONDS ) ) ; to . await ( ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) . assertComplete ( ) ; final TestObserverEx < Integer > to1 = new TestObserverEx < > ( ) ; to1 . onSubscribe ( Disposable . empty ( ) ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) to1 . onComplete ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; to1 . await ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; assertEquals ( 0 , to . errors ( ) . size ( ) ) ; to . onError ( new TestException ( ) ) ; assertEquals ( 1 , to . errors ( ) . size ( ) ) ; TestHelper . assertError ( to . errors ( ) , 0 , TestException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertValueCount ( 0 ) ; assertEquals ( Collections . emptyList ( ) , to . values ( ) ) ; to . onNext ( 1 ) ; assertEquals ( Collections . singletonList ( 1 ) , to . values ( ) ) ; to . dispose ( ) ; assertTrue ( to . isDisposed ( ) ) ; to . assertValue ( 1 ) ; to . onComplete ( ) ; 
assertEquals ( "NONE" , TestObserverEx . fusionModeToString ( QueueFuseable . NONE ) ) ; assertEquals ( "SYNC" , TestObserverEx . fusionModeToString ( QueueFuseable . SYNC ) ) ; assertEquals ( "ASYNC" , TestObserverEx . fusionModeToString ( QueueFuseable . ASYNC ) ) ; assertEquals ( "Unknown(100)" , TestObserverEx . fusionModeToString ( 100 ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertNotComplete ( ) ; to . onComplete ( ) ; try to . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) to . assertTerminated ( ) ; to . onComplete ( ) ; try to . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) try to . assertTerminated ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) try to . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . assertValue ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) to . onNext ( 1 ) ; to . assertValue ( 1 ) ; try to . assertValue ( 2 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) to . onNext ( 2 ) ; try to . assertValue ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onNext ( 1 ) ; to . assertError ( IllegalStateException . class ) ; to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onNext ( null ) ; to . assertFailure ( NullPointerException . class , ( Integer ) null ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertNotTerminated ( ) ; to . onError ( new TestException ( ) ) ; to . assertTerminated ( ) ; to . onError ( new IOException ( ) ) ; try to . assertTerminated ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onError ( new TestException ( ) ) ; to . onComplete ( ) ; try to . assertTerminated ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( null ) ; to . assertError ( NullPointerException . class ) ; to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; Disposable d1 = Disposable . empty ( ) ; to . onSubscribe ( d1 ) ; assertTrue ( d1 . isDisposed ( ) ) ; to . assertError ( IllegalStateException . class ) ; to = new TestObserverEx < > ( ) ; to . dispose ( ) ; d1 = Disposable . empty ( ) ; to . onSubscribe ( d1 ) ; assertTrue ( d1 . isDisposed ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onNext ( 1 ) ; to . onNext ( 2 ) ; try to . assertValueSequence ( Collections . < Integer > emptyList ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError expected ) assertTrue ( expected . getMessage ( ) , expected . getMessage ( ) . startsWith ( "More values received than expected (0)" ) ) ; try to . assertValueSequence ( Collections . singletonList ( 1 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError expected ) assertTrue ( expected . getMessage ( ) , expected . getMessage ( ) . startsWith ( "More values received than expected (1)" ) ) ; to . assertValueSequence ( Arrays . asList ( 1 , 2 ) ) ; try to . assertValueSequence ( Arrays . asList ( 1 , 2 , 3 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError expected ) assertTrue ( expected . getMessage ( ) , expected . getMessage ( ) . startsWith ( "Fewer values received than expected (2)" ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; try to . assertEmpty ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) to . onSubscribe ( Disposable . empty ( ) ) ; to . assertEmpty ( ) ; to . onNext ( 1 ) ; try to . assertEmpty ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try to . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . assertNotSubscribed ( ) ; to . errors ( ) . add ( new TestException ( ) ) ; try to . assertNotSubscribed ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; TestException e = new TestException ( ) ; to . errors ( ) . add ( e ) ; to . errors ( ) . add ( new TestException ( ) ) ; try to . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) try to . assertError ( e ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) try to . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) try to . assertErrorMessage ( "" ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . onError ( new RuntimeException ( ) ) ; try to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable throwable ) throws Exception throw new TestException ( ) ; ) ; catch ( TestException ex ) return ; fail ( "Error in predicate but not thrown!" ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) to . onComplete ( ) ; to . assertComplete ( ) ; to . onComplete ( ) ; try to . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onComplete ( ) ; to . assertError ( IllegalStateException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . onComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( TestException ex ) to . assertTerminated ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . onError ( new IOException ( ) ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( TestException ex ) to . assertTerminated ( ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . SYNC ) ; Observable . range ( 1 , 5 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . subscribe ( to ) ; to . assertSubscribed ( ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . subscribe ( to ) ; us . onNext ( 1 ) ; to . assertSubscribed ( ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertFailure ( TestException . class ) ; 
assertFalse ( Observable . just ( 1 ) . test ( ) . assertResult ( 1 ) . isDisposed ( ) ) ; 
assertFalse ( Observable . error ( new TestException ( ) ) . test ( ) . assertFailure ( TestException . class ) . isDisposed ( ) ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . subscribe ( to ) ; us . onNext ( 1 ) ; us . onComplete ( ) ; to . assertSubscribed ( ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
assertThrows ( "No values" , AssertionError . class , ( ) -> TestObserverEx < Object > to = new TestObserverEx < > ( ) ; Observable . empty ( ) . subscribe ( to ) ; to . assertValue ( new Predicate < Object > ( ) @ Override public boolean test ( final Object o ) throws Exception return false ; ) ; ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 ) . subscribe ( to ) ; to . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; 
assertThrows ( "Value not present" , AssertionError . class , ( ) -> TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 ) . subscribe ( to ) ; to . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o != 1 ; ) ; ) ; 
assertThrows ( "Value present but other values as well" , AssertionError . class , ( ) -> TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 , 2 ) . subscribe ( to ) ; to . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
assertThrows ( "No values" , AssertionError . class , ( ) -> TestObserverEx < Object > to = new TestObserverEx < > ( ) ; Observable . empty ( ) . subscribe ( to ) ; to . assertValueAt ( 0 , new Predicate < Object > ( ) @ Override public boolean test ( final Object o ) throws Exception return false ; ) ; ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 , 2 ) . subscribe ( to ) ; to . assertValueAt ( 1 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 2 ; ) ; 
assertThrows ( "Value not present" , AssertionError . class , ( ) -> TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 , 2 , 3 ) . subscribe ( to ) ; to . assertValueAt ( 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o != 3 ; ) ; ) ; 
assertThrows ( "Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 , 2 ) . subscribe ( to ) ; to . assertValueAt ( 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
assertThrows ( "No values" , AssertionError . class , ( ) -> TestObserverEx < Object > to = new TestObserverEx < > ( ) ; Observable . empty ( ) . subscribe ( to ) ; to . assertValueAt ( 0 , "a" ) ; ) ; 
TestObserverEx < String > to = new TestObserverEx < > ( ) ; Observable . just ( "a" , "b" ) . subscribe ( to ) ; to . assertValueAt ( 1 , "b" ) ; 
assertThrows ( "\nexpected: b (class: String)\ngot: c (class: String) (latch = 0, values = 3, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserverEx < String > to = new TestObserverEx < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValueAt ( 2 , "b" ) ; ) ; 
assertThrows ( "Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserverEx < String > to = new TestObserverEx < > ( ) ; Observable . just ( "a" , "b" ) . subscribe ( to ) ; to . assertValueAt ( 2 , "c" ) ; ) ; 
try for ( int i = 1 ; i < 3 ; i ++ ) Observable . just ( i ) . test ( ) . withTag ( "testing with item=" + i ) . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "testing with item=2" ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertValuesOnly ( ) ; to . onNext ( 5 ) ; to . assertValuesOnly ( 5 ) ; to . onNext ( - 1 ) ; to . assertValuesOnly ( 5 , - 1 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertValuesOnly ( ) ; to . onNext ( 5 ) ; to . assertValuesOnly ( 5 ) ; to . onNext ( - 1 ) ; try to . assertValuesOnly ( 5 ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onComplete ( ) ; try to . assertValuesOnly ( ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onError ( new TestException ( ) ) ; try to . assertValuesOnly ( ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
$EMPTY$
return false ; 
return TimesteppingScheduler . this . now ( unit ) ; 
return new TimesteppingWorker ( ) ; 
if ( stepEnabled ) return time ++ ; return time ; 
lastThread = Thread . currentThread ( ) ; if ( s == null ) errors . add ( new NullPointerException ( "onSubscribe received a null Subscription" ) ) ; return ; if ( ! upstream . compareAndSet ( null , s ) ) s . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) errors . add ( new IllegalStateException ( "onSubscribe received multiple subscriptions: " + s ) ) ; return ; if ( initialFusionMode != 0 ) if ( s instanceof QueueSubscription ) qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( initialFusionMode ) ; establishedFusionMode = m ; if ( m == QueueFuseable . SYNC ) checkSubscriptionOnce = true ; lastThread = Thread . currentThread ( ) ; try T t ; while ( ( t = qs . poll ( ) ) != null ) values . add ( t ) ; completions ++ ; catch ( Throwable ex ) errors . add ( ex ) ; return ; downstream . onSubscribe ( s ) ; long mr = missedRequested . getAndSet ( 0L ) ; if ( mr != 0L ) s . request ( mr ) ; onStart ( ) ; 
$EMPTY$
if ( ! checkSubscriptionOnce ) checkSubscriptionOnce = true ; if ( upstream . get ( ) == null ) errors . add ( new NullPointerException ( "onSubscribe not called in proper order" ) ) ; try lastThread = Thread . currentThread ( ) ; errors . add ( t ) ; if ( t == null ) errors . add ( new IllegalStateException ( "onError received a null Throwable" ) ) ; downstream . onError ( t ) ; finally done . countDown ( ) ; 
if ( ! checkSubscriptionOnce ) checkSubscriptionOnce = true ; if ( upstream . get ( ) == null ) errors . add ( new IllegalStateException ( "onSubscribe not called in proper order" ) ) ; try lastThread = Thread . currentThread ( ) ; completions ++ ; downstream . onComplete ( ) ; finally done . countDown ( ) ; 
if ( ! cancelled ) cancelled = true ; SubscriptionHelper . cancel ( upstream ) ; 
return cancelled ; 
cancel ( ) ; 
return cancelled ; 
return upstream . get ( ) != null ; 
if ( upstream . get ( ) == null ) throw fail ( "Not subscribed!" ) ; return this ; 
if ( upstream . get ( ) != null ) throw fail ( "Subscribed!" ) ; else if ( ! errors . isEmpty ( ) ) throw fail ( "Not subscribed but errors found" ) ; return this ; 
if ( qs == null ) throw new AssertionError ( "Upstream is not fuseable." ) ; return this ; 
if ( qs != null ) throw new AssertionError ( "Upstream is fuseable." ) ; return this ; 
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
return lastThread ; 
int s = values . size ( ) ; for ( int i = 0 ; i < s ; i ++ ) T v = this . values . get ( i ) ; try if ( valuePredicate . test ( v ) ) throw fail ( "Value at position " + i + " matches predicate " + valuePredicate . toString ( ) + ", which was not expected." ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; return ( U ) this ; 
if ( done . getCount ( ) != 0 ) throw fail ( "Subscriber still running!" ) ; long c = completions ; if ( c > 1 ) throw fail ( "Terminated with multiple completions: " + c ) ; int s = errors . size ( ) ; if ( s > 1 ) throw fail ( "Terminated with multiple errors: " + s ) ; if ( c != 0 && s != 0 ) throw fail ( "Terminated with multiple completions and errors: " + c ) ; return ( U ) this ; 
if ( done . getCount ( ) == 0 ) throw fail ( "Subscriber terminated!" ) ; return ( U ) this ; 
int s = errors . size ( ) ; if ( s == 0 ) throw fail ( "No errors" ) ; else if ( s == 1 ) Throwable e = errors . get ( 0 ) ; String errorMessage = e . getMessage ( ) ; if ( ! Objects . equals ( message , errorMessage ) ) throw fail ( "\nexpected: " + message + "\ngot: " + errorMessage + "; Error message differs" ) ; else throw fail ( "Multiple errors" ) ; return ( U ) this ; 
return timeout ; 
timeout = false ; return ( U ) this ; 
if ( ! timeout ) throw fail ( "No timeout?!" ) ; return ( U ) this ; 
if ( timeout ) throw fail ( "Timeout?!" ) ; return ( U ) this ; 
return errors ; 
return done . getCount ( ) == 0 ; 
return completions ; 
return fail ( message ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; oi . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertValueCount ( 2 ) ; ts . assertTerminated ( ) ; 
assertThrows ( AssertionError . class , ( ) -> Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; oi . subscribe ( ts ) ; ts . assertValues ( 1 ) ; ts . assertValueCount ( 2 ) ; ts . assertTerminated ( ) ; ) ; 
assertThrows ( AssertionError . class , ( ) -> Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; oi . subscribe ( ts ) ; ts . assertValues ( 1 , 3 ) ; ts . assertValueCount ( 2 ) ; ts . assertTerminated ( ) ; ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; oi . subscribe ( ts ) ; ts . assertNever ( 3 ) ; ts . assertValueCount ( 2 ) ; ts . assertTerminated ( ) ; 
assertThrows ( AssertionError . class , ( ) -> Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; oi . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNever ( 2 ) ; ts . assertValueCount ( 2 ) ; ts . assertTerminated ( ) ; ) ; 
assertThrows ( AssertionError . class , ( ) -> TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNever ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 2 , 3 ) . subscribe ( ts ) ; ts . assertNever ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; 
assertThrows ( AssertionError . class , ( ) -> PublishProcessor < Integer > p = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; p . subscribe ( ts ) ; p . onNext ( 1 ) ; p . onNext ( 2 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertValueCount ( 2 ) ; ts . assertTerminated ( ) ; ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; Subscriber < Integer > mockSubscriber = TestHelper . mockSubscriber ( ) ; oi . subscribe ( new TestSubscriberEx < > ( mockSubscriber ) ) ; InOrder inOrder = inOrder ( mockSubscriber ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ) . take ( 2 ) ; Subscriber < Integer > mockSubscriber = TestHelper . mockSubscriber ( ) ; oi . subscribe ( new TestSubscriberEx < > ( mockSubscriber ) ) ; InOrder inOrder = inOrder ( mockSubscriber ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
RuntimeException e = new RuntimeException ( "Oops" ) ; TestSubscriberEx < Object > subscriber = new TestSubscriberEx < > ( ) ; Flowable . error ( e ) . subscribe ( subscriber ) ; subscriber . assertError ( e ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; final AtomicBoolean unsub = new AtomicBoolean ( false ) ; Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) unsub . set ( true ) ; ) . delay ( 1000 , TimeUnit . MILLISECONDS ) . subscribe ( ts ) ; ts . awaitDone ( 100 , TimeUnit . MILLISECONDS ) ; ts . dispose ( ) ; assertTrue ( unsub . get ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( null ) ; ts . onComplete ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( null ) ; ts . onComplete ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( null , 0L ) ; ts . onComplete ( ) ; 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < > ( ) ; ts0 . onSubscribe ( EmptySubscription . INSTANCE ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ts0 ) ; ts . onComplete ( ) ; ts0 . assertTerminated ( ) ; 
TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ts1 ) ; ts2 . onComplete ( ) ; ts1 . assertComplete ( ) ; 
TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ts1 , 0L ) ; ts2 . onComplete ( ) ; ts1 . assertComplete ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; assertFalse ( ts . isCancelled ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNoErrors ( ) ; catch ( AssertionError ex ) return ; fail ( "Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; try ts . assertComplete ( ) ; catch ( AssertionError ex ) return ; fail ( "Not completed and no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onComplete ( ) ; ts . onComplete ( ) ; try ts . assertComplete ( ) ; catch ( AssertionError ex ) return ; fail ( "Multiple completions and no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onComplete ( ) ; try ts . assertNotComplete ( ) ; catch ( AssertionError ex ) return ; fail ( "Completed and no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onComplete ( ) ; ts . onComplete ( ) ; try ts . assertNotComplete ( ) ; catch ( AssertionError ex ) return ; fail ( "Multiple completions and no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNoErrors ( ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; if ( ce . size ( ) != 2 ) ce . printStackTrace ( ) ; assertEquals ( 2 , ce . size ( ) ) ; return ; fail ( "Multiple Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( TestException . class ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; assertEquals ( 2 , ce . size ( ) ) ; return ; fail ( "Multiple Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( new TestException ( ) ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; assertEquals ( 2 , ce . size ( ) ) ; return ; fail ( "Multiple Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; assertEquals ( 2 , ce . size ( ) ) ; return ; fail ( "Multiple Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onError ( new TestException ( ) ) ; try ts . assertError ( new TestException ( ) ) ; catch ( AssertionError ex ) return ; fail ( "Different Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onError ( new RuntimeException ( ) ) ; try ts . assertError ( new TestException ( ) ) ; catch ( AssertionError ex ) return ; fail ( "Different Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onError ( new RuntimeException ( ) ) ; try ts . assertError ( TestException . class ) ; catch ( AssertionError ex ) return ; fail ( "Different Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onError ( new RuntimeException ( ) ) ; try ts . assertError ( Functions . < Throwable > alwaysFalse ( ) ) ; catch ( AssertionError ex ) return ; fail ( "Different Error present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onError ( new RuntimeException ( ) ) ; try ts . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable throwable ) throws Exception throw new TestException ( ) ; ) ; catch ( TestException ex ) return ; fail ( "Error in predicate but not thrown!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; try ts . assertError ( TestException . class ) ; catch ( AssertionError ex ) return ; fail ( "No present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; try ts . assertError ( new TestException ( ) ) ; catch ( AssertionError ex ) return ; fail ( "No present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; try ts . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; catch ( AssertionError ex ) return ; fail ( "No present but no assertion error!" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final Thread t0 = Thread . currentThread ( ) ; Worker w = Schedulers . computation ( ) . createWorker ( ) ; try w . schedule ( new Runnable ( ) @ Override public void run ( ) t0 . interrupt ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; try if ( ts . await ( 5 , TimeUnit . SECONDS ) ) fail ( "Did not interrupt wait!" ) ; catch ( InterruptedException expected ) finally w . dispose ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final Thread t0 = Thread . currentThread ( ) ; Worker w = Schedulers . computation ( ) . createWorker ( ) ; try w . schedule ( new Runnable ( ) @ Override public void run ( ) t0 . interrupt ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; try if ( ts . await ( 5 , TimeUnit . SECONDS ) ) fail ( "Did not interrupt wait!" ) ; catch ( InterruptedException expected ) finally Thread . interrupted ( ) ; w . dispose ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; final Thread t0 = Thread . currentThread ( ) ; Worker w = Schedulers . computation ( ) . createWorker ( ) ; try w . schedule ( new Runnable ( ) @ Override public void run ( ) t0 . interrupt ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; try ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException allowed ) assertTrue ( allowed . toString ( ) , allowed . getCause ( ) instanceof InterruptedException ) ; ts . dispose ( ) ; if ( ! ts . isCancelled ( ) ) fail ( "Did not unsubscribe!" ) ; finally w . dispose ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onComplete ( ) ; try ts . assertNotTerminated ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNotTerminated ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onComplete ( ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNotTerminated ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( EmptySubscription . INSTANCE ) ; ts . onError ( new TestException ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertNotTerminated ( ) ; throw new RuntimeException ( "Failed to report there were terminal event(s)!" ) ; catch ( AssertionError ex ) Throwable e = ex . getCause ( ) ; if ( ! ( e instanceof CompositeException ) ) fail ( "Multiple Error present but the reported error doesn't have a composite cause!" ) ; CompositeException ce = ( CompositeException ) e ; assertEquals ( 2 , ce . size ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onNext ( 1 ) ; try ts . assertNoValues ( ) ; throw new RuntimeException ( "Failed to report there were values!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onNext ( 1 ) ; ts . onNext ( 2 ) ; try ts . assertValueCount ( 3 ) ; throw new RuntimeException ( "Failed to report there were values!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < Integer > ( ) @ Override public void onComplete ( ) throw new TestException ( ) ; ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ts0 ) ; try ts . onComplete ( ) ; catch ( TestException ex ) ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; 
TestSubscriberEx < Integer > ts0 = new TestSubscriberEx < Integer > ( ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ts0 ) ; try ts . onError ( new RuntimeException ( ) ) ; catch ( TestException ex ) ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; 
TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ts1 ) ; ts . assertNotSubscribed ( ) ; assertFalse ( ts . hasSubscription ( ) ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . assertNotSubscribed ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) assertTrue ( ts . hasSubscription ( ) ) ; assertFalse ( ts . isDisposed ( ) ) ; ts . onNext ( 1 ) ; ts . onError ( new TestException ( ) ) ; ts . onComplete ( ) ; ts1 . assertValue ( 1 ) . assertError ( TestException . class ) . assertComplete ( ) ; ts . dispose ( ) ; assertTrue ( ts . isDisposed ( ) ) ; assertSame ( Thread . currentThread ( ) , ts . lastThread ( ) ) ; try ts . assertNoValues ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertValueCount ( 0 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) ts . assertValueSequence ( Collections . singletonList ( 1 ) ) ; try ts . assertValueSequence ( Collections . singletonList ( 2 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; try ts . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertError ( new TestException ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertErrorMessage ( "" ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertSubscribed ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertTerminated ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertSubscribed ( ) ; ts . assertNoErrors ( ) ; TestException ex = new TestException ( "Forced failure" ) ; ts . onError ( ex ) ; ts . assertError ( ex ) ; ts . assertError ( TestException . class ) ; ts . assertErrorMessage ( "Forced failure" ) ; ts . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; ts . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable t ) return t . getMessage ( ) != null && t . getMessage ( ) . contains ( "Forced" ) ; ) ; try ts . assertErrorMessage ( "" ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertError ( new RuntimeException ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertError ( IOException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertNoErrors ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try ts . assertError ( Functions . < Throwable > alwaysFalse ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) ts . assertTerminated ( ) ; ts . assertValueCount ( 0 ) ; ts . assertNoValues ( ) ; 
assertEquals ( 1 , TestSubscriberEx . EmptySubscriber . values ( ) . length ) ; assertNotNull ( TestSubscriberEx . EmptySubscriber . valueOf ( "INSTANCE" ) ) ; 
assertEquals ( "null" , TestSubscriberEx . valueAndClass ( null ) ) ; assertEquals ( "1 (class: Integer)" , TestSubscriberEx . valueAndClass ( 1 ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onError ( new TestException ( "Forced failure" ) ) ; ts . assertFailure ( TestException . class ) ; ts . assertFailure ( Functions . < Throwable > alwaysTrue ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "Forced failure" ) ; ts . onNext ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; ts . assertFailure ( Functions . < Throwable > alwaysTrue ( ) , 1 ) ; ts . assertFailureAndMessage ( TestException . class , "Forced failure" , 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertNotFuseable ( ) ; try ts . assertFuseable ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertFusionMode ( QueueFuseable . SYNC ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; ts . onSubscribe ( new ScalarSubscription < > ( ts , 1 ) ) ; ts . assertFuseable ( ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) ; try ts . assertFusionMode ( QueueFuseable . NONE ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertNotFuseable ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . assertNotTerminated ( ) ; ts . onError ( null ) ; try ts . assertNotTerminated ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onComplete ( ) ; ts . assertResult ( ) ; try ts . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) ts . onNext ( 1 ) ; ts . assertResult ( 1 ) ; try ts . assertResult ( 2 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertResult ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; assertFalse ( ts . await ( 100 , TimeUnit . MILLISECONDS ) ) ; ts . awaitDone ( 100 , TimeUnit . MILLISECONDS ) ; assertTrue ( ts . isDisposed ( ) ) ; assertFalse ( ts . await ( 100 , TimeUnit . MILLISECONDS ) ) ; ts . assertNotComplete ( ) . assertNoErrors ( ) ; ts . onComplete ( ) ; assertTrue ( ts . await ( 100 , TimeUnit . MILLISECONDS ) ) ; ts . await ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertComplete ( ) . assertNoErrors ( ) ; assertTrue ( ts . await ( 5 , TimeUnit . SECONDS ) ) ; final TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; ts1 . onSubscribe ( new BooleanSubscription ( ) ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) ts1 . onComplete ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; ts1 . await ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; assertEquals ( 0 , ts . errors ( ) . size ( ) ) ; ts . onError ( new TestException ( ) ) ; assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; TestHelper . assertError ( ts . errors ( ) , 0 , TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertNoValues ( ) ; assertEquals ( Collections . emptyList ( ) , ts . values ( ) ) ; ts . onNext ( 1 ) ; assertEquals ( Collections . singletonList ( 1 ) , ts . values ( ) ) ; ts . cancel ( ) ; assertTrue ( ts . isCancelled ( ) ) ; assertTrue ( ts . isDisposed ( ) ) ; ts . assertValue ( 1 ) ; ts . onComplete ( ) ; 
assertEquals ( "NONE" , TestSubscriberEx . fusionModeToString ( QueueFuseable . NONE ) ) ; assertEquals ( "SYNC" , TestSubscriberEx . fusionModeToString ( QueueFuseable . SYNC ) ) ; assertEquals ( "ASYNC" , TestSubscriberEx . fusionModeToString ( QueueFuseable . ASYNC ) ) ; assertEquals ( "Unknown(100)" , TestSubscriberEx . fusionModeToString ( 100 ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertNotComplete ( ) ; ts . onComplete ( ) ; try ts . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) ts . assertTerminated ( ) ; ts . onComplete ( ) ; try ts . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) try ts . assertTerminated ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) try ts . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . assertValue ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) ts . onNext ( 1 ) ; ts . assertValue ( 1 ) ; try ts . assertValue ( 2 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) ts . onNext ( 2 ) ; try ts . assertValue ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onNext ( 1 ) ; ts . assertError ( IllegalStateException . class ) ; ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onNext ( null ) ; ts . assertFailure ( NullPointerException . class , ( Integer ) null ) ; 
final TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; try ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException allowed ) assertTrue ( allowed . toString ( ) , allowed . getCause ( ) instanceof InterruptedException ) ; Thread . currentThread ( ) . interrupt ( ) ; try ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException allowed ) assertTrue ( allowed . toString ( ) , allowed . getCause ( ) instanceof InterruptedException ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertNotTerminated ( ) ; ts . onError ( new TestException ( ) ) ; ts . assertTerminated ( ) ; ts . onError ( new IOException ( ) ) ; try ts . assertTerminated ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onError ( new TestException ( ) ) ; ts . onComplete ( ) ; try ts . assertTerminated ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( null ) ; ts . assertError ( NullPointerException . class ) ; ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; ts . onSubscribe ( bs1 ) ; assertTrue ( bs1 . isCancelled ( ) ) ; ts . assertError ( IllegalStateException . class ) ; ts = new TestSubscriberEx < > ( ) ; ts . dispose ( ) ; bs1 = new BooleanSubscription ( ) ; ts . onSubscribe ( bs1 ) ; assertTrue ( bs1 . isCancelled ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onNext ( 1 ) ; ts . onNext ( 2 ) ; try ts . assertValueSequence ( Collections . < Integer > emptyList ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try ts . assertValueSequence ( Collections . singletonList ( 1 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) ts . assertValueSequence ( Arrays . asList ( 1 , 2 ) ) ; try ts . assertValueSequence ( Arrays . asList ( 1 , 2 , 3 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; try ts . assertEmpty ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertEmpty ( ) ; ts . onNext ( 1 ) ; try ts . assertEmpty ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . assertNotSubscribed ( ) ; ts . errors ( ) . add ( new TestException ( ) ) ; try ts . assertNotSubscribed ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; TestException e = new TestException ( ) ; ts . errors ( ) . add ( e ) ; ts . errors ( ) . add ( new TestException ( ) ) ; try ts . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) try ts . assertError ( e ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) try ts . assertErrorMessage ( "" ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) ts . onComplete ( ) ; ts . assertComplete ( ) ; ts . onComplete ( ) ; try ts . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onComplete ( ) ; ts . assertError ( IllegalStateException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . onComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( TestException ex ) ts . assertTerminated ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; try ts . onError ( new IOException ( ) ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( TestException ex ) ts . assertTerminated ( ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . range ( 1 , 5 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . subscribe ( ts ) ; ts . assertSubscribed ( ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . subscribe ( ts ) ; up . onNext ( 1 ) ; ts . assertSubscribed ( ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertFailure ( TestException . class ) ; 
assertThrows ( "No values" , AssertionError . class , ( ) -> TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; Flowable . empty ( ) . subscribe ( ts ) ; ts . assertValue ( new Predicate < Object > ( ) @ Override public boolean test ( final Object o ) throws Exception return false ; ) ; ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 ) . subscribe ( ts ) ; ts . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; 
assertThrows ( "Value not present" , AssertionError . class , ( ) -> TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 ) . subscribe ( ts ) ; ts . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o != 1 ; ) ; ) ; 
assertThrows ( "Value present but other values as well" , AssertionError . class , ( ) -> TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
assertThrows ( "No values" , AssertionError . class , ( ) -> TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; Flowable . empty ( ) . subscribe ( ts ) ; ts . assertValueAt ( 0 , new Predicate < Object > ( ) @ Override public boolean test ( final Object o ) throws Exception return false ; ) ; ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValueAt ( 1 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 2 ; ) ; 
assertThrows ( "Value not present" , AssertionError . class , ( ) -> TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 , 2 , 3 ) . subscribe ( ts ) ; ts . assertValueAt ( 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o != 3 ; ) ; ) ; 
assertThrows ( "Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 , 2 ) . subscribe ( ts ) ; ts . assertValueAt ( 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
Flowable . range ( 1 , 5 ) . test ( 0 ) . requestMore ( 1 ) . assertValue ( 1 ) . requestMore ( 2 ) . assertValues ( 1 , 2 , 3 ) . requestMore ( 3 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
try for ( int i = 1 ; i < 3 ; i ++ ) Flowable . just ( i ) . test ( ) . withTag ( "testing with item=" + i ) . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "testing with item=2" ) ) ; 
Thread . interrupted ( ) ; TestSubscriberEx < Object > ts = Flowable . never ( ) . to ( TestHelper . < Object > testConsumer ( ) ) ; assertFalse ( ts . await ( 1 , TimeUnit . MILLISECONDS ) ) ; try ts . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "timeout!" ) ) ; 
try Flowable . never ( ) . test ( ) . awaitDone ( 1 , TimeUnit . MILLISECONDS ) . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "timeout!" ) ) ; 
TestSubscriberEx < Object > ts = Flowable . never ( ) . to ( TestHelper . < Object > testConsumer ( ) ) ; assertFalse ( ts . await ( 1 , TimeUnit . MILLISECONDS ) ) ; try ts . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "timeout!" ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . cancel ( ) ; try ts . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( Throwable ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "disposed!" ) ) ; 
Flowable . range ( 1 , 10 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . test ( 5 ) . awaitCount ( 5 ) . assertValues ( 1 , 2 , 3 , 4 , 5 ) . requestMore ( 5 ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 4 ) . test ( ) . awaitCount ( 5 ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
try Flowable . just ( 1 ) . test ( ) . assertValueAt ( 0 , new Predicate < Integer > ( ) @ Override public boolean test ( Integer t ) throws Exception throw new IllegalArgumentException ( ) ; ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertValuesOnly ( ) ; ts . onNext ( 5 ) ; ts . assertValuesOnly ( 5 ) ; ts . onNext ( - 1 ) ; ts . assertValuesOnly ( 5 , - 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . assertValuesOnly ( ) ; ts . onNext ( 5 ) ; ts . assertValuesOnly ( 5 ) ; ts . onNext ( - 1 ) ; try ts . assertValuesOnly ( 5 ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onComplete ( ) ; try ts . assertValuesOnly ( ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; ts . onError ( new TestException ( ) ) ; try ts . assertValuesOnly ( ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
FlowableSubscriber < T > w = mock ( FlowableSubscriber . class ) ; Mockito . doAnswer ( new Answer < Object > ( ) @ Override public Object answer ( InvocationOnMock a ) throws Throwable Subscription s = a . getArgument ( 0 ) ; s . request ( Long . MAX_VALUE ) ; return null ; ) . when ( w ) . onSubscribe ( ( Subscription ) any ( ) ) ; return w ; 
return mock ( Observer . class ) ; 
return mock ( MaybeObserver . class ) ; 
return mock ( SingleObserver . class ) ; 
return mock ( CompletableObserver . class ) ; 
try Constructor < ? > c = clazz . getDeclaredConstructor ( ) ; c . setAccessible ( true ) ; try c . newInstance ( ) ; fail ( "Should have thrown InvocationTargetException(IllegalStateException)" ) ; catch ( InvocationTargetException ex ) assertEquals ( "No instances!" , ex . getCause ( ) . getMessage ( ) ) ; catch ( Exception ex ) AssertionError ae = new AssertionError ( ex . toString ( ) ) ; ae . initCause ( ex ) ; throw ae ; 
final List < Throwable > list = Collections . synchronizedList ( new ArrayList < > ( ) ) ; RxJavaPlugins . setErrorHandler ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) list . add ( t ) ; ) ; return list ; 
assertEquals ( 0 , e . getEnumConstants ( ) . length ) ; try try Method m0 = e . getDeclaredMethod ( "values" ) ; Object [ ] a = ( Object [ ] ) m0 . invoke ( null ) ; assertEquals ( 0 , a . length ) ; Method m = e . getDeclaredMethod ( "valueOf" , String . class ) ; m . invoke ( "INSTANCE" ) ; fail ( "Should have thrown!" ) ; catch ( InvocationTargetException ex ) fail ( ex . toString ( ) ) ; catch ( IllegalAccessException ex ) fail ( ex . toString ( ) ) ; catch ( IllegalArgumentException ex ) catch ( NoSuchMethodException ex ) fail ( ex . toString ( ) ) ; 
List < Throwable > list = trackPluginErrors ( ) ; try final CountDownLatch cdl = new CountDownLatch ( 1 ) ; source . subscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) try s . request ( - 99 ) ; s . cancel ( ) ; s . cancel ( ) ; finally cdl . countDown ( ) ; @ Override public void onNext ( Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw new AssertionError ( ex . getMessage ( ) ) ; assertTrue ( list . toString ( ) , list . get ( 0 ) instanceof IllegalArgumentException ) ; assertEquals ( "n > 0 required but it was -99" , list . get ( 0 ) . getMessage ( ) ) ; finally RxJavaPlugins . setErrorHandler ( null ) ; 
try s . request ( - 99 ) ; s . cancel ( ) ; s . cancel ( ) ; finally cdl . countDown ( ) ; 
$EMPTY$
$EMPTY$
$EMPTY$
List < Throwable > list = trackPluginErrors ( ) ; try final CountDownLatch cdl = new CountDownLatch ( 1 ) ; FlowableSubscriber < Object > bad = new FlowableSubscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) try s . request ( - 99 ) ; s . cancel ( ) ; s . cancel ( ) ; finally cdl . countDown ( ) ; @ Override public void onNext ( Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; @ SuppressWarnings ( "unchecked" ) FlowableSubscriber < Object > [ ] subs = new FlowableSubscriber [ source . parallelism ( ) ] ; subs [ 0 ] = bad ; for ( int i = 1 ; i < subs . length ; i ++ ) subs [ i ] = NoOpConsumer . INSTANCE ; source . subscribe ( subs ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw new AssertionError ( ex . getMessage ( ) ) ; assertTrue ( list . toString ( ) , list . get ( 0 ) instanceof IllegalArgumentException ) ; assertEquals ( "n > 0 required but it was -99" , list . get ( 0 ) . getMessage ( ) ) ; finally RxJavaPlugins . setErrorHandler ( null ) ; 
try s . request ( - 99 ) ; s . cancel ( ) ; s . cancel ( ) ; finally cdl . countDown ( ) ; 
$EMPTY$
$EMPTY$
$EMPTY$
race ( r1 , r2 , Schedulers . single ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( 2 ) ; final CountDownLatch cdl = new CountDownLatch ( 2 ) ; final Throwable [ ] errors = null , null ; s . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) if ( count . decrementAndGet ( ) != 0 ) while ( count . get ( ) != 0 ) try try r1 . run ( ) ; catch ( Throwable ex ) errors [ 0 ] = ex ; finally cdl . countDown ( ) ; ) ; if ( count . decrementAndGet ( ) != 0 ) while ( count . get ( ) != 0 ) try try r2 . run ( ) ; catch ( Throwable ex ) errors [ 1 ] = ex ; finally cdl . countDown ( ) ; try if ( ! cdl . await ( 5 , TimeUnit . SECONDS ) ) throw new AssertionError ( "The wait timed out!" ) ; catch ( InterruptedException ex ) throw new RuntimeException ( ex ) ; if ( errors [ 0 ] != null && errors [ 1 ] == null ) throw ExceptionHelper . wrapOrThrow ( errors [ 0 ] ) ; if ( errors [ 0 ] == null && errors [ 1 ] != null ) throw ExceptionHelper . wrapOrThrow ( errors [ 1 ] ) ; if ( errors [ 0 ] != null && errors [ 1 ] != null ) throw new CompositeException ( errors ) ; 
if ( ex instanceof UndeliverableException ) ex = ex . getCause ( ) ; return ( ( CompositeException ) ex ) . getExceptions ( ) ; 
try q . offer ( null ) ; fail ( "Should have thrown!" ) ; catch ( UnsupportedOperationException ex ) try q . offer ( null , null ) ; fail ( "Should have thrown!" ) ; catch ( UnsupportedOperationException ex ) 
try Method m = enumClass . getMethod ( "values" ) ; m . setAccessible ( true ) ; Method e = enumClass . getMethod ( "valueOf" , String . class ) ; m . setAccessible ( true ) ; for ( Enum < E > o : ( Enum < E > [ ] ) m . invoke ( null ) ) assertSame ( o , e . invoke ( null , o . name ( ) ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try BooleanSubscription s1 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( s1 ) ; BooleanSubscription s2 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( s2 ) ; assertFalse ( s1 . isCancelled ( ) ) ; assertTrue ( s2 . isCancelled ( ) ) ; assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
assertFalse ( "Disposed upfront?!" , d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( "Not disposed?!" , d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( "Not disposed again?!" , d . isDisposed ( ) ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < > ( 0L ) ; source . subscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) ts . onSubscribe ( new BooleanSubscription ( ) ) ; s . cancel ( ) ; s . cancel ( ) ; @ Override public void onNext ( Object t ) ts . onNext ( t ) ; @ Override public void onError ( Throwable t ) ts . onError ( t ) ; @ Override public void onComplete ( ) ts . onComplete ( ) ; ) ; ts . assertEmpty ( ) ; 
ts . onSubscribe ( new BooleanSubscription ( ) ) ; s . cancel ( ) ; s . cancel ( ) ; 
ts . onNext ( t ) ; 
ts . onError ( t ) ; 
ts . onComplete ( ) ; 
final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; source . subscribe ( new MaybeObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) try b [ 0 ] = d . isDisposed ( ) ; d . dispose ( ) ; b [ 1 ] = d . isDisposed ( ) ; d . dispose ( ) ; finally cdl . countDown ( ) ; @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "Reports disposed upfront?" , false , b [ 0 ] ) ; assertEquals ( "Didn't report disposed after?" , true , b [ 1 ] ) ; 
try b [ 0 ] = d . isDisposed ( ) ; d . dispose ( ) ; b [ 1 ] = d . isDisposed ( ) ; d . dispose ( ) ; finally cdl . countDown ( ) ; 
$EMPTY$
$EMPTY$
$EMPTY$
final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; source . subscribe ( new Observer < Object > ( ) @ Override public void onSubscribe ( Disposable d ) try b [ 0 ] = d . isDisposed ( ) ; d . dispose ( ) ; b [ 1 ] = d . isDisposed ( ) ; d . dispose ( ) ; finally cdl . countDown ( ) ; @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "Reports disposed upfront?" , false , b [ 0 ] ) ; assertEquals ( "Didn't report disposed after?" , true , b [ 1 ] ) ; 
try b [ 0 ] = d . isDisposed ( ) ; d . dispose ( ) ; b [ 1 ] = d . isDisposed ( ) ; d . dispose ( ) ; finally cdl . countDown ( ) ; 
$EMPTY$
final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; source . subscribe ( new SingleObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) try b [ 0 ] = d . isDisposed ( ) ; d . dispose ( ) ; b [ 1 ] = d . isDisposed ( ) ; d . dispose ( ) ; finally cdl . countDown ( ) ; @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "Reports disposed upfront?" , false , b [ 0 ] ) ; assertEquals ( "Didn't report disposed after?" , true , b [ 1 ] ) ; 
final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; source . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) try b [ 0 ] = d . isDisposed ( ) ; d . dispose ( ) ; b [ 1 ] = d . isDisposed ( ) ; d . dispose ( ) ; finally cdl . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "Reports disposed upfront?" , false , b [ 0 ] ) ; assertEquals ( "Didn't report disposed after?" , true , b [ 1 ] ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe < T > source = new Maybe < T > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; MaybeSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe < T > source = new Maybe < T > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; SingleSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe < T > source = new Maybe < T > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; ObservableSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe < T > source = new Maybe < T > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; Publisher < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Single < T > source = new Single < T > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; MaybeSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Single < T > source = new Single < T > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; ObservableSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Single < T > source = new Single < T > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; Publisher < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Maybe < T > source = new Maybe < T > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; CompletableSource out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Single < T > source = new Single < T > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; SingleSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Flowable < T > source = new Flowable < T > ( ) @ Override protected void subscribeActual ( Subscriber < ? super T > subscriber ) try BooleanSubscription bs1 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs2 ) ; b [ 0 ] = bs1 . isCancelled ( ) ; b [ 1 ] = bs2 . isCancelled ( ) ; finally cdl . countDown ( ) ; ; Publisher < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
try BooleanSubscription bs1 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs2 ) ; b [ 0 ] = bs1 . isCancelled ( ) ; b [ 1 ] = bs2 . isCancelled ( ) ; finally cdl . countDown ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null , null , null ; final CountDownLatch cdl = new CountDownLatch ( 2 ) ; ParallelFlowable < T > source = new ParallelFlowable < T > ( ) @ Override public void subscribe ( Subscriber < ? super T > [ ] subscribers ) for ( int i = 0 ; i < subscribers . length ; i ++ ) try BooleanSubscription bs1 = new BooleanSubscription ( ) ; subscribers [ i ] . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; subscribers [ i ] . onSubscribe ( bs2 ) ; b [ i * 2 + 0 ] = bs1 . isCancelled ( ) ; b [ i * 2 + 1 ] = bs2 . isCancelled ( ) ; finally cdl . countDown ( ) ; @ Override public int parallelism ( ) return 2 ; ; ParallelFlowable < ? > out = transform . apply ( source ) ; out . subscribe ( new Subscriber [ ] NoOpConsumer . INSTANCE , NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "Rail 1 First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Rail 1 Second not disposed?" , true , b [ 1 ] ) ; assertEquals ( "Rail 2 First disposed?" , false , b [ 2 ] ) ; assertEquals ( "Rail 2 Second not disposed?" , true , b [ 3 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; assertError ( errors , 1 , IllegalStateException . class , "Subscription already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null , null , null ; final CountDownLatch cdl = new CountDownLatch ( 2 ) ; ParallelFlowable < T > source = new ParallelFlowable < T > ( ) @ Override public void subscribe ( Subscriber < ? super T > [ ] subscribers ) for ( int i = 0 ; i < subscribers . length ; i ++ ) try BooleanSubscription bs1 = new BooleanSubscription ( ) ; subscribers [ i ] . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; subscribers [ i ] . onSubscribe ( bs2 ) ; b [ i * 2 + 0 ] = bs1 . isCancelled ( ) ; b [ i * 2 + 1 ] = bs2 . isCancelled ( ) ; finally cdl . countDown ( ) ; @ Override public int parallelism ( ) return 2 ; ; Flowable < ? > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "Rail 1 First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Rail 1 Second not disposed?" , true , b [ 1 ] ) ; assertEquals ( "Rail 2 First disposed?" , false , b [ 2 ] ) ; assertEquals ( "Rail 2 Second not disposed?" , true , b [ 3 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; assertError ( errors , 1 , IllegalStateException . class , "Subscription already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable < T > source = new Observable < T > ( ) @ Override protected void subscribeActual ( Observer < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; ObservableSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable < T > source = new Observable < T > ( ) @ Override protected void subscribeActual ( Observer < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; SingleSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable < T > source = new Observable < T > ( ) @ Override protected void subscribeActual ( Observer < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; MaybeSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable < T > source = new Observable < T > ( ) @ Override protected void subscribeActual ( Observer < ? super T > observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; CompletableSource out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Flowable < T > source = new Flowable < T > ( ) @ Override protected void subscribeActual ( Subscriber < ? super T > subscriber ) try BooleanSubscription bs1 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs2 ) ; b [ 0 ] = bs1 . isCancelled ( ) ; b [ 1 ] = bs2 . isCancelled ( ) ; finally cdl . countDown ( ) ; ; ObservableSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First cancelled?" , false , b [ 0 ] ) ; assertEquals ( "Second not cancelled?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Flowable < T > source = new Flowable < T > ( ) @ Override protected void subscribeActual ( Subscriber < ? super T > subscriber ) try BooleanSubscription bs1 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs2 ) ; b [ 0 ] = bs1 . isCancelled ( ) ; b [ 1 ] = bs2 . isCancelled ( ) ; finally cdl . countDown ( ) ; ; SingleSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First cancelled?" , false , b [ 0 ] ) ; assertEquals ( "Second not cancelled?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Flowable < T > source = new Flowable < T > ( ) @ Override protected void subscribeActual ( Subscriber < ? super T > subscriber ) try BooleanSubscription bs1 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs2 ) ; b [ 0 ] = bs1 . isCancelled ( ) ; b [ 1 ] = bs2 . isCancelled ( ) ; finally cdl . countDown ( ) ; ; MaybeSource < R > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First cancelled?" , false , b [ 0 ] ) ; assertEquals ( "Second not cancelled?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Flowable < T > source = new Flowable < T > ( ) @ Override protected void subscribeActual ( Subscriber < ? super T > subscriber ) try BooleanSubscription bs1 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs2 ) ; b [ 0 ] = bs1 . isCancelled ( ) ; b [ 1 ] = bs2 . isCancelled ( ) ; finally cdl . countDown ( ) ; ; Completable out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First cancelled?" , false , b [ 0 ] ) ; assertEquals ( "Second not cancelled?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable source = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; CompletableSource out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable source = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; MaybeSource < T > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable source = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; SingleSource < T > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable source = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; Publisher < ? > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try final Boolean [ ] b = null , null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable source = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) try Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; b [ 0 ] = d1 . isDisposed ( ) ; b [ 1 ] = d2 . isDisposed ( ) ; finally cdl . countDown ( ) ; ; ObservableSource < ? > out = transform . apply ( source ) ; out . subscribe ( NoOpConsumer . INSTANCE ) ; try assertTrue ( "Timed out" , cdl . await ( 5 , TimeUnit . SECONDS ) ) ; catch ( InterruptedException ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertEquals ( "First disposed?" , false , b [ 0 ] ) ; assertEquals ( "Second not disposed?" , true , b [ 1 ] ) ; assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < T > pp = PublishProcessor . create ( ) ; TestSubscriber < U > ts = new TestSubscriber < > ( ) ; try new MaybeToFlowable < > ( composer . apply ( pp . singleElement ( ) ) ) . subscribe ( ts ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertTrue ( "Not subscribed to source!" , pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( "Dispose not propagated!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; try new CompletableToFlowable < Integer > ( composer . apply ( pp . ignoreElements ( ) ) ) . subscribe ( ts ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertTrue ( "Not subscribed to source!" , pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( "Dispose not propagated!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < T > pp = PublishProcessor . create ( ) ; TestSubscriber < U > ts = new TestSubscriber < > ( ) ; try new SingleToFlowable < > ( composer . apply ( pp . singleElement ( ) ) ) . subscribe ( ts ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < T > pp = PublishProcessor . create ( ) ; TestSubscriber < U > ts = new TestSubscriber < > ( ) ; try new MaybeToFlowable < > ( composer . apply ( pp . singleOrError ( ) ) ) . subscribe ( ts ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
final CountDownLatch cdl = new CountDownLatch ( 1 ) ; final Boolean [ ] state = null , null , null , null ; source . subscribe ( new Observer < T > ( ) @ Override public void onSubscribe ( Disposable d ) try if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < Object > qd = ( QueueDisposable < Object > ) d ; state [ 0 ] = true ; int m = qd . requestFusion ( QueueFuseable . ANY ) ; if ( m != QueueFuseable . NONE ) state [ 1 ] = true ; state [ 2 ] = qd . isEmpty ( ) ; qd . clear ( ) ; state [ 3 ] = qd . isEmpty ( ) ; cdl . countDown ( ) ; finally d . dispose ( ) ; @ Override public void onNext ( T value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; assertTrue ( "Not fuseable" , state [ 0 ] ) ; assertTrue ( "Fusion rejected" , state [ 1 ] ) ; assertNotNull ( state [ 2 ] ) ; assertTrue ( "Did not empty" , state [ 3 ] ) ; catch ( InterruptedException ex ) throw new RuntimeException ( ex ) ; 
final CountDownLatch cdl = new CountDownLatch ( 1 ) ; final Boolean [ ] state = null , null , null , null ; source . subscribe ( new FlowableSubscriber < T > ( ) @ Override public void onSubscribe ( Subscription s ) try if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < Object > qs = ( QueueSubscription < Object > ) s ; state [ 0 ] = true ; int m = qs . requestFusion ( QueueFuseable . ANY ) ; if ( m != QueueFuseable . NONE ) state [ 1 ] = true ; state [ 2 ] = qs . isEmpty ( ) ; qs . clear ( ) ; state [ 3 ] = qs . isEmpty ( ) ; cdl . countDown ( ) ; finally s . cancel ( ) ; @ Override public void onNext ( T value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; try assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; assertTrue ( "Not fuseable" , state [ 0 ] ) ; assertTrue ( "Fusion rejected" , state [ 1 ] ) ; assertNotNull ( state [ 2 ] ) ; assertTrue ( "Did not empty" , state [ 3 ] ) ; catch ( InterruptedException ex ) throw new RuntimeException ( ex ) ; 
return compositeList ( to . errors ( ) . get ( 0 ) ) ; 
return compositeList ( ts . errors ( ) . get ( 0 ) ) ; 
int n = source . parallelism ( ) ; @ SuppressWarnings ( "unchecked" ) TestSubscriber < Object > [ ] tss = new TestSubscriber [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) tss [ i ] = new TestSubscriber < > ( ) . withTag ( "" + i ) ; source . subscribe ( tss ) ; for ( int i = 0 ; i <= n ; i ++ ) tss [ i ] . assertFailure ( IllegalArgumentException . class ) ; 
return new Observable < T > ( ) @ Override protected void subscribeActual ( Observer < ? super T > observer ) observer . onSubscribe ( new QueueDisposable < T > ( ) @ Override public int requestFusion ( int mode ) return 0 ; @ Override public boolean offer ( T value ) throw new IllegalStateException ( ) ; @ Override public boolean offer ( T v1 , T v2 ) throw new IllegalStateException ( ) ; @ Override public T poll ( ) throws Exception return null ; @ Override public boolean isEmpty ( ) return true ; @ Override public void clear ( ) @ Override public void dispose ( ) @ Override public boolean isDisposed ( ) return false ; ) ; ; 
return null ; 
return true ; 
$EMPTY$
$EMPTY$
return false ; 
return new Flowable < T > ( ) @ Override protected void subscribeActual ( Subscriber < ? super T > subscriber ) subscriber . onSubscribe ( new QueueSubscription < T > ( ) @ Override public int requestFusion ( int mode ) return 0 ; @ Override public boolean offer ( T value ) throw new IllegalStateException ( ) ; @ Override public boolean offer ( T v1 , T v2 ) throw new IllegalStateException ( ) ; @ Override public T poll ( ) throws Exception return null ; @ Override public boolean isEmpty ( ) return true ; @ Override public void clear ( ) @ Override public void cancel ( ) @ Override public void request ( long n ) ) ; ; 
return null ; 
return true ; 
$EMPTY$
$EMPTY$
return new FlowableStripBoundary < > ( upstream ) ; 
return qs . poll ( ) ; 
qs . clear ( ) ; 
return qs . isEmpty ( ) ; 
upstream . cancel ( ) ; 
return new FlowableStripBoundary < > ( null ) ; 
return new ObservableStripBoundary < > ( upstream ) ; 
return new ObservableStripBoundary < > ( null ) ; 
return new TestConsumerExConverters < > ( false , 0 ) ; 
TestSubscriberEx < T > tse = new TestSubscriberEx < > ( initialRequest ) ; if ( cancelled ) tse . cancel ( ) ; tse . setInitialFusionMode ( fusionMode ) ; return f . subscribeWith ( tse ) ; 
TestObserverEx < Void > toe = new TestObserverEx < > ( ) ; if ( cancelled ) toe . dispose ( ) ; toe . setInitialFusionMode ( fusionMode ) ; return upstream . subscribeWith ( toe ) ; 
TestObserverEx < T > toe = new TestObserverEx < > ( ) ; if ( cancelled ) toe . dispose ( ) ; toe . setInitialFusionMode ( fusionMode ) ; return upstream . subscribeWith ( toe ) ; 
TestObserverEx < T > toe = new TestObserverEx < > ( ) ; if ( cancelled ) toe . dispose ( ) ; toe . setInitialFusionMode ( fusionMode ) ; return upstream . subscribeWith ( toe ) ; 
TestObserverEx < T > toe = new TestObserverEx < > ( ) ; if ( cancelled ) toe . dispose ( ) ; toe . setInitialFusionMode ( fusionMode ) ; return upstream . subscribeWith ( toe ) ; 
TestSubscriberEx < T > tse = new TestSubscriberEx < > ( ) ; if ( cancelled ) tse . dispose ( ) ; tse . setInitialFusionMode ( fusionMode ) ; return upstream . subscribeWith ( tse ) ; 
return findSource ( baseClassName , "io.reactivex.rxjava3.core" ) ; 
URL u = TestHelper . class . getResource ( TestHelper . class . getSimpleName ( ) + ".class" ) ; String path = new File ( u . toURI ( ) ) . toString ( ) . replace ( '\\' , '/' ) ; parentPackage = parentPackage . replace ( "." , "/" ) ; String p = null ; while ( true ) int idx = path . lastIndexOf ( "/" ) ; if ( idx < 0 ) break ; path = path . substring ( 0 , idx ) ; String check = path + "/src/main/java" ; if ( new File ( check ) . exists ( ) ) p = check + "/" + parentPackage + "/" + baseClassName + ".java" ; break ; if ( p == null ) System . err . println ( "Unable to locate the RxJava sources" ) ; return null ; File f = new File ( p ) ; if ( f . canRead ( ) ) return f ; System . out . println ( "Can't read " + p ) ; return null ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final SerialDisposable disposable = new SerialDisposable ( ) ; T result = Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Throwable disposable . dispose ( ) ; throw new TestException ( ) ; ) . to ( transform ) ; if ( result instanceof MaybeSource ) TestObserverEx < Object > to = new TestObserverEx < > ( ) ; disposable . set ( to ) ; ( ( MaybeSource < ? > ) result ) . subscribe ( to ) ; to . assertEmpty ( ) ; else if ( result instanceof SingleSource ) TestObserverEx < Object > to = new TestObserverEx < > ( ) ; disposable . set ( to ) ; ( ( SingleSource < ? > ) result ) . subscribe ( to ) ; to . assertEmpty ( ) ; else if ( result instanceof CompletableSource ) TestObserverEx < Object > to = new TestObserverEx < > ( ) ; disposable . set ( to ) ; ( ( CompletableSource ) result ) . subscribe ( to ) ; to . assertEmpty ( ) ; else if ( result instanceof ObservableSource ) TestObserverEx < Object > to = new TestObserverEx < > ( ) ; disposable . set ( to ) ; ( ( ObservableSource < ? > ) result ) . subscribe ( to ) ; to . assertEmpty ( ) ; else if ( result instanceof Publisher ) TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; disposable . set ( Disposable . fromSubscription ( ts ) ) ; ( ( Publisher < ? > ) result ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; else fail ( "Unsupported transformation output: " + result + " of class " + ( result != null ? result . getClass ( ) : " <null>" ) ) ; assertFalse ( "No undeliverable errors received" , errors . isEmpty ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final SerialDisposable disposable = new SerialDisposable ( ) ; T result = Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Throwable disposable . dispose ( ) ; throw new TestException ( ) ; ) . to ( transform ) ; if ( result instanceof MaybeSource ) TestObserverEx < Object > to = new TestObserverEx < > ( ) ; disposable . set ( to ) ; ( ( MaybeSource < ? > ) result ) . subscribe ( to ) ; to . assertEmpty ( ) ; else if ( result instanceof SingleSource ) TestObserverEx < Object > to = new TestObserverEx < > ( ) ; disposable . set ( to ) ; ( ( SingleSource < ? > ) result ) . subscribe ( to ) ; to . assertEmpty ( ) ; else if ( result instanceof CompletableSource ) TestObserverEx < Object > to = new TestObserverEx < > ( ) ; disposable . set ( to ) ; ( ( CompletableSource ) result ) . subscribe ( to ) ; to . assertEmpty ( ) ; else if ( result instanceof ObservableSource ) TestObserverEx < Object > to = new TestObserverEx < > ( ) ; disposable . set ( to ) ; ( ( ObservableSource < ? > ) result ) . subscribe ( to ) ; to . assertEmpty ( ) ; else if ( result instanceof Publisher ) TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; disposable . set ( Disposable . fromSubscription ( ts ) ) ; ( ( Publisher < ? > ) result ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; else fail ( "Unsupported transformation output: " + result + " of class " + ( result != null ? result . getClass ( ) : " <null>" ) ) ; assertFalse ( "No undeliverable errors received" , errors . isEmpty ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = trackPluginErrors ( ) ; try action . accept ( errors ) ; finally RxJavaPlugins . reset ( ) ; 
try cf . get ( ) ; fail ( "Should have thrown!" ) ; catch ( Throwable ex ) if ( ! error . isInstance ( ex . getCause ( ) ) ) ex . printStackTrace ( ) ; fail ( "Wrong cause: " + ex . getCause ( ) ) ; 
AtomicInteger sync = new AtomicInteger ( 2 ) ; Schedulers . single ( ) . scheduleDirect ( ( ) -> if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) run . run ( ) ; resume . countDown ( ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) 
return f -> new Flowable < T > ( ) @ Override protected void subscribeActual ( @ NonNull Subscriber < @ NonNull ? super T > subscriber ) f . subscribe ( new ForwardingConditionalSubscriber < > ( subscriber ) ) ; ; 
lastThread = Thread . currentThread ( ) ; if ( d == null ) errors . add ( new NullPointerException ( "onSubscribe received a null Subscription" ) ) ; return ; if ( ! upstream . compareAndSet ( null , d ) ) d . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) errors . add ( new IllegalStateException ( "onSubscribe received multiple subscriptions: " + d ) ) ; return ; if ( initialFusionMode != 0 ) if ( d instanceof QueueDisposable ) qd = ( QueueDisposable < T > ) d ; int m = qd . requestFusion ( initialFusionMode ) ; establishedFusionMode = m ; if ( m == QueueFuseable . SYNC ) checkSubscriptionOnce = true ; lastThread = Thread . currentThread ( ) ; try T t ; while ( ( t = qd . poll ( ) ) != null ) values . add ( t ) ; completions ++ ; upstream . lazySet ( DisposableHelper . DISPOSED ) ; catch ( Throwable ex ) errors . add ( ex ) ; return ; downstream . onSubscribe ( d ) ; 
if ( ! checkSubscriptionOnce ) checkSubscriptionOnce = true ; if ( upstream . get ( ) == null ) errors . add ( new IllegalStateException ( "onSubscribe not called in proper order" ) ) ; try lastThread = Thread . currentThread ( ) ; if ( t == null ) errors . add ( new NullPointerException ( "onError received a null Throwable" ) ) ; else errors . add ( t ) ; downstream . onError ( t ) ; finally done . countDown ( ) ; 
if ( ! checkSubscriptionOnce ) checkSubscriptionOnce = true ; if ( upstream . get ( ) == null ) errors . add ( new IllegalStateException ( "onSubscribe not called in proper order" ) ) ; try lastThread = Thread . currentThread ( ) ; completions ++ ; downstream . onComplete ( ) ; finally done . countDown ( ) ; 
DisposableHelper . dispose ( upstream ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
return upstream . get ( ) != null ; 
if ( upstream . get ( ) == null ) throw fail ( "Not subscribed!" ) ; return this ; 
if ( upstream . get ( ) != null ) throw fail ( "Subscribed!" ) ; else if ( ! errors . isEmpty ( ) ) throw fail ( "Not subscribed but errors found" ) ; return this ; 
if ( qd == null ) throw new AssertionError ( "Upstream is not fuseable." ) ; return this ; 
if ( qd != null ) throw new AssertionError ( "Upstream is fuseable." ) ; return this ; 
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
Single < Integer > cache = Single . just ( 1 ) . cache ( ) ; cache . test ( ) . assertResult ( 1 ) ; cache . test ( ) . assertResult ( 1 ) ; 
Single < Object > cache = Single . error ( new TestException ( ) ) . cache ( ) ; cache . test ( ) . assertFailure ( TestException . class ) ; cache . test ( ) . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Single < Integer > cache = ps . single ( - 99 ) . cache ( ) ; TestObserver < Integer > to1 = cache . test ( ) ; TestObserver < Integer > to2 = cache . test ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to1 . assertResult ( 1 ) ; to2 . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Single < Integer > cache = ps . single ( - 99 ) . cache ( ) ; TestObserver < Integer > to1 = cache . test ( ) ; TestObserver < Integer > to2 = cache . test ( ) ; to1 . dispose ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to1 . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; to2 . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Single < Integer > cache = ps . single ( - 99 ) . cache ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ts1 . cancel ( ) ; ; cache . toFlowable ( ) . subscribe ( ts2 ) ; cache . toFlowable ( ) . subscribe ( ts1 ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; ts1 . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ts2 . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Single < Integer > cache = ps . single ( - 99 ) . cache ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < Integer > ( ) @ Override public void onError ( Throwable t ) super . onError ( t ) ; ts1 . cancel ( ) ; ; cache . toFlowable ( ) . subscribe ( ts2 ) ; cache . toFlowable ( ) . subscribe ( ts1 ) ; ps . onError ( new TestException ( ) ) ; ts1 . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; ts2 . assertFailure ( TestException . class ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single . just ( "Hello World!" ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertValueSequence ( Arrays . asList ( "Hello World!" ) ) ; 
final AtomicReference < String > v = new AtomicReference < > ( ) ; Single . just ( "Hello World!" ) . subscribe ( new SingleObserver < String > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( String value ) v . set ( value ) ; @ Override public void onError ( Throwable error ) ) ; assertEquals ( "Hello World!" , v . get ( ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single . just ( "A" ) . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) return s + "B" ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertValueSequence ( Arrays . asList ( "AB" ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single < String > a = Single . just ( "A" ) ; Single < String > b = Single . just ( "B" ) ; Single . zip ( a , b , new BiFunction < String , String , String > ( ) @ Override public String apply ( String a1 , String b1 ) return a1 + b1 ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertValueSequence ( Arrays . asList ( "AB" ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single . just ( "A" ) . zipWith ( Single . just ( "B" ) , new BiFunction < String , String , String > ( ) @ Override public String apply ( String a1 , String b1 ) return a1 + b1 ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertValueSequence ( Arrays . asList ( "AB" ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single < String > a = Single . just ( "A" ) ; Single < String > b = Single . just ( "B" ) ; Single . merge ( a , b ) . subscribe ( ts ) ; ts . assertValueSequence ( Arrays . asList ( "A" , "B" ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single . just ( "A" ) . mergeWith ( Single . just ( "B" ) ) . subscribe ( ts ) ; ts . assertValueSequence ( Arrays . asList ( "A" , "B" ) ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Single . unsafeCreate ( new SingleSource < Object > ( ) @ Override public void subscribe ( SingleObserver < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( "Hello" ) ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertValueSequence ( Arrays . asList ( "Hello" ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; Single . unsafeCreate ( new SingleSource < Object > ( ) @ Override public void subscribe ( SingleObserver < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new RuntimeException ( "fail" ) ) ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertError ( RuntimeException . class ) ; ts . assertErrorMessage ( "fail" ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single . just ( "Hello" ) . subscribeOn ( Schedulers . io ( ) ) . map ( new Function < String , String > ( ) @ Override public String apply ( String v ) System . out . println ( "SubscribeOn Thread: " + Thread . currentThread ( ) ) ; return v ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < String , String > ( ) @ Override public String apply ( String v ) System . out . println ( "ObserveOn Thread: " + Thread . currentThread ( ) ) ; return v ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueSequence ( Arrays . asList ( "Hello" ) ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; Single . just ( "Hello" ) . flatMap ( new Function < String , Single < String > > ( ) @ Override public Single < String > apply ( String s ) return Single . just ( s + " World!" ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . toFlowable ( ) . subscribe ( ts ) ; if ( ! ts . await ( 5 , TimeUnit . SECONDS ) ) ts . cancel ( ) ; Assert . fail ( "TestSubscriber timed out." ) ; ts . assertValueSequence ( Arrays . asList ( "Hello World!" ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single < String > s1 = Single . < String > unsafeCreate ( new SingleSource < String > ( ) @ Override public void subscribe ( SingleObserver < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; try Thread . sleep ( 5000 ) ; catch ( InterruptedException e ) observer . onSuccess ( "success" ) ; ) . subscribeOn ( Schedulers . io ( ) ) ; s1 . timeout ( 100 , TimeUnit . MILLISECONDS ) . toFlowable ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertError ( TimeoutException . class ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Single < String > s1 = Single . < String > unsafeCreate ( new SingleSource < String > ( ) @ Override public void subscribe ( SingleObserver < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; try Thread . sleep ( 5000 ) ; catch ( InterruptedException e ) observer . onSuccess ( "success" ) ; ) . subscribeOn ( Schedulers . io ( ) ) ; s1 . timeout ( 100 , TimeUnit . MILLISECONDS , Single . just ( "hello" ) ) . toFlowable ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertValue ( "hello" ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; final AtomicBoolean unsubscribed = new AtomicBoolean ( ) ; final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; Single < String > s1 = Single . < String > unsafeCreate ( new SingleSource < String > ( ) @ Override public void subscribe ( final SingleObserver < ? super String > observer ) SerialDisposable sd = new SerialDisposable ( ) ; observer . onSubscribe ( sd ) ; final Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try Thread . sleep ( 5000 ) ; observer . onSuccess ( "success" ) ; catch ( InterruptedException e ) interrupted . set ( true ) ; latch . countDown ( ) ; ) ; sd . replace ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; t . interrupt ( ) ; latch . countDown ( ) ; ) ) ; t . start ( ) ; ) ; s1 . toFlowable ( ) . subscribe ( ts ) ; Thread . sleep ( 100 ) ; ts . cancel ( ) ; if ( latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) assertTrue ( unsubscribed . get ( ) ) ; assertTrue ( interrupted . get ( ) ) ; else fail ( "timed out waiting for latch" ) ; 
final SerialDisposable sd = new SerialDisposable ( ) ; SingleObserver < String > ts = new SingleObserver < String > ( ) @ Override public void onSubscribe ( Disposable d ) sd . replace ( d ) ; @ Override public void onSuccess ( String value ) @ Override public void onError ( Throwable error ) ; final AtomicBoolean unsubscribed = new AtomicBoolean ( ) ; final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; Single < String > s1 = Single . unsafeCreate ( new SingleSource < String > ( ) @ Override public void subscribe ( final SingleObserver < ? super String > observer ) SerialDisposable sd = new SerialDisposable ( ) ; observer . onSubscribe ( sd ) ; final Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try Thread . sleep ( 5000 ) ; observer . onSuccess ( "success" ) ; catch ( InterruptedException e ) interrupted . set ( true ) ; latch . countDown ( ) ; ) ; sd . replace ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; t . interrupt ( ) ; latch . countDown ( ) ; ) ) ; t . start ( ) ; ) ; s1 . subscribe ( ts ) ; Thread . sleep ( 100 ) ; sd . dispose ( ) ; if ( latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) assertTrue ( unsubscribed . get ( ) ) ; assertTrue ( interrupted . get ( ) ) ; else fail ( "timed out waiting for latch" ) ; 
final AtomicBoolean unsubscribed = new AtomicBoolean ( ) ; final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; Single < String > s1 = Single . unsafeCreate ( new SingleSource < String > ( ) @ Override public void subscribe ( final SingleObserver < ? super String > observer ) SerialDisposable sd = new SerialDisposable ( ) ; observer . onSubscribe ( sd ) ; final Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) try Thread . sleep ( 5000 ) ; observer . onSuccess ( "success" ) ; catch ( InterruptedException e ) interrupted . set ( true ) ; latch . countDown ( ) ; ) ; sd . replace ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; t . interrupt ( ) ; latch . countDown ( ) ; ) ) ; t . start ( ) ; ) ; Disposable subscription = s1 . subscribe ( ) ; Thread . sleep ( 100 ) ; subscription . dispose ( ) ; if ( latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) assertTrue ( unsubscribed . get ( ) ) ; assertTrue ( interrupted . get ( ) ) ; else fail ( "timed out waiting for latch" ) ; 
Single < String > s = Single . unsafeCreate ( new SingleSource < String > ( ) @ Override public void subscribe ( SingleObserver < ? super String > t ) t . onSubscribe ( Disposable . empty ( ) ) ; t . onSuccess ( "hello" ) ; ) ; TestSubscriber < String > ts = new TestSubscriber < > ( 0L ) ; s . toFlowable ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValue ( "hello" ) ; 
Flowable < String > a = Single . just ( "a" ) . toFlowable ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; a . subscribe ( ts ) ; ts . assertValue ( "a" ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Single . just ( 1 ) . doOnEvent ( null ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 0 ) ; Single . just ( 1 ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( final Integer integer , final Throwable throwable ) throws Exception if ( integer != null ) atomicInteger . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 0 ) ; Single . error ( new RuntimeException ( ) ) . doOnEvent ( new BiConsumer < Object , Throwable > ( ) @ Override public void accept ( final Object o , final Throwable throwable ) throws Exception if ( throwable != null ) atomicInteger . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
assertEquals ( 1 , Single . just ( 1 ) . toFuture ( ) . get ( ) . intValue ( ) ) ; 
try Single . error ( new TestException ( ) ) . toFuture ( ) . get ( ) ; catch ( ExecutionException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; 
Iterable < ? extends Flowable < Integer > > f = SingleInternalHelper . iterableToFlowable ( Arrays . asList ( Single . just ( 1 ) ) ) ; Iterator < ? extends Flowable < Integer > > iterator = f . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; 
final List < Single < Integer > > singles = Arrays . asList ( Single . just ( 1 ) , Single . just ( 4 ) ) ; Single . zip ( singles , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( final Object [ ] o ) throws Exception int sum = 0 ; for ( Object i : o ) sum += ( Integer ) i ; return sum ; ) . test ( ) . assertResult ( 5 ) ; 
Single . just ( 1 ) . to ( new SingleConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Single < Integer > v ) return v . toFlowable ( ) ; ) . test ( ) . assertResult ( 1 ) ; 
Single . fromObservable ( null ) ; 
Single . fromObservable ( Observable . empty ( ) ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
Single . fromObservable ( Observable . just ( 1 , 2 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( IllegalArgumentException . class ) . assertErrorMessage ( "Sequence contains more than one element!" ) ; 
Single . fromObservable ( Observable . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Single . fromObservable ( Observable . error ( new RuntimeException ( "some error" ) ) ) . to ( TestHelper . testConsumer ( ) ) . assertFailure ( RuntimeException . class ) . assertErrorMessage ( "some error" ) ; 
new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) throw new NullPointerException ( ) ; . test ( ) ; 
final TestScheduler testScheduler = new TestScheduler ( ) ; final AtomicLong atomicLong = new AtomicLong ( ) ; Single . timer ( 2 , TimeUnit . SECONDS , testScheduler ) . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( final Long value ) throws Exception atomicLong . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicLong . get ( ) ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 0 , atomicLong . get ( ) ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 1 , atomicLong . get ( ) ) ; 
final Integer [ ] value = null ; Single . just ( 1 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception value [ 0 ] = v ; ) ; assertEquals ( ( Integer ) 1 , value [ 0 ] ) ; 
final Object [ ] value = null , null ; Single . just ( 1 ) . subscribe ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception value [ 0 ] = v ; value [ 1 ] = e ; ) ; assertEquals ( 1 , value [ 0 ] ) ; assertNull ( value [ 1 ] ) ; 
final Object [ ] value = null , null ; TestException ex = new TestException ( ) ; Single . error ( ex ) . subscribe ( new BiConsumer < Object , Throwable > ( ) @ Override public void accept ( Object v , Throwable e ) throws Exception value [ 0 ] = v ; value [ 1 ] = e ; ) ; assertNull ( value [ 0 ] ) ; assertEquals ( ex , value [ 1 ] ) ; 
try new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) throw new IllegalArgumentException ( ) ; . test ( ) ; catch ( NullPointerException ex ) if ( ! ( ex . getCause ( ) instanceof IllegalArgumentException ) ) fail ( ex . toString ( ) + ": should have thrown NPE(IAE)" ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Disposable d = ps . single ( - 99 ) . subscribe ( new BiConsumer < Object , Object > ( ) @ Override public void accept ( Object t1 , Object t2 ) throws Exception ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Disposable d = ps . single ( - 99 ) . subscribe ( Functions . < Integer > emptyConsumer ( ) ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try Single . just ( 1 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Exception throw new TestException ( ) ; ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try Single . < Integer > error ( new TestException ( "Outer failure" ) ) . subscribe ( Functions . < Integer > emptyConsumer ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throws Exception throw new TestException ( "Inner failure" ) ; ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > cel = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( cel , 0 , TestException . class , "Outer failure" ) ; TestHelper . assertError ( cel , 1 , TestException . class , "Inner failure" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try Single . just ( 1 ) . subscribe ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer t , Throwable e ) throws Exception throw new TestException ( ) ; ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try Single . < Integer > error ( new TestException ( "Outer failure" ) ) . subscribe ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer a , Throwable t ) throws Exception throw new TestException ( "Inner failure" ) ; ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > cel = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( cel , 0 , TestException . class , "Outer failure" ) ; TestHelper . assertError ( cel , 1 , TestException . class , "Inner failure" ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . single ( - 99 ) . test ( false ) ; assertTrue ( ps . hasObservers ( ) ) ; 
assertTrue ( Single . just ( 1 ) . subscribe ( ) . isDisposed ( ) ) ; 
assertTrue ( Single . error ( new TestException ( ) ) . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) . isDisposed ( ) ) ; 
final Object [ ] result = null , null ; Disposable d = Single . just ( 1 ) . subscribe ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer t1 , Throwable t2 ) throws Exception result [ 0 ] = t1 ; result [ 1 ] = t2 ; ) ; assertTrue ( "Not disposed?!" , d . isDisposed ( ) ) ; assertEquals ( 1 , result [ 0 ] ) ; assertNull ( result [ 1 ] ) ; 
final Object [ ] result = null , null ; Disposable d = Single . < Integer > error ( new IOException ( ) ) . subscribe ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer t1 , Throwable t2 ) throws Exception result [ 0 ] = t1 ; result [ 1 ] = t2 ; ) ; assertTrue ( "Not disposed?!" , d . isDisposed ( ) ) ; assertNull ( result [ 0 ] ) ; assertTrue ( "" + result [ 1 ] , result [ 1 ] instanceof IOException ) ; 
Single . amb ( new Iterable < Single < Object > > ( ) @ Override public Iterator < Single < Object > > iterator ( ) return null ; ) . test ( ) . assertError ( NullPointerException . class ) ; 
Single . amb ( Arrays . asList ( null , just1 ) ) . test ( ) . assertError ( NullPointerException . class ) ; 
Single . ambArray ( null , just1 ) . test ( ) . assertError ( NullPointerException . class ) ; 
Single . concat ( new Iterable < Single < Object > > ( ) @ Override public Iterator < Single < Object > > iterator ( ) return null ; ) . blockingSubscribe ( ) ; 
Single . concat ( Arrays . asList ( just1 , null ) ) . blockingSubscribe ( ) ; 
int maxArgs = 4 ; @ SuppressWarnings ( "rawtypes" ) Class < Single > clazz = Single . class ; for ( int argCount = 2 ; argCount <= maxArgs ; argCount ++ ) for ( int argNull = 1 ; argNull <= argCount ; argNull ++ ) Class < ? > [ ] params = new Class [ argCount ] ; Arrays . fill ( params , SingleSource . class ) ; Object [ ] values = new Object [ argCount ] ; Arrays . fill ( values , just1 ) ; values [ argNull - 1 ] = null ; Method m = clazz . getMethod ( "concat" , params ) ; try m . invoke ( null , values ) ; Assert . fail ( "No exception for argCount " + argCount + " / argNull " + argNull ) ; catch ( InvocationTargetException ex ) if ( ! ( ex . getCause ( ) instanceof NullPointerException ) ) Assert . fail ( "Unexpected exception for argCount " + argCount + " / argNull " + argNull + ": " + ex ) ; 
Single . defer ( Functions . < Single < Object > > nullSupplier ( ) ) . blockingGet ( ) ; 
Single . error ( Functions . < Throwable > nullSupplier ( ) ) . blockingGet ( ) ; 
Single . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return null ; ) . blockingGet ( ) ; 
FutureTask < Object > f = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; f . run ( ) ; Single . fromFuture ( f ) . blockingGet ( ) ; 
FutureTask < Object > f = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; f . run ( ) ; Single . fromFuture ( f , 1 , TimeUnit . SECONDS ) . blockingGet ( ) ; 
Single . merge ( new Iterable < Single < Object > > ( ) @ Override public Iterator < Single < Object > > iterator ( ) return null ; ) . blockingSubscribe ( ) ; 
Single . merge ( Arrays . asList ( null , just1 ) ) . blockingSubscribe ( ) ; 
int maxArgs = 4 ; @ SuppressWarnings ( "rawtypes" ) Class < Single > clazz = Single . class ; for ( int argCount = 2 ; argCount <= maxArgs ; argCount ++ ) for ( int argNull = 1 ; argNull <= argCount ; argNull ++ ) Class < ? > [ ] params = new Class [ argCount ] ; Arrays . fill ( params , SingleSource . class ) ; Object [ ] values = new Object [ argCount ] ; Arrays . fill ( values , just1 ) ; values [ argNull - 1 ] = null ; Method m = clazz . getMethod ( "merge" , params ) ; try m . invoke ( null , values ) ; Assert . fail ( "No exception for argCount " + argCount + " / argNull " + argNull ) ; catch ( InvocationTargetException ex ) if ( ! ( ex . getCause ( ) instanceof NullPointerException ) ) Assert . fail ( "Unexpected exception for argCount " + argCount + " / argNull " + argNull + ": " + ex ) ; 
Single . using ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , new Function < Object , Single < Object > > ( ) @ Override public Single < Object > apply ( Object d ) return null ; , Functions . emptyConsumer ( ) ) . blockingGet ( ) ; 
Single . zip ( new Iterable < Single < Object > > ( ) @ Override public Iterator < Single < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingGet ( ) ; 
Single . zip ( Arrays . asList ( null , just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingGet ( ) ; 
Single . zip ( Arrays . asList ( just1 , just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return null ; ) . blockingGet ( ) ; 
@ SuppressWarnings ( "rawtypes" ) Class < Single > clazz = Single . class ; for ( int argCount = 3 ; argCount < 10 ; argCount ++ ) for ( int argNull = 1 ; argNull <= argCount ; argNull ++ ) Class < ? > [ ] params = new Class [ argCount + 1 ] ; Arrays . fill ( params , SingleSource . class ) ; Class < ? > fniClass = Class . forName ( "io.reactivex.rxjava3.functions.Function" + argCount ) ; params [ argCount ] = fniClass ; Object [ ] values = new Object [ argCount + 1 ] ; Arrays . fill ( values , just1 ) ; values [ argNull - 1 ] = null ; values [ argCount ] = Proxy . newProxyInstance ( getClass ( ) . getClassLoader ( ) , new Class [ ] fniClass , new InvocationHandler ( ) @ Override public Object invoke ( Object o , Method m , Object [ ] a ) throws Throwable return 1 ; ) ; Method m = clazz . getMethod ( "zip" , params ) ; try m . invoke ( null , values ) ; Assert . fail ( "No exception for argCount " + argCount + " / argNull " + argNull ) ; catch ( InvocationTargetException ex ) if ( ! ( ex . getCause ( ) instanceof NullPointerException ) ) Assert . fail ( "Unexpected exception for argCount " + argCount + " / argNull " + argNull + ": " + ex ) ; values [ argCount ] = Proxy . newProxyInstance ( getClass ( ) . getClassLoader ( ) , new Class [ ] fniClass , new InvocationHandler ( ) @ Override public Object invoke ( Object o , Method m1 , Object [ ] a ) throws Throwable return null ; ) ; try ( ( Single < Object > ) m . invoke ( null , values ) ) . blockingGet ( ) ; Assert . fail ( "No exception for argCount " + argCount + " / argNull " + argNull ) ; catch ( InvocationTargetException ex ) if ( ! ( ex . getCause ( ) instanceof NullPointerException ) ) Assert . fail ( "Unexpected exception for argCount " + argCount + " / argNull " + argNull + ": " + ex ) ; Class < ? > [ ] params = new Class [ argCount + 1 ] ; Arrays . fill ( params , SingleSource . class ) ; Class < ? > fniClass = Class . forName ( "io.reactivex.rxjava3.functions.Function" + argCount ) ; params [ argCount ] = fniClass ; Object [ ] values = new Object [ argCount + 1 ] ; Arrays . fill ( values , just1 ) ; values [ argCount ] = null ; Method m = clazz . getMethod ( "zip" , params ) ; try m . invoke ( null , values ) ; Assert . fail ( "No exception for argCount " + argCount + " / zipper function " ) ; catch ( InvocationTargetException ex ) if ( ! ( ex . getCause ( ) instanceof NullPointerException ) ) Assert . fail ( "Unexpected exception for argCount " + argCount + " / zipper function: " + ex ) ; 
Single . zip ( Arrays . asList ( just1 , null ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingGet ( ) ; 
Single . zipArray ( new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , just1 , null ) . blockingGet ( ) ; 
Single . zipArray ( new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return null ; , just1 , just1 ) . blockingGet ( ) ; 
just1 . flatMap ( new Function < Integer , Single < Object > > ( ) @ Override public Single < Object > apply ( Integer v ) return null ; ) . blockingGet ( ) ; 
just1 . flatMapPublisher ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . lift ( new SingleOperator < Object , Integer > ( ) @ Override public SingleObserver < ? super Integer > apply ( SingleObserver < ? super Object > observer ) return null ; ) . blockingGet ( ) ; 
error . onErrorReturn ( new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable t ) throws Exception return null ; ) . blockingGet ( ) ; 
try error . onErrorResumeNext ( new Function < Throwable , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Throwable e ) return null ; ) . blockingGet ( ) ; catch ( CompositeException ex ) assertTrue ( ex . toString ( ) , ex . getExceptions ( ) . get ( 1 ) instanceof NullPointerException ) ; 
error . repeatWhen ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > v ) return null ; ) . blockingSubscribe ( ) ; 
error . retryWhen ( new Function < Flowable < ? extends Throwable > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < ? extends Throwable > e ) return null ; ) . blockingGet ( ) ; 
just1 . subscribe ( null , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) ) ; 
just1 . zipWith ( just1 , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingGet ( ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Single . fromCallable ( new Callable < Boolean > ( ) @ Override public Boolean call ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; throw new IllegalArgumentException ( ) ; ) . retry ( Integer . MAX_VALUE , new Predicate < Throwable > ( ) @ Override public boolean test ( final Throwable throwable ) throws Exception return ! ( throwable instanceof IllegalArgumentException ) ; ) . test ( ) . assertFailure ( IllegalArgumentException . class ) ; assertEquals ( 3 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Single . fromCallable ( new Callable < Boolean > ( ) @ Override public Boolean call ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; return true ; ) . retry ( 2 , Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( true ) ; assertEquals ( 3 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Single . fromCallable ( new Callable < Boolean > ( ) @ Override public Boolean call ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; return true ; ) . retry ( 1 , Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( RuntimeException . class ) ; assertEquals ( 2 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 2 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Single . fromCallable ( new Callable < Boolean > ( ) @ Override public Boolean call ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; return true ; ) . retry ( 0 , Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( RuntimeException . class ) ; assertEquals ( 1 , numberOfSubscribeCalls . get ( ) ) ; 
Single . just ( 1 ) . retryUntil ( ( ) -> true ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . retryUntil ( ( ) -> false ) . test ( ) . assertResult ( 1 ) ; 
Single . error ( new TestException ( ) ) . retryUntil ( ( ) -> true ) . test ( ) . assertFailure ( TestException . class ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; Single . defer ( ( ) -> if ( counter . getAndIncrement ( ) == 0 ) return Single . error ( new TestException ( ) ) ; return Single . just ( 1 ) ; ) . retryUntil ( ( ) -> false ) . test ( ) . assertResult ( 1 ) ; 
observer = TestHelper . mockObserver ( ) ; 
return new SerializedObserver < > ( o ) ; 
TestSingleThreadedObservable onSubscribe = new TestSingleThreadedObservable ( "one" , "two" , "three" ) ; Observable < String > w = Observable . unsafeCreate ( onSubscribe ) ; Observer < String > aw = serializedObserver ( observer ) ; w . subscribe ( aw ) ; onSubscribe . waitToFinish ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" ) ; Observable < String > w = Observable . unsafeCreate ( onSubscribe ) ; BusyObserver busySubscriber = new BusyObserver ( ) ; Observer < String > aw = serializedObserver ( busySubscriber ) ; w . subscribe ( aw ) ; onSubscribe . waitToFinish ( ) ; assertEquals ( 3 , busySubscriber . onNextCount . get ( ) ) ; assertFalse ( busySubscriber . onError ) ; assertTrue ( busySubscriber . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busySubscriber . maxConcurrentThreads . get ( ) ) ; 
TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" , null ) ; Observable < String > w = Observable . unsafeCreate ( onSubscribe ) ; BusyObserver busySubscriber = new BusyObserver ( ) ; Observer < String > aw = serializedObserver ( busySubscriber ) ; w . subscribe ( aw ) ; onSubscribe . waitToFinish ( ) ; busySubscriber . terminalEvent . await ( ) ; System . out . println ( "OnSubscribe maxConcurrentThreads: " + onSubscribe . maxConcurrentThreads . get ( ) + "  Observer maxConcurrentThreads: " + busySubscriber . maxConcurrentThreads . get ( ) ) ; assertTrue ( busySubscriber . onNextCount . get ( ) < 4 ) ; assertTrue ( busySubscriber . onError ) ; assertFalse ( busySubscriber . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busySubscriber . maxConcurrentThreads . get ( ) ) ; 
int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" , null , "four" , "five" , "six" , "seven" , "eight" , "nine" ) ; Observable < String > w = Observable . unsafeCreate ( onSubscribe ) ; BusyObserver busySubscriber = new BusyObserver ( ) ; Observer < String > aw = serializedObserver ( busySubscriber ) ; w . subscribe ( aw ) ; onSubscribe . waitToFinish ( ) ; System . out . println ( "OnSubscribe maxConcurrentThreads: " + onSubscribe . maxConcurrentThreads . get ( ) + "  Observer maxConcurrentThreads: " + busySubscriber . maxConcurrentThreads . get ( ) ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busySubscriber . maxConcurrentThreads . get ( ) ) ; System . out . println ( "onNext count: " + busySubscriber . onNextCount . get ( ) ) ; assertFalse ( busySubscriber . onComplete ) ; assertTrue ( busySubscriber . onError ) ; assertTrue ( busySubscriber . onNextCount . get ( ) < 9 ) ; 
ExecutorService tp = Executors . newFixedThreadPool ( 20 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestConcurrencySubscriber tw = new TestConcurrencySubscriber ( ) ; Observer < String > w = serializedObserver ( new SafeObserver < > ( tw ) ) ; Future < ? > f1 = tp . submit ( new OnNextThread ( w , 12000 ) ) ; Future < ? > f2 = tp . submit ( new OnNextThread ( w , 5000 ) ) ; Future < ? > f3 = tp . submit ( new OnNextThread ( w , 75000 ) ) ; Future < ? > f4 = tp . submit ( new OnNextThread ( w , 13500 ) ) ; Future < ? > f5 = tp . submit ( new OnNextThread ( w , 22000 ) ) ; Future < ? > f6 = tp . submit ( new OnNextThread ( w , 15000 ) ) ; Future < ? > f7 = tp . submit ( new OnNextThread ( w , 7500 ) ) ; Future < ? > f8 = tp . submit ( new OnNextThread ( w , 23500 ) ) ; Future < ? > f10 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f1 , f2 , f3 , f4 ) ) ; try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) Future < ? > f11 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f4 , f6 , f7 ) ) ; Future < ? > f12 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f4 , f6 , f7 ) ) ; Future < ? > f13 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f4 , f6 , f7 ) ) ; Future < ? > f14 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f4 , f6 , f7 ) ) ; Future < ? > f15 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onError , f1 , f2 , f3 , f4 ) ) ; Future < ? > f16 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onError , f1 , f2 , f3 , f4 ) ) ; Future < ? > f17 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onError , f1 , f2 , f3 , f4 ) ) ; Future < ? > f18 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onError , f1 , f2 , f3 , f4 ) ) ; waitOnThreads ( f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f10 , f11 , f12 , f13 , f14 , f15 , f16 , f17 , f18 ) ; @ SuppressWarnings ( "unused" ) int numNextEvents = tw . assertEvents ( null ) ; for ( int i = 0 ; i < errors . size ( ) ; i ++ ) TestHelper . assertUndeliverable ( errors , i , RuntimeException . class ) ; catch ( Throwable e ) fail ( "Concurrency test failed: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; finally tp . shutdown ( ) ; try tp . awaitTermination ( 5000 , TimeUnit . MILLISECONDS ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService tp = Executors . newFixedThreadPool ( 20 ) ; try TestConcurrencySubscriber tw = new TestConcurrencySubscriber ( ) ; Observer < String > w = serializedObserver ( new SafeObserver < > ( tw ) ) ; w . onSubscribe ( Disposable . empty ( ) ) ; Future < ? > f1 = tp . submit ( new OnNextThread ( w , 12000 ) ) ; Future < ? > f2 = tp . submit ( new OnNextThread ( w , 5000 ) ) ; Future < ? > f3 = tp . submit ( new OnNextThread ( w , 75000 ) ) ; Future < ? > f4 = tp . submit ( new OnNextThread ( w , 13500 ) ) ; Future < ? > f5 = tp . submit ( new OnNextThread ( w , 22000 ) ) ; Future < ? > f6 = tp . submit ( new OnNextThread ( w , 15000 ) ) ; Future < ? > f7 = tp . submit ( new OnNextThread ( w , 7500 ) ) ; Future < ? > f8 = tp . submit ( new OnNextThread ( w , 23500 ) ) ; Future < ? > f10 = tp . submit ( new CompletionThread ( w , TestConcurrencySubscriberEvent . onComplete , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 ) ) ; try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) waitOnThreads ( f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f10 ) ; int numNextEvents = tw . assertEvents ( null ) ; assertEquals ( 173500 , numNextEvents ) ; catch ( Throwable e ) fail ( "Concurrency test failed: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; finally tp . shutdown ( ) ; try tp . awaitTermination ( 25000 , TimeUnit . MILLISECONDS ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; 
ExecutorService tp1 = Executors . newFixedThreadPool ( 1 ) ; ExecutorService tp2 = Executors . newFixedThreadPool ( 1 ) ; try int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) final CountDownLatch firstOnNext = new CountDownLatch ( 1 ) ; final CountDownLatch onNextCount = new CountDownLatch ( 2 ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final CountDownLatch running = new CountDownLatch ( 2 ) ; TestObserverEx < String > to = new TestObserverEx < > ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String t ) firstOnNext . countDown ( ) ; try latch . await ( ) ; catch ( InterruptedException e ) ) ; Observer < String > o = serializedObserver ( to ) ; Future < ? > f1 = tp1 . submit ( new OnNextThread ( o , 1 , onNextCount , running ) ) ; Future < ? > f2 = tp2 . submit ( new OnNextThread ( o , 1 , onNextCount , running ) ) ; running . await ( ) ; firstOnNext . await ( ) ; Thread t1 = to . lastThread ( ) ; System . out . println ( "first onNext on thread: " + t1 ) ; latch . countDown ( ) ; waitOnThreads ( f1 , f2 ) ; assertEquals ( 2 , to . values ( ) . size ( ) ) ; Thread t2 = to . lastThread ( ) ; System . out . println ( "second onNext on thread: " + t2 ) ; assertSame ( t1 , t2 ) ; System . out . println ( to . values ( ) ) ; o . onComplete ( ) ; System . out . println ( to . values ( ) ) ; finally tp1 . shutdown ( ) ; tp2 . shutdown ( ) ; 
$EMPTY$
$EMPTY$
firstOnNext . countDown ( ) ; try latch . await ( ) ; catch ( InterruptedException e ) 
TestObserver < String > to = new TestObserver < > ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( String t ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) ) ; final Observer < String > o = serializedObserver ( to ) ; AtomicInteger p1 = new AtomicInteger ( ) ; AtomicInteger p2 = new AtomicInteger ( ) ; o . onSubscribe ( Disposable . empty ( ) ) ; DisposableObserver < String > as1 = new DisposableObserver < String > ( ) @ Override public void onNext ( String t ) o . onNext ( t ) ; @ Override public void onError ( Throwable t ) RxJavaPlugins . onError ( t ) ; @ Override public void onComplete ( ) ; DisposableObserver < String > as2 = new DisposableObserver < String > ( ) @ Override public void onNext ( String t ) o . onNext ( t ) ; @ Override public void onError ( Throwable t ) RxJavaPlugins . onError ( t ) ; @ Override public void onComplete ( ) ; infinite ( p1 ) . subscribe ( as1 ) ; infinite ( p2 ) . subscribe ( as2 ) ; Thread . sleep ( 100 ) ; System . out . println ( "p1: " + p1 . get ( ) + " p2: " + p2 . get ( ) + " => should be close to each other unless we have thread starvation" ) ; assertEquals ( p1 . get ( ) , p2 . get ( ) , 10000 ) ; as1 . dispose ( ) ; as2 . dispose ( ) ; 
$EMPTY$
$EMPTY$
try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) 
return Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) Disposable bs = Disposable . empty ( ) ; observer . onSubscribe ( bs ) ; while ( ! bs . isDisposed ( ) ) observer . onNext ( "onNext" ) ; produced . incrementAndGet ( ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) ; 
Disposable bs = Disposable . empty ( ) ; observer . onSubscribe ( bs ) ; while ( ! bs . isDisposed ( ) ) observer . onNext ( "onNext" ) ; produced . incrementAndGet ( ) ; 
if ( running != null ) running . countDown ( ) ; for ( int i = 0 ; i < numStringsToSend ; i ++ ) observer . onNext ( Thread . currentThread ( ) . getId ( ) + "-" + i ) ; if ( latch != null ) latch . countDown ( ) ; produced . incrementAndGet ( ) ; 
if ( waitOnThese != null ) for ( Future < ? > f : waitOnThese ) try f . get ( ) ; catch ( Throwable e ) System . err . println ( "Error while waiting on future in CompletionThread" ) ; if ( event == TestConcurrencySubscriberEvent . onError ) observer . onError ( new RuntimeException ( "mocked exception" ) ) ; else if ( event == TestConcurrencySubscriberEvent . onComplete ) observer . onComplete ( ) ; else throw new IllegalArgumentException ( "Expecting either onError or onComplete" ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "TestSingleThreadedObservable subscribed to ..." ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestSingleThreadedObservable thread" ) ; for ( String s : values ) System . out . println ( "TestSingleThreadedObservable onNext: " + s ) ; observer . onNext ( s ) ; observer . onComplete ( ) ; catch ( Throwable e ) throw new RuntimeException ( e ) ; ) ; System . out . println ( "starting TestSingleThreadedObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestSingleThreadedObservable thread" ) ; 
try t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; 
try t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; 
int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; if ( concurrentThreads > 1 ) new RuntimeException ( "should not be greater than 1" ) . printStackTrace ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Observer < Integer > > serial = new AtomicReference < > ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer v ) serial . get ( ) . onError ( new TestException ( ) ) ; serial . get ( ) . onError ( new TestException ( ) ) ; super . onNext ( v ) ; ; SerializedObserver < Integer > sobs = new SerializedObserver < > ( to ) ; sobs . onSubscribe ( Disposable . empty ( ) ) ; serial . set ( sobs ) ; sobs . onNext ( 1 ) ; to . assertValue ( 1 ) ; to . assertError ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final AtomicReference < Observer < Integer > > serial = new AtomicReference < > ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer v ) serial . get ( ) . onComplete ( ) ; serial . get ( ) . onComplete ( ) ; super . onNext ( v ) ; ; SerializedObserver < Integer > sobs = new SerializedObserver < > ( to ) ; sobs . onSubscribe ( Disposable . empty ( ) ) ; serial . set ( sobs ) ; sobs . onNext ( 1 ) ; to . assertValue ( 1 ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; SerializedObserver < Integer > so = new SerializedObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; assertFalse ( so . isDisposed ( ) ) ; to . dispose ( ) ; assertTrue ( so . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; final SerializedObserver < Integer > so = new SerializedObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) so . onComplete ( ) ; ; TestHelper . race ( r , r ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; final SerializedObserver < Integer > so = new SerializedObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . size ( ) <= 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; final SerializedObserver < Integer > so = new SerializedObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertError ( ex ) . assertNotComplete ( ) ; assertTrue ( to . values ( ) . size ( ) <= 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; final SerializedObserver < Integer > so = new SerializedObserver < > ( to , true ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertError ( ex ) . assertNotComplete ( ) ; assertTrue ( to . values ( ) . size ( ) <= 1 ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = new TestObserver < > ( ) ; final SerializedObserver < Integer > so = new SerializedObserver < > ( to ) ; so . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; final SerializedObserver < Integer > so = new SerializedObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) so . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) so . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( to . completions ( ) != 0 ) to . assertResult ( ) ; else to . assertFailure ( TestException . class ) . assertError ( ex ) ; for ( Throwable e : errors ) assertTrue ( e . toString ( ) , e . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; final SerializedObserver < Integer > so = new SerializedObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; so . onNext ( null ) ; to . assertFailureAndMessage ( NullPointerException . class , ExceptionHelper . nullWarning ( "onNext called with a null value." ) ) ; 
AtomicReference < SerializedObserver < Integer > > soRef = new AtomicReference < > ( ) ; TestObserverEx < Integer > to = new TestObserverEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; soRef . get ( ) . onNext ( 2 ) ; soRef . get ( ) . onError ( new TestException ( ) ) ; ; final SerializedObserver < Integer > so = new SerializedObserver < > ( to , true ) ; soRef . set ( so ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; so . onNext ( 1 ) ; to . assertFailure ( TestException . class , 1 , 2 ) ; 
assertEquals ( message , assertThrows ( clazz , run ) . getMessage ( ) ) ; 
assertTrue ( assertThrows ( clazz , run ) . getMessage ( ) . matches ( regex ) ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < > ( ) ; oi . subscribe ( subscriber ) ; subscriber . assertValues ( 1 , 2 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertComplete ( ) . assertNoErrors ( ) ; 
assertThrows ( AssertionError . class , ( ) -> Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < > ( ) ; oi . subscribe ( subscriber ) ; subscriber . assertValue ( 1 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertComplete ( ) . assertNoErrors ( ) ; ) ; 
assertThrows ( AssertionError . class , ( ) -> Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < > ( ) ; oi . subscribe ( subscriber ) ; subscriber . assertValues ( 1 , 3 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertComplete ( ) . assertNoErrors ( ) ; ) ; 
assertThrows ( AssertionError . class , ( ) -> PublishProcessor < Integer > p = PublishProcessor . create ( ) ; TestSubscriber < Integer > subscriber = new TestSubscriber < > ( ) ; p . subscribe ( subscriber ) ; p . onNext ( 1 ) ; p . onNext ( 2 ) ; subscriber . assertValues ( 1 , 2 ) ; subscriber . assertValueCount ( 2 ) ; subscriber . assertComplete ( ) . assertNoErrors ( ) ; ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 ) ) ; Subscriber < Integer > mockSubscriber = TestHelper . mockSubscriber ( ) ; oi . subscribe ( new TestSubscriber < > ( mockSubscriber ) ) ; InOrder inOrder = inOrder ( mockSubscriber ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > oi = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ) . take ( 2 ) ; Subscriber < Integer > mockSubscriber = TestHelper . mockSubscriber ( ) ; oi . subscribe ( new TestSubscriber < > ( mockSubscriber ) ) ; InOrder inOrder = inOrder ( mockSubscriber ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( mockSubscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable . error ( new RuntimeException ( ) ) . subscribe ( new TestSubscriber < > ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onNext ( 1 ) ; try ts . assertValue ( ( Integer ) null ) ; catch ( AssertionError ex ) return ; fail ( "Null element check assertion didn't happen!" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onNext ( null ) ; try ts . assertValue ( 1 ) ; catch ( AssertionError ex ) return ; fail ( "Null element check assertion didn't happen!" ) ; 
TestObserver < Integer > to1 = TestObserver . create ( ) ; TestObserver < Integer > to = TestObserver . create ( to1 ) ; assertFalse ( to . hasSubscription ( ) ) ; to . onSubscribe ( Disposable . empty ( ) ) ; assertTrue ( to . hasSubscription ( ) ) ; assertFalse ( to . isDisposed ( ) ) ; to . onNext ( 1 ) ; to . onError ( new TestException ( ) ) ; to . onComplete ( ) ; to1 . assertValue ( 1 ) . assertError ( TestException . class ) . assertComplete ( ) ; to . dispose ( ) ; assertTrue ( to . isDisposed ( ) ) ; try to . assertNoValues ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertValueCount ( 0 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) to . assertValueSequence ( Collections . singletonList ( 1 ) ) ; try to . assertValueSequence ( Collections . singletonList ( 2 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) 
TestObserver < Integer > to = TestObserver . create ( ) ; try to . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertError ( new TestException ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertSubscribed ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) to . onSubscribe ( Disposable . empty ( ) ) ; to . assertSubscribed ( ) ; to . assertNoErrors ( ) ; TestException ex = new TestException ( "Forced failure" ) ; to . onError ( ex ) ; to . assertError ( ex ) ; to . assertError ( TestException . class ) ; to . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable t ) throws Exception return t . getMessage ( ) != null && t . getMessage ( ) . contains ( "Forced" ) ; ) ; try to . assertError ( new RuntimeException ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertError ( IOException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertError ( Functions . < Throwable > alwaysFalse ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) try to . assertNoErrors ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError exc ) to . assertValueCount ( 0 ) ; to . assertNoValues ( ) ; 
assertEquals ( 1 , TestObserver . EmptyObserver . values ( ) . length ) ; assertNotNull ( TestObserver . EmptyObserver . valueOf ( "INSTANCE" ) ) ; 
assertEquals ( "null" , TestObserver . valueAndClass ( null ) ) ; assertEquals ( "1 (class: Integer)" , TestObserver . valueAndClass ( 1 ) ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onError ( new TestException ( "Forced failure" ) ) ; to . assertFailure ( TestException . class ) ; to . onNext ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to = TestObserver . create ( ) ; to . onSubscribe ( new ScalarDisposable < > ( to , 1 ) ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onComplete ( ) ; to . assertResult ( ) ; try to . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) to . onNext ( 1 ) ; to . assertResult ( 1 ) ; try to . assertResult ( 2 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) try to . assertResult ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( to . await ( 100 , TimeUnit . MILLISECONDS ) ) ; to . awaitDone ( 100 , TimeUnit . MILLISECONDS ) ; assertTrue ( to . isDisposed ( ) ) ; assertFalse ( to . await ( 100 , TimeUnit . MILLISECONDS ) ) ; to . assertNotComplete ( ) ; to . assertNoErrors ( ) ; to . onComplete ( ) ; assertTrue ( to . await ( 100 , TimeUnit . MILLISECONDS ) ) ; to . await ( ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; assertTrue ( to . await ( 5 , TimeUnit . SECONDS ) ) ; final TestObserver < Integer > to1 = TestObserver . create ( ) ; to1 . onSubscribe ( Disposable . empty ( ) ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) to1 . onComplete ( ) ; , 200 , TimeUnit . MILLISECONDS ) ; to1 . await ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; assertEquals ( 0 , to . values ( ) . size ( ) ) ; assertEquals ( Collections . emptyList ( ) , to . values ( ) ) ; to . onNext ( 1 ) ; assertEquals ( Collections . singletonList ( 1 ) , to . values ( ) ) ; to . dispose ( ) ; assertTrue ( to . isDisposed ( ) ) ; to . assertValue ( 1 ) ; to . onComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertNotComplete ( ) ; to . onComplete ( ) ; try to . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) to . onComplete ( ) ; try to . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) try to . assertNotComplete ( ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . assertValue ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) to . onNext ( 1 ) ; to . assertValue ( 1 ) ; try to . assertValue ( 2 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) to . onNext ( 2 ) ; try to . assertValue ( 1 ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( Throwable ex ) 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onNext ( 1 ) ; to . assertError ( IllegalStateException . class ) ; to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onNext ( null ) ; to . assertFailure ( NullPointerException . class , ( Integer ) null ) ; 
final TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; try to . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException allowed ) assertTrue ( allowed . toString ( ) , allowed . getCause ( ) instanceof InterruptedException ) ; Thread . currentThread ( ) . interrupt ( ) ; try to . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException allowed ) assertTrue ( allowed . toString ( ) , allowed . getCause ( ) instanceof InterruptedException ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onError ( new TestException ( ) ) ; to . onError ( new IOException ( ) ) ; try to . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError ex ) to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onError ( new TestException ( ) ) ; to . onComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( null ) ; to . assertError ( NullPointerException . class ) ; to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; Disposable d1 = Disposable . empty ( ) ; to . onSubscribe ( d1 ) ; assertTrue ( d1 . isDisposed ( ) ) ; to . assertError ( IllegalStateException . class ) ; to = TestObserver . create ( ) ; to . dispose ( ) ; d1 = Disposable . empty ( ) ; to . onSubscribe ( d1 ) ; assertTrue ( d1 . isDisposed ( ) ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onNext ( 1 ) ; to . onNext ( 2 ) ; try to . assertValueSequence ( Collections . < Integer > emptyList ( ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError expected ) assertTrue ( expected . getMessage ( ) , expected . getMessage ( ) . startsWith ( "More values received than expected (0)" ) ) ; try to . assertValueSequence ( Collections . singletonList ( 1 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError expected ) assertTrue ( expected . getMessage ( ) , expected . getMessage ( ) . startsWith ( "More values received than expected (1)" ) ) ; to . assertValueSequence ( Arrays . asList ( 1 , 2 ) ) ; try to . assertValueSequence ( Arrays . asList ( 1 , 2 , 3 ) ) ; throw new RuntimeException ( "Should have thrown" ) ; catch ( AssertionError expected ) assertTrue ( expected . getMessage ( ) , expected . getMessage ( ) . startsWith ( "Fewer values received than expected (2)" ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; try to . assertEmpty ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) to . onSubscribe ( Disposable . empty ( ) ) ; to . assertEmpty ( ) ; to . onNext ( 1 ) ; try to . assertEmpty ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestObserver < Integer > to = new TestObserver < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try to . awaitDone ( 5 , TimeUnit . SECONDS ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; TestException e = new TestException ( ) ; to . onError ( e ) ; to . onError ( new TestException ( ) ) ; try to . assertError ( TestException . class ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) try to . assertError ( e ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) try to . assertError ( Functions . < Throwable > alwaysTrue ( ) ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onError ( new RuntimeException ( ) ) ; try to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable throwable ) throws Exception throw new TestException ( ) ; ) ; catch ( TestException ex ) return ; fail ( "Error in predicate but not thrown!" ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) to . onComplete ( ) ; to . assertComplete ( ) ; to . onComplete ( ) ; try to . assertComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) 
TestObserver < Integer > to = new TestObserver < > ( ) ; to . onComplete ( ) ; to . assertError ( IllegalStateException . class ) ; 
TestObserver < Integer > to = new TestObserver < > ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . onComplete ( ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( TestException ex ) to . assertComplete ( ) . assertNoErrors ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; to . onSubscribe ( Disposable . empty ( ) ) ; try to . onError ( new IOException ( ) ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( TestException ex ) to . assertNotComplete ( ) . assertError ( Throwable . class ) ; 
assertFalse ( Observable . just ( 1 ) . test ( ) . assertResult ( 1 ) . isDisposed ( ) ) ; 
assertFalse ( Observable . error ( new TestException ( ) ) . test ( ) . assertFailure ( TestException . class ) . isDisposed ( ) ) ; 
assertThrowsWithMessage ( "No values (latch = 0, values = 0, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < Object > to = new TestObserver < > ( ) ; Observable . empty ( ) . subscribe ( to ) ; to . assertValue ( new Predicate < Object > ( ) @ Override public boolean test ( final Object o ) throws Exception return false ; ) ; ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . subscribe ( to ) ; to . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; 
assertThrowsWithMessage ( "Value 1 (class: Integer) at position 0 did not pass the predicate (latch = 0, values = 1, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . subscribe ( to ) ; to . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o != 1 ; ) ; ) ; 
assertThrowsWithMessage ( "The first value passed the predicate but this consumer received more than one value (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . subscribe ( to ) ; to . assertValue ( new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
assertThrowsWithMessage ( "No values (latch = 0, values = 0, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < Object > to = new TestObserver < > ( ) ; Observable . empty ( ) . subscribe ( to ) ; to . assertValueAt ( 0 , new Predicate < Object > ( ) @ Override public boolean test ( final Object o ) throws Exception return false ; ) ; ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . subscribe ( to ) ; to . assertValueAt ( 1 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 2 ; ) ; 
assertThrowsWithMessage ( "Value 3 (class: Integer) at position 2 did not pass the predicate (latch = 0, values = 3, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 , 3 ) . subscribe ( to ) ; to . assertValueAt ( 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o != 3 ; ) ; ) ; 
assertThrowsWithMessage ( "Index 2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . subscribe ( to ) ; to . assertValueAt ( 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
assertThrowsWithMessage ( "Index -2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . subscribe ( to ) ; to . assertValueAt ( - 2 , new Predicate < Integer > ( ) @ Override public boolean test ( final Integer o ) throws Exception return o == 1 ; ) ; ) ; 
assertThrowsWithMessage ( "No values (latch = 0, values = 0, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < Object > to = new TestObserver < > ( ) ; Observable . empty ( ) . subscribe ( to ) ; to . assertValueAt ( 0 , "a" ) ; ) ; 
TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" ) . subscribe ( to ) ; to . assertValueAt ( 1 , "b" ) ; 
assertThrowsWithMessage ( "\nexpected: b (class: String)\ngot: c (class: String); Value at position 2 differ (latch = 0, values = 3, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValueAt ( 2 , "b" ) ; ) ; 
assertThrowsWithMessageMatchRegex ( ASSERT_MESSAGE_REGEX , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValueAt ( 2 , "b" ) ; ) ; 
assertThrowsWithMessage ( "\nexpected: 2 [a, b]\ngot: 3 [a, b, c]; Value count differs (latch = 0, values = 3, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValues ( "a" , "b" ) ; ) ; 
assertThrowsWithMessageMatchRegex ( ASSERT_MESSAGE_REGEX , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValues ( "a" , "b" ) ; ) ; 
assertThrowsWithMessage ( "\nexpected: d (class: String)\ngot: c (class: String); Value at position 2 differ (latch = 0, values = 3, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValues ( "a" , "b" , "d" ) ; ) ; 
assertThrowsWithMessageMatchRegex ( ASSERT_MESSAGE_REGEX , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValues ( "a" , "b" , "d" ) ; ) ; 
assertThrowsWithMessage ( "\nexpected: 2\ngot: 3; Value counts differ (latch = 0, values = 3, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValueCount ( 2 ) ; ) ; 
assertThrowsWithMessageMatchRegex ( ASSERT_MESSAGE_REGEX , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValueCount ( 2 ) ; ) ; 
assertThrowsWithMessage ( "\nexpected: d (class: String)\ngot: c (class: String); Value at position 2 differ (latch = 0, values = 3, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValueSequence ( Arrays . asList ( "a" , "b" , "d" ) ) ; ) ; 
assertThrowsWithMessageMatchRegex ( ASSERT_MESSAGE_REGEX , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" , "c" ) . subscribe ( to ) ; to . assertValueSequence ( Arrays . asList ( "a" , "b" , "d" ) ) ; ) ; 
assertThrowsWithMessage ( "Index 2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" ) . subscribe ( to ) ; to . assertValueAt ( 2 , "c" ) ; ) ; 
assertThrowsWithMessage ( "Index -2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)" , AssertionError . class , ( ) -> TestObserver < String > to = new TestObserver < > ( ) ; Observable . just ( "a" , "b" ) . subscribe ( to ) ; to . assertValueAt ( - 2 , "c" ) ; ) ; 
try for ( int i = 1 ; i < 3 ; i ++ ) Observable . just ( i ) . test ( ) . withTag ( "testing with item=" + i ) . assertResult ( 1 ) ; throw new RuntimeException ( "Should have thrown!" ) ; catch ( AssertionError ex ) assertTrue ( ex . toString ( ) , ex . toString ( ) . contains ( "testing with item=2" ) ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertValuesOnly ( ) ; to . onNext ( 5 ) ; to . assertValuesOnly ( 5 ) ; to . onNext ( - 1 ) ; to . assertValuesOnly ( 5 , - 1 ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . assertValuesOnly ( ) ; to . onNext ( 5 ) ; to . assertValuesOnly ( 5 ) ; to . onNext ( - 1 ) ; try to . assertValuesOnly ( 5 ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onComplete ( ) ; try to . assertValuesOnly ( ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onError ( new TestException ( ) ) ; try to . assertValuesOnly ( ) ; throw new RuntimeException ( ) ; catch ( AssertionError ex ) 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . onError ( null ) ; to . assertFailure ( NullPointerException . class ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; to . awaitCount ( 1 ) ; assertTrue ( to . timeout ) ; 
try TestObserver < Integer > to = TestObserver . create ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; to . awaitCount ( 1 ) ; finally Thread . interrupted ( ) ; 
super . onStart ( ) ; start ++ ; 
complete ++ ; dispose ( ) ; 
errors . add ( e ) ; dispose ( ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; rmo . add ( null ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; assertFalse ( rmo . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rmo . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rmo . dispose ( ) ; assertTrue ( rmo . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; rmo . dispose ( ) ; assertTrue ( rmo . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; assertFalse ( rmo . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rmo . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rmo . onComplete ( ) ; assertTrue ( rmo . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; assertFalse ( rmo . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rmo . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rmo . onSuccess ( 1 ) ; assertTrue ( rmo . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; assertFalse ( rmo . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rmo . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rmo . onError ( new TestException ( ) ) ; assertTrue ( rmo . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; assertFalse ( rmo . isDisposed ( ) ) ; assertEquals ( 0 , rmo . start ) ; assertNull ( rmo . value ) ; assertTrue ( rmo . errors . isEmpty ( ) ) ; Maybe . just ( 1 ) . subscribe ( rmo ) ; assertTrue ( rmo . isDisposed ( ) ) ; assertEquals ( 1 , rmo . start ) ; assertEquals ( Integer . valueOf ( 1 ) , rmo . value ) ; assertEquals ( 0 , rmo . complete ) ; assertTrue ( rmo . errors . isEmpty ( ) ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; assertFalse ( rmo . isDisposed ( ) ) ; assertEquals ( 0 , rmo . start ) ; assertNull ( rmo . value ) ; assertTrue ( rmo . errors . isEmpty ( ) ) ; Maybe . < Integer > empty ( ) . subscribe ( rmo ) ; assertTrue ( rmo . isDisposed ( ) ) ; assertEquals ( 1 , rmo . start ) ; assertNull ( rmo . value ) ; assertEquals ( 1 , rmo . complete ) ; assertTrue ( rmo . errors . isEmpty ( ) ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; assertFalse ( rmo . isDisposed ( ) ) ; assertEquals ( 0 , rmo . start ) ; assertNull ( rmo . value ) ; assertTrue ( rmo . errors . isEmpty ( ) ) ; final RuntimeException error = new RuntimeException ( "error" ) ; Maybe . < Integer > error ( error ) . subscribe ( rmo ) ; assertTrue ( rmo . isDisposed ( ) ) ; assertEquals ( 1 , rmo . start ) ; assertNull ( rmo . value ) ; assertEquals ( 0 , rmo . complete ) ; assertEquals ( 1 , rmo . errors . size ( ) ) ; assertTrue ( rmo . errors . contains ( error ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; rmo . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; rmo . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , rmo . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( rmo . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestResourceMaybeObserver < Integer > rmo = new TestResourceMaybeObserver < > ( ) ; rmo . dispose ( ) ; Disposable d = Disposable . empty ( ) ; rmo . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , rmo . start ) ; 
super . onStart ( ) ; start ++ ; 
errors . add ( e ) ; 
TestSingle < Integer > tc = new TestSingle < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; assertTrue ( tc . values . isEmpty ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; Single . just ( 1 ) . subscribe ( tc ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( 1 , tc . values . get ( 0 ) . intValue ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestSingle < Integer > tc = new TestSingle < > ( ) ; tc . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( tc . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestSingle < Integer > tc = new TestSingle < > ( ) ; tc . dispose ( ) ; assertTrue ( tc . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; 
super . onStart ( ) ; start ++ ; 
complete ++ ; dispose ( ) ; 
errors . add ( e ) ; dispose ( ) ; 
TestResourceCompletableObserver rco = new TestResourceCompletableObserver ( ) ; rco . add ( null ) ; 
TestResourceCompletableObserver rco = new TestResourceCompletableObserver ( ) ; assertFalse ( rco . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rco . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rco . dispose ( ) ; assertTrue ( rco . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; rco . dispose ( ) ; assertTrue ( rco . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceCompletableObserver rco = new TestResourceCompletableObserver ( ) ; assertFalse ( rco . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rco . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rco . onComplete ( ) ; assertTrue ( rco . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceCompletableObserver rco = new TestResourceCompletableObserver ( ) ; assertFalse ( rco . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rco . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rco . onError ( new TestException ( ) ) ; assertTrue ( rco . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceCompletableObserver rco = new TestResourceCompletableObserver ( ) ; assertFalse ( rco . isDisposed ( ) ) ; assertEquals ( 0 , rco . start ) ; assertTrue ( rco . errors . isEmpty ( ) ) ; Completable . complete ( ) . subscribe ( rco ) ; assertTrue ( rco . isDisposed ( ) ) ; assertEquals ( 1 , rco . start ) ; assertEquals ( 1 , rco . complete ) ; assertTrue ( rco . errors . isEmpty ( ) ) ; 
TestResourceCompletableObserver rco = new TestResourceCompletableObserver ( ) ; assertFalse ( rco . isDisposed ( ) ) ; assertEquals ( 0 , rco . start ) ; assertTrue ( rco . errors . isEmpty ( ) ) ; final RuntimeException error = new RuntimeException ( "error" ) ; Completable . error ( error ) . subscribe ( rco ) ; assertTrue ( rco . isDisposed ( ) ) ; assertEquals ( 1 , rco . start ) ; assertEquals ( 0 , rco . complete ) ; assertEquals ( 1 , rco . errors . size ( ) ) ; assertTrue ( rco . errors . contains ( error ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestResourceCompletableObserver rco = new TestResourceCompletableObserver ( ) ; rco . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; rco . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , rco . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( rco . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestResourceCompletableObserver rco = new TestResourceCompletableObserver ( ) ; rco . dispose ( ) ; Disposable d = Disposable . empty ( ) ; rco . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , rco . start ) ; 
super . onStart ( ) ; start ++ ; 
errors . add ( e ) ; 
completions ++ ; 
TestDisposableObserver < Integer > tc = new TestDisposableObserver < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; assertTrue ( tc . values . isEmpty ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; Observable . just ( 1 ) . subscribe ( tc ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( 1 , tc . values . get ( 0 ) . intValue ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestDisposableObserver < Integer > tc = new TestDisposableObserver < > ( ) ; tc . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( tc . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestDisposableObserver < Integer > tc = new TestDisposableObserver < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; tc . dispose ( ) ; assertTrue ( tc . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; 
super . onStart ( ) ; start ++ ; 
errors . add ( e ) ; 
complete ++ ; 
TestMaybe < Integer > tc = new TestMaybe < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; assertTrue ( tc . values . isEmpty ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; assertEquals ( 0 , tc . complete ) ; Maybe . just ( 1 ) . subscribe ( tc ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( 1 , tc . values . get ( 0 ) . intValue ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; assertEquals ( 0 , tc . complete ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestMaybe < Integer > tc = new TestMaybe < > ( ) ; tc . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( tc . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestMaybe < Integer > tc = new TestMaybe < > ( ) ; tc . dispose ( ) ; assertTrue ( tc . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; 
AtomicReference < Throwable > onError = new AtomicReference < > ( ) ; try OBSERVER_ONNEXT_FAIL ( onError ) . onNext ( "one" ) ; fail ( "expects exception to be thrown" ) ; catch ( Exception e ) assertNull ( onError . get ( ) ) ; assertTrue ( e instanceof SafeObserverTestException ) ; assertEquals ( "onNextFail" , e . getMessage ( ) ) ; 
AtomicReference < Throwable > onError = new AtomicReference < > ( ) ; try SafeObserver < String > safeObserver = new SafeObserver < > ( OBSERVER_ONNEXT_FAIL ( onError ) ) ; safeObserver . onSubscribe ( Disposable . empty ( ) ) ; safeObserver . onNext ( "one" ) ; assertNotNull ( onError . get ( ) ) ; assertTrue ( onError . get ( ) instanceof SafeObserverTestException ) ; assertEquals ( "onNextFail" , onError . get ( ) . getMessage ( ) ) ; catch ( Exception e ) fail ( "expects exception to be passed to onError" ) ; 
AtomicReference < Throwable > onError = new AtomicReference < > ( ) ; try OBSERVER_ONCOMPLETED_FAIL ( onError ) . onComplete ( ) ; fail ( "expects exception to be thrown" ) ; catch ( Exception e ) assertNull ( onError . get ( ) ) ; assertTrue ( e instanceof SafeObserverTestException ) ; assertEquals ( "onCompleteFail" , e . getMessage ( ) ) ; 
try OBSERVER_ONERROR_FAIL ( ) . onError ( new SafeObserverTestException ( "error!" ) ) ; fail ( "expects exception to be thrown" ) ; catch ( Exception e ) assertTrue ( e instanceof SafeObserverTestException ) ; assertEquals ( "onErrorFail" , e . getMessage ( ) ) ; 
try OBSERVER_ONNEXT_ONERROR_FAIL ( ) . onNext ( "one" ) ; fail ( "expects exception to be thrown" ) ; catch ( Exception e ) e . printStackTrace ( ) ; assertTrue ( e instanceof SafeObserverTestException ) ; assertEquals ( "onNextFail" , e . getMessage ( ) ) ; 
return new DefaultObserver < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) onError . set ( e ) ; @ Override public void onNext ( String args ) throw new SafeObserverTestException ( "onNextFail" ) ; ; 
$EMPTY$
onError . set ( e ) ; 
return new DefaultObserver < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new SafeObserverTestException ( "onErrorFail" ) ; @ Override public void onNext ( String args ) throw new SafeObserverTestException ( "onNextFail" ) ; ; 
return new DefaultObserver < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new SafeObserverTestException ( "onErrorFail" ) ; @ Override public void onNext ( String args ) ; 
return new DefaultObserver < String > ( ) @ Override public void onComplete ( ) throw new SafeObserverTestException ( "onCompleteFail" ) ; @ Override public void onError ( Throwable e ) onError . set ( e ) ; @ Override public void onNext ( String args ) ; 
Observer < Integer > actual = new DefaultObserver < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ; SafeObserver < Integer > observer = new SafeObserver < > ( actual ) ; assertSame ( actual , observer . downstream ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; SafeObserver < Integer > so = new SafeObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; to . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertTrue ( so . isDisposed ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; SafeObserver < Integer > so = new SafeObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; so . onComplete ( ) ; so . onNext ( 1 ) ; so . onError ( new TestException ( ) ) ; so . onComplete ( ) ; to . assertResult ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; SafeObserver < Integer > so = new SafeObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; so . onNext ( null ) ; to . assertFailure ( NullPointerException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; SafeObserver < Integer > so = new SafeObserver < > ( to ) ; so . onNext ( 1 ) ; to . assertFailureAndMessage ( NullPointerException . class , "Subscription not set!" ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; SafeObserver < Integer > so = new SafeObserver < > ( to ) ; so . onError ( new TestException ( ) ) ; to . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( to , 0 , TestException . class ) ; TestHelper . assertError ( to , 1 , NullPointerException . class , "Subscription not set!" ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; SafeObserver < Integer > so = new SafeObserver < > ( to ) ; so . onComplete ( ) ; to . assertFailureAndMessage ( NullPointerException . class , "Subscription not set!" ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; SafeObserver < Integer > so = new SafeObserver < > ( to ) ; Disposable d = Disposable . empty ( ) ; so . onSubscribe ( d ) ; so . onNext ( 1 ) ; so . onComplete ( ) ; to . assertResult ( 1 ) ; 
if ( crashDispose ) throw new TestException ( "dispose()" ) ; 
return false ; 
if ( crashOnSubscribe ) throw new TestException ( "onSubscribe()" ) ; 
if ( -- crashOnNext == 0 ) throw new TestException ( "onNext(" + value + ")" ) ; 
return new SafeObserver < > ( this ) ; 
if ( ! clazz . isInstance ( error ) ) throw new AssertionError ( "Different error: " + error ) ; return this ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , true , false , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onNext ( 1 ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "onNext(1)" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "onError(io.reactivex.rxjava3.exceptions.TestException: onNext(1))" ) ; finally RxJavaPlugins . reset ( ) ; 
CrashDummy cd = new CrashDummy ( false , 1 , false , false , true ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onNext ( 1 ) ; cd . assertError ( CompositeException . class ) ; cd . assertInnerError ( 0 , TestException . class , "onNext(1)" ) ; cd . assertInnerError ( 1 , TestException . class , "dispose()" ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , false , false , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onSubscribe ( cd ) ; TestHelper . assertError ( list , 0 , IllegalStateException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , false , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class , "onSubscribe()" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , false , true ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "onSubscribe()" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "dispose()" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , false , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onNext ( 1 ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "onSubscribe()" ) ; finally RxJavaPlugins . reset ( ) ; 
CrashDummy cd = new CrashDummy ( false , 1 , false , false , true ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onNext ( null ) ; cd . assertInnerError ( 0 , NullPointerException . class ) ; cd . assertInnerError ( 1 , TestException . class , "dispose()" ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , true , false , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onNext ( 1 ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "onError(java.lang.NullPointerException: Subscription not set!)" ) ; finally RxJavaPlugins . reset ( ) ; 
CrashDummy cd = new CrashDummy ( false , 1 , false , false , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onError ( null ) ; cd . assertError ( NullPointerException . class ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , false , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onError ( new TestException ( ) ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class ) ; TestHelper . assertError ( ce , 1 , NullPointerException . class , "Subscription not set!" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , true , false , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onError ( new TestException ( ) ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class ) ; TestHelper . assertError ( ce , 1 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 2 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , false , true , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onSubscribe ( cd ) ; so . onComplete ( ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class , "onComplete()" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( true , 1 , false , true , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onComplete ( ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "onSubscribe()" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try CrashDummy cd = new CrashDummy ( false , 1 , true , true , false ) ; SafeObserver < Object > so = cd . toSafe ( ) ; so . onComplete ( ) ; TestHelper . assertError ( list , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( list . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , NullPointerException . class , "Subscription not set!" ) ; TestHelper . assertError ( ce , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
super . onStart ( ) ; start ++ ; 
errors . add ( e ) ; dispose ( ) ; 
complete ++ ; dispose ( ) ; 
TestResourceObserver < Integer > ro = new TestResourceObserver < > ( ) ; ro . add ( null ) ; 
TestResourceObserver < Integer > ro = new TestResourceObserver < > ( ) ; assertFalse ( ro . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; ro . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; ro . dispose ( ) ; assertTrue ( ro . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; ro . dispose ( ) ; assertTrue ( ro . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceObserver < Integer > ro = new TestResourceObserver < > ( ) ; assertFalse ( ro . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; ro . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; ro . onComplete ( ) ; assertTrue ( ro . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceObserver < Integer > ro = new TestResourceObserver < > ( ) ; assertFalse ( ro . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; ro . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; ro . onError ( new TestException ( ) ) ; assertTrue ( ro . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceObserver < Integer > tc = new TestResourceObserver < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; assertTrue ( tc . values . isEmpty ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; Observable . just ( 1 ) . subscribe ( tc ) ; assertTrue ( tc . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( 1 , tc . values . get ( 0 ) . intValue ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; 
TestResourceObserver < Integer > tc = new TestResourceObserver < > ( ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; assertTrue ( tc . values . isEmpty ( ) ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; final RuntimeException error = new RuntimeException ( "error" ) ; Observable . < Integer > error ( error ) . subscribe ( tc ) ; assertTrue ( tc . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; assertTrue ( tc . values . isEmpty ( ) ) ; assertEquals ( 1 , tc . errors . size ( ) ) ; assertTrue ( tc . errors . contains ( error ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestResourceObserver < Integer > tc = new TestResourceObserver < > ( ) ; tc . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( tc . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestResourceObserver < Integer > tc = new TestResourceObserver < > ( ) ; tc . dispose ( ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; 
super . onStart ( ) ; start ++ ; 
errors . add ( e ) ; dispose ( ) ; 
TestResourceSingleObserver < Integer > rso = new TestResourceSingleObserver < > ( ) ; rso . add ( null ) ; 
TestResourceSingleObserver < Integer > rso = new TestResourceSingleObserver < > ( ) ; assertFalse ( rso . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rso . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rso . dispose ( ) ; assertTrue ( rso . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; rso . dispose ( ) ; assertTrue ( rso . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceSingleObserver < Integer > rso = new TestResourceSingleObserver < > ( ) ; assertFalse ( rso . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rso . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rso . onSuccess ( 1 ) ; assertTrue ( rso . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceSingleObserver < Integer > rso = new TestResourceSingleObserver < > ( ) ; assertFalse ( rso . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; rso . add ( d ) ; assertFalse ( d . isDisposed ( ) ) ; rso . onError ( new TestException ( ) ) ; assertTrue ( rso . isDisposed ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestResourceSingleObserver < Integer > rso = new TestResourceSingleObserver < > ( ) ; assertFalse ( rso . isDisposed ( ) ) ; assertEquals ( 0 , rso . start ) ; assertNull ( rso . value ) ; assertTrue ( rso . errors . isEmpty ( ) ) ; Single . just ( 1 ) . subscribe ( rso ) ; assertTrue ( rso . isDisposed ( ) ) ; assertEquals ( 1 , rso . start ) ; assertEquals ( Integer . valueOf ( 1 ) , rso . value ) ; assertTrue ( rso . errors . isEmpty ( ) ) ; 
TestResourceSingleObserver < Integer > rso = new TestResourceSingleObserver < > ( ) ; assertFalse ( rso . isDisposed ( ) ) ; assertEquals ( 0 , rso . start ) ; assertNull ( rso . value ) ; assertTrue ( rso . errors . isEmpty ( ) ) ; final RuntimeException error = new RuntimeException ( "error" ) ; Single . < Integer > error ( error ) . subscribe ( rso ) ; assertTrue ( rso . isDisposed ( ) ) ; assertEquals ( 1 , rso . start ) ; assertNull ( rso . value ) ; assertEquals ( 1 , rso . errors . size ( ) ) ; assertTrue ( rso . errors . contains ( error ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestResourceSingleObserver < Integer > rso = new TestResourceSingleObserver < > ( ) ; rso . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; rso . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , rso . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( rso . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestResourceSingleObserver < Integer > rso = new TestResourceSingleObserver < > ( ) ; rso . dispose ( ) ; Disposable d = Disposable . empty ( ) ; rso . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , rso . start ) ; 
super . onStart ( ) ; start ++ ; 
complete ++ ; 
errors . add ( e ) ; 
TestCompletable tc = new TestCompletable ( ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; assertEquals ( 0 , tc . complete ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; Completable . complete ( ) . subscribe ( tc ) ; assertFalse ( tc . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; assertEquals ( 1 , tc . complete ) ; assertTrue ( tc . errors . isEmpty ( ) ) ; 
List < Throwable > error = TestHelper . trackPluginErrors ( ) ; try TestCompletable tc = new TestCompletable ( ) ; tc . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , tc . start ) ; TestHelper . assertError ( error , 0 , IllegalStateException . class , EndConsumerHelper . composeMessage ( tc . getClass ( ) . getName ( ) ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestCompletable tc = new TestCompletable ( ) ; tc . dispose ( ) ; assertTrue ( tc . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; tc . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , tc . start ) ; 
count ++ ; caught = e ; completed . countDown ( ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; throw new IllegalArgumentException ( ) ; ) . retry ( Integer . MAX_VALUE , new Predicate < Throwable > ( ) @ Override public boolean test ( final Throwable throwable ) throws Exception return ! ( throwable instanceof IllegalArgumentException ) ; ) . test ( ) . assertFailure ( IllegalArgumentException . class ) ; assertEquals ( 3 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; ) . retry ( 2 , Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; assertEquals ( 3 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 3 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; ) . retry ( 1 , Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( RuntimeException . class ) ; assertEquals ( 2 , numberOfSubscribeCalls . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 2 ) ; final AtomicInteger numberOfSubscribeCalls = new AtomicInteger ( 0 ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception numberOfSubscribeCalls . incrementAndGet ( ) ; if ( atomicInteger . decrementAndGet ( ) != 0 ) throw new RuntimeException ( ) ; ) . retry ( 0 , Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( RuntimeException . class ) ; assertEquals ( 1 , numberOfSubscribeCalls . get ( ) ) ; 
Completable . complete ( ) . retryUntil ( ( ) -> true ) . test ( ) . assertResult ( ) ; 
Completable . complete ( ) . retryUntil ( ( ) -> false ) . test ( ) . assertResult ( ) ; 
Completable . error ( new TestException ( ) ) . retryUntil ( ( ) -> true ) . test ( ) . assertFailure ( TestException . class ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; Completable . defer ( ( ) -> if ( counter . getAndIncrement ( ) == 0 ) return Completable . error ( new TestException ( ) ) ; return Completable . complete ( ) ; ) . retryUntil ( ( ) -> false ) . test ( ) . assertResult ( ) ; 
return new Iterator < Completable > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Completable next ( ) throw new TestException ( ) ; @ Override public void remove ( ) ; 
return new Iterator < Completable > ( ) @ Override public boolean hasNext ( ) throw new TestException ( ) ; @ Override public Completable next ( ) return null ; @ Override public void remove ( ) ; 
Completable c = Completable . complete ( ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concatArray ( ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concatArray ( normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . concatArray ( error . completable ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concatArray ( normal . completable , normal . completable , normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . concatArray ( normal . completable , error . completable , normal . completable ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concatArray ( normal . completable , null ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( Collections . < Completable > emptyList ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) return null ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( Collections . singleton ( normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . concat ( Arrays . asList ( normal . completable , normal . completable , normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . concat ( Collections . singleton ( error . completable ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( Arrays . asList ( normal . completable , error . completable ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( new IterableIteratorHasNextThrows ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( new IterableIteratorNextThrows ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( Flowable . < Completable > empty ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( Flowable . < Completable > error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new TestException ( ) ; ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( Flowable . just ( normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . concat ( Flowable . just ( error . completable ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . concat ( Flowable . just ( normal . completable ) . repeat ( 3 ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . concat ( Flowable . just ( normal . completable , error . completable ) ) ; c . blockingAwait ( ) ; 
final List < Long > requested = new ArrayList < > ( ) ; Flowable < Completable > cs = Flowable . just ( normal . completable ) . repeat ( 10 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long v ) requested . add ( v ) ; ) ; Completable c = Completable . concat ( cs , 5 ) ; c . blockingAwait ( ) ; Assert . assertEquals ( Arrays . asList ( 5L , 4L , 4L ) , requested ) ; 
Completable c = Completable . unsafeCreate ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) throw new NullPointerException ( ) ; ) ; c . blockingAwait ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable c = Completable . unsafeCreate ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; Assert . fail ( "Did not throw exception" ) ; catch ( NullPointerException ex ) if ( ! ( ex . getCause ( ) instanceof TestException ) ) ex . printStackTrace ( ) ; Assert . fail ( "Did not wrap the TestException but it returned: " + ex ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Completable c = Completable . defer ( new Supplier < Completable > ( ) @ Override public Completable get ( ) return normal . completable ; ) ; normal . assertSubscriptions ( 0 ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . defer ( new Supplier < Completable > ( ) @ Override public Completable get ( ) return null ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . defer ( new Supplier < Completable > ( ) @ Override public Completable get ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . defer ( new Supplier < Completable > ( ) @ Override public Completable get ( ) return error . completable ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return null ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . error ( new TestException ( ) ) ; c . blockingAwait ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return calls . getAndIncrement ( ) ; ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
Completable c = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . fromPublisher ( Flowable . empty ( ) ) ; c . blockingAwait ( ) ; 
for ( int n = 1 ; n < 10000 ; n *= 10 ) Completable c = Completable . fromPublisher ( Flowable . range ( 1 , n ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . fromPublisher ( Flowable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new TestException ( ) ; ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . fromObservable ( Observable . empty ( ) ) ; c . blockingAwait ( ) ; 
for ( int n = 1 ; n < 10000 ; n *= 10 ) Completable c = Completable . fromObservable ( Observable . range ( 1 , n ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . fromObservable ( Observable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new TestException ( ) ; ) ) ; c . blockingAwait ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = Completable . fromAction ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
Completable c = Completable . fromAction ( new Action ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . fromSingle ( Single . just ( 1 ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . fromSingle ( Single . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new TestException ( ) ; ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeArray ( ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeArray ( normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . mergeArray ( error . completable ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeArray ( normal . completable , normal . completable , normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . mergeArray ( normal . completable , error . completable , normal . completable ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeArray ( normal . completable , null ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( Collections . < Completable > emptyList ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) return null ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( Collections . singleton ( normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . merge ( Arrays . asList ( normal . completable , normal . completable , normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . merge ( Collections . singleton ( error . completable ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( Arrays . asList ( normal . completable , error . completable ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( new IterableIteratorHasNextThrows ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( new IterableIteratorNextThrows ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( Flowable . < Completable > empty ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( Flowable . < Completable > error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new TestException ( ) ; ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( Flowable . just ( normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . merge ( Flowable . just ( error . completable ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . merge ( Flowable . just ( normal . completable ) . repeat ( 3 ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . merge ( Flowable . just ( normal . completable , error . completable ) ) ; c . blockingAwait ( ) ; 
final List < Long > requested = new ArrayList < > ( ) ; Flowable < Completable > cs = Flowable . just ( normal . completable ) . repeat ( 10 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long v ) requested . add ( v ) ; ) ; Completable c = Completable . merge ( cs , 5 ) ; c . blockingAwait ( ) ; Assert . assertEquals ( Arrays . asList ( 5L , 1L , 1L , 1L , 1L , 1L , 1L , 1L , 1L , 1L , 1L ) , requested ) ; 
Completable c = Completable . mergeArrayDelayError ( ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeArrayDelayError ( normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . mergeArrayDelayError ( error . completable ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeArrayDelayError ( normal . completable , normal . completable , normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . mergeArrayDelayError ( normal . completable , error . completable , normal . completable ) ; try c . blockingAwait ( ) ; catch ( TestException ex ) normal . assertSubscriptions ( 2 ) ; 
Completable c = Completable . mergeArrayDelayError ( normal . completable , null ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( Collections . < Completable > emptyList ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) return null ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( Collections . singleton ( normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . mergeDelayError ( Arrays . asList ( normal . completable , normal . completable , normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . mergeDelayError ( Collections . singleton ( error . completable ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( Arrays . asList ( normal . completable , error . completable , normal . completable ) ) ; try c . blockingAwait ( ) ; catch ( TestException ex ) normal . assertSubscriptions ( 2 ) ; 
Completable c = Completable . mergeDelayError ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( new IterableIteratorHasNextThrows ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( new IterableIteratorNextThrows ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( Flowable . < Completable > empty ( ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( Flowable . < Completable > error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new TestException ( ) ; ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( Flowable . just ( normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . mergeDelayError ( Flowable . just ( error . completable ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . mergeDelayError ( Flowable . just ( normal . completable ) . repeat ( 3 ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 3 ) ; 
Completable c = Completable . mergeDelayError ( Flowable . just ( normal . completable , error . completable ) ) ; c . blockingAwait ( ) ; 
final List < Long > requested = new ArrayList < > ( ) ; Flowable < Completable > cs = Flowable . just ( normal . completable ) . repeat ( 10 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long v ) requested . add ( v ) ; ) ; Completable c = Completable . mergeDelayError ( cs , 5 ) ; c . blockingAwait ( ) ; Assert . assertEquals ( Arrays . asList ( 5L , 1L , 1L , 1L , 1L , 1L , 1L , 1L , 1L , 1L , 1L ) , requested ) ; 
final AtomicBoolean onSubscribeCalled = new AtomicBoolean ( ) ; final AtomicInteger calls = new AtomicInteger ( ) ; Completable . never ( ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) onSubscribeCalled . set ( true ) ; @ Override public void onError ( Throwable e ) calls . getAndIncrement ( ) ; @ Override public void onComplete ( ) calls . getAndIncrement ( ) ; ) ; Assert . assertTrue ( "onSubscribe not called" , onSubscribeCalled . get ( ) ) ; Assert . assertEquals ( "There were calls to onXXX methods" , 0 , calls . get ( ) ) ; 
Completable c = Completable . timer ( 500 , TimeUnit . MILLISECONDS ) ; c . blockingAwait ( ) ; 
Completable c = Completable . timer ( 500 , TimeUnit . MILLISECONDS , Schedulers . newThread ( ) ) ; c . blockingAwait ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Completable c = Completable . timer ( 250 , TimeUnit . MILLISECONDS , scheduler ) ; final AtomicInteger calls = new AtomicInteger ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onComplete ( ) calls . getAndIncrement ( ) ; @ Override public void onError ( Throwable e ) RxJavaPlugins . onError ( e ) ; ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; Assert . assertEquals ( 0 , calls . get ( ) ) ; scheduler . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
Completable c = Completable . timer ( 250 , TimeUnit . MILLISECONDS ) ; final SequentialDisposable sd = new SequentialDisposable ( ) ; final AtomicInteger calls = new AtomicInteger ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) sd . replace ( d ) ; @ Override public void onError ( Throwable e ) calls . getAndIncrement ( ) ; @ Override public void onComplete ( ) calls . getAndIncrement ( ) ; ) ; Thread . sleep ( 100 ) ; sd . dispose ( ) ; Thread . sleep ( 200 ) ; Assert . assertEquals ( 0 , calls . get ( ) ) ; 
final AtomicInteger dispose = new AtomicInteger ( ) ; Completable c = Completable . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Object , Completable > ( ) @ Override public Completable apply ( Object v ) return normal . completable ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer d ) dispose . set ( d ) ; ) ; final AtomicBoolean disposedFirst = new AtomicBoolean ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) error . lazySet ( e ) ; @ Override public void onComplete ( ) disposedFirst . set ( dispose . get ( ) != 0 ) ; ) ; Assert . assertEquals ( 1 , dispose . get ( ) ) ; Assert . assertTrue ( "Not disposed first" , disposedFirst . get ( ) ) ; Assert . assertNull ( error . get ( ) ) ; 
final AtomicInteger dispose = new AtomicInteger ( ) ; Completable c = Completable . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return normal . completable ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer d ) dispose . set ( d ) ; , false ) ; final AtomicBoolean disposedFirst = new AtomicBoolean ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) error . lazySet ( e ) ; @ Override public void onComplete ( ) disposedFirst . set ( dispose . get ( ) != 0 ) ; ) ; Assert . assertEquals ( 1 , dispose . get ( ) ) ; Assert . assertFalse ( "Disposed first" , disposedFirst . get ( ) ) ; Assert . assertNull ( error . get ( ) ) ; 
final AtomicInteger dispose = new AtomicInteger ( ) ; Completable c = Completable . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return error . completable ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer d ) dispose . set ( d ) ; ) ; final AtomicBoolean disposedFirst = new AtomicBoolean ( ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) disposedFirst . set ( dispose . get ( ) != 0 ) ; @ Override public void onComplete ( ) complete . set ( true ) ; ) ; Assert . assertEquals ( 1 , dispose . get ( ) ) ; Assert . assertTrue ( "Not disposed first" , disposedFirst . get ( ) ) ; Assert . assertFalse ( complete . get ( ) ) ; 
final AtomicInteger dispose = new AtomicInteger ( ) ; Completable c = Completable . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return error . completable ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer d ) dispose . set ( d ) ; , false ) ; final AtomicBoolean disposedFirst = new AtomicBoolean ( ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) disposedFirst . set ( dispose . get ( ) != 0 ) ; @ Override public void onComplete ( ) complete . set ( true ) ; ) ; Assert . assertEquals ( 1 , dispose . get ( ) ) ; Assert . assertFalse ( "Disposed first" , disposedFirst . get ( ) ) ; Assert . assertFalse ( complete . get ( ) ) ; 
Completable c = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , new Function < Object , Completable > ( ) @ Override public Completable apply ( Object v ) return null ; , new Consumer < Object > ( ) @ Override public void accept ( Object v ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throw new TestException ( ) ; , new Function < Object , Completable > ( ) @ Override public Completable apply ( Object v ) return normal . completable ; , new Consumer < Object > ( ) @ Override public void accept ( Object v ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , new Function < Object , Completable > ( ) @ Override public Completable apply ( Object v ) throw new TestException ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object v ) ) ; c . blockingAwait ( ) ; 
Completable c = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , new Function < Object , Completable > ( ) @ Override public Completable apply ( Object v ) return normal . completable ; , new Consumer < Object > ( ) @ Override public void accept ( Object v ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = error . completable . compose ( new CompletableTransformer ( ) @ Override public Completable apply ( Completable n ) return n . onErrorComplete ( ) ; ) ; c . blockingAwait ( ) ; 
Completable c = normal . completable . concatWith ( normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 2 ) ; 
Completable c = normal . completable . concatWith ( error . completable ) ; c . blockingAwait ( ) ; 
Completable c = normal . completable . delay ( 250 , TimeUnit . MILLISECONDS ) ; final AtomicBoolean done = new AtomicBoolean ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) error . set ( e ) ; @ Override public void onComplete ( ) done . set ( true ) ; ) ; Thread . sleep ( 100 ) ; Assert . assertFalse ( "Already done" , done . get ( ) ) ; int timeout = 10 ; while ( timeout -- > 0 && ! done . get ( ) ) Thread . sleep ( 100 ) ; Assert . assertTrue ( "Not done" , done . get ( ) ) ; Assert . assertNull ( error . get ( ) ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; final Completable c = error . completable . delay ( 250 , TimeUnit . MILLISECONDS , scheduler ) ; final AtomicBoolean done = new AtomicBoolean ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) error . set ( e ) ; @ Override public void onComplete ( ) done . set ( true ) ; ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; Assert . assertTrue ( error . get ( ) . toString ( ) , error . get ( ) instanceof TestException ) ; Assert . assertFalse ( "Already done" , done . get ( ) ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; Assert . assertFalse ( "Already done" , done . get ( ) ) ; 
Completable c = error . completable . delay ( 250 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) ; final AtomicBoolean done = new AtomicBoolean ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) error . set ( e ) ; @ Override public void onComplete ( ) done . set ( true ) ; ) ; Thread . sleep ( 100 ) ; Assert . assertFalse ( "Already done" , done . get ( ) ) ; Assert . assertNull ( error . get ( ) ) ; Thread . sleep ( 200 ) ; Assert . assertFalse ( "Already done" , done . get ( ) ) ; Assert . assertTrue ( error . get ( ) instanceof TestException ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = normal . completable . doOnComplete ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = error . completable . doOnComplete ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; try c . blockingAwait ( ) ; Assert . fail ( "Failed to throw TestException" ) ; catch ( TestException ex ) Assert . assertEquals ( 0 , calls . get ( ) ) ; 
Completable c = normal . completable . doOnComplete ( new Action ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = normal . completable . doOnDispose ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 0 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = error . completable . doOnDispose ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; try c . blockingAwait ( ) ; Assert . fail ( "No exception thrown" ) ; catch ( TestException ex ) Assert . assertEquals ( 0 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = normal . completable . doOnDispose ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) d . dispose ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable c = normal . completable . doOnDispose ( new Action ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) d . dispose ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Completable c = normal . completable . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) error . set ( e ) ; ) ; c . blockingAwait ( ) ; Assert . assertNull ( error . get ( ) ) ; 
final AtomicReference < Throwable > err = new AtomicReference < > ( ) ; Completable c = error . completable . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) err . set ( e ) ; ) ; try c . blockingAwait ( ) ; Assert . fail ( "Did not throw exception" ) ; catch ( Throwable e ) Assert . assertTrue ( err . get ( ) instanceof TestException ) ; 
Completable c = error . completable . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throw new IllegalStateException ( ) ; ) ; try c . blockingAwait ( ) ; catch ( CompositeException ex ) List < Throwable > a = ex . getExceptions ( ) ; Assert . assertEquals ( 2 , a . size ( ) ) ; Assert . assertTrue ( a . get ( 0 ) instanceof TestException ) ; Assert . assertTrue ( a . get ( 1 ) instanceof IllegalStateException ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = normal . completable . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) calls . getAndIncrement ( ) ; ) ; for ( int i = 0 ; i < 10 ; i ++ ) c . blockingAwait ( ) ; Assert . assertEquals ( 10 , calls . get ( ) ) ; 
Completable c = normal . completable . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = normal . completable . doOnTerminate ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = error . completable . doOnTerminate ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; try c . blockingAwait ( ) ; Assert . fail ( "Did dot throw exception" ) ; catch ( TestException ex ) Assert . assertEquals ( 1 , calls . get ( ) ) ; 
Completable c = normal . completable . lift ( new CompletableOperator ( ) @ Override public CompletableObserver apply ( CompletableObserver v ) return null ; ) ; c . blockingAwait ( ) ; 
return null ; 
Completable c = normal . completable . lift ( new CompletableOperatorSwap ( ) ) ; c . blockingAwait ( ) ; 
Completable c = error . completable . lift ( new CompletableOperatorSwap ( ) ) ; c . blockingAwait ( ) ; 
Completable c = normal . completable . mergeWith ( normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 2 ) ; 
final AtomicReference < String > name = new AtomicReference < > ( ) ; final AtomicReference < Throwable > err = new AtomicReference < > ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable c = normal . completable . observeOn ( Schedulers . computation ( ) ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onComplete ( ) name . set ( Thread . currentThread ( ) . getName ( ) ) ; cdl . countDown ( ) ; @ Override public void onError ( Throwable e ) err . set ( e ) ; cdl . countDown ( ) ; ) ; cdl . await ( ) ; Assert . assertNull ( err . get ( ) ) ; Assert . assertTrue ( name . get ( ) . startsWith ( "RxComputation" ) ) ; 
final AtomicReference < String > name = new AtomicReference < > ( ) ; final AtomicReference < Throwable > err = new AtomicReference < > ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable c = error . completable . observeOn ( Schedulers . computation ( ) ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onComplete ( ) name . set ( Thread . currentThread ( ) . getName ( ) ) ; cdl . countDown ( ) ; @ Override public void onError ( Throwable e ) name . set ( Thread . currentThread ( ) . getName ( ) ) ; err . set ( e ) ; cdl . countDown ( ) ; ) ; cdl . await ( ) ; Assert . assertTrue ( err . get ( ) instanceof TestException ) ; Assert . assertTrue ( name . get ( ) . startsWith ( "RxComputation" ) ) ; 
Completable c = error . completable . onErrorComplete ( ) ; c . blockingAwait ( ) ; 
Completable c = error . completable . onErrorComplete ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) return e instanceof IllegalStateException ; ) ; c . blockingAwait ( ) ; 
Completable c = error . completable . onErrorResumeNext ( new Function < Throwable , Completable > ( ) @ Override public Completable apply ( Throwable e ) return null ; ) ; try c . blockingAwait ( ) ; Assert . fail ( "Did not throw an exception" ) ; catch ( CompositeException ex ) List < Throwable > errors = ex . getExceptions ( ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , NullPointerException . class ) ; assertEquals ( 2 , errors . size ( ) ) ; 
Completable c = error . completable . onErrorResumeNext ( new Function < Throwable , Completable > ( ) @ Override public Completable apply ( Throwable e ) throw new TestException ( ) ; ) ; try c . blockingAwait ( ) ; Assert . fail ( "Did not throw an exception" ) ; catch ( CompositeException ex ) List < Throwable > a = ex . getExceptions ( ) ; Assert . assertEquals ( 2 , a . size ( ) ) ; Assert . assertTrue ( a . get ( 0 ) instanceof TestException ) ; Assert . assertTrue ( a . get ( 1 ) instanceof TestException ) ; 
Completable c = error . completable . onErrorResumeNext ( new Function < Throwable , Completable > ( ) @ Override public Completable apply ( Throwable v ) return normal . completable ; ) ; c . blockingAwait ( ) ; 
Completable c = error . completable . onErrorResumeNext ( new Function < Throwable , Completable > ( ) @ Override public Completable apply ( Throwable v ) return error . completable ; ) ; c . blockingAwait ( ) ; 
final AtomicReference < Throwable > err = new AtomicReference < > ( ) ; final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception calls . getAndIncrement ( ) ; Thread . sleep ( 100 ) ; return null ; ) . repeat ( ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( final Disposable d ) Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) d . dispose ( ) ; , 550 , TimeUnit . MILLISECONDS ) ; @ Override public void onError ( Throwable e ) err . set ( e ) ; @ Override public void onComplete ( ) ) ; Assert . assertEquals ( 6 , calls . get ( ) ) ; Assert . assertNull ( err . get ( ) ) ; 
Completable c = error . completable . repeat ( ) ; c . blockingAwait ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception calls . getAndIncrement ( ) ; return null ; ) . repeat ( 5 ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 5 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception calls . getAndIncrement ( ) ; return null ; ) . repeat ( 1 ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception calls . getAndIncrement ( ) ; return null ; ) . repeat ( 0 ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 0 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( 5 ) ; Completable c = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception calls . getAndIncrement ( ) ; return null ; ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) return times . decrementAndGet ( ) == 0 ; ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 5 , calls . get ( ) ) ; 
Completable c = normal . completable . retry ( ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
final AtomicInteger calls = new AtomicInteger ( 5 ) ; Completable c = Completable . fromAction ( new Action ( ) @ Override public void run ( ) if ( calls . decrementAndGet ( ) != 0 ) throw new TestException ( ) ; ) . retry ( ) ; c . blockingAwait ( ) ; 
Completable c = error . completable . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer n , Throwable e ) return n < 5 ; ) ; c . blockingAwait ( ) ; 
Completable c = error . completable . retry ( 5 ) ; c . blockingAwait ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = Completable . fromAction ( new Action ( ) @ Override public void run ( ) if ( calls . incrementAndGet ( ) != 6 ) throw new TestException ( ) ; ) . retry ( 5 ) ; c . blockingAwait ( ) ; assertEquals ( 6 , calls . get ( ) ) ; 
normal . completable . retry ( - 1 ) ; 
Completable c = error . completable . retry ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) return false ; ) ; c . blockingAwait ( ) ; 
final AtomicInteger calls = new AtomicInteger ( 5 ) ; Completable c = Completable . fromAction ( new Action ( ) @ Override public void run ( ) if ( calls . decrementAndGet ( ) != 0 ) throw new TestException ( ) ; ) . retry ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) return true ; ) ; c . blockingAwait ( ) ; 
final AtomicInteger calls = new AtomicInteger ( 5 ) ; Completable c = Completable . fromAction ( new Action ( ) @ Override public void run ( ) if ( calls . decrementAndGet ( ) != 0 ) throw new TestException ( ) ; ) . retryWhen ( new Function < Flowable < ? extends Throwable > , Publisher < Object > > ( ) @ SuppressWarnings ( "rawtypes" , "unchecked" ) @ Override public Publisher < Object > apply ( Flowable < ? extends Throwable > f ) return ( Publisher ) f ; ) ; c . blockingAwait ( ) ; 
final AtomicBoolean complete = new AtomicBoolean ( ) ; Completable c = normal . completable . delay ( 100 , TimeUnit . MILLISECONDS ) . doOnComplete ( new Action ( ) @ Override public void run ( ) complete . set ( true ) ; ) ; Disposable d = c . subscribe ( ) ; assertFalse ( d . isDisposed ( ) ) ; Thread . sleep ( 150 ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
final AtomicBoolean complete = new AtomicBoolean ( ) ; Completable c = normal . completable . delay ( 200 , TimeUnit . MILLISECONDS ) . doOnComplete ( new Action ( ) @ Override public void run ( ) complete . set ( true ) ; ) ; Disposable d = c . subscribe ( ) ; Thread . sleep ( 100 ) ; d . dispose ( ) ; Thread . sleep ( 150 ) ; Assert . assertFalse ( "Completed" , complete . get ( ) ) ; 
final AtomicReference < Throwable > err = new AtomicReference < > ( ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; normal . completable . subscribe ( new Action ( ) @ Override public void run ( ) complete . set ( true ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) err . set ( e ) ; ) ; Assert . assertNull ( err . get ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) ) ; 
final AtomicReference < Throwable > err = new AtomicReference < > ( ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; error . completable . subscribe ( new Action ( ) @ Override public void run ( ) complete . set ( true ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) err . set ( e ) ; ) ; Assert . assertTrue ( err . get ( ) instanceof TestException ) ; Assert . assertFalse ( "Not completed" , complete . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Throwable > err = new AtomicReference < > ( ) ; normal . completable . subscribe ( new Action ( ) @ Override public void run ( ) throw new TestException ( ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) err . set ( e ) ; ) ; Assert . assertNull ( err . get ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try error . completable . subscribe ( new Action ( ) @ Override public void run ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throw new TestException ( ) ; ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; normal . completable . toObservable ( ) . subscribe ( to ) ; to . assertComplete ( ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; error . completable . toObservable ( ) . subscribe ( to ) ; to . assertNotComplete ( ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; 
final AtomicBoolean run = new AtomicBoolean ( ) ; normal . completable . subscribe ( new Action ( ) @ Override public void run ( ) run . set ( true ) ; ) ; Assert . assertTrue ( "Not completed" , run . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicBoolean run = new AtomicBoolean ( ) ; error . completable . subscribe ( new Action ( ) @ Override public void run ( ) run . set ( true ) ; ) ; Assert . assertFalse ( "Completed" , run . get ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; normal . completable . toFlowable ( ) . subscribe ( ts ) ; ts . assertComplete ( ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; error . completable . toFlowable ( ) . subscribe ( ts ) ; ts . assertNotComplete ( ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; 
final AtomicReference < String > name = new AtomicReference < > ( ) ; Completable c = Completable . unsafeCreate ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) name . set ( Thread . currentThread ( ) . getName ( ) ) ; EmptyDisposable . complete ( observer ) ; ) . subscribeOn ( Schedulers . computation ( ) ) ; c . blockingAwait ( ) ; Assert . assertTrue ( name . get ( ) . startsWith ( "RxComputation" ) ) ; 
final AtomicReference < String > name = new AtomicReference < > ( ) ; Completable c = Completable . unsafeCreate ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) name . set ( Thread . currentThread ( ) . getName ( ) ) ; EmptyDisposable . error ( new TestException ( ) , observer ) ; ) . subscribeOn ( Schedulers . computation ( ) ) ; try c . blockingAwait ( ) ; Assert . fail ( "No exception thrown" ) ; catch ( TestException ex ) Assert . assertTrue ( name . get ( ) . startsWith ( "RxComputation" ) ) ; 
Completable c = Completable . never ( ) . timeout ( 100 , TimeUnit . MILLISECONDS , normal . completable ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception Thread . sleep ( 50 ) ; return null ; ) . timeout ( 100 , TimeUnit . MILLISECONDS , normal . completable ) ; c . blockingAwait ( ) ; Thread . sleep ( 100 ) ; normal . assertSubscriptions ( 0 ) ; 
normal . completable . to ( new CompletableConverter < Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Completable c ) return c . toFlowable ( ) ; ) . test ( ) . assertComplete ( ) . assertNoValues ( ) ; 
normal . completable . to ( new CompletableConverter < Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Completable c ) return c . toFlowable ( ) ; ) . test ( ) . assertComplete ( ) . assertNoValues ( ) ; 
Completable . complete ( ) . to ( new CompletableConverter < Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Completable v ) return v . toFlowable ( ) ; ) . test ( ) . assertComplete ( ) ; 
normal . completable . toFlowable ( ) . blockingForEach ( Functions . emptyConsumer ( ) ) ; 
error . completable . toFlowable ( ) . blockingForEach ( Functions . emptyConsumer ( ) ) ; 
normal . completable . toObservable ( ) . blockingForEach ( Functions . emptyConsumer ( ) ) ; 
error . completable . toObservable ( ) . blockingForEach ( Functions . emptyConsumer ( ) ) ; 
Assert . assertEquals ( 1 , normal . completable . toSingle ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; ) . blockingGet ( ) ) ; 
error . completable . toSingle ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; ) . blockingGet ( ) ; 
normal . completable . toSingle ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; ) . blockingGet ( ) ; 
normal . completable . toSingle ( new Supplier < Object > ( ) @ Override public Object get ( ) throw new TestException ( ) ; ) . blockingGet ( ) ; 
error . completable . toSingleDefault ( 1 ) . blockingGet ( ) ; 
Assert . assertEquals ( ( Integer ) 1 , normal . completable . toSingleDefault ( 1 ) . blockingGet ( ) ) ; 
final AtomicReference < String > name = new AtomicReference < > ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; normal . completable . delay ( 1 , TimeUnit . SECONDS ) . doOnDispose ( new Action ( ) @ Override public void run ( ) name . set ( Thread . currentThread ( ) . getName ( ) ) ; cdl . countDown ( ) ; ) . unsubscribeOn ( Schedulers . computation ( ) ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( final Disposable d ) Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) d . dispose ( ) ; , 100 , TimeUnit . MILLISECONDS ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; cdl . await ( ) ; Assert . assertTrue ( name . get ( ) . startsWith ( "RxComputation" ) ) ; 
Completable c = Completable . ambArray ( ) ; c . blockingAwait ( ) ; 
Completable c = Completable . ambArray ( normal . completable ) ; c . blockingAwait ( ) ; 
Completable . ambArray ( error . completable ) . test ( ) . assertError ( TestException . class ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; Completable c1 = Completable . fromPublisher ( pp1 ) ; Completable c2 = Completable . fromPublisher ( pp2 ) ; Completable c = Completable . ambArray ( c1 , c2 ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; c . subscribe ( new Action ( ) @ Override public void run ( ) complete . set ( true ) ; ) ; Assert . assertTrue ( "First subject no subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Second subject no subscribers" , pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; Assert . assertFalse ( "First subject has subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertFalse ( "Second subject has subscribers" , pp2 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; Completable c1 = Completable . fromPublisher ( pp1 ) ; Completable c2 = Completable . fromPublisher ( pp2 ) ; Completable c = Completable . ambArray ( c1 , c2 ) ; final AtomicReference < Throwable > complete = new AtomicReference < > ( ) ; c . subscribe ( Functions . EMPTY_ACTION , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) complete . set ( v ) ; ) ; Assert . assertTrue ( "First subject no subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Second subject no subscribers" , pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; Assert . assertFalse ( "First subject has subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertFalse ( "Second subject has subscribers" , pp2 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) instanceof TestException ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; Completable c1 = Completable . fromPublisher ( pp1 ) ; Completable c2 = Completable . fromPublisher ( pp2 ) ; Completable c = Completable . ambArray ( c1 , c2 ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; c . subscribe ( new Action ( ) @ Override public void run ( ) complete . set ( true ) ; ) ; Assert . assertTrue ( "First subject no subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Second subject no subscribers" , pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; Assert . assertFalse ( "First subject has subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertFalse ( "Second subject has subscribers" , pp2 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; Completable c1 = Completable . fromPublisher ( pp1 ) ; Completable c2 = Completable . fromPublisher ( pp2 ) ; Completable c = Completable . ambArray ( c1 , c2 ) ; final AtomicReference < Throwable > complete = new AtomicReference < > ( ) ; c . subscribe ( Functions . EMPTY_ACTION , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) complete . set ( v ) ; ) ; Assert . assertTrue ( "First subject no subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Second subject no subscribers" , pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; Assert . assertFalse ( "First subject has subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertFalse ( "Second subject has subscribers" , pp2 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) instanceof TestException ) ; 
Completable . ambArray ( null , normal . completable ) . test ( ) . assertError ( NullPointerException . class ) ; 
Completable c = Completable . amb ( Collections . < Completable > emptyList ( ) ) ; c . blockingAwait ( ) ; 
Completable . amb ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) return null ; ) . test ( ) . assertError ( NullPointerException . class ) ; 
Completable . amb ( Arrays . asList ( null , normal . completable ) ) . test ( ) . assertError ( NullPointerException . class ) ; 
Completable c = Completable . amb ( Collections . singleton ( normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = Completable . amb ( Arrays . asList ( normal . completable , normal . completable , normal . completable ) ) ; c . blockingAwait ( ) ; normal . assertSubscriptions ( 1 ) ; 
Completable . amb ( Collections . singleton ( error . completable ) ) . test ( ) . assertError ( TestException . class ) ; 
Completable . amb ( Arrays . asList ( error . completable , normal . completable ) ) . test ( ) . assertError ( TestException . class ) ; 
Completable . amb ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) throw new TestException ( ) ; ) . test ( ) . assertError ( TestException . class ) ; 
Completable . amb ( new IterableIteratorHasNextThrows ( ) ) . test ( ) . assertError ( TestException . class ) ; 
Completable . amb ( new IterableIteratorNextThrows ( ) ) . test ( ) . assertError ( TestException . class ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; Completable c1 = Completable . fromPublisher ( pp1 ) ; Completable c2 = Completable . fromPublisher ( pp2 ) ; Completable c = c1 . ambWith ( c2 ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; c . subscribe ( new Action ( ) @ Override public void run ( ) complete . set ( true ) ; ) ; Assert . assertTrue ( "First subject no subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Second subject no subscribers" , pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; Assert . assertFalse ( "First subject has subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertFalse ( "Second subject has subscribers" , pp2 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; Completable c1 = Completable . fromPublisher ( pp1 ) ; Completable c2 = Completable . fromPublisher ( pp2 ) ; Completable c = c1 . ambWith ( c2 ) ; final AtomicReference < Throwable > complete = new AtomicReference < > ( ) ; c . subscribe ( Functions . EMPTY_ACTION , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) complete . set ( v ) ; ) ; Assert . assertTrue ( "First subject no subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Second subject no subscribers" , pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; Assert . assertFalse ( "First subject has subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertFalse ( "Second subject has subscribers" , pp2 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) instanceof TestException ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; Completable c1 = Completable . fromPublisher ( pp1 ) ; Completable c2 = Completable . fromPublisher ( pp2 ) ; Completable c = c1 . ambWith ( c2 ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; c . subscribe ( new Action ( ) @ Override public void run ( ) complete . set ( true ) ; ) ; Assert . assertTrue ( "First subject no subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Second subject no subscribers" , pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; Assert . assertFalse ( "First subject has subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertFalse ( "Second subject has subscribers" , pp2 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) ) ; 
PublishProcessor < Object > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Object > pp2 = PublishProcessor . create ( ) ; Completable c1 = Completable . fromPublisher ( pp1 ) ; Completable c2 = Completable . fromPublisher ( pp2 ) ; Completable c = c1 . ambWith ( c2 ) ; final AtomicReference < Throwable > complete = new AtomicReference < > ( ) ; c . subscribe ( Functions . EMPTY_ACTION , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) complete . set ( v ) ; ) ; Assert . assertTrue ( "First subject no subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Second subject no subscribers" , pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; Assert . assertFalse ( "First subject has subscribers" , pp1 . hasSubscribers ( ) ) ; Assert . assertFalse ( "Second subject has subscribers" , pp2 . hasSubscribers ( ) ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) instanceof TestException ) ; 
final AtomicBoolean run = new AtomicBoolean ( ) ; Completable c = normal . completable . startWith ( Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception run . set ( normal . get ( ) == 0 ) ; return null ; ) ) ; c . blockingAwait ( ) ; Assert . assertTrue ( "Did not start with other" , run . get ( ) ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = normal . completable . startWith ( error . completable ) ; try c . blockingAwait ( ) ; Assert . fail ( "Did not throw TestException" ) ; catch ( TestException ex ) normal . assertSubscriptions ( 0 ) ; error . assertSubscriptions ( 1 ) ; 
final AtomicBoolean run = new AtomicBoolean ( ) ; Flowable < Object > c = normal . completable . startWith ( Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception run . set ( normal . get ( ) == 0 ) ; return 1 ; ) ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; c . subscribe ( ts ) ; Assert . assertTrue ( "Did not start with other" , run . get ( ) ) ; normal . assertSubscriptions ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
Flowable < Object > c = normal . completable . startWith ( Flowable . error ( new TestException ( ) ) ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; c . subscribe ( ts ) ; normal . assertSubscriptions ( 0 ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
final AtomicBoolean run = new AtomicBoolean ( ) ; Observable < Object > o = normal . completable . startWith ( Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception run . set ( normal . get ( ) == 0 ) ; return 1 ; ) ) ; TestObserver < Object > to = new TestObserver < > ( ) ; o . subscribe ( to ) ; Assert . assertTrue ( "Did not start with other" , run . get ( ) ) ; normal . assertSubscriptions ( 1 ) ; to . assertValue ( 1 ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; 
Observable < Object > o = normal . completable . startWith ( Observable . error ( new TestException ( ) ) ) ; TestObserver < Object > to = new TestObserver < > ( ) ; o . subscribe ( to ) ; normal . assertSubscriptions ( 0 ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; Completable . complete ( ) . andThen ( Flowable . just ( "foo" ) ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertValue ( "foo" ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; TestObserver < String > to = new TestObserver < > ( ) ; Completable . complete ( ) . andThen ( Observable . just ( "foo" ) ) . subscribe ( to ) ; to . assertValue ( "foo" ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; 
Thread . UncaughtExceptionHandler originalHandler = Thread . getDefaultUncaughtExceptionHandler ( ) ; CapturingUncaughtExceptionHandler handler = new CapturingUncaughtExceptionHandler ( ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; RxJavaPlugins . setErrorHandler ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable error ) throws Exception Thread . currentThread ( ) . getUncaughtExceptionHandler ( ) . uncaughtException ( Thread . currentThread ( ) , error ) ; ) ; try action . run ( ) ; assertEquals ( "Should have received exactly 1 exception" , 1 , handler . count ) ; Throwable caught = handler . caught ; while ( caught != null ) if ( caught instanceof TestException ) break ; if ( caught == caught . getCause ( ) ) break ; caught = caught . getCause ( ) ; assertTrue ( "A TestException should have been delivered to the handler" , caught instanceof TestException ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; finally Thread . setDefaultUncaughtExceptionHandler ( originalHandler ) ; RxJavaPlugins . setErrorHandler ( null ) ; 
expectUncaughtTestException ( new Action ( ) @ Override public void run ( ) normal . completable . subscribe ( new Action ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ; ) ; 
expectUncaughtTestException ( new Action ( ) @ Override public void run ( ) error . completable . subscribe ( new Action ( ) @ Override public void run ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throw new TestException ( ) ; ) ; ) ; 
expectUncaughtTestException ( new Action ( ) @ Override public void run ( ) error . completable . toSingleDefault ( 1 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer integer ) ) ; ) ; 
Consumer < Integer > onDispose = new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throw new TestException ( ) ; ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Completable . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) return null ; , onDispose ) . < Integer > toFlowable ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( CompositeException . class ) ; CompositeException ex = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; List < Throwable > listEx = ex . getExceptions ( ) ; assertEquals ( 2 , listEx . size ( ) ) ; assertTrue ( listEx . get ( 0 ) . toString ( ) , listEx . get ( 0 ) instanceof NullPointerException ) ; assertTrue ( listEx . get ( 1 ) . toString ( ) , listEx . get ( 1 ) instanceof TestException ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; Disposable completableSubscription = completable . subscribe ( ) ; stringSubject . onError ( new TestException ( ) ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; Disposable completableSubscription = completable . subscribe ( new Action ( ) @ Override public void run ( ) ) ; stringSubject . onComplete ( ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; 
PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; final AtomicReference < Disposable > disposableRef = new AtomicReference < > ( ) ; Disposable completableSubscription = completable . subscribe ( new Action ( ) @ Override public void run ( ) if ( disposableRef . get ( ) . isDisposed ( ) ) disposableRef . set ( null ) ; ) ; disposableRef . set ( completableSubscription ) ; stringSubject . onComplete ( ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; assertNotNull ( "Unsubscribed before the call to onComplete" , disposableRef . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; Disposable completableSubscription = completable . subscribe ( new Action ( ) @ Override public void run ( ) ) ; stringSubject . onError ( new TestException ( ) ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; Disposable completableSubscription = completable . subscribe ( new Action ( ) @ Override public void run ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) ) ; stringSubject . onComplete ( ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; 
PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; Disposable completableSubscription = completable . subscribe ( new Action ( ) @ Override public void run ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) ) ; stringSubject . onError ( new TestException ( ) ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( 0 ) ; TestScheduler scheduler = new TestScheduler ( ) ; Completable . complete ( ) . andThen ( Flowable . just ( "foo" ) . delay ( 1 , TimeUnit . SECONDS , scheduler ) ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNotTerminated ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValue ( "foo" ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( 0 ) ; Completable . never ( ) . andThen ( Single . just ( "foo" ) ) . toFlowable ( ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNotTerminated ( ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; final AtomicBoolean hasRun = new AtomicBoolean ( false ) ; final Exception e = new Exception ( ) ; Completable . error ( e ) . andThen ( new Single < String > ( ) @ Override public void subscribeActual ( SingleObserver < ? super String > observer ) hasRun . set ( true ) ; observer . onSuccess ( "foo" ) ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( e ) ; Assert . assertFalse ( "Should not have subscribed to single when completable errors" , hasRun . get ( ) ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( 0 ) ; TestScheduler scheduler = new TestScheduler ( ) ; Completable . complete ( ) . andThen ( Single . just ( "foo" ) . delay ( 1 , TimeUnit . SECONDS , scheduler ) ) . toFlowable ( ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNotTerminated ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValue ( "foo" ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
onCreate = spy ( new Function < Completable , Completable > ( ) @ Override public Completable apply ( Completable t ) return t ; ) ; RxJavaPlugins . setOnCompletableAssembly ( onCreate ) ; onStart = spy ( new BiFunction < Completable , CompletableObserver , CompletableObserver > ( ) @ Override public CompletableObserver apply ( Completable t1 , CompletableObserver t2 ) return t2 ; ) ; RxJavaPlugins . setOnCompletableSubscribe ( onStart ) ; 
RxJavaPlugins . reset ( ) ; 
CompletableSource subscriber = mock ( CompletableSource . class ) ; Completable create = Completable . unsafeCreate ( subscriber ) ; verify ( onCreate , times ( 1 ) ) . apply ( create ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = normal . completable . doOnComplete ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = error . completable . doOnComplete ( new Action ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; try c . blockingAwait ( ) ; Assert . fail ( "Failed to throw TestException" ) ; catch ( TestException ex ) Assert . assertEquals ( 0 , calls . get ( ) ) ; 
Completable c = normal . completable . doOnComplete ( new Action ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
final AtomicBoolean doneAfter = new AtomicBoolean ( ) ; final AtomicBoolean complete = new AtomicBoolean ( ) ; Completable c = normal . completable . doAfterTerminate ( new Action ( ) @ Override public void run ( ) doneAfter . set ( complete . get ( ) ) ; ) ; c . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) complete . set ( true ) ; ) ; c . blockingAwait ( ) ; Assert . assertTrue ( "Not completed" , complete . get ( ) ) ; Assert . assertTrue ( "Closure called before onComplete" , doneAfter . get ( ) ) ; 
final AtomicBoolean doneAfter = new AtomicBoolean ( ) ; Completable c = error . completable . doAfterTerminate ( new Action ( ) @ Override public void run ( ) doneAfter . set ( true ) ; ) ; try c . blockingAwait ( 5 , TimeUnit . SECONDS ) ; Assert . fail ( "Did not throw TestException" ) ; catch ( TestException ex ) Assert . assertTrue ( "Closure not called" , doneAfter . get ( ) ) ; 
expectUncaughtTestException ( new Action ( ) @ Override public void run ( ) error . completable . subscribe ( ) ; ) ; 
expectUncaughtTestException ( new Action ( ) @ Override public void run ( ) error . completable . subscribe ( new Action ( ) @ Override public void run ( ) ) ; ) ; 
expectUncaughtTestException ( new Action ( ) @ Override public void run ( ) error . completable . toSingleDefault ( 0 ) . subscribe ( ) ; ) ; 
final AtomicBoolean run = new AtomicBoolean ( ) ; Completable c = normal . completable . andThen ( Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception run . set ( normal . get ( ) == 0 ) ; return null ; ) ) ; c . blockingAwait ( ) ; Assert . assertFalse ( "Start with other" , run . get ( ) ) ; normal . assertSubscriptions ( 1 ) ; 
Completable c = normal . completable . andThen ( error . completable ) ; try c . blockingAwait ( ) ; Assert . fail ( "Did not throw TestException" ) ; catch ( TestException ex ) normal . assertSubscriptions ( 1 ) ; error . assertSubscriptions ( 1 ) ; 
final AtomicBoolean run = new AtomicBoolean ( ) ; Flowable < Object > c = normal . completable . andThen ( Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception run . set ( normal . get ( ) == 0 ) ; return 1 ; ) ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; c . subscribe ( ts ) ; Assert . assertFalse ( "Start with other" , run . get ( ) ) ; normal . assertSubscriptions ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
Flowable < Object > c = normal . completable . andThen ( Flowable . error ( new TestException ( ) ) ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; c . subscribe ( ts ) ; normal . assertSubscriptions ( 1 ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > onDispose = mock ( Consumer . class ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Completable . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throw new TestException ( ) ; , onDispose ) . < Integer > toFlowable ( ) . subscribe ( ts ) ; verify ( onDispose ) . accept ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
Consumer < Integer > onDispose = new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throw new TestException ( ) ; ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Completable . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throw new TestException ( ) ; , onDispose ) . < Integer > toFlowable ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( CompositeException . class ) ; CompositeException ex = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; List < Throwable > listEx = ex . getExceptions ( ) ; assertEquals ( 2 , listEx . size ( ) ) ; assertTrue ( listEx . get ( 0 ) . toString ( ) , listEx . get ( 0 ) instanceof TestException ) ; assertTrue ( listEx . get ( 1 ) . toString ( ) , listEx . get ( 1 ) instanceof TestException ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > onDispose = mock ( Consumer . class ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Completable . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) return null ; , onDispose ) . < Integer > toFlowable ( ) . subscribe ( ts ) ; verify ( onDispose ) . accept ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( NullPointerException . class ) ; 
PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; Disposable completableSubscription = completable . subscribe ( ) ; stringSubject . onComplete ( ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Completable completable = Completable . unsafeCreate ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) observer . onComplete ( ) ; ) ; completable . < String > toFlowable ( ) . subscribe ( ts ) ; verify ( onStart , times ( 1 ) ) . apply ( eq ( completable ) , any ( CompletableObserver . class ) ) ; 
TestSubscriber < Object > ts = new TestSubscriber < Object > ( ) @ Override public void onStart ( ) onNext ( 1 ) ; ; normal . completable . < Object > toFlowable ( ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; error . completable . onErrorComplete ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable t ) throw new TestException ( "Forced inner failure" ) ; ) . < String > toFlowable ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( CompositeException . class ) ; CompositeException composite = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; List < Throwable > errors = composite . getExceptions ( ) ; Assert . assertEquals ( 2 , errors . size ( ) ) ; Assert . assertTrue ( errors . get ( 0 ) . toString ( ) , errors . get ( 0 ) instanceof TestException ) ; Assert . assertNull ( errors . get ( 0 ) . toString ( ) , errors . get ( 0 ) . getMessage ( ) ) ; Assert . assertTrue ( errors . get ( 1 ) . toString ( ) , errors . get ( 1 ) instanceof TestException ) ; Assert . assertEquals ( errors . get ( 1 ) . toString ( ) , "Forced inner failure" , errors . get ( 1 ) . getMessage ( ) ) ; 
PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; final AtomicReference < Disposable > disposableRef = new AtomicReference < > ( ) ; Disposable completableSubscription = completable . subscribe ( new Action ( ) @ Override public void run ( ) if ( disposableRef . get ( ) . isDisposed ( ) ) disposableRef . set ( null ) ; , Functions . emptyConsumer ( ) ) ; disposableRef . set ( completableSubscription ) ; stringSubject . onComplete ( ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; assertNotNull ( "Unsubscribed before the call to onComplete" , disposableRef . get ( ) ) ; 
PublishSubject < String > stringSubject = PublishSubject . create ( ) ; Completable completable = stringSubject . ignoreElements ( ) ; final AtomicReference < Disposable > disposableRef = new AtomicReference < > ( ) ; Disposable completableSubscription = completable . subscribe ( Functions . EMPTY_ACTION , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) if ( disposableRef . get ( ) . isDisposed ( ) ) disposableRef . set ( null ) ; ) ; disposableRef . set ( completableSubscription ) ; stringSubject . onError ( new TestException ( ) ) ; assertTrue ( "Not unsubscribed?" , completableSubscription . isDisposed ( ) ) ; assertNotNull ( "Unsubscribed before the call to onError" , disposableRef . get ( ) ) ; 
expectUncaughtTestException ( new Action ( ) @ Override public void run ( ) normal . completable . toSingleDefault ( 1 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer integer ) throw new TestException ( ) ; ) ; ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( 0 ) ; Completable . never ( ) . andThen ( Flowable . just ( "foo" ) ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNotTerminated ( ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; final AtomicBoolean hasRun = new AtomicBoolean ( false ) ; final Exception e = new Exception ( ) ; Completable . unsafeCreate ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver co ) co . onSubscribe ( Disposable . empty ( ) ) ; co . onError ( e ) ; ) . andThen ( Flowable . < String > unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > s ) hasRun . set ( true ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( "foo" ) ; s . onComplete ( ) ; ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( e ) ; Assert . assertFalse ( "Should not have subscribed to observable when completable errors" , hasRun . get ( ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; Completable . complete ( ) . andThen ( Single . just ( "foo" ) ) . toFlowable ( ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertValue ( "foo" ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try Completable c = Completable . fromFuture ( exec . submit ( new Runnable ( ) @ Override public void run ( ) ) ) ; c . blockingAwait ( ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; Completable c = Completable . fromFuture ( exec . submit ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ) ; try c . blockingAwait ( ) ; Assert . fail ( "Failed to throw Exception" ) ; catch ( RuntimeException ex ) if ( ! ( ( ex . getCause ( ) instanceof ExecutionException ) && ( ex . getCause ( ) . getCause ( ) instanceof TestException ) ) ) ex . printStackTrace ( ) ; Assert . fail ( "Wrong exception received" ) ; finally exec . shutdown ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable c = Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) calls . getAndIncrement ( ) ; ) ; c . blockingAwait ( ) ; Assert . assertEquals ( 1 , calls . get ( ) ) ; 
Completable c = Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ; c . blockingAwait ( ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( 0 ) ; Completable . complete ( ) . doOnEvent ( new Consumer < Throwable > ( ) @ Override public void accept ( final Throwable throwable ) throws Exception if ( throwable == null ) atomicInteger . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicInteger atomicInteger = new AtomicInteger ( 0 ) ; Completable . error ( new RuntimeException ( ) ) . doOnEvent ( new Consumer < Throwable > ( ) @ Override public void accept ( final Throwable throwable ) throws Exception if ( throwable != null ) atomicInteger . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Disposable d = pp . ignoreElements ( ) . subscribe ( Functions . EMPTY_ACTION , Functions . emptyConsumer ( ) ) ; assertFalse ( d . isDisposed ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
final TestScheduler testScheduler = new TestScheduler ( ) ; final AtomicLong atomicLong = new AtomicLong ( ) ; Completable . timer ( 2 , TimeUnit . SECONDS , testScheduler ) . subscribe ( new Action ( ) @ Override public void run ( ) throws Exception atomicLong . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicLong . get ( ) ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 0 , atomicLong . get ( ) ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertEquals ( 1 , atomicLong . get ( ) ) ; 
errors = TestHelper . trackPluginErrors ( ) ; 
RxJavaPlugins . reset ( ) ; assertFalse ( "" + errors , errors . isEmpty ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; Throwable c = errors . get ( 0 ) . getCause ( ) ; assertTrue ( "" + c , c instanceof TestException ) ; 
Flowable . error ( new TestException ( ) ) . subscribe ( ) ; 
Flowable . error ( new TestException ( ) ) . subscribe ( Functions . emptyConsumer ( ) ) ; 
Flowable . error ( new TestException ( ) ) . forEachWhile ( Functions . alwaysTrue ( ) ) ; 
Flowable . error ( new TestException ( ) ) . blockingSubscribe ( Functions . emptyConsumer ( ) ) ; 
Flowable . error ( new TestException ( ) ) . blockingSubscribe ( Functions . emptyConsumer ( ) , 128 ) ; 
Observable . error ( new TestException ( ) ) . subscribe ( ) ; 
Observable . error ( new TestException ( ) ) . subscribe ( Functions . emptyConsumer ( ) ) ; 
Observable . error ( new TestException ( ) ) . forEachWhile ( Functions . alwaysTrue ( ) ) ; 
Observable . error ( new TestException ( ) ) . blockingSubscribe ( Functions . emptyConsumer ( ) ) ; 
Single . error ( new TestException ( ) ) . subscribe ( ) ; 
Single . error ( new TestException ( ) ) . subscribe ( Functions . emptyConsumer ( ) ) ; 
Maybe . error ( new TestException ( ) ) . subscribe ( ) ; 
Maybe . error ( new TestException ( ) ) . subscribe ( Functions . emptyConsumer ( ) ) ; 
Completable . error ( new TestException ( ) ) . subscribe ( ) ; 
Completable . error ( new TestException ( ) ) . subscribe ( Functions . EMPTY_ACTION ) ; 
TestHelper . checkUtilityClass ( ExceptionHelper . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; Observable . just ( 1 , 2 , 3 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) throw new RuntimeException ( "hello" ) ; ) ; TestHelper . assertError ( errors , 0 , RuntimeException . class ) ; assertTrue ( errors . get ( 0 ) . toString ( ) , errors . get ( 0 ) . getMessage ( ) . contains ( "hello" ) ) ; RxJavaPlugins . reset ( ) ; 
final PublishSubject < Integer > a = PublishSubject . create ( ) ; final PublishSubject < Integer > b = PublishSubject . create ( ) ; final int MAX_STACK_DEPTH = 800 ; final AtomicInteger depth = new AtomicInteger ( ) ; a . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; @ Override public void onNext ( Integer n ) b . onNext ( n + 1 ) ; ) ; b . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; @ Override public void onNext ( Integer n ) if ( depth . get ( ) < MAX_STACK_DEPTH ) depth . set ( Thread . currentThread ( ) . getStackTrace ( ) . length ) ; a . onNext ( n + 1 ) ; ) ; a . onNext ( 1 ) ; assertTrue ( depth . get ( ) >= MAX_STACK_DEPTH ) ; 
Observable . just ( 1 ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; @ Override public void onNext ( Integer t ) throw new StackOverflowError ( ) ; ) ; 
Observable . just ( 1 ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; @ Override public void onNext ( Integer t ) throw new ThreadDeath ( ) ; ) ; 
TestHelper . checkUtilityClass ( Exceptions . class ) ; 
try Exceptions . throwIfFatal ( new ThreadDeath ( ) ) ; fail ( "Didn't throw fatal exception" ) ; catch ( ThreadDeath ex ) try Exceptions . throwIfFatal ( new LinkageError ( ) ) ; fail ( "Didn't throw fatal error" ) ; catch ( LinkageError ex ) try ExceptionHelper . wrapOrThrow ( new LinkageError ( ) ) ; fail ( "Didn't propagate Error" ) ; catch ( LinkageError ex ) 
try Exceptions . propagate ( new InternalError ( ) ) ; fail ( "Didn't throw exception" ) ; catch ( InternalError ex ) try throw Exceptions . propagate ( new IllegalArgumentException ( ) ) ; catch ( IllegalArgumentException ex ) try throw ExceptionHelper . wrapOrThrow ( new IOException ( ) ) ; catch ( RuntimeException ex ) if ( ! ( ex . getCause ( ) instanceof IOException ) ) fail ( ex . toString ( ) + ": should have thrown RuntimeException(IOException)" ) ; 
OnErrorNotImplementedException ex = new OnErrorNotImplementedException ( null ) ; assertTrue ( "" + ex . getCause ( ) , ex . getCause ( ) instanceof NullPointerException ) ; 
OnErrorNotImplementedException ex = new OnErrorNotImplementedException ( "Message" , null ) ; assertTrue ( "" + ex . getCause ( ) , ex . getCause ( ) instanceof NullPointerException ) ; 
OnErrorNotImplementedException ex = new OnErrorNotImplementedException ( "Message" , new TestException ( "Forced failure" ) ) ; assertTrue ( "" + ex . getCause ( ) , ex . getCause ( ) instanceof TestException ) ; assertEquals ( "" + ex . getCause ( ) , "Forced failure" , ex . getCause ( ) . getMessage ( ) ) ; 
List < Throwable > throwables = new ArrayList < > ( ) ; throwables . add ( ex1 ) ; throwables . add ( ex2 ) ; throwables . add ( ex3 ) ; return new CompositeException ( throwables ) ; 
Throwable rootCause = new Throwable ( "RootCause" ) ; Throwable e1 = new Throwable ( "1" , rootCause ) ; Throwable e2 = new Throwable ( "2" , rootCause ) ; Throwable e3 = new Throwable ( "3" , rootCause ) ; CompositeException ce = new CompositeException ( e1 , e2 , e3 ) ; System . err . println ( "----------------------------- print composite stacktrace" ) ; ce . printStackTrace ( ) ; assertEquals ( 3 , ce . getExceptions ( ) . size ( ) ) ; assertNoCircularReferences ( ce ) ; assertNotNull ( getRootCause ( ce ) ) ; System . err . println ( "----------------------------- print cause stacktrace" ) ; ce . getCause ( ) . printStackTrace ( ) ; 
try new CompositeException ( ) ; fail ( "CompositeException should fail if errors is empty" ) ; catch ( IllegalArgumentException e ) assertEquals ( "errors is empty" , e . getMessage ( ) ) ; try new CompositeException ( new ArrayList < > ( ) ) ; fail ( "CompositeException should fail if errors is empty" ) ; catch ( IllegalArgumentException e ) assertEquals ( "errors is empty" , e . getMessage ( ) ) ; 
CompositeException cex = new CompositeException ( ex1 , ex2 ) ; System . err . println ( "----------------------------- print composite stacktrace" ) ; cex . printStackTrace ( ) ; assertEquals ( 2 , cex . getExceptions ( ) . size ( ) ) ; assertNoCircularReferences ( cex ) ; assertNotNull ( getRootCause ( cex ) ) ; System . err . println ( "----------------------------- print cause stacktrace" ) ; cex . getCause ( ) . printStackTrace ( ) ; 
CompositeException cex = new CompositeException ( ex2 , ex1 ) ; System . err . println ( "----------------------------- print composite stacktrace" ) ; cex . printStackTrace ( ) ; assertEquals ( 2 , cex . getExceptions ( ) . size ( ) ) ; assertNoCircularReferences ( cex ) ; assertNotNull ( getRootCause ( cex ) ) ; System . err . println ( "----------------------------- print cause stacktrace" ) ; cex . getCause ( ) . printStackTrace ( ) ; 
CompositeException cex = new CompositeException ( ex1 , getNewCompositeExceptionWithEx123 ( ) ) ; System . err . println ( "----------------------------- print composite stacktrace" ) ; cex . printStackTrace ( ) ; assertEquals ( 3 , cex . getExceptions ( ) . size ( ) ) ; assertNoCircularReferences ( cex ) ; assertNotNull ( getRootCause ( cex ) ) ; System . err . println ( "----------------------------- print cause stacktrace" ) ; cex . getCause ( ) . printStackTrace ( ) ; 
CompositeException cex = new CompositeException ( getNewCompositeExceptionWithEx123 ( ) , ex1 ) ; System . err . println ( "----------------------------- print composite stacktrace" ) ; cex . printStackTrace ( ) ; assertEquals ( 3 , cex . getExceptions ( ) . size ( ) ) ; assertNoCircularReferences ( cex ) ; assertNotNull ( getRootCause ( cex ) ) ; System . err . println ( "----------------------------- print cause stacktrace" ) ; cex . getCause ( ) . printStackTrace ( ) ; 
List < Throwable > exs = new ArrayList < > ( ) ; exs . add ( getNewCompositeExceptionWithEx123 ( ) ) ; exs . add ( getNewCompositeExceptionWithEx123 ( ) ) ; CompositeException cex = new CompositeException ( exs ) ; System . err . println ( "----------------------------- print composite stacktrace" ) ; cex . printStackTrace ( ) ; assertEquals ( 3 , cex . getExceptions ( ) . size ( ) ) ; assertNoCircularReferences ( cex ) ; assertNotNull ( getRootCause ( cex ) ) ; System . err . println ( "----------------------------- print cause stacktrace" ) ; cex . getCause ( ) . printStackTrace ( ) ; 
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintStream printStream = new PrintStream ( baos ) ; ex . printStackTrace ( printStream ) ; assertFalse ( baos . toString ( ) . contains ( "CIRCULAR REFERENCE" ) ) ; 
Throwable root = ex . getCause ( ) ; if ( root == null ) return null ; else while ( true ) if ( root . getCause ( ) == null ) return root ; else root = root . getCause ( ) ; 
CompositeException composite = new CompositeException ( ( List < Throwable > ) null ) ; composite . getCause ( ) ; composite . printStackTrace ( ) ; 
CompositeException composite = new CompositeException ( Collections . singletonList ( ( Throwable ) null ) ) ; composite . getCause ( ) ; composite . printStackTrace ( ) ; 
Throwable t = new Throwable ( ) private static final long serialVersionUID = - 3282577447436848385L ; @ Override public synchronized Throwable initCause ( Throwable cause ) throw new UnsupportedOperationException ( ) ; ; CompositeException cex = new CompositeException ( t , ex1 ) ; System . err . println ( "----------------------------- print composite stacktrace" ) ; cex . printStackTrace ( ) ; assertEquals ( 2 , cex . getExceptions ( ) . size ( ) ) ; assertNoCircularReferences ( cex ) ; assertNotNull ( getRootCause ( cex ) ) ; System . err . println ( "----------------------------- print cause stacktrace" ) ; cex . getCause ( ) . printStackTrace ( ) ; 
Throwable t = new Throwable ( "ThrowableWithNullInitCause" ) private static final long serialVersionUID = - 7984762607894527888L ; @ Override public synchronized Throwable initCause ( Throwable cause ) return null ; ; CompositeException cex = new CompositeException ( t , ex1 ) ; System . err . println ( "----------------------------- print composite stacktrace" ) ; cex . printStackTrace ( ) ; assertEquals ( 2 , cex . getExceptions ( ) . size ( ) ) ; assertNoCircularReferences ( cex ) ; assertNotNull ( getRootCause ( cex ) ) ; System . err . println ( "----------------------------- print cause stacktrace" ) ; cex . getCause ( ) . printStackTrace ( ) ; 
CompositeException compositeException = new CompositeException ( ex1 , ex3 ) ; assertEquals ( "2 exceptions occurred. " , compositeException . getMessage ( ) ) ; 
CompositeException compositeException = new CompositeException ( ex1 , ex2 , ex3 ) ; assertEquals ( "3 exceptions occurred. " , compositeException . getMessage ( ) ) ; 
assertTrue ( new CompositeException ( ( Throwable [ ] ) null ) . getExceptions ( ) . get ( 0 ) instanceof NullPointerException ) ; assertTrue ( new CompositeException ( ( Iterable < Throwable > ) null ) . getExceptions ( ) . get ( 0 ) instanceof NullPointerException ) ; assertTrue ( new CompositeException ( null , new TestException ( ) ) . getExceptions ( ) . get ( 0 ) instanceof NullPointerException ) ; 
StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; new CompositeException ( new TestException ( ) ) . printStackTrace ( pw ) ; assertTrue ( sw . toString ( ) . contains ( "TestException" ) ) ; 
Throwable e = new BadException ( ) ; assertSame ( e , new CompositeException ( e ) . getCause ( ) . getCause ( ) ) ; assertSame ( e , new CompositeException ( new RuntimeException ( e ) ) . getCause ( ) . getCause ( ) . getCause ( ) ) ; 
CompositeException composite = new CompositeException ( new TestException ( "ex1" ) , new TestException ( "ex2" ) , new TestException ( "ex3" , new TestException ( "ex4" ) ) ) ; String overview = composite . getCause ( ) . getMessage ( ) ; assertTrue ( overview , overview . contains ( "Multiple exceptions (3)" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.TestException: ex1" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.TestException: ex2" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.TestException: ex3" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.TestException: ex4" ) ) ; assertTrue ( overview , overview . contains ( "at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.exceptionOverview" ) ) ; 
CompositeException composite = new CompositeException ( new TestException ( "ex1" ) , new CompositeException . ExceptionOverview ( "example" ) ) ; String overview = composite . getCause ( ) . getMessage ( ) ; assertTrue ( overview , overview . contains ( "Multiple exceptions (2)" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.TestException: ex1" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.CompositeException.ExceptionOverview: example" ) ) ; assertEquals ( overview , 2 , overview . split ( "at\\s" ) . length ) ; 
TestException ex0 = new TestException ( "ex0" ) ; TestException ex1 = new TestException ( "ex1" , ex0 ) ; CompositeException composite = new CompositeException ( ex1 , new TestException ( "ex2" , ex1 ) ) ; String overview = composite . getCause ( ) . getMessage ( ) ; System . err . println ( overview ) ; assertTrue ( overview , overview . contains ( "Multiple exceptions (2)" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.TestException: ex0" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.TestException: ex1" ) ) ; assertTrue ( overview , overview . contains ( "io.reactivex.rxjava3.exceptions.TestException: ex2" ) ) ; assertTrue ( overview , overview . contains ( "(cause not expanded again) io.reactivex.rxjava3.exceptions.TestException: ex0" ) ) ; assertEquals ( overview , 5 , overview . split ( "at\\s" ) . length ) ; 
TestException ex1 = new TestException ( "ex1" ) ; TestException ex2 = new TestException ( "ex2" ) ; CompositeException composite1 = new CompositeException ( ex1 , ex2 ) ; TestException ex3 = new TestException ( "ex3" ) ; TestException ex4 = new TestException ( "ex4" , composite1 ) ; CompositeException composite2 = new CompositeException ( ex3 , ex4 ) ; String overview = composite2 . getCause ( ) . getMessage ( ) ; System . err . println ( overview ) ; assertTrue ( overview , overview . contains ( "        Multiple exceptions (2)" ) ) ; assertTrue ( overview , overview . contains ( "        |-- io.reactivex.rxjava3.exceptions.TestException: ex1" ) ) ; assertTrue ( overview , overview . contains ( "        |-- io.reactivex.rxjava3.exceptions.TestException: ex2" ) ) ; 
TestException ex = new TestException ( "ex1" ) ; CompositeException composite = new CompositeException ( ex ) ; assertSame ( composite . getCause ( ) , ex ) ; 
DelayedRunnable dl = new DelayedRunnable ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; ) ; dl . run ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; DelayedRunnable dl = new DelayedRunnable ( new Runnable ( ) @ Override public void run ( ) count . incrementAndGet ( ) ; ) ; dl . dispose ( ) ; dl . dispose ( ) ; dl . run ( ) ; assertEquals ( 0 , count . get ( ) ) ; 
final int [ ] count = 0 ; ImmediateThinScheduler . INSTANCE . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) count [ 0 ] ++ ; ) ; assertEquals ( 1 , count [ 0 ] ) ; 
ImmediateThinScheduler . INSTANCE . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . SECONDS ) ; 
ImmediateThinScheduler . INSTANCE . schedulePeriodicallyDirect ( Functions . EMPTY_RUNNABLE , 1 , 1 , TimeUnit . SECONDS ) ; 
final int [ ] count = 0 ; Worker w = ImmediateThinScheduler . INSTANCE . createWorker ( ) ; assertFalse ( w . isDisposed ( ) ) ; w . schedule ( new Runnable ( ) @ Override public void run ( ) count [ 0 ] ++ ; ) ; assertEquals ( 1 , count [ 0 ] ) ; 
ImmediateThinScheduler . INSTANCE . createWorker ( ) . schedule ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . SECONDS ) ; 
ImmediateThinScheduler . INSTANCE . createWorker ( ) . schedulePeriodically ( Functions . EMPTY_RUNNABLE , 1 , 1 , TimeUnit . SECONDS ) ; 
final int [ ] calls = 0 ; Runnable r = new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; ; Scheduler s = new SingleScheduler ( ) ; s . shutdown ( ) ; assertEquals ( Disposable . disposed ( ) , s . scheduleDirect ( r ) ) ; assertEquals ( Disposable . disposed ( ) , s . scheduleDirect ( r , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( Disposable . disposed ( ) , s . schedulePeriodicallyDirect ( r , 1 , 1 , TimeUnit . SECONDS ) ) ; Worker w = s . createWorker ( ) ; ( ( ScheduledWorker ) w ) . executor . shutdownNow ( ) ; assertEquals ( Disposable . disposed ( ) , w . schedule ( r ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedule ( r , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( Disposable . disposed ( ) , w . schedulePeriodically ( r , 1 , 1 , TimeUnit . SECONDS ) ) ; assertEquals ( 0 , calls [ 0 ] ) ; w . dispose ( ) ; assertTrue ( w . isDisposed ( ) ) ; 
final Scheduler s = new SingleScheduler ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) s . shutdown ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) s . start ( ) ; ; TestHelper . race ( r1 , r1 ) ; 
final Scheduler s = Schedulers . single ( ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . single ( ) ; Disposable d = s . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) throw new IllegalStateException ( ) ; ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
final Scheduler s = Schedulers . single ( ) ; Disposable d = s . scheduleDirect ( Functions . EMPTY_RUNNABLE , 1 , TimeUnit . MILLISECONDS ) ; while ( ! d . isDisposed ( ) ) Thread . sleep ( 1 ) ; 
return Schedulers . single ( ) ; 
TestHelper . withErrorTracking ( errors -> Scheduler s = RxJavaPlugins . createSingleScheduler ( new RxThreadFactory ( "Test" ) ) ; s . shutdown ( ) ; Runnable run = mock ( Runnable . class ) ; s . schedulePeriodicallyDirect ( run , 1 , 0 , TimeUnit . MILLISECONDS ) ; Thread . sleep ( 100 ) ; verify ( run , never ( ) ) . run ( ) ; TestHelper . assertUndeliverable ( errors , 0 , RejectedExecutionException . class ) ; ) ; 
RxThreadFactory tf = new RxThreadFactory ( "Test" , 1 ) ; assertEquals ( "RxThreadFactory[Test]" , tf . toString ( ) ) ; Thread t = tf . newThread ( Functions . EMPTY_RUNNABLE ) ; assertTrue ( t . isDaemon ( ) ) ; assertEquals ( 1 , t . getPriority ( ) ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try InstantPeriodicTask task = new InstantPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , exec ) ; try task . call ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException excepted ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally exec . shutdownNow ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try InstantPeriodicTask task = new InstantPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , exec ) ; assertFalse ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; finally exec . shutdownNow ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try InstantPeriodicTask task = new InstantPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , exec ) ; task . setFirst ( new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) ) ; task . setRest ( new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) ) ; assertFalse ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; finally exec . shutdownNow ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try InstantPeriodicTask task = new InstantPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , exec ) ; task . runner = Thread . currentThread ( ) ; task . setFirst ( new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) ) ; task . setRest ( new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) ) ; assertFalse ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; finally exec . shutdownNow ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try InstantPeriodicTask task = new InstantPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , exec ) ; task . dispose ( ) ; FutureTask < Void > f1 = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; task . setFirst ( f1 ) ; assertTrue ( f1 . isCancelled ( ) ) ; FutureTask < Void > f2 = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; task . setRest ( f2 ) ; assertTrue ( f2 . isCancelled ( ) ) ; finally exec . shutdownNow ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try InstantPeriodicTask task = new InstantPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , exec ) ; task . runner = Thread . currentThread ( ) ; task . dispose ( ) ; FutureTask < Void > f1 = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; task . setFirst ( f1 ) ; assertTrue ( f1 . isCancelled ( ) ) ; FutureTask < Void > f2 = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; task . setRest ( f2 ) ; assertTrue ( f2 . isCancelled ( ) ) ; finally exec . shutdownNow ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final InstantPeriodicTask task = new InstantPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , exec ) ; final FutureTask < Void > f1 = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) task . setFirst ( f1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) task . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( f1 . isCancelled ( ) ) ; assertTrue ( task . isDisposed ( ) ) ; finally exec . shutdownNow ( ) ; RxJavaPlugins . reset ( ) ; 
ExecutorService exec = Executors . newSingleThreadExecutor ( ) ; try for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final InstantPeriodicTask task = new InstantPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , exec ) ; final FutureTask < Void > f1 = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) task . setRest ( f1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) task . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( f1 . isCancelled ( ) ) ; assertTrue ( task . isDisposed ( ) ) ; finally exec . shutdownNow ( ) ; RxJavaPlugins . reset ( ) ; 
boolean savedScheduledRelease = IoScheduler . USE_SCHEDULED_RELEASE ; IoScheduler . USE_SCHEDULED_RELEASE = true ; try Flowable . just ( "item" ) . observeOn ( Schedulers . io ( ) ) . firstOrError ( ) . map ( item -> for ( int i = 0 ; i < 50 ; i ++ ) Completable . complete ( ) . observeOn ( Schedulers . io ( ) ) . blockingAwait ( ) ; return "Done" ; ) . ignoreElement ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertComplete ( ) ; finally IoScheduler . USE_SCHEDULED_RELEASE = savedScheduledRelease ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BooleanRunnable task = new BooleanRunnable ( ( ) -> throw new TestException ( ) ; ) ; try task . run ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestScheduler tSched = new TestScheduler ( ) ; SchedulerWhen sched = maxConcurrentScheduler ( tSched ) ; TestSubscriber < Long > tSub = TestSubscriber . create ( ) ; asyncWork ( sched ) . subscribe ( tSub ) ; tSub . assertValueCount ( 0 ) ; tSched . advanceTimeBy ( 0 , SECONDS ) ; tSub . assertValueCount ( 0 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 2 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 4 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 5 ) ; tSub . assertComplete ( ) ; sched . dispose ( ) ; 
final TestScheduler tSched = new TestScheduler ( ) ; SchedulerWhen sched = throttleScheduler ( tSched ) ; TestSubscriber < Long > tSub = TestSubscriber . create ( ) ; asyncWork ( sched ) . subscribe ( tSub ) ; tSub . assertValueCount ( 0 ) ; tSched . advanceTimeBy ( 0 , SECONDS ) ; tSub . assertValueCount ( 0 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 1 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 1 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 2 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 2 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 3 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 3 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 4 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 4 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 5 ) ; tSub . assertComplete ( ) ; sched . dispose ( ) ; 
TestScheduler tSched = new TestScheduler ( ) ; SchedulerWhen sched = maxConcurrentScheduler ( tSched ) ; TestSubscriber < Long > tSub = TestSubscriber . create ( ) ; syncWork ( sched ) . subscribe ( tSub ) ; tSub . assertValueCount ( 0 ) ; tSched . advanceTimeBy ( 0 , SECONDS ) ; tSub . assertValueCount ( 5 ) ; tSub . assertComplete ( ) ; sched . dispose ( ) ; 
final TestScheduler tSched = new TestScheduler ( ) ; SchedulerWhen sched = throttleScheduler ( tSched ) ; TestSubscriber < Long > tSub = TestSubscriber . create ( ) ; syncWork ( sched ) . subscribe ( tSub ) ; tSub . assertValueCount ( 0 ) ; tSched . advanceTimeBy ( 0 , SECONDS ) ; tSub . assertValueCount ( 1 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 2 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 3 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 4 ) ; tSched . advanceTimeBy ( 1 , SECONDS ) ; tSub . assertValueCount ( 5 ) ; tSub . assertComplete ( ) ; sched . dispose ( ) ; 
return Flowable . range ( 1 , 5 ) . flatMap ( new Function < Integer , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Integer t ) return Flowable . timer ( 1 , SECONDS , sched ) ; ) ; 
return Flowable . range ( 1 , 5 ) . flatMap ( new Function < Integer , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Integer t ) return Flowable . defer ( new Supplier < Flowable < Long > > ( ) @ Override public Flowable < Long > get ( ) return Flowable . just ( 0l ) ; ) . subscribeOn ( sched ) ; ) ; 
SchedulerWhen sched = new SchedulerWhen ( new Function < Flowable < Flowable < Completable > > , Completable > ( ) @ Override public Completable apply ( Flowable < Flowable < Completable > > workerActions ) Flowable < Completable > workers = workerActions . map ( new Function < Flowable < Completable > , Completable > ( ) @ Override public Completable apply ( Flowable < Completable > actions ) return Completable . concat ( actions ) ; ) ; return Completable . merge ( workers , 2 ) ; , tSched ) ; return sched ; 
SchedulerWhen sched = new SchedulerWhen ( new Function < Flowable < Flowable < Completable > > , Completable > ( ) @ Override public Completable apply ( Flowable < Flowable < Completable > > workerActions ) Flowable < Completable > workers = workerActions . map ( new Function < Flowable < Completable > , Completable > ( ) @ Override public Completable apply ( Flowable < Completable > actions ) return Completable . concat ( actions ) ; ) ; return Completable . concat ( workers . map ( new Function < Completable , Completable > ( ) @ Override public Completable apply ( Completable worker ) return worker . delay ( 1 , SECONDS , tSched ) ; ) ) ; , tSched ) ; return sched ; 
Scheduler comp = Schedulers . computation ( ) ; Scheduler limited = comp . when ( new Function < Flowable < Flowable < Completable > > , Completable > ( ) @ Override public Completable apply ( Flowable < Flowable < Completable > > t ) return Completable . merge ( Flowable . merge ( t , 10 ) ) ; ) ; merge ( just ( just ( 1 ) . subscribeOn ( limited ) . observeOn ( comp ) ) . repeat ( 1000 ) ) . blockingSubscribe ( ) ; 
SchedulerWhen . SUBSCRIBED . dispose ( ) ; assertFalse ( SchedulerWhen . SUBSCRIBED . isDisposed ( ) ) ; 
new SchedulerWhen ( new Function < Flowable < Flowable < Completable > > , Completable > ( ) @ Override public Completable apply ( Flowable < Flowable < Completable > > v ) throws Exception throw new TestException ( ) ; , Schedulers . single ( ) ) ; 
SchedulerWhen sw = new SchedulerWhen ( new Function < Flowable < Flowable < Completable > > , Completable > ( ) @ Override public Completable apply ( Flowable < Flowable < Completable > > v ) throws Exception return Completable . never ( ) ; , Schedulers . single ( ) ) ; assertFalse ( sw . isDisposed ( ) ) ; sw . dispose ( ) ; assertTrue ( sw . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final ScheduledAction sa = new ScheduledAction ( ) private static final long serialVersionUID = - 672980251643733156L ; @ Override protected Disposable callActual ( Worker actualWorker , CompletableObserver actionCompletable ) return Disposable . empty ( ) ; ; assertFalse ( sa . isDisposed ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) sa . dispose ( ) ; ; TestHelper . race ( r1 , r1 ) ; assertTrue ( sa . isDisposed ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; ScheduledAction sa = new ScheduledAction ( ) private static final long serialVersionUID = - 672980251643733156L ; @ Override protected Disposable callActual ( Worker actualWorker , CompletableObserver actionCompletable ) count . incrementAndGet ( ) ; return Disposable . empty ( ) ; ; assertFalse ( sa . isDisposed ( ) ) ; sa . dispose ( ) ; assertTrue ( sa . isDisposed ( ) ) ; sa . dispose ( ) ; assertTrue ( sa . isDisposed ( ) ) ; sa . call ( Schedulers . single ( ) . createWorker ( ) , null ) ; assertEquals ( 0 , count . get ( ) ) ; sa . set ( Disposable . empty ( ) ) ; sa . call ( Schedulers . single ( ) . createWorker ( ) , null ) ; assertEquals ( 0 , count . get ( ) ) ; sa = new ScheduledAction ( ) private static final long serialVersionUID = - 672980251643733156L ; @ Override protected Disposable callActual ( Worker actualWorker , CompletableObserver actionCompletable ) count . incrementAndGet ( ) ; dispose ( ) ; return Disposable . empty ( ) ; ; sa . call ( Schedulers . single ( ) . createWorker ( ) , null ) ; assertEquals ( 1 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; OnCompletedAction a = new OnCompletedAction ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , new DisposableCompletableObserver ( ) @ Override public void onComplete ( ) count . incrementAndGet ( ) ; @ Override public void onError ( Throwable e ) count . decrementAndGet ( ) ; e . printStackTrace ( ) ; ) ; try a . run ( ) ; fail ( "Should have thrown" ) ; catch ( TestException expected ) assertEquals ( 1 , count . get ( ) ) ; 
QueueWorker qw = new QueueWorker ( PublishProcessor . < ScheduledAction > create ( ) , Schedulers . single ( ) . createWorker ( ) ) ; assertFalse ( qw . isDisposed ( ) ) ; qw . dispose ( ) ; assertTrue ( qw . isDisposed ( ) ) ; qw . dispose ( ) ; assertTrue ( qw . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( ) ; , true ) ; try task . run ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ConcurrentLinkedQueue < ThreadWorker > expire = new ConcurrentLinkedQueue < > ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; CachedWorkerPool . evictExpiredWorkers ( expire , cd ) ; 
ConcurrentLinkedQueue < ThreadWorker > expire = new ConcurrentLinkedQueue < > ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; ThreadWorker tw = new ThreadWorker ( new RxThreadFactory ( "IoExpiryTest" ) ) ; try expire . add ( tw ) ; cd . add ( tw ) ; CachedWorkerPool . evictExpiredWorkers ( expire , cd ) ; assertTrue ( tw . isDisposed ( ) ) ; assertTrue ( expire . isEmpty ( ) ) ; finally tw . dispose ( ) ; 
ConcurrentLinkedQueue < ThreadWorker > expire = new ConcurrentLinkedQueue < > ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; ThreadWorker tw = new ThreadWorker ( new RxThreadFactory ( "IoExpiryTest" ) ) ; tw . setExpirationTime ( System . nanoTime ( ) + 10_000_000_000L ) ; try expire . add ( tw ) ; cd . add ( tw ) ; CachedWorkerPool . evictExpiredWorkers ( expire , cd ) ; assertFalse ( tw . isDisposed ( ) ) ; assertFalse ( expire . isEmpty ( ) ) ; finally tw . dispose ( ) ; 
ConcurrentLinkedQueue < ThreadWorker > expire = new ConcurrentLinkedQueue < > ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; ThreadWorker tw = new ThreadWorker ( new RxThreadFactory ( "IoExpiryTest" ) ) ; tw . dispose ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) expire . add ( tw ) ; cd . add ( tw ) ; TestHelper . race ( ( ) -> CachedWorkerPool . evictExpiredWorkers ( expire , cd ) , ( ) -> expire . remove ( tw ) ) ; 
Thread . currentThread ( ) . interrupt ( ) ; final int [ ] calls = 0 ; assertSame ( EmptyDisposable . INSTANCE , Schedulers . trampoline ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; , 1 , TimeUnit . SECONDS ) ) ; assertTrue ( Thread . interrupted ( ) ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
Worker w = Schedulers . trampoline ( ) . createWorker ( ) ; assertFalse ( w . isDisposed ( ) ) ; w . dispose ( ) ; assertTrue ( w . isDisposed ( ) ) ; assertEquals ( EmptyDisposable . INSTANCE , w . schedule ( Functions . EMPTY_RUNNABLE ) ) ; 
final Worker w = Schedulers . trampoline ( ) . createWorker ( ) ; try final int [ ] calls = 0 , 0 ; w . schedule ( new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; w . schedule ( new Runnable ( ) @ Override public void run ( ) calls [ 1 ] ++ ; ) . dispose ( ) ; ) ; assertEquals ( 1 , calls [ 0 ] ) ; assertEquals ( 0 , calls [ 1 ] ) ; finally w . dispose ( ) ; 
final Worker w = Schedulers . trampoline ( ) . createWorker ( ) ; try final int [ ] calls = 0 , 0 ; w . schedule ( new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; w . schedule ( new Runnable ( ) @ Override public void run ( ) calls [ 1 ] ++ ; , 1 , TimeUnit . MILLISECONDS ) ; w . dispose ( ) ; ) ; assertEquals ( 1 , calls [ 0 ] ) ; assertEquals ( 0 , calls [ 1 ] ) ; finally w . dispose ( ) ; 
final Worker w = Schedulers . trampoline ( ) . createWorker ( ) ; try final int [ ] calls = 0 , 0 ; w . schedule ( new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; w . dispose ( ) ; assertSame ( EmptyDisposable . INSTANCE , w . schedule ( new Runnable ( ) @ Override public void run ( ) calls [ 1 ] ++ ; , 1 , TimeUnit . MILLISECONDS ) ) ; ) ; assertEquals ( 1 , calls [ 0 ] ) ; assertEquals ( 0 , calls [ 1 ] ) ; finally w . dispose ( ) ; 
final Worker w = Schedulers . trampoline ( ) . createWorker ( ) ; try final int [ ] calls = 0 ; Thread . currentThread ( ) . interrupt ( ) ; w . schedule ( new Runnable ( ) @ Override public void run ( ) calls [ 0 ] ++ ; , 1 , TimeUnit . DAYS ) ; assertTrue ( Thread . interrupted ( ) ) ; assertEquals ( 0 , calls [ 0 ] ) ; finally w . dispose ( ) ; 
TrampolineWorker w = new TrampolineWorker ( ) ; Runnable r = mock ( Runnable . class ) ; SleepingRunnable run = new SleepingRunnable ( r , w , 0 ) ; w . dispose ( ) ; run . run ( ) ; verify ( r , never ( ) ) . run ( ) ; 
TrampolineWorker w = new TrampolineWorker ( ) ; Runnable r = mock ( Runnable . class ) ; SleepingRunnable run = new SleepingRunnable ( r , w , 0 ) ; run . run ( ) ; verify ( r ) . run ( ) ; 
final TrampolineWorker w = new TrampolineWorker ( ) ; Runnable r = mock ( Runnable . class ) ; SleepingRunnable run = new SleepingRunnable ( r , w , System . currentTimeMillis ( ) + 200 ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) w . dispose ( ) ; , 100 , TimeUnit . MILLISECONDS ) ; run . run ( ) ; verify ( r , never ( ) ) . run ( ) ; 
Scheduler . Worker w = Schedulers . trampoline ( ) . createWorker ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) Runnable run = mock ( Runnable . class ) ; AtomicInteger sync = new AtomicInteger ( 2 ) ; w . schedule ( ( ) -> Disposable d = w . schedule ( run ) ; Schedulers . single ( ) . scheduleDirect ( ( ) -> if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) d . dispose ( ) ; ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) ) ; 
CompositeDisposable set = new CompositeDisposable ( ) ; ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; set . add ( run ) ; assertFalse ( run . isDisposed ( ) ) ; set . dispose ( ) ; assertTrue ( run . isDisposed ( ) ) ; 
CompositeDisposable set = new CompositeDisposable ( ) ; ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; set . add ( run ) ; assertFalse ( run . isDisposed ( ) ) ; run . dispose ( ) ; run . dispose ( ) ; assertTrue ( run . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) CompositeDisposable set = new CompositeDisposable ( ) ; final ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; set . add ( run ) ; final FutureTask < Object > ft = new FutureTask < > ( Functions . EMPTY_RUNNABLE , 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) run . setFuture ( ft ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) run . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertEquals ( 0 , set . size ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) CompositeDisposable set = new CompositeDisposable ( ) ; final ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; set . add ( run ) ; final FutureTask < Object > ft = new FutureTask < > ( Functions . EMPTY_RUNNABLE , 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) run . setFuture ( ft ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) run . run ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertEquals ( 0 , set . size ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) CompositeDisposable set = new CompositeDisposable ( ) ; final ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; set . add ( run ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) run . dispose ( ) ; ; TestHelper . race ( r1 , r1 ) ; assertEquals ( 0 , set . size ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) CompositeDisposable set = new CompositeDisposable ( ) ; final ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; set . add ( run ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) run . call ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) run . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertEquals ( 0 , set . size ( ) ) ; 
Thread . currentThread ( ) . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) @ Override public void uncaughtException ( Thread t , Throwable e ) throw new TestException ( "Second" ) ; ) ; CompositeDisposable set = new CompositeDisposable ( ) ; final ScheduledRunnable run = new ScheduledRunnable ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( "First" ) ; , set ) ; set . add ( run ) ; try run . run ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) assertEquals ( "Second" , ex . getMessage ( ) ) ; finally Thread . currentThread ( ) . setUncaughtExceptionHandler ( null ) ; assertTrue ( run . isDisposed ( ) ) ; assertEquals ( 0 , set . size ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try CompositeDisposable set = new CompositeDisposable ( ) ; final ScheduledRunnable run = new ScheduledRunnable ( new Runnable ( ) @ Override public void run ( ) throw new TestException ( "First" ) ; , set ) ; set . add ( run ) ; try run . run ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) assertTrue ( run . isDisposed ( ) ) ; assertEquals ( 0 , set . size ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "First" ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , null ) ; run . dispose ( ) ; run . call ( ) ; 
ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , new CompositeDisposable ( ) ) ; run . dispose ( ) ; run . call ( ) ; 
ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , null ) ; run . setFuture ( new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) ) ; run . dispose ( ) ; run . call ( ) ; 
ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , null ) ; run . dispose ( ) ; run . setFuture ( new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) ) ; run . call ( ) ; 
ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , null ) ; run . dispose ( ) ; run . set ( 2 , Thread . currentThread ( ) ) ; run . setFuture ( new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) ) ; run . call ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) CompositeDisposable set = new CompositeDisposable ( ) ; final ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; set . add ( run ) ; final FutureTask < Void > ft = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) run . call ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) run . setFuture ( ft ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final CompositeDisposable set = new CompositeDisposable ( ) ; final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final AtomicInteger sync = new AtomicInteger ( 2 ) ; final AtomicInteger syncb = new AtomicInteger ( 2 ) ; Runnable r0 = new Runnable ( ) @ Override public void run ( ) set . dispose ( ) ; if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) if ( syncb . decrementAndGet ( ) != 0 ) while ( syncb . get ( ) != 0 ) for ( int j = 0 ; j < 1000 ; j ++ ) if ( Thread . currentThread ( ) . isInterrupted ( ) ) interrupted . set ( true ) ; break ; ; final ScheduledRunnable run = new ScheduledRunnable ( r0 , set ) ; set . add ( run ) ; final FutureTask < Void > ft = new FutureTask < > ( run , null ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) if ( sync . decrementAndGet ( ) != 0 ) while ( sync . get ( ) != 0 ) run . setFuture ( ft ) ; if ( syncb . decrementAndGet ( ) != 0 ) while ( syncb . get ( ) != 0 ) ; TestHelper . race ( ft , r2 ) ; assertFalse ( "The task was interrupted" , interrupted . get ( ) ) ; 
final ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , null ) ; run . run ( ) ; assertEquals ( ScheduledRunnable . DONE , run . get ( ScheduledRunnable . FUTURE_INDEX ) ) ; run . dispose ( ) ; assertEquals ( ScheduledRunnable . DONE , run . get ( ScheduledRunnable . FUTURE_INDEX ) ) ; 
final ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , null ) ; run . set ( ScheduledRunnable . THREAD_INDEX , Thread . currentThread ( ) ) ; run . dispose ( ) ; assertEquals ( ScheduledRunnable . SYNC_DISPOSED , run . get ( ScheduledRunnable . FUTURE_INDEX ) ) ; run . dispose ( ) ; assertEquals ( ScheduledRunnable . SYNC_DISPOSED , run . get ( ScheduledRunnable . FUTURE_INDEX ) ) ; run . run ( ) ; assertEquals ( ScheduledRunnable . SYNC_DISPOSED , run . get ( ScheduledRunnable . FUTURE_INDEX ) ) ; 
final ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , null ) ; run . dispose ( ) ; assertEquals ( ScheduledRunnable . ASYNC_DISPOSED , run . get ( ScheduledRunnable . FUTURE_INDEX ) ) ; run . dispose ( ) ; assertEquals ( ScheduledRunnable . ASYNC_DISPOSED , run . get ( ScheduledRunnable . FUTURE_INDEX ) ) ; run . run ( ) ; assertEquals ( ScheduledRunnable . ASYNC_DISPOSED , run . get ( ScheduledRunnable . FUTURE_INDEX ) ) ; 
ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , null ) ; assertFalse ( run . isDisposed ( ) ) ; run . run ( ) ; assertTrue ( run . isDisposed ( ) ) ; 
CompositeDisposable set = new CompositeDisposable ( ) ; ScheduledRunnable run = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; set . add ( run ) ; assertFalse ( run . isDisposed ( ) ) ; run . run ( ) ; assertTrue ( run . isDisposed ( ) ) ; assertFalse ( set . remove ( run ) ) ; 
CompositeDisposable set = new CompositeDisposable ( ) ; ScheduledRunnable task = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; assertEquals ( "ScheduledRunnable[Waiting]" , task . toString ( ) ) ; task . set ( ScheduledRunnable . THREAD_INDEX , Thread . currentThread ( ) ) ; assertEquals ( "ScheduledRunnable[Running on " + Thread . currentThread ( ) + "]" , task . toString ( ) ) ; task . dispose ( ) ; assertEquals ( "ScheduledRunnable[Disposed(Sync)]" , task . toString ( ) ) ; task . set ( ScheduledRunnable . FUTURE_INDEX , ScheduledRunnable . DONE ) ; assertEquals ( "ScheduledRunnable[Finished]" , task . toString ( ) ) ; task = new ScheduledRunnable ( Functions . EMPTY_RUNNABLE , set ) ; task . dispose ( ) ; assertEquals ( "ScheduledRunnable[Disposed(Async)]" , task . toString ( ) ) ; 
final List < Worker > list = new ArrayList < > ( ) ; SchedulerMultiWorkerSupport mws = ( SchedulerMultiWorkerSupport ) Schedulers . computation ( ) ; mws . createWorkers ( max * 2 , new WorkerCallback ( ) @ Override public void onWorker ( int i , Worker w ) list . add ( w ) ; ) ; assertEquals ( max * 2 , list . size ( ) ) ; 
final List < Worker > list = new ArrayList < > ( ) ; ComputationScheduler . NONE . createWorkers ( max * 2 , new WorkerCallback ( ) @ Override public void onWorker ( int i , Worker w ) list . add ( w ) ; ) ; assertEquals ( max * 2 , list . size ( ) ) ; for ( Worker w : list ) assertEquals ( ComputationScheduler . SHUTDOWN_WORKER , w ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable composite = new CompositeDisposable ( ) ; try final CountDownLatch cdl = new CountDownLatch ( max * 2 ) ; final Set < String > threads1 = Collections . synchronizedSet ( new HashSet < > ( ) ) ; final Set < String > threads2 = Collections . synchronizedSet ( new HashSet < > ( ) ) ; Runnable parallel1 = new Runnable ( ) @ Override public void run ( ) final List < Worker > list1 = new ArrayList < > ( ) ; SchedulerMultiWorkerSupport mws = ( SchedulerMultiWorkerSupport ) Schedulers . computation ( ) ; mws . createWorkers ( max , new WorkerCallback ( ) @ Override public void onWorker ( int i , Worker w ) list1 . add ( w ) ; composite . add ( w ) ; ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) threads1 . add ( Thread . currentThread ( ) . getName ( ) ) ; cdl . countDown ( ) ; ; for ( Worker w : list1 ) w . schedule ( run ) ; ; Runnable parallel2 = new Runnable ( ) @ Override public void run ( ) final List < Worker > list2 = new ArrayList < > ( ) ; SchedulerMultiWorkerSupport mws = ( SchedulerMultiWorkerSupport ) Schedulers . computation ( ) ; mws . createWorkers ( max , new WorkerCallback ( ) @ Override public void onWorker ( int i , Worker w ) list2 . add ( w ) ; composite . add ( w ) ; ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) threads2 . add ( Thread . currentThread ( ) . getName ( ) ) ; cdl . countDown ( ) ; ; for ( Worker w : list2 ) w . schedule ( run ) ; ; TestHelper . race ( parallel1 , parallel2 ) ; assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; assertEquals ( threads1 . toString ( ) , max , threads1 . size ( ) ) ; assertEquals ( threads2 . toString ( ) , max , threads2 . size ( ) ) ; finally composite . dispose ( ) ; 
assertEquals ( 8 , ComputationScheduler . cap ( 8 , - 1 ) ) ; assertEquals ( 8 , ComputationScheduler . cap ( 8 , 0 ) ) ; assertEquals ( 4 , ComputationScheduler . cap ( 8 , 4 ) ) ; assertEquals ( 8 , ComputationScheduler . cap ( 8 , 8 ) ) ; assertEquals ( 8 , ComputationScheduler . cap ( 8 , 9 ) ) ; assertEquals ( 8 , ComputationScheduler . cap ( 8 , 16 ) ) ; 
assertNotNull ( new ExecutorScheduler . SingleHolder ( ) ) ; 
TestHelper . checkUtilityClass ( SchedulerPoolFactory . class ) ; 
assertTrue ( SchedulerPoolFactory . getBooleanProperty ( false , "key" , false , true , failingPropertiesAccessor ) ) ; assertFalse ( SchedulerPoolFactory . getBooleanProperty ( false , "key" , true , false , failingPropertiesAccessor ) ) ; 
assertTrue ( SchedulerPoolFactory . getBooleanProperty ( true , "key" , true , false , missingPropertiesAccessor ) ) ; assertFalse ( SchedulerPoolFactory . getBooleanProperty ( true , "key" , false , true , missingPropertiesAccessor ) ) ; 
assertTrue ( SchedulerPoolFactory . getBooleanProperty ( true , "key" , true , false , failingPropertiesAccessor ) ) ; assertFalse ( SchedulerPoolFactory . getBooleanProperty ( true , "key" , false , true , failingPropertiesAccessor ) ) ; 
assertTrue ( SchedulerPoolFactory . getBooleanProperty ( true , "true" , true , false , Functions . < String > identity ( ) ) ) ; assertFalse ( SchedulerPoolFactory . getBooleanProperty ( true , "false" , false , true , Functions . < String > identity ( ) ) ) ; 
AbstractDirectTask task = new AbstractDirectTask ( Functions . EMPTY_RUNNABLE , true ) private static final long serialVersionUID = 208585707945686116L ; ; final Boolean [ ] interrupted = null ; assertFalse ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; FutureTask < Void > ft = new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) @ Override public boolean cancel ( boolean mayInterruptIfRunning ) interrupted [ 0 ] = mayInterruptIfRunning ; return super . cancel ( mayInterruptIfRunning ) ; ; task . setFuture ( ft ) ; assertTrue ( interrupted [ 0 ] ) ; assertTrue ( task . isDisposed ( ) ) ; 
AbstractDirectTask task = new AbstractDirectTask ( Functions . EMPTY_RUNNABLE , true ) private static final long serialVersionUID = 208585707945686116L ; ; final Boolean [ ] interrupted = null ; assertFalse ( task . isDisposed ( ) ) ; task . runner = Thread . currentThread ( ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; FutureTask < Void > ft = new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) @ Override public boolean cancel ( boolean mayInterruptIfRunning ) interrupted [ 0 ] = mayInterruptIfRunning ; return super . cancel ( mayInterruptIfRunning ) ; ; task . setFuture ( ft ) ; assertFalse ( interrupted [ 0 ] ) ; assertTrue ( task . isDisposed ( ) ) ; 
AbstractDirectTask task = new AbstractDirectTask ( Functions . EMPTY_RUNNABLE , true ) private static final long serialVersionUID = 208585707945686116L ; ; final Boolean [ ] interrupted = null ; FutureTask < Void > ft = new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) @ Override public boolean cancel ( boolean mayInterruptIfRunning ) interrupted [ 0 ] = mayInterruptIfRunning ; return super . cancel ( mayInterruptIfRunning ) ; ; assertFalse ( task . isDisposed ( ) ) ; task . setFuture ( ft ) ; assertFalse ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; assertTrue ( interrupted [ 0 ] ) ; 
AbstractDirectTask task = new AbstractDirectTask ( Functions . EMPTY_RUNNABLE , true ) private static final long serialVersionUID = 208585707945686116L ; ; final Boolean [ ] interrupted = null ; FutureTask < Void > ft = new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) @ Override public boolean cancel ( boolean mayInterruptIfRunning ) interrupted [ 0 ] = mayInterruptIfRunning ; return super . cancel ( mayInterruptIfRunning ) ; ; assertFalse ( task . isDisposed ( ) ) ; task . setFuture ( ft ) ; task . runner = Thread . currentThread ( ) ; assertFalse ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; assertFalse ( interrupted [ 0 ] ) ; 
AbstractDirectTask task = new AbstractDirectTask ( Functions . EMPTY_RUNNABLE , true ) private static final long serialVersionUID = 208585707945686116L ; ; final Boolean [ ] interrupted = null ; FutureTask < Void > ft = new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) @ Override public boolean cancel ( boolean mayInterruptIfRunning ) interrupted [ 0 ] = mayInterruptIfRunning ; return super . cancel ( mayInterruptIfRunning ) ; ; task . set ( AbstractDirectTask . FINISHED ) ; task . setFuture ( ft ) ; assertTrue ( task . isDisposed ( ) ) ; assertNull ( interrupted [ 0 ] ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; assertNull ( interrupted [ 0 ] ) ; 
AbstractDirectTask task = new AbstractDirectTask ( Functions . EMPTY_RUNNABLE , true ) private static final long serialVersionUID = 208585707945686116L ; ; final Boolean [ ] interrupted = null ; FutureTask < Void > ft = new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) @ Override public boolean cancel ( boolean mayInterruptIfRunning ) interrupted [ 0 ] = mayInterruptIfRunning ; return super . cancel ( mayInterruptIfRunning ) ; ; task . set ( AbstractDirectTask . FINISHED ) ; assertTrue ( task . isDisposed ( ) ) ; task . dispose ( ) ; assertTrue ( task . isDisposed ( ) ) ; task . setFuture ( ft ) ; assertTrue ( task . isDisposed ( ) ) ; assertNull ( interrupted [ 0 ] ) ; assertTrue ( task . isDisposed ( ) ) ; assertNull ( interrupted [ 0 ] ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AbstractDirectTask task = new AbstractDirectTask ( Functions . EMPTY_RUNNABLE , true ) private static final long serialVersionUID = 208585707945686116L ; ; final Boolean [ ] interrupted = null ; final FutureTask < Void > ft = new FutureTask < Void > ( Functions . EMPTY_RUNNABLE , null ) @ Override public boolean cancel ( boolean mayInterruptIfRunning ) interrupted [ 0 ] = mayInterruptIfRunning ; return super . cancel ( mayInterruptIfRunning ) ; ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) task . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) task . setFuture ( ft ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestDirectTask task = new TestDirectTask ( ) ; assertEquals ( "TestDirectTask[Waiting]" , task . toString ( ) ) ; task . runner = Thread . currentThread ( ) ; assertEquals ( "TestDirectTask[Running on " + Thread . currentThread ( ) + "]" , task . toString ( ) ) ; task . dispose ( ) ; assertEquals ( "TestDirectTask[Disposed]" , task . toString ( ) ) ; task . set ( AbstractDirectTask . FINISHED ) ; assertEquals ( "TestDirectTask[Finished]" , task . toString ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try InterruptibleRunnable task = new InterruptibleRunnable ( ( ) -> throw new TestException ( ) ; , null ) ; try task . run ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Disposable d = Disposable . empty ( ) ; DisposeOnCancel doc = new DisposeOnCancel ( d ) ; assertFalse ( doc . cancel ( true ) ) ; assertFalse ( doc . isCancelled ( ) ) ; assertFalse ( doc . isDone ( ) ) ; assertNull ( doc . get ( ) ) ; assertNull ( doc . get ( 1 , TimeUnit . SECONDS ) ) ; 
BasicFuseableSubscriber < Integer , Integer > fcs = new BasicFuseableSubscriber < Integer , Integer > ( new TestSubscriber < > ( 0L ) ) @ Override public void onNext ( Integer t ) @ Override public int requestFusion ( int mode ) return 0 ; @ Nullable @ Override public Integer poll ( ) throws Exception return null ; ; fcs . onSubscribe ( new ScalarSubscription < > ( fcs , 1 ) ) ; TestHelper . assertNoOffer ( fcs ) ; assertFalse ( fcs . isEmpty ( ) ) ; fcs . clear ( ) ; assertTrue ( fcs . isEmpty ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; BasicFuseableSubscriber < Integer , Integer > bfs = new BasicFuseableSubscriber < Integer , Integer > ( ts ) @ Override protected boolean beforeDownstream ( ) return false ; @ Override public void onNext ( @ NonNull Integer t ) ts . onNext ( t ) ; @ Override public int requestFusion ( int mode ) return 0 ; @ Override public @ Nullable Integer poll ( ) throws Throwable return null ; ; bfs . onSubscribe ( new BooleanSubscription ( ) ) ; assertFalse ( ts . hasSubscription ( ) ) ; 
final List < Object > received = new ArrayList < > ( ) ; LambdaSubscriber < Object > subscriber = new LambdaSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception throw new TestException ( ) ; ) ; assertFalse ( subscriber . isDisposed ( ) ) ; Flowable . just ( 1 ) . subscribe ( subscriber ) ; assertTrue ( received . toString ( ) , received . get ( 0 ) instanceof TestException ) ; assertEquals ( received . toString ( ) , 1 , received . size ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; 
final List < Object > received = new ArrayList < > ( ) ; LambdaSubscriber < Object > subscriber = new LambdaSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception throw new TestException ( ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception s . request ( Long . MAX_VALUE ) ; ) ; assertFalse ( subscriber . isDisposed ( ) ) ; Flowable . just ( 1 ) . subscribe ( subscriber ) ; assertTrue ( received . toString ( ) , received . get ( 0 ) instanceof TestException ) ; assertEquals ( received . toString ( ) , 1 , received . size ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final List < Object > received = new ArrayList < > ( ) ; LambdaSubscriber < Object > subscriber = new LambdaSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception s . request ( Long . MAX_VALUE ) ; ) ; assertFalse ( subscriber . isDisposed ( ) ) ; Flowable . < Integer > error ( new TestException ( "Outer" ) ) . subscribe ( subscriber ) ; assertTrue ( received . toString ( ) , received . isEmpty ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "Inner" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final List < Object > received = new ArrayList < > ( ) ; LambdaSubscriber < Object > subscriber = new LambdaSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception s . request ( Long . MAX_VALUE ) ; ) ; assertFalse ( subscriber . isDisposed ( ) ) ; Flowable . < Integer > empty ( ) . subscribe ( subscriber ) ; assertTrue ( received . toString ( ) , received . isEmpty ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < Integer > source = Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) BooleanSubscription s1 = new BooleanSubscription ( ) ; s . onSubscribe ( s1 ) ; BooleanSubscription s2 = new BooleanSubscription ( ) ; s . onSubscribe ( s2 ) ; assertFalse ( s1 . isCancelled ( ) ) ; assertTrue ( s2 . isCancelled ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; ) ; final List < Object > received = new ArrayList < > ( ) ; LambdaSubscriber < Object > subscriber = new LambdaSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception s . request ( Long . MAX_VALUE ) ; ) ; source . subscribe ( subscriber ) ; assertEquals ( Arrays . asList ( 1 , 100 ) , received ) ; 
Flowable < Integer > source = Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) BooleanSubscription s1 = new BooleanSubscription ( ) ; s . onSubscribe ( s1 ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onNext ( 2 ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; ) ; final List < Object > received = new ArrayList < > ( ) ; LambdaSubscriber < Object > subscriber = new LambdaSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception s . request ( Long . MAX_VALUE ) ; ) ; source . subscribe ( subscriber ) ; assertEquals ( Arrays . asList ( 1 , 100 ) , received ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final List < Throwable > errors = new ArrayList < > ( ) ; pp . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception errors . add ( e ) ; ) ; assertTrue ( "No observers?!" , pp . hasSubscribers ( ) ) ; assertTrue ( "Has errors already?!" , errors . isEmpty ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( "Has observers?!" , pp . hasSubscribers ( ) ) ; assertFalse ( "No errors?!" , errors . isEmpty ( ) ) ; assertTrue ( errors . toString ( ) , errors . get ( 0 ) instanceof TestException ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final List < Throwable > errors = new ArrayList < > ( ) ; pp . subscribe ( new LambdaSubscriber < > ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception errors . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception throw new TestException ( ) ; ) ) ; assertFalse ( "Has observers?!" , pp . hasSubscribers ( ) ) ; assertFalse ( "No errors?!" , errors . isEmpty ( ) ) ; assertTrue ( errors . toString ( ) , errors . get ( 0 ) instanceof TestException ) ; 
LambdaSubscriber < Integer > subscriber = new LambdaSubscriber < > ( Functions . < Integer > emptyConsumer ( ) , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION , FlowableInternalHelper . RequestMax . INSTANCE ) ; assertFalse ( subscriber . hasCustomOnError ( ) ) ; 
LambdaSubscriber < Integer > subscriber = new LambdaSubscriber < > ( Functions . < Integer > emptyConsumer ( ) , Functions . < Throwable > emptyConsumer ( ) , Functions . EMPTY_ACTION , FlowableInternalHelper . RequestMax . INSTANCE ) ; assertTrue ( subscriber . hasCustomOnError ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; final SinglePostCompleteSubscriber < Integer , Integer > spc = new SinglePostCompleteSubscriber < Integer , Integer > ( ts ) private static final long serialVersionUID = - 2848918821531562637L ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) complete ( 1 ) ; ; spc . onSubscribe ( new BooleanSubscription ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) spc . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 ) ; 
InnerQueuedSubscriberSupport < Integer > support = new InnerQueuedSubscriberSupport < Integer > ( ) @ Override public void innerNext ( InnerQueuedSubscriber < Integer > inner , Integer value ) @ Override public void innerError ( InnerQueuedSubscriber < Integer > inner , Throwable e ) @ Override public void innerComplete ( InnerQueuedSubscriber < Integer > inner ) @ Override public void drain ( ) ; InnerQueuedSubscriber < Integer > inner = new InnerQueuedSubscriber < > ( support , 4 ) ; final List < Long > requests = new ArrayList < > ( ) ; inner . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requests . add ( n ) ; @ Override public void cancel ( ) ) ; inner . request ( 1 ) ; inner . request ( 1 ) ; inner . request ( 1 ) ; inner . request ( 1 ) ; inner . request ( 1 ) ; assertEquals ( Arrays . asList ( 4L , 3L ) , requests ) ; 
final List < Object > list = new ArrayList < > ( ) ; Subscriber < Object > sub = new Subscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) s . request ( 10 ) ; @ Override public void onNext ( Object t ) list . add ( t ) ; @ Override public void onError ( Throwable t ) list . add ( t ) ; @ Override public void onComplete ( ) list . add ( "Done" ) ; ; new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( s ) ; . subscribe ( sub ) ; assertTrue ( list . toString ( ) , list . get ( 0 ) instanceof StrictSubscriber ) ; 
s . request ( 10 ) ; 
list . add ( t ) ; 
list . add ( t ) ; 
list . add ( "Done" ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; SubscriberWrapper < Integer > wrapper = new SubscriberWrapper < > ( ts ) ; Flowable . range ( 1 , 5 ) . subscribe ( wrapper ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0 ) ; SubscriberWrapper < Integer > wrapper = new SubscriberWrapper < > ( ts ) ; Flowable . range ( 1 , 5 ) . subscribe ( wrapper ) ; ts . assertEmpty ( ) . requestMore ( 1 ) . assertValue ( 1 ) . requestMore ( 2 ) . assertValues ( 1 , 2 , 3 ) . requestMore ( 2 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; SubscriberWrapper < Integer > wrapper = new SubscriberWrapper < > ( ts ) ; Flowable . range ( 1 , 5 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . subscribe ( wrapper ) ; ts . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
final List < Object > list = new ArrayList < > ( ) ; Subscriber < Object > sub = new Subscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) s . request ( 5 ) ; list . add ( 0 ) ; @ Override public void onNext ( Object t ) list . add ( t ) ; @ Override public void onError ( Throwable t ) list . add ( t ) ; @ Override public void onComplete ( ) list . add ( "Done" ) ; ; Flowable . range ( 1 , 5 ) . subscribe ( sub ) ; assertEquals ( Arrays . < Object > asList ( 0 , 1 , 2 , 3 , 4 , 5 , "Done" ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Subscriber < Object > sub = new Subscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) s . request ( 0 ) ; @ Override public void onNext ( Object t ) list . add ( t ) ; @ Override public void onError ( Throwable t ) list . add ( t ) ; @ Override public void onComplete ( ) list . add ( "Done" ) ; ; Flowable . range ( 1 , 5 ) . subscribe ( sub ) ; assertTrue ( list . toString ( ) , list . get ( 0 ) instanceof IllegalArgumentException ) ; assertTrue ( list . toString ( ) , list . get ( 0 ) . toString ( ) . contains ( "3.9" ) ) ; 
final List < Object > list = new ArrayList < > ( ) ; Subscriber < Object > sub = new Subscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) s . request ( - 99 ) ; @ Override public void onNext ( Object t ) list . add ( t ) ; @ Override public void onError ( Throwable t ) list . add ( t ) ; @ Override public void onComplete ( ) list . add ( "Done" ) ; ; Flowable . range ( 1 , 5 ) . subscribe ( sub ) ; assertTrue ( list . toString ( ) , list . get ( 0 ) instanceof IllegalArgumentException ) ; assertTrue ( list . toString ( ) , list . get ( 0 ) . toString ( ) . contains ( "3.9" ) ) ; 
final List < Object > list = new ArrayList < > ( ) ; Subscriber < Object > sub = new Subscriber < Object > ( ) Subscription upstream ; @ Override public void onSubscribe ( Subscription s ) this . upstream = s ; @ Override public void onNext ( Object t ) list . add ( t ) ; @ Override public void onError ( Throwable t ) upstream . cancel ( ) ; list . add ( t ) ; @ Override public void onComplete ( ) upstream . cancel ( ) ; list . add ( "Done" ) ; ; new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) BooleanSubscription b = new BooleanSubscription ( ) ; s . onSubscribe ( b ) ; s . onComplete ( ) ; list . add ( b . isCancelled ( ) ) ; . subscribe ( sub ) ; assertEquals ( Arrays . < Object > asList ( "Done" , false ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Subscriber < Object > sub = new Subscriber < Object > ( ) Subscription upstream ; @ Override public void onSubscribe ( Subscription s ) this . upstream = s ; @ Override public void onNext ( Object t ) list . add ( t ) ; @ Override public void onError ( Throwable t ) upstream . cancel ( ) ; list . add ( t . getMessage ( ) ) ; @ Override public void onComplete ( ) upstream . cancel ( ) ; list . add ( "Done" ) ; ; new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > s ) BooleanSubscription b = new BooleanSubscription ( ) ; s . onSubscribe ( b ) ; s . onError ( new TestException ( "Forced failure" ) ) ; list . add ( b . isCancelled ( ) ) ; . subscribe ( sub ) ; assertEquals ( Arrays . < Object > asList ( "Forced failure" , false ) , list ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; SubscriberWrapper < Integer > wrapper = new SubscriberWrapper < > ( ts ) ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) BooleanSubscription b1 = new BooleanSubscription ( ) ; s . onSubscribe ( b1 ) ; BooleanSubscription b2 = new BooleanSubscription ( ) ; s . onSubscribe ( b2 ) ; assertTrue ( b1 . isCancelled ( ) ) ; assertTrue ( b2 . isCancelled ( ) ) ; . subscribe ( wrapper ) ; ts . assertFailure ( IllegalStateException . class ) ; assertTrue ( ts . errors ( ) . toString ( ) , ts . errors ( ) . get ( 0 ) . getMessage ( ) . contains ( "2.12" ) ) ; 
events . add ( "OnComplete" ) ; 
events . add ( t ) ; 
return source . subscribe ( onNext , onError , onComplete , composite ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , Functions . ON_ERROR_MISSING , ( ) -> ) ; assertFalse ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onComplete ( ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; assertEquals ( 0 , composite . size ( ) ) ; 
subscribeAutoDispose ( processor , composite , this , this , ( ) -> ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onComplete ( ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; assertEquals ( 0 , composite . size ( ) ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onError ( new IOException ( ) ) ; assertEquals ( events . toString ( ) , 1 , events . get ( 0 ) ) ; assertTrue ( events . toString ( ) , events . get ( 1 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onComplete ( ) ; assertEquals ( Arrays . < Object > asList ( 1 , "OnComplete" ) , events ) ; assertEquals ( 0 , composite . size ( ) ) ; 
subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onError ( new IOException ( ) ) ; assertEquals ( events . toString ( ) , 1 , events . get ( 0 ) ) ; assertTrue ( events . toString ( ) , events . get ( 1 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , composite . size ( ) ) ; assertFalse ( processor . hasSubscribers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , new Consumer < Object > ( ) @ Override public void accept ( Object t ) throws Exception throw new IOException ( ) ; , this , this ) ; processor . onNext ( 1 ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; assertTrue ( events . toString ( ) , events . get ( 0 ) instanceof IOException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , this , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throws Exception throw new IOException ( t ) ; , this ) ; processor . onError ( new IllegalArgumentException ( ) ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > inners = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( inners , 0 , IllegalArgumentException . class ) ; TestHelper . assertError ( inners , 1 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , new Consumer < Object > ( ) @ Override public void accept ( Object t ) throws Exception throw new IOException ( ) ; , Functions . ON_ERROR_MISSING , ( ) -> ) ; processor . onNext ( 1 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; assertTrue ( errors . get ( 0 ) . getCause ( ) instanceof IOException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , this , this , new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) ; processor . onNext ( 1 ) ; processor . onComplete ( ) ; assertEquals ( Arrays . asList ( 1 ) , events ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 2 ) ; s . onComplete ( ) ; s . onError ( new IOException ( ) ) ; , composite , this , this , this ) ; assertEquals ( Arrays . < Object > asList ( 1 , "OnComplete" ) , events ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final List < Object > received = new ArrayList < > ( ) ; BoundedSubscriber < Object > subscriber = new BoundedSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object o ) throws Exception received . add ( o ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throws Exception received . add ( throwable ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 1 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription subscription ) throws Exception throw new TestException ( ) ; , 128 ) ; assertFalse ( subscriber . isDisposed ( ) ) ; Flowable . just ( 1 ) . subscribe ( subscriber ) ; assertTrue ( received . toString ( ) , received . get ( 0 ) instanceof TestException ) ; assertEquals ( received . toString ( ) , 1 , received . size ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; 
final List < Object > received = new ArrayList < > ( ) ; BoundedSubscriber < Object > subscriber = new BoundedSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object o ) throws Exception throw new TestException ( ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throws Exception received . add ( throwable ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 1 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription subscription ) throws Exception subscription . request ( 128 ) ; , 128 ) ; assertFalse ( subscriber . isDisposed ( ) ) ; Flowable . just ( 1 ) . subscribe ( subscriber ) ; assertTrue ( received . toString ( ) , received . get ( 0 ) instanceof TestException ) ; assertEquals ( received . toString ( ) , 1 , received . size ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final List < Object > received = new ArrayList < > ( ) ; BoundedSubscriber < Object > subscriber = new BoundedSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object o ) throws Exception received . add ( o ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throws Exception throw new TestException ( "Inner" ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 1 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription subscription ) throws Exception subscription . request ( 128 ) ; , 128 ) ; assertFalse ( subscriber . isDisposed ( ) ) ; Flowable . < Integer > error ( new TestException ( "Outer" ) ) . subscribe ( subscriber ) ; assertTrue ( received . toString ( ) , received . isEmpty ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "Inner" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final List < Object > received = new ArrayList < > ( ) ; BoundedSubscriber < Object > subscriber = new BoundedSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object o ) throws Exception received . add ( o ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throws Exception received . add ( throwable ) ; , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription subscription ) throws Exception subscription . request ( 128 ) ; , 128 ) ; assertFalse ( subscriber . isDisposed ( ) ) ; Flowable . < Integer > empty ( ) . subscribe ( subscriber ) ; assertTrue ( received . toString ( ) , received . isEmpty ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final List < Throwable > errors = new ArrayList < > ( ) ; BoundedSubscriber < Integer > s = new BoundedSubscriber < > ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception errors . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription subscription ) throws Exception subscription . request ( 128 ) ; , 128 ) ; pp . subscribe ( s ) ; assertTrue ( "No observers?!" , pp . hasSubscribers ( ) ) ; assertTrue ( "Has errors already?!" , errors . isEmpty ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( "Has observers?!" , pp . hasSubscribers ( ) ) ; assertFalse ( "No errors?!" , errors . isEmpty ( ) ) ; assertTrue ( errors . toString ( ) , errors . get ( 0 ) instanceof TestException ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final List < Throwable > errors = new ArrayList < > ( ) ; BoundedSubscriber < Integer > s = new BoundedSubscriber < > ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception errors . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception throw new TestException ( ) ; , 128 ) ; pp . subscribe ( s ) ; assertFalse ( "Has observers?!" , pp . hasSubscribers ( ) ) ; assertFalse ( "No errors?!" , errors . isEmpty ( ) ) ; assertTrue ( errors . toString ( ) , errors . get ( 0 ) instanceof TestException ) ; 
Flowable < Integer > source = Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) BooleanSubscription s1 = new BooleanSubscription ( ) ; s . onSubscribe ( s1 ) ; BooleanSubscription s2 = new BooleanSubscription ( ) ; s . onSubscribe ( s2 ) ; assertFalse ( s1 . isCancelled ( ) ) ; assertTrue ( s2 . isCancelled ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; ) ; final List < Object > received = new ArrayList < > ( ) ; BoundedSubscriber < Object > subscriber = new BoundedSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception s . request ( 128 ) ; , 128 ) ; source . subscribe ( subscriber ) ; assertEquals ( Arrays . asList ( 1 , 100 ) , received ) ; 
Flowable < Integer > source = Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) BooleanSubscription s1 = new BooleanSubscription ( ) ; s . onSubscribe ( s1 ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onNext ( 2 ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; ) ; final List < Object > received = new ArrayList < > ( ) ; BoundedSubscriber < Object > subscriber = new BoundedSubscriber < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception s . request ( 128 ) ; , 128 ) ; source . subscribe ( subscriber ) ; assertEquals ( Arrays . asList ( 1 , 100 ) , received ) ; 
BoundedSubscriber < Integer > subscriber = new BoundedSubscriber < > ( Functions . < Integer > emptyConsumer ( ) , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION , Functions . < Subscription > boundedConsumer ( 128 ) , 128 ) ; assertFalse ( subscriber . hasCustomOnError ( ) ) ; 
BoundedSubscriber < Integer > subscriber = new BoundedSubscriber < > ( Functions . < Integer > emptyConsumer ( ) , Functions . < Throwable > emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . < Subscription > boundedConsumer ( 128 ) , 128 ) ; assertTrue ( subscriber . hasCustomOnError ( ) ) ; 
BoundedSubscriber < Integer > subscriber = new BoundedSubscriber < > ( Functions . < Integer > emptyConsumer ( ) , Functions . < Throwable > emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . < Subscription > boundedConsumer ( 128 ) , 128 ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs ) ; subscriber . cancel ( ) ; assertTrue ( bs . isCancelled ( ) ) ; 
BoundedSubscriber < Integer > subscriber = new BoundedSubscriber < > ( Functions . < Integer > emptyConsumer ( ) , Functions . < Throwable > emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . < Subscription > boundedConsumer ( 128 ) , 128 ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; subscriber . onSubscribe ( bs ) ; assertFalse ( subscriber . isDisposed ( ) ) ; subscriber . dispose ( ) ; assertTrue ( bs . isCancelled ( ) ) ; assertTrue ( subscriber . isDisposed ( ) ) ; 
return new QueueDrainSubscriber < Integer , Integer , Integer > ( ts , new SpscArrayQueue < > ( 4 ) ) @ Override public void onNext ( Integer t ) fastPathEmitMax ( t , false , d ) ; @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) super . accept ( a , v ) ; a . onNext ( v ) ; return true ; ; 
return new QueueDrainSubscriber < Integer , Integer , Integer > ( ts , new SpscArrayQueue < > ( 4 ) ) @ Override public void onNext ( Integer t ) fastPathOrderedEmitMax ( t , false , d ) ; @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) super . accept ( a , v ) ; a . onNext ( v ) ; return true ; ; 
return new QueueDrainSubscriber < Integer , Integer , Integer > ( ts , new SpscArrayQueue < > ( 4 ) ) @ Override public void onNext ( Integer t ) fastPathEmitMax ( t , false , d ) ; @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) super . accept ( a , v ) ; a . onNext ( v ) ; return false ; ; 
return new QueueDrainSubscriber < Integer , Integer , Integer > ( ts , new SpscArrayQueue < > ( 4 ) ) @ Override public void onNext ( Integer t ) fastPathOrderedEmitMax ( t , false , d ) ; @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) super . accept ( a , v ) ; a . onNext ( v ) ; return false ; ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createUnordered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . onNext ( 1 ) ; ts . assertFailure ( MissingBackpressureException . class ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createOrdered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . onNext ( 1 ) ; ts . assertFailure ( MissingBackpressureException . class ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createUnordered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; assertTrue ( qd . accept ( ts , 0 ) ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try qd . requested ( - 1 ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createUnordered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . requested ( 1 ) ; qd . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createOrdered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . requested ( 1 ) ; qd . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createUnordered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . enter ( ) ; qd . onNext ( 1 ) ; ts . assertEmpty ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createOrdered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . enter ( ) ; qd . onNext ( 1 ) ; ts . assertEmpty ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createOrdered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . queue . offer ( 0 ) ; qd . requested ( 2 ) ; qd . onNext ( 1 ) ; ts . assertValuesOnly ( 0 , 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; final QueueDrainSubscriber < Integer , Integer , Integer > qd = createUnordered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . requested ( Long . MAX_VALUE ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) qd . onNext ( 1 ) ; ; TestHelper . race ( r1 , r1 ) ; ts . assertValuesOnly ( 1 , 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; final QueueDrainSubscriber < Integer , Integer , Integer > qd = createOrdered ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . requested ( Long . MAX_VALUE ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) qd . onNext ( 1 ) ; ; TestHelper . race ( r1 , r1 ) ; ts . assertValuesOnly ( 1 , 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createUnorderedReject ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . requested ( 1 ) ; qd . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; assertEquals ( 1 , qd . requested ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainSubscriber < Integer , Integer , Integer > qd = createOrderedReject ( ts , d ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; qd . requested ( 1 ) ; qd . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; assertEquals ( 1 , qd . requested ( ) ) ; 
fs = new FutureSubscriber < > ( ) ; 
assertFalse ( fs . isDone ( ) ) ; assertFalse ( fs . isCancelled ( ) ) ; fs . cancel ( ) ; fs . cancel ( ) ; fs . request ( 10 ) ; fs . request ( - 99 ) ; fs . cancel ( false ) ; assertTrue ( fs . isDone ( ) ) ; assertTrue ( fs . isCancelled ( ) ) ; try fs . get ( ) ; fail ( "Should have thrown" ) ; catch ( CancellationException ex ) try fs . get ( 1 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown" ) ; catch ( CancellationException ex ) 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fs . onError ( new TestException ( "One" ) ) ; fs . onError ( new TestException ( "Two" ) ) ; try fs . get ( 5 , TimeUnit . MILLISECONDS ) ; catch ( ExecutionException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; assertEquals ( "One" , ex . getCause ( ) . getMessage ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Two" ) ; finally RxJavaPlugins . reset ( ) ; 
fs . onNext ( 1 ) ; fs . onComplete ( ) ; assertEquals ( 1 , fs . get ( 5 , TimeUnit . MILLISECONDS ) . intValue ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BooleanSubscription s = new BooleanSubscription ( ) ; fs . onSubscribe ( s ) ; BooleanSubscription s2 = new BooleanSubscription ( ) ; fs . onSubscribe ( s2 ) ; assertFalse ( s . isCancelled ( ) ) ; assertTrue ( s2 . isCancelled ( ) ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FutureSubscriber < Integer > fs = new FutureSubscriber < > ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) fs . cancel ( false ) ; ; TestHelper . race ( r , r ) ; 
Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) fs . onNext ( 1 ) ; fs . onComplete ( ) ; , 100 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , fs . get ( 5 , TimeUnit . SECONDS ) . intValue ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FutureSubscriber < Integer > fs = new FutureSubscriber < > ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) fs . cancel ( false ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) fs . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FutureSubscriber < Integer > fs = new FutureSubscriber < > ( ) ; if ( i % 3 == 0 ) fs . onSubscribe ( new BooleanSubscription ( ) ) ; if ( i % 2 == 0 ) fs . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) fs . cancel ( false ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) fs . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
fs . onError ( new TestException ( "One" ) ) ; fs . onComplete ( ) ; try fs . get ( 5 , TimeUnit . MILLISECONDS ) ; catch ( ExecutionException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; assertEquals ( "One" , ex . getCause ( ) . getMessage ( ) ) ; 
fs . onComplete ( ) ; fs . onError ( new TestException ( "One" ) ) ; try assertNull ( fs . get ( 5 , TimeUnit . MILLISECONDS ) ) ; catch ( ExecutionException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof NoSuchElementException ) ; 
fs . cancel ( true ) ; fs . onError ( new TestException ( "One" ) ) ; try fs . get ( 5 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown" ) ; catch ( CancellationException ex ) 
fs . cancel ( true ) ; fs . onComplete ( ) ; try fs . get ( 5 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown" ) ; catch ( CancellationException ex ) 
fs . onNext ( 1 ) ; fs . onComplete ( ) ; fs . onComplete ( ) ; assertEquals ( 1 , fs . get ( 5 , TimeUnit . MILLISECONDS ) . intValue ( ) ) ; 
Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) fs . onNext ( 1 ) ; fs . onComplete ( ) ; , 500 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , fs . get ( ) . intValue ( ) ) ; 
try fs . get ( 1 , TimeUnit . NANOSECONDS ) ; fail ( "Should have thrown" ) ; catch ( TimeoutException expected ) assertEquals ( timeoutMessage ( 1 , TimeUnit . NANOSECONDS ) , expected . getMessage ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fs . onNext ( 1 ) ; fs . onComplete ( ) ; fs . onError ( new TestException ( "One" ) ) ; assertEquals ( ( Integer ) 1 , fs . get ( 5 , TimeUnit . MILLISECONDS ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ConditionalSubscriber < Integer > cs = new ConditionalSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public boolean tryOnNext ( Integer t ) return false ; ; BasicFuseableConditionalSubscriber < Integer , Integer > fcs = new BasicFuseableConditionalSubscriber < Integer , Integer > ( cs ) @ Override public boolean tryOnNext ( Integer t ) return false ; @ Override public void onNext ( Integer t ) @ Override public int requestFusion ( int mode ) return 0 ; @ Nullable @ Override public Integer poll ( ) throws Exception return null ; ; fcs . onSubscribe ( new ScalarSubscription < > ( fcs , 1 ) ) ; TestHelper . assertNoOffer ( fcs ) ; assertFalse ( fcs . isEmpty ( ) ) ; fcs . clear ( ) ; assertTrue ( fcs . isEmpty ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) ConditionalSubscriber < Integer > ts = mock ( ConditionalSubscriber . class ) ; BasicFuseableConditionalSubscriber < Integer , Integer > bfs = new BasicFuseableConditionalSubscriber < Integer , Integer > ( ts ) @ Override protected boolean beforeDownstream ( ) return false ; @ Override public void onNext ( @ NonNull Integer t ) ts . onNext ( t ) ; @ Override public int requestFusion ( int mode ) return 0 ; @ Override public boolean tryOnNext ( @ NonNull Integer t ) return false ; @ Override public @ Nullable Integer poll ( ) throws Throwable return null ; ; bfs . onSubscribe ( new BooleanSubscription ( ) ) ; verify ( ts , never ( ) ) . onSubscribe ( any ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . map ( v -> v ) . filter ( v -> true ) ) ; 
@ SuppressWarnings ( "unchecked" ) ConditionalSubscriber < Integer > ts = mock ( ConditionalSubscriber . class ) ; BasicFuseableConditionalSubscriber < Integer , Integer > bfs = new BasicFuseableConditionalSubscriber < Integer , Integer > ( ts ) @ Override protected boolean beforeDownstream ( ) return false ; @ Override public void onNext ( @ NonNull Integer t ) ts . onNext ( t ) ; @ Override public int requestFusion ( int mode ) return 0 ; @ Override public boolean tryOnNext ( @ NonNull Integer t ) return false ; @ Override public @ Nullable Integer poll ( ) throws Throwable return null ; ; bfs . onSubscribe ( new BooleanSubscription ( ) ) ; assertEquals ( QueueFuseable . NONE , bfs . transitiveBoundaryFusion ( QueueFuseable . ANY ) ) ; 
@ SuppressWarnings ( "unchecked" ) ConditionalSubscriber < Integer > ts = mock ( ConditionalSubscriber . class ) ; BasicFuseableConditionalSubscriber < Integer , Integer > bfs = new BasicFuseableConditionalSubscriber < Integer , Integer > ( ts ) @ Override protected boolean beforeDownstream ( ) return false ; @ Override public void onNext ( @ NonNull Integer t ) ts . onNext ( t ) ; @ Override public int requestFusion ( int mode ) return 0 ; @ Override public boolean tryOnNext ( @ NonNull Integer t ) return false ; @ Override public @ Nullable Integer poll ( ) throws Throwable return null ; ; bfs . onSubscribe ( EmptySubscription . INSTANCE ) ; assertEquals ( QueueFuseable . ASYNC , bfs . transitiveBoundaryFusion ( QueueFuseable . ANY ) ) ; 
@ SuppressWarnings ( "unchecked" ) ConditionalSubscriber < Integer > ts = mock ( ConditionalSubscriber . class ) ; BasicFuseableConditionalSubscriber < Integer , Integer > bfs = new BasicFuseableConditionalSubscriber < Integer , Integer > ( ts ) @ Override protected boolean beforeDownstream ( ) return false ; @ Override public void onNext ( @ NonNull Integer t ) ts . onNext ( t ) ; @ Override public int requestFusion ( int mode ) return 0 ; @ Override public boolean tryOnNext ( @ NonNull Integer t ) return false ; @ Override public @ Nullable Integer poll ( ) throws Throwable return null ; ; bfs . onSubscribe ( EmptySubscription . INSTANCE ) ; assertEquals ( QueueFuseable . NONE , bfs . transitiveBoundaryFusion ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; ts . assertNoValues ( ) ; ds . onComplete ( ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 1 ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; ts . assertNoValues ( ) ; ds . onComplete ( ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ts . assertNoValues ( ) ; ds . onComplete ( ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ts . assertNoValues ( ) ; ds . onError ( new TestException ( ) ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; pp . subscribe ( ds ) ; assertTrue ( "No subscribers?" , pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; ds . onNext ( 1 ) ; ds . onComplete ( ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; assertFalse ( "Subscribers?" , pp . hasSubscribers ( ) ) ; assertTrue ( "Deferred not unsubscribed?" , ds . isCancelled ( ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; Flowable . just ( 1 ) . ignoreElements ( ) . < Integer > toFlowable ( ) . subscribe ( ds ) ; ts . assertNoValues ( ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . subscribeTo ( Flowable . just ( 1 ) ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . subscribeTo ( Flowable . range ( 1 , 10 ) ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValue ( 10 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; ts . assertNoValues ( ) ; ds . onComplete ( ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
super . onNext ( t ) ; cancel ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 0L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; ds . onComplete ( ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; ts . request ( 1 ) ; ds . onComplete ( ) ; ds . onComplete ( ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; ds . onComplete ( ) ; ds . onComplete ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; ts . request ( 1 ) ; ts . request ( 1 ) ; ds . onComplete ( ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . downstreamRequest ( - 99 ) ; RxJavaPlugins . reset ( ) ; TestHelper . assertError ( list , 0 , IllegalArgumentException . class , "n > 0 required but it was -99" ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ts . cancel ( ) ; ds . downstreamRequest ( 1 ) ; ds . onNext ( 1 ) ; ds . onComplete ( ) ; ds . onComplete ( ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
Worker w = Schedulers . computation ( ) . createWorker ( ) ; try for ( int i = 0 ; i < 10000 ; i ++ ) final TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; final AtomicInteger ready = new AtomicInteger ( 2 ) ; w . schedule ( new Runnable ( ) @ Override public void run ( ) ready . decrementAndGet ( ) ; while ( ready . get ( ) != 0 ) ts . request ( 1 ) ; ) ; ready . decrementAndGet ( ) ; while ( ready . get ( ) != 0 ) ds . onComplete ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; finally w . dispose ( ) ; 
Worker w = Schedulers . io ( ) . createWorker ( ) ; Worker w2 = Schedulers . io ( ) . createWorker ( ) ; int m = 10000 ; if ( Runtime . getRuntime ( ) . availableProcessors ( ) < 3 ) m = 1000 ; try for ( int i = 0 ; i < m ; i ++ ) final TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; TestingDeferredScalarSubscriber ds = new TestingDeferredScalarSubscriber ( ts ) ; ds . setupDownstream ( ) ; ds . onNext ( 1 ) ; final AtomicInteger ready = new AtomicInteger ( 3 ) ; w . schedule ( new Runnable ( ) @ Override public void run ( ) ready . decrementAndGet ( ) ; while ( ready . get ( ) != 0 ) ts . request ( 1 ) ; ) ; w2 . schedule ( new Runnable ( ) @ Override public void run ( ) ready . decrementAndGet ( ) ; while ( ready . get ( ) != 0 ) ts . request ( 1 ) ; ) ; ready . decrementAndGet ( ) ; while ( ready . get ( ) != 0 ) ds . onComplete ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; finally w . dispose ( ) ; w2 . dispose ( ) ; 
onSubscribe ( new BooleanSubscription ( ) ) ; 
p . subscribe ( this ) ; 
TestHelper . doubleOnSubscribe ( new DeferredScalarSubscriber < Integer , Integer > ( new TestSubscriber < > ( ) ) private static final long serialVersionUID = - 4445381578878059054L ; @ Override public void onNext ( Integer t ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestHelper . checkEnum ( EmptyComponent . class ) ; EmptyComponent c = EmptyComponent . INSTANCE ; assertTrue ( c . isDisposed ( ) ) ; c . request ( 10 ) ; c . request ( - 10 ) ; Disposable d = Disposable . empty ( ) ; c . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; BooleanSubscription s = new BooleanSubscription ( ) ; c . onSubscribe ( s ) ; assertTrue ( s . isCancelled ( ) ) ; c . onNext ( null ) ; c . onNext ( 1 ) ; c . onComplete ( ) ; c . onError ( new TestException ( ) ) ; c . onSuccess ( 2 ) ; c . cancel ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . doubleOnSubscribe ( new BlockingSubscriber < Integer > ( new ArrayDeque < > ( ) ) ) ; 
BlockingSubscriber < Integer > bq = new BlockingSubscriber < > ( new ArrayDeque < > ( ) ) ; assertFalse ( bq . isCancelled ( ) ) ; bq . cancel ( ) ; assertTrue ( bq . isCancelled ( ) ) ; bq . cancel ( ) ; assertTrue ( bq . isCancelled ( ) ) ; 
TestHelper . doubleOnSubscribe ( new BlockingFirstSubscriber < Integer > ( ) ) ; 
BlockingFirstSubscriber < Integer > bf = new BlockingFirstSubscriber < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try bf . blockingGet ( ) ; fail ( "Should have thrown!" ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
BlockingFirstSubscriber < Integer > bf = new BlockingFirstSubscriber < > ( ) ; bf . onSubscribe ( new BooleanSubscription ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; try bf . blockingGet ( ) ; fail ( "Should have thrown!" ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
final BlockingFirstSubscriber < Integer > bf = new BlockingFirstSubscriber < > ( ) ; final AtomicBoolean b = new AtomicBoolean ( ) ; Subscription s = new Subscription ( ) @ Override public void request ( long n ) bf . cancelled = true ; @ Override public void cancel ( ) b . set ( true ) ; ; bf . onSubscribe ( s ) ; assertTrue ( b . get ( ) ) ; 
final BlockingFirstSubscriber < Integer > bf = new BlockingFirstSubscriber < > ( ) ; final AtomicBoolean b = new AtomicBoolean ( ) ; bf . cancelled = true ; Subscription s = new Subscription ( ) @ Override public void request ( long n ) b . set ( true ) ; @ Override public void cancel ( ) ; bf . onSubscribe ( s ) ; assertFalse ( b . get ( ) ) ; 
BooleanSubscription bs = new BooleanSubscription ( ) ; Disposable d = Disposable . empty ( ) ; s . setResource ( d ) ; s . onSubscribe ( bs ) ; assertFalse ( d . isDisposed ( ) ) ; assertFalse ( s . isDisposed ( ) ) ; ts . cancel ( ) ; assertTrue ( bs . isCancelled ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; assertTrue ( s . isDisposed ( ) ) ; 
BooleanSubscription bs = new BooleanSubscription ( ) ; Disposable d = Disposable . empty ( ) ; s . setResource ( d ) ; s . onSubscribe ( bs ) ; s . onError ( new TestException ( ) ) ; assertTrue ( d . isDisposed ( ) ) ; assertFalse ( bs . isCancelled ( ) ) ; ts . assertFailure ( TestException . class ) ; 
BooleanSubscription bs = new BooleanSubscription ( ) ; Disposable d = Disposable . empty ( ) ; s . setResource ( d ) ; s . onSubscribe ( bs ) ; s . onComplete ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertFalse ( bs . isCancelled ( ) ) ; ts . assertResult ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . lift ( new FlowableOperator < Object , Object > ( ) @ Override public Subscriber < ? super Object > apply ( Subscriber < ? super Object > s ) throws Exception return new SubscriberResourceWrapper < > ( s ) ; ) ; ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . lift ( new FlowableOperator < Object , Object > ( ) @ Override public Subscriber < ? super Object > apply ( Subscriber < ? super Object > s ) throws Exception return new SubscriberResourceWrapper < > ( s ) ; ) ) ; 
Flowable . range ( 1 , 10 ) . subscribeWith ( new TestSubscriber < > ( ) ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable . range ( 1 , 10 ) . subscribeWith ( new TestObserver < > ( ) ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
$EMPTY$
this . value = 100 ; 
this . value = value ; 
this . value = e ; 
assertEquals ( 1 , Single . just ( 1 ) . subscribeWith ( new ObserverImpl ( ) ) . value ) ; 
assertEquals ( 100 , Completable . complete ( ) . subscribeWith ( new ObserverImpl ( ) ) . value ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ScalarSubscription < Integer > sc = new ScalarSubscription < > ( ts , 1 ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try sc . request ( - 99 ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class , "n > 0 required but it was -99" ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ScalarSubscription < Integer > sc = new ScalarSubscription < > ( ts , 1 ) ; TestHelper . assertNoOffer ( sc ) ; 
return null ; 
return false ; 
$EMPTY$
$EMPTY$
return null ; 
return false ; 
$EMPTY$
$EMPTY$
TestHelper . assertNoOffer ( new EmptyQS ( ) ) ; 
TestHelper . assertNoOffer ( new EmptyIntQS ( ) ) ; 
TestHelper . checkEnum ( EmptySubscription . class ) ; assertEquals ( "EmptySubscription" , EmptySubscription . INSTANCE . toString ( ) ) ; TestHelper . assertNoOffer ( EmptySubscription . INSTANCE ) ; 
TestHelper . checkEnum ( SubscriptionHelper . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try SubscriptionHelper . validate ( null , null ) ; TestHelper . assertError ( errors , 0 , NullPointerException . class , "next is null" ) ; finally RxJavaPlugins . reset ( ) ; 
SubscriptionHelper . CANCELLED . cancel ( ) ; 
AtomicReference < Subscription > atomicSubscription = new AtomicReference < > ( ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; assertTrue ( SubscriptionHelper . set ( atomicSubscription , bs1 ) ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; assertTrue ( SubscriptionHelper . set ( atomicSubscription , bs2 ) ) ; assertTrue ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; 
AtomicReference < Subscription > atomicSubscription = new AtomicReference < > ( ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; assertTrue ( SubscriptionHelper . replace ( atomicSubscription , bs1 ) ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; assertTrue ( SubscriptionHelper . replace ( atomicSubscription , bs2 ) ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Subscription > atomicSubscription = new AtomicReference < > ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) SubscriptionHelper . cancel ( atomicSubscription ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Subscription > atomicSubscription = new AtomicReference < > ( ) ; final BooleanSubscription bs1 = new BooleanSubscription ( ) ; final BooleanSubscription bs2 = new BooleanSubscription ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) SubscriptionHelper . set ( atomicSubscription , bs1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) SubscriptionHelper . set ( atomicSubscription , bs2 ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( bs1 . isCancelled ( ) ^ bs2 . isCancelled ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Subscription > atomicSubscription = new AtomicReference < > ( ) ; final BooleanSubscription bs1 = new BooleanSubscription ( ) ; final BooleanSubscription bs2 = new BooleanSubscription ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) SubscriptionHelper . replace ( atomicSubscription , bs1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) SubscriptionHelper . replace ( atomicSubscription , bs2 ) ; ; TestHelper . race ( r1 , r2 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; 
AtomicReference < Subscription > atomicSubscription = new AtomicReference < > ( ) ; SubscriptionHelper . cancel ( atomicSubscription ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; assertFalse ( SubscriptionHelper . set ( atomicSubscription , bs1 ) ) ; assertTrue ( bs1 . isCancelled ( ) ) ; assertFalse ( SubscriptionHelper . set ( atomicSubscription , null ) ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; assertFalse ( SubscriptionHelper . replace ( atomicSubscription , bs2 ) ) ; assertTrue ( bs2 . isCancelled ( ) ) ; assertFalse ( SubscriptionHelper . replace ( atomicSubscription , null ) ) ; 
AtomicReference < Subscription > atomicSubscription = new AtomicReference < > ( ) ; AtomicLong r = new AtomicLong ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try SubscriptionHelper . deferredRequest ( atomicSubscription , r , - 99 ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class , "n > 0 required but it was -99" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Subscription > atomicSubscription = new AtomicReference < > ( ) ; final AtomicLong r = new AtomicLong ( ) ; final AtomicLong q = new AtomicLong ( ) ; final Subscription a = new Subscription ( ) @ Override public void request ( long n ) q . addAndGet ( n ) ; @ Override public void cancel ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) SubscriptionHelper . deferredSetOnce ( atomicSubscription , r , a ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) SubscriptionHelper . deferredRequest ( atomicSubscription , r , 1 ) ; ; TestHelper . race ( r1 , r2 ) ; assertSame ( a , atomicSubscription . get ( ) ) ; assertEquals ( 1 , q . get ( ) ) ; assertEquals ( 0 , r . get ( ) ) ; 
AtomicReference < Subscription > ref = new AtomicReference < > ( ) ; Subscription sub = mock ( Subscription . class ) ; assertTrue ( SubscriptionHelper . setOnce ( ref , sub , 1 ) ) ; verify ( sub ) . request ( 1 ) ; verify ( sub , never ( ) ) . cancel ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try sub = mock ( Subscription . class ) ; assertFalse ( SubscriptionHelper . setOnce ( ref , sub , 1 ) ) ; verify ( sub , never ( ) ) . request ( anyLong ( ) ) ; verify ( sub ) . cancel ( ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; finally RxJavaPlugins . reset ( ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . getAndIncrement ( ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; sa . setSubscription ( bs1 ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; sa . setSubscription ( bs2 ) ; assertTrue ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try sa . request ( - 99 ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class , "n > 0 required but it was -99" ) ; finally RxJavaPlugins . reset ( ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . request ( Long . MAX_VALUE ) ; assertEquals ( Long . MAX_VALUE , sa . requested ) ; assertTrue ( sa . isUnbounded ( ) ) ; sa . unbounded = false ; sa . request ( Long . MAX_VALUE ) ; assertEquals ( Long . MAX_VALUE , sa . requested ) ; sa . produced ( 1 ) ; assertEquals ( Long . MAX_VALUE , sa . requested ) ; sa . unbounded = false ; sa . produced ( Long . MAX_VALUE ) ; assertEquals ( Long . MAX_VALUE , sa . requested ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . cancelled = true ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; sa . missedSubscription . set ( bs1 ) ; sa . getAndIncrement ( ) ; sa . drainLoop ( ) ; assertTrue ( bs1 . isCancelled ( ) ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . getAndIncrement ( ) ; sa . requested = Long . MAX_VALUE ; sa . drainLoop ( ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . getAndIncrement ( ) ; sa . requested = 0 ; sa . missedRequested . set ( 1 ) ; sa . drainLoop ( ) ; assertEquals ( 1 , sa . requested ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . getAndIncrement ( ) ; sa . requested = 0 ; sa . missedRequested . set ( Long . MAX_VALUE ) ; sa . missedProduced . set ( 1 ) ; sa . drainLoop ( ) ; assertEquals ( Long . MAX_VALUE , sa . requested ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . getAndIncrement ( ) ; sa . requested = 0 ; sa . missedRequested . set ( 1 ) ; sa . missedProduced . set ( 2 ) ; sa . drainLoop ( ) ; assertEquals ( 0 , sa . requested ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "More produced than requested: -1" ) ; finally RxJavaPlugins . reset ( ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . getAndIncrement ( ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; sa . missedSubscription . set ( bs1 ) ; sa . drainLoop ( ) ; assertSame ( bs1 , sa . actual ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( false ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; sa . setSubscription ( bs1 ) ; sa . setSubscription ( bs2 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; sa . setSubscription ( bs1 ) ; sa . setSubscription ( bs2 ) ; assertTrue ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( false ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; BooleanSubscription bs3 = new BooleanSubscription ( ) ; sa . setSubscription ( bs1 ) ; sa . getAndIncrement ( ) ; sa . setSubscription ( bs2 ) ; sa . setSubscription ( bs3 ) ; sa . drainLoop ( ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; assertFalse ( bs3 . isCancelled ( ) ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; BooleanSubscription bs3 = new BooleanSubscription ( ) ; sa . setSubscription ( bs1 ) ; sa . getAndIncrement ( ) ; sa . setSubscription ( bs2 ) ; sa . setSubscription ( bs3 ) ; sa . drainLoop ( ) ; assertTrue ( bs1 . isCancelled ( ) ) ; assertTrue ( bs2 . isCancelled ( ) ) ; assertFalse ( bs3 . isCancelled ( ) ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( false ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; sa . setSubscription ( bs1 ) ; sa . getAndIncrement ( ) ; sa . setSubscription ( bs2 ) ; sa . drainLoop ( ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; sa . setSubscription ( bs1 ) ; sa . getAndIncrement ( ) ; sa . setSubscription ( bs2 ) ; sa . drainLoop ( ) ; assertTrue ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try SubscriptionArbiter sa = new SubscriptionArbiter ( true ) ; sa . produced ( 2 ) ; assertEquals ( 0 , sa . requested ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "More produced than requested: -2" ) ; finally RxJavaPlugins . reset ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; Subscription s = mock ( Subscription . class ) ; as . setSubscription ( s ) ; as . request ( 1 ) ; as . cancel ( ) ; verify ( s ) . request ( 1 ) ; verify ( s ) . cancel ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; Subscription s = mock ( Subscription . class ) ; as . request ( 1 ) ; as . setSubscription ( s ) ; as . cancel ( ) ; verify ( s ) . request ( 1 ) ; verify ( s ) . cancel ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; Subscription s = mock ( Subscription . class ) ; as . request ( 1 ) ; as . cancel ( ) ; as . setSubscription ( s ) ; verify ( s , never ( ) ) . request ( 1 ) ; verify ( s ) . cancel ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; Subscription s = mock ( Subscription . class ) ; as . setSubscription ( s ) ; Subscription s1 = mock ( Subscription . class ) ; as . setSubscription ( s1 ) ; assertSame ( as . actual . get ( ) , s ) ; verify ( s1 ) . cancel ( ) ; 
Disposable r = mock ( Disposable . class ) ; AsyncSubscription as = new AsyncSubscription ( r ) ; as . cancel ( ) ; verify ( r ) . dispose ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; Disposable r = mock ( Disposable . class ) ; assertTrue ( as . setResource ( r ) ) ; as . cancel ( ) ; verify ( r ) . dispose ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; Disposable r = mock ( Disposable . class ) ; assertTrue ( as . replaceResource ( r ) ) ; as . cancel ( ) ; verify ( r ) . dispose ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; Disposable r = mock ( Disposable . class ) ; assertTrue ( as . setResource ( r ) ) ; Disposable r2 = mock ( Disposable . class ) ; assertTrue ( as . setResource ( r2 ) ) ; as . cancel ( ) ; verify ( r ) . dispose ( ) ; verify ( r2 ) . dispose ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; Disposable r = mock ( Disposable . class ) ; assertTrue ( as . replaceResource ( r ) ) ; Disposable r2 = mock ( Disposable . class ) ; as . replaceResource ( r2 ) ; as . cancel ( ) ; verify ( r , never ( ) ) . dispose ( ) ; verify ( r2 ) . dispose ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; as . cancel ( ) ; Disposable r = mock ( Disposable . class ) ; as . setResource ( r ) ; verify ( r ) . dispose ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; as . cancel ( ) ; Disposable r = mock ( Disposable . class ) ; as . replaceResource ( r ) ; verify ( r ) . dispose ( ) ; 
Disposable r = mock ( Disposable . class ) ; AsyncSubscription as = new AsyncSubscription ( r ) ; Subscription s = mock ( Subscription . class ) ; as . setSubscription ( s ) ; as . cancel ( ) ; as . cancel ( ) ; as . cancel ( ) ; verify ( s , never ( ) ) . request ( anyLong ( ) ) ; verify ( s ) . cancel ( ) ; verify ( r ) . dispose ( ) ; 
AsyncSubscription as = new AsyncSubscription ( ) ; assertFalse ( as . isDisposed ( ) ) ; as . dispose ( ) ; assertTrue ( as . isDisposed ( ) ) ; 
ArrayCompositeSubscription ac = new ArrayCompositeSubscription ( 1 ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; ac . setResource ( 0 , bs1 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; ac . setResource ( 0 , bs2 ) ; assertTrue ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; assertFalse ( ac . isDisposed ( ) ) ; ac . dispose ( ) ; assertTrue ( bs2 . isCancelled ( ) ) ; assertTrue ( ac . isDisposed ( ) ) ; BooleanSubscription bs3 = new BooleanSubscription ( ) ; assertFalse ( ac . setResource ( 0 , bs3 ) ) ; assertTrue ( bs3 . isCancelled ( ) ) ; assertFalse ( ac . setResource ( 0 , null ) ) ; 
ArrayCompositeSubscription ac = new ArrayCompositeSubscription ( 1 ) ; BooleanSubscription bs1 = new BooleanSubscription ( ) ; ac . replaceResource ( 0 , bs1 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; BooleanSubscription bs2 = new BooleanSubscription ( ) ; ac . replaceResource ( 0 , bs2 ) ; assertFalse ( bs1 . isCancelled ( ) ) ; assertFalse ( bs2 . isCancelled ( ) ) ; assertFalse ( ac . isDisposed ( ) ) ; ac . dispose ( ) ; assertTrue ( bs2 . isCancelled ( ) ) ; assertTrue ( ac . isDisposed ( ) ) ; BooleanSubscription bs3 = new BooleanSubscription ( ) ; ac . replaceResource ( 0 , bs3 ) ; assertTrue ( bs3 . isCancelled ( ) ) ; ac . replaceResource ( 0 , null ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ArrayCompositeSubscription ac = new ArrayCompositeSubscription ( 1000 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) ac . dispose ( ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ArrayCompositeSubscription ac = new ArrayCompositeSubscription ( 1 ) ; final BooleanSubscription s1 = new BooleanSubscription ( ) ; final BooleanSubscription s2 = new BooleanSubscription ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ac . setResource ( 0 , s1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ac . replaceResource ( 0 , s2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
DeferredScalarSubscription < Integer > ds = new DeferredScalarSubscription < > ( new TestSubscriber < > ( ) ) ; assertEquals ( QueueFuseable . NONE , ds . requestFusion ( QueueFuseable . SYNC ) ) ; 
DeferredScalarSubscription < Integer > ds = new DeferredScalarSubscription < > ( new TestSubscriber < > ( ) ) ; ds . value = 1 ; ds . clear ( ) ; assertEquals ( DeferredScalarSubscription . FUSED_CONSUMED , ds . get ( ) ) ; assertNull ( ds . value ) ; 
DeferredScalarSubscription < Integer > ds = new DeferredScalarSubscription < > ( new TestSubscriber < > ( ) ) ; assertTrue ( ds . tryCancel ( ) ) ; assertFalse ( ds . tryCancel ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final DeferredScalarSubscription < Integer > ds = new DeferredScalarSubscription < > ( new TestSubscriber < > ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ds . complete ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ds . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; final DeferredScalarSubscription < Integer > ds = new DeferredScalarSubscription < > ( ts ) ; ts . onSubscribe ( ds ) ; ds . complete ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ds . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ds . value = null ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . values ( ) . size ( ) >= 1 ) ts . assertValue ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; final DeferredScalarSubscription < Integer > ds = new DeferredScalarSubscription < > ( ts ) ; ts . onSubscribe ( ds ) ; ds . complete ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ds . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ds . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . values ( ) . size ( ) >= 1 ) ts . assertValue ( 1 ) ; 
Flowable . range ( 1 , 5 ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) ) . test ( ) . assertResult ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . range ( 1 , 5 ) . concatMapCompletable ( Functions . justFunction ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter . incrementAndGet ( ) ; ) ) ) . test ( ) . assertResult ( ) ; assertEquals ( 5 , counter . get ( ) ) ; 
Flowable . range ( 1 , 1024 ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) , 32 ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 1024 ) . hide ( ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) , 32 ) . test ( ) . assertResult ( ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . concatMapCompletable ( Functions . justFunction ( Completable . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Void > to = Flowable . range ( 1 , 5 ) . concatMapCompletableDelayError ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; assertEquals ( 5 , ( ( CompositeException ) to . errors ( ) . get ( 0 ) ) . getExceptions ( ) . size ( ) ) ; 
Flowable . just ( 1 ) . concatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; pp . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; pp . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onError ( new TestException ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . concatMapCompletableDelayError ( Functions . justFunction ( cs ) , false ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; pp . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; to . assertEmpty ( ) ; cs . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; final CompletableSubject cs2 = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . concatMapCompletableDelayError ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception if ( v == 1 ) return cs ; return cs2 ; , true , 32 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; pp . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onError ( new TestException ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 2 ) ; to . assertEmpty ( ) ; cs2 . onComplete ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . assertEmpty ( ) ; pp . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToCompletable ( new Function < Flowable < Object > , Completable > ( ) @ Override public Completable apply ( Flowable < Object > f ) throws Exception return f . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) ) ; ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; s . onError ( new TestException ( ) ) ; . concatMapCompletable ( Functions . justFunction ( Completable . never ( ) ) , 1 ) . test ( ) . assertFailure ( MissingBackpressureException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) . assertNotComplete ( ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; final TestObserver < Void > to = pp . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onComplete ( ) ; to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; final TestObserver < Void > to = pp . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onComplete ( ) ; cs . onComplete ( ) ; to . assertResult ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return upstream . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return upstream . concatMapCompletableDelayError ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; , false , 2 ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return upstream . concatMapCompletableDelayError ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; , true , 2 ) ; ) ; 
Flowable . range ( 1 , 5 ) . hide ( ) . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 5 ) . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
TestHelper . < Integer > rejectFlowableFusion ( ) . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertEmpty ( ) ; 
Flowable . range ( 1 , 5 ) . map ( v -> if ( v == 3 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 5 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 1024 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; , 32 ) . test ( ) . assertValueCount ( 1024 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . error ( new TestException ( ) ) . concatMapSingle ( Functions . justFunction ( Single . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . concatMapSingle ( Functions . justFunction ( Single . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . concatMapSingleDelayError ( Functions . justFunction ( ms ) , false ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; assertTrue ( ms . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . concatMapSingleDelayError ( Functions . justFunction ( Single . never ( ) ) ) ; ) ; 
Observable . range ( 1 , 5 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Observable . range ( 1 , 5 ) . concatWith ( Observable . < Integer > never ( ) ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . test ( ) . assertValues ( 1 , 2 , 3 , 4 , 5 ) . assertNoErrors ( ) . assertNotComplete ( ) . dispose ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "outer" ) ) ; . concatMapSingle ( Functions . justFunction ( Single . error ( new TestException ( "inner" ) ) ) , 1 ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "outer" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < SingleObserver < ? super Integer > > obs = new AtomicReference < > ( ) ; TestObserverEx < Integer > to = ps . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; obs . set ( observer ) ; ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ps . onNext ( 1 ) ; ps . onError ( new TestException ( "outer" ) ) ; obs . get ( ) . onError ( new TestException ( "inner" ) ) ; to . assertFailureAndMessage ( TestException . class , "outer" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserverEx < Object > to = Observable . range ( 1 , 5 ) . concatMapSingleDelayError ( new Function < Integer , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Integer v ) throws Exception return Single . error ( new TestException ( ) ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; CompositeException ce = ( CompositeException ) to . errors ( ) . get ( 0 ) ; assertEquals ( 5 , ce . getExceptions ( ) . size ( ) ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Object > to = ps . concatMapSingle ( new Function < Integer , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
TestObserver < Object > to = Observable . just ( 1 ) . concatMapSingle ( new Function < Integer , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . hide ( ) . concatMapSingle ( Functions . justFunction ( Single . never ( ) ) ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . concatMapSingleDelayError ( Functions . justFunction ( ms ) , false ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; ps . onComplete ( ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; to . assertResult ( 1 , 1 ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; Observable . empty ( ) . concatMapSingle ( Functions . justFunction ( ss ) ) . test ( ) . assertResult ( ) ; assertFalse ( ss . hasObservers ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; ConcatMapSingleMainObserver < Integer , Integer > operator = new ConcatMapSingleMainObserver < > ( to , Functions . justFunction ( Single . < Integer > never ( ) ) , 16 , ErrorMode . IMMEDIATE ) ; operator . onSubscribe ( Disposable . empty ( ) ) ; operator . queue . offer ( 1 ) ; operator . getAndIncrement ( ) ; to . dispose ( ) ; assertFalse ( operator . queue . isEmpty ( ) ) ; operator . addAndGet ( - 2 ) ; operator . dispose ( ) ; assertTrue ( operator . queue . isEmpty ( ) ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = Observable . fromArray ( ss , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) ) . concatMapSingle ( Functions . < Single < Integer > > identity ( ) , 2 ) . test ( ) ; to . assertEmpty ( ) ; ss . onSuccess ( 1 ) ; to . assertResult ( 1 , 2 , 3 , 4 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final SingleSubject < Integer > ss = SingleSubject . create ( ) ; final TestObserver < Integer > to = Observable . just ( 1 ) . hide ( ) . concatMapSingle ( Functions . justFunction ( ss ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ss . onSuccess ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertNoErrors ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapSingleDelayError ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; , false , 2 ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapSingleDelayError ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; , true , 2 ) ; ) ; 
Observable . range ( 1 , 5 ) . hide ( ) . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . < Integer > rejectObservableFusion ( ) . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertEmpty ( ) ; 
Observable . range ( 1 , 5 ) . map ( v -> if ( v == 3 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . observableStripBoundary ( ) ) . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ss . flatMapObservable ( Functions . justFunction ( ps ) ) . test ( ) ; assertTrue ( ss . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ss . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ss . flatMapObservable ( Functions . justFunction ( ps ) ) . test ( ) ; assertTrue ( ss . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; ss . onSuccess ( 1 ) ; assertFalse ( ss . hasObservers ( ) ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ss . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ss . flatMapObservable ( Functions . justFunction ( ps ) ) . test ( ) ; assertTrue ( ss . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; ss . onError ( new TestException ( ) ) ; assertFalse ( ss . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ss . flatMapObservable ( Functions . justFunction ( ps ) ) . test ( ) ; assertTrue ( ss . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; ss . onSuccess ( 1 ) ; assertFalse ( ss . hasObservers ( ) ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertFalse ( ss . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . flatMapObservable ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Single . never ( ) . flatMapObservable ( Functions . justFunction ( Observable . never ( ) ) ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = ms . flatMapPublisher ( Functions . justFunction ( pp ) ) . test ( ) ; assertTrue ( ms . hasObservers ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( ms . hasObservers ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = ms . flatMapPublisher ( Functions . justFunction ( pp ) ) . test ( ) ; assertTrue ( ms . hasObservers ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ms . onSuccess ( 1 ) ; assertFalse ( ms . hasObservers ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( ms . hasObservers ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Maybe . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToFlowable ( new Function < Maybe < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Maybe < Object > m ) throws Exception return m . flatMapPublisher ( Functions . justFunction ( Flowable . never ( ) ) ) ; ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = cs . andThen ( pp ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( cs . hasObservers ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = cs . andThen ( pp ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; cs . onComplete ( ) ; assertFalse ( cs . hasObservers ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( cs . hasObservers ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletableToFlowable ( new Function < Completable , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Completable m ) throws Exception return m . andThen ( Flowable . never ( ) ) ; ) ; 
Observable . range ( 1 , 5 ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . error ( new TestException ( ) ) . switchMapSingle ( Functions . justFunction ( Single . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . switchMapSingle ( Functions . justFunction ( Single . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . switchMapSingle ( Functions . justFunction ( Single . never ( ) ) ) ; ) ; 
Observable . range ( 1 , 5 ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms1 = SingleSubject . create ( ) ; final SingleSubject < Integer > ms2 = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms1 ; return ms2 ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ms1 . hasObservers ( ) ) ; ps . onNext ( 2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms1 = SingleSubject . create ( ) ; final SingleSubject < Integer > ms2 = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms1 ; return ms2 ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ms1 . hasObservers ( ) ) ; ps . onNext ( 2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; 
Observable . just ( 1 ) . hide ( ) . switchMapSingle ( new Function < Integer , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . hide ( ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception to . dispose ( ) ; return Single . just ( 1 ) ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) to . dispose ( ) ; return Single . just ( 1 ) ; ) . subscribe ( to ) ; to . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "outer" ) ) ; . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . error ( new TestException ( "inner" ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "outer" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < SingleObserver < ? super Integer > > moRef = new AtomicReference < > ( ) ; TestObserverEx < Integer > to = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "outer" ) ) ; . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; moRef . set ( observer ) ; ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertFailureAndMessage ( TestException . class , "outer" ) ; moRef . get ( ) . onError ( new TestException ( "inner" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; final TestObserver < Integer > to = ps . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; final TestObserverEx < Integer > to = ps . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Single . never ( ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to . errors ( ) . size ( ) != 0 ) assertTrue ( errors . isEmpty ( ) ) ; to . assertFailure ( TestException . class ) ; else if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; final TestObserver < Integer > to = ps . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Single . never ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; final TestObserver < Integer > to = ps . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Single . never ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onSuccess ( 3 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertNoErrors ( ) . assertNotComplete ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestHelper . checkDisposed ( ps . switchMapSingle ( Functions . justFunction ( ms ) ) ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ; ps . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
TestObserver < Integer > to = Observable . just ( 1 ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; Observable . empty ( ) . switchMapSingle ( Functions . justFunction ( ss ) ) . test ( ) . assertResult ( ) ; assertFalse ( ss . hasObservers ( ) ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( 1 ) . switchMapSingle ( Functions . justFunction ( ss ) ) . test ( ) ; assertTrue ( ss . hasObservers ( ) ) ; to . assertEmpty ( ) ; ss . onSuccess ( 2 ) ; to . assertResult ( 2 ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . switchMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . switchMapSingleDelayError ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; ) ; ) ; 
Observable . range ( 1 , 10 ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . test ( ) . assertResult ( ) ; 
Observable . < Integer > error ( new TestException ( ) ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; to . assertEmpty ( ) ; cs . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
final CompletableSubject [ ] css = CompletableSubject . create ( ) , CompletableSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return css [ v ] ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 0 ) ; assertTrue ( css [ 0 ] . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertFalse ( css [ 0 ] . hasObservers ( ) ) ; assertTrue ( css [ 1 ] . hasObservers ( ) ) ; ps . onComplete ( ) ; to . assertEmpty ( ) ; assertTrue ( css [ 1 ] . hasObservers ( ) ) ; css [ 1 ] . onComplete ( ) ; to . assertResult ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestHelper . checkDisposed ( ps . switchMapCompletable ( Functions . justFunction ( cs ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservableToCompletable ( new Function < Observable < Object > , Completable > ( ) @ Override public Completable apply ( Observable < Object > f ) throws Exception return f . switchMapCompletable ( Functions . justFunction ( Completable . never ( ) ) ) ; ) ; 
Observable . range ( 1 , 5 ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer f ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer f ) throws Exception to . dispose ( ) ; return Completable . complete ( ) ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex0 = new TestException ( ) ; final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex0 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "main" ) ) ; . switchMapCompletable ( Functions . justFunction ( Completable . error ( new TestException ( "inner" ) ) ) ) . to ( TestHelper . testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "main" ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletableDelayError ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; cs . onError ( new TestException ( ) ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletableDelayError ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to . assertEmpty ( ) ; cs . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . switchMapCompletableDelayError ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; ps . onError ( new TestException ( ) ) ; to . assertEmpty ( ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Void > to = Observable . just ( 1 ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; Observable . empty ( ) . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) . assertResult ( ) ; assertFalse ( cs . hasObservers ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = Observable . just ( 1 ) . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; to . assertEmpty ( ) ; cs . onComplete ( ) ; to . assertResult ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Observable < Integer > upstream ) return upstream . switchMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Observable < Integer > upstream ) return upstream . switchMapCompletableDelayError ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; ) ; ) ; 
Observable . range ( 1 , 5 ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) ) . test ( ) . assertResult ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable . range ( 1 , 5 ) . concatMapCompletable ( Functions . justFunction ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter . incrementAndGet ( ) ; ) ) ) . test ( ) . assertResult ( ) ; assertEquals ( 5 , counter . get ( ) ) ; 
Observable . range ( 1 , 1024 ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) , 32 ) . test ( ) . assertResult ( ) ; 
Observable . < Integer > error ( new TestException ( ) ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . concatMapCompletable ( Functions . justFunction ( Completable . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Void > to = Observable . range ( 1 , 5 ) . concatMapCompletableDelayError ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; assertEquals ( 5 , ( ( CompositeException ) to . errors ( ) . get ( 0 ) ) . getExceptions ( ) . size ( ) ) ; 
Observable . just ( 1 ) . concatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onError ( new TestException ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . concatMapCompletableDelayError ( Functions . justFunction ( cs ) , false ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; to . assertEmpty ( ) ; cs . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; final CompletableSubject cs2 = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . concatMapCompletableDelayError ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception if ( v == 1 ) return cs ; return cs2 ; , true , 32 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onError ( new TestException ( ) ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 2 ) ; to . assertEmpty ( ) ; cs2 . onComplete ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to . assertEmpty ( ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeObservableToCompletable ( new Function < Observable < Object > , Completable > ( ) @ Override public Completable apply ( Observable < Object > f ) throws Exception return f . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) ) ; ) ; 
TestHelper . checkDisposed ( Observable . never ( ) . concatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) ) ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = ps . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) . assertNotComplete ( ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; final TestObserver < Void > to = ps . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onComplete ( ) ; to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; final TestObserver < Void > to = ps . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; ps . onComplete ( ) ; cs . onComplete ( ) ; to . assertResult ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; final TestObserver < Void > to = ps . observeOn ( ImmediateThinScheduler . INSTANCE ) . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; cs . onComplete ( ) ; to . assertResult ( ) ; 
final CompletableSubject cs = CompletableSubject . create ( ) ; TestHelper . rejectObservableFusion ( ) . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) . assertEmpty ( ) ; 
final CompletableSubject cs = CompletableSubject . create ( ) ; Observable . empty ( ) . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) . assertResult ( ) ; 
final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = Observable . just ( 1 ) . concatMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onComplete ( ) ; to . assertResult ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Observable < Integer > upstream ) return upstream . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Observable < Integer > upstream ) return upstream . concatMapCompletableDelayError ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; , false , 2 ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Observable < Integer > upstream ) return upstream . concatMapCompletableDelayError ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; , true , 2 ) ; ) ; 
Observable . range ( 1 , 5 ) . hide ( ) . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 5 ) . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
TestHelper . < Integer > rejectObservableFusion ( ) . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertEmpty ( ) ; 
Observable . range ( 1 , 5 ) . map ( v -> if ( v == 3 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . observableStripBoundary ( ) ) . concatMapCompletable ( v -> Completable . complete ( ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 1024 ) . concatMapMaybe ( Maybe :: just , 32 ) . test ( ) . assertValueCount ( 1024 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 1024 ) . hide ( ) . concatMapMaybe ( Maybe :: just , 32 ) . test ( ) . assertValueCount ( 1024 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 1024 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; , 32 ) . test ( 0 ) ; for ( int i = 1 ; i <= 1024 ; i ++ ) ts . assertValueCount ( i - 1 ) . assertNoErrors ( ) . assertNotComplete ( ) . requestMore ( 1 ) . assertValueCount ( i ) . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . range ( 1 , 10 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v % 2 == 0 ) return Maybe . just ( v ) ; return Maybe . empty ( ) ; ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 1024 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v % 2 == 0 ) return Maybe . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; return Maybe . < Integer > empty ( ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 512 ) . assertNoErrors ( ) . assertComplete ( ) ; for ( int i = 0 ; i < 512 ; i ++ ) ts . assertValueAt ( i , ( i + 1 ) * 2 ) ; 
Flowable . error ( new TestException ( ) ) . concatMapMaybe ( Functions . justFunction ( Maybe . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . concatMapMaybe ( Functions . justFunction ( Maybe . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . concatMapMaybeDelayError ( Functions . justFunction ( ms ) , false ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; assertTrue ( ms . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . concatMapMaybeDelayError ( Functions . justFunction ( ms ) , false ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; assertTrue ( ms . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . assertEmpty ( ) ; ms . onComplete ( ) ; ts . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . concatMapMaybeDelayError ( Functions . justFunction ( Maybe . empty ( ) ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; s . onError ( new TestException ( ) ) ; . concatMapMaybe ( Functions . justFunction ( Maybe . never ( ) ) , 1 ) . test ( ) . assertFailure ( MissingBackpressureException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 5 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Flowable . range ( 1 , 5 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . test ( 3 ) . assertValues ( 1 , 2 , 3 ) . assertNoErrors ( ) . assertNotComplete ( ) . cancel ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < MaybeObserver < ? super Integer > > obs = new AtomicReference < > ( ) ; TestSubscriberEx < Integer > ts = pp . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; obs . set ( observer ) ; ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; pp . onNext ( 1 ) ; pp . onError ( new TestException ( "outer" ) ) ; obs . get ( ) . onError ( new TestException ( "inner" ) ) ; ts . assertFailureAndMessage ( TestException . class , "outer" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriberEx < Object > ts = Flowable . range ( 1 , 5 ) . concatMapMaybeDelayError ( new Function < Integer , MaybeSource < ? extends Object > > ( ) @ Override public MaybeSource < ? extends Object > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( ) ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; CompositeException ce = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; assertEquals ( 5 , ce . getExceptions ( ) . size ( ) ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Object > ts = pp . concatMapMaybe ( new Function < Integer , MaybeSource < ? extends Object > > ( ) @ Override public MaybeSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; ts . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ConcatMapMaybeSubscriber < Integer , Integer > operator = new ConcatMapMaybeSubscriber < > ( ts , Functions . justFunction ( Maybe . < Integer > never ( ) ) , 16 , ErrorMode . IMMEDIATE ) ; operator . onSubscribe ( new BooleanSubscription ( ) ) ; operator . queue . offer ( 1 ) ; operator . getAndIncrement ( ) ; ts . cancel ( ) ; assertFalse ( operator . queue . isEmpty ( ) ) ; operator . addAndGet ( - 2 ) ; operator . cancel ( ) ; assertTrue ( operator . queue . isEmpty ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestSubscriber < Integer > ts = Flowable . just ( 1 ) . hide ( ) . concatMapMaybe ( Functions . justFunction ( ms ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ms . onSuccess ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertNoErrors ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapMaybeDelayError ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; , false , 2 ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapMaybeDelayError ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; , true , 2 ) ; ) ; 
Flowable . range ( 1 , 5 ) . hide ( ) . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . < Integer > rejectFlowableFusion ( ) . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertEmpty ( ) ; 
Flowable . range ( 1 , 5 ) . map ( v -> if ( v == 3 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Observable . range ( 1 , 5 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 10 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v % 2 == 0 ) return Maybe . just ( v ) ; return Maybe . empty ( ) ; ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
Observable . error ( new TestException ( ) ) . switchMapMaybe ( Functions . justFunction ( Maybe . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . switchMapMaybe ( Functions . justFunction ( Maybe . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . switchMapMaybe ( Functions . justFunction ( Maybe . never ( ) ) ) ; ) ; 
Observable . range ( 1 , 5 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms1 = MaybeSubject . create ( ) ; final MaybeSubject < Integer > ms2 = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms1 ; return ms2 ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ms1 . hasObservers ( ) ) ; ps . onNext ( 2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms1 = MaybeSubject . create ( ) ; final MaybeSubject < Integer > ms2 = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms1 ; return ms2 ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ms1 . hasObservers ( ) ) ; ps . onNext ( 2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; 
Observable . just ( 1 ) . hide ( ) . switchMapMaybe ( new Function < Integer , MaybeSource < ? extends Object > > ( ) @ Override public MaybeSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception to . dispose ( ) ; return Maybe . just ( 1 ) ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) to . dispose ( ) ; return Maybe . just ( 1 ) ; ) . subscribe ( to ) ; to . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "outer" ) ) ; . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( "inner" ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "outer" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < MaybeObserver < ? super Integer > > moRef = new AtomicReference < > ( ) ; TestObserverEx < Integer > to = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "outer" ) ) ; . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; moRef . set ( observer ) ; ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertFailureAndMessage ( TestException . class , "outer" ) ; moRef . get ( ) . onError ( new TestException ( "inner" ) ) ; moRef . get ( ) . onComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestObserver < Integer > to = ps . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestObserverEx < Integer > to = ps . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Maybe . never ( ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to . errors ( ) . size ( ) != 0 ) assertTrue ( errors . isEmpty ( ) ) ; to . assertFailure ( TestException . class ) ; else if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestObserver < Integer > to = ps . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Maybe . never ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestObserver < Integer > to = ps . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Maybe . empty ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onSuccess ( 3 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertNoErrors ( ) . assertNotComplete ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestHelper . checkDisposed ( ps . switchMapMaybe ( Functions . justFunction ( ms ) ) ) ; 
