PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . count ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToSingle ( new Function < Maybe < Object > , SingleSource < Long > > ( ) @ Override public SingleSource < Long > apply ( Maybe < Object > f ) throws Exception return f . count ( ) ; ) ; 
assertSame ( Maybe . empty ( ) , ( ( HasUpstreamMaybeSource < Object > ) ( Maybe . empty ( ) . count ( ) ) ) . source ( ) ) ; 
Maybe . fromObservable ( Observable . empty ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . fromObservable ( Observable . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . fromObservable ( Observable . range ( 1 , 5 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . fromObservable ( Observable . error ( new TestException ( ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Object > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = Maybe . just ( 1 ) . delaySubscription ( pp ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . assertEmpty ( ) ; pp . onNext ( "one" ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Maybe . < Integer > empty ( ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Integer > to = Maybe . just ( 1 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) . test ( ) ; to . assertEmpty ( ) ; scheduler . advanceTimeBy ( 99 , TimeUnit . MILLISECONDS ) ; to . assertEmpty ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; to . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . delaySubscription ( Flowable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . error ( new TestException ( ) ) . delaySubscription ( Flowable . empty ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . delaySubscription ( Flowable . never ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > m ) throws Exception return m . delaySubscription ( Flowable . just ( 1 ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable < Integer > f = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 2 ) ; ; Maybe . just ( 1 ) . delaySubscription ( f ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToMaybe ( f -> Maybe . just ( 1 ) . delaySubscription ( f ) ) ; 
Maybe < Integer > m = Maybe . just ( 1 ) ; assertSame ( m , ( ( ( HasUpstreamMaybeSource < ? > ) m . toObservable ( ) ) . source ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToObservable ( new Function < Maybe < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Maybe < Object > m ) throws Exception return m . toObservable ( ) ; ) ; 
Maybe . just ( Notification . createOnNext ( 1 ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( Notification . < Integer > createOnComplete ( ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) . test ( ) . assertResult ( ) ; 
@ SuppressWarnings ( "unchecked" ) Function < Notification < Integer > , Notification < Integer > > function = mock ( Function . class ) ; Maybe . < Notification < Integer > > empty ( ) . dematerialize ( function ) . test ( ) . assertResult ( ) ; verify ( function , never ( ) ) . apply ( any ( ) ) ; 
Maybe . < Notification < Integer > > error ( new TestException ( ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( Notification . < Integer > createOnError ( new TestException ( ) ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ SuppressWarnings ( "unchecked" , "rawtypes" ) @ Override public MaybeSource < Object > apply ( Maybe < Object > v ) throws Exception return v . dematerialize ( ( Function ) Functions . identity ( ) ) ; ) ; 
TestHelper . checkDisposed ( MaybeSubject . < Notification < Integer > > create ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ) ; 
Maybe . just ( Notification . createOnNext ( 1 ) ) . dematerialize ( new Function < Notification < Integer > , Notification < Integer > > ( ) @ Override public Notification < Integer > apply ( Notification < Integer > v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( Notification . createOnNext ( 1 ) ) . dematerialize ( Functions . justFunction ( ( Notification < Integer > ) null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe . just ( Notification . createOnNext ( 1 ) ) . dematerialize ( new Function < Notification < Integer > , Notification < String > > ( ) @ Override public Notification < String > apply ( Notification < Integer > v ) throws Exception return Notification . createOnNext ( "Value-" + 1 ) ; ) . test ( ) . assertResult ( "Value-1" ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . flatMap ( Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justSupplier ( Maybe . just ( 1 ) ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Maybe < Integer > m ) throws Exception return m . flatMap ( Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justSupplier ( Maybe . just ( 1 ) ) ) ; ) ; 
Maybe . just ( 1 ) . flatMap ( Functions . justFunction ( ( Maybe < Integer > ) null ) , Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justSupplier ( Maybe . just ( 1 ) ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestObserverEx < Integer > to = Maybe . < Integer > error ( new TestException ( ) ) . flatMap ( Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justFunction ( ( Maybe < Integer > ) null ) , Functions . justSupplier ( Maybe . just ( 1 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class ) ; TestHelper . assertError ( ce , 1 , NullPointerException . class ) ; 
Maybe . < Integer > empty ( ) . flatMap ( Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justSupplier ( ( Maybe < Integer > ) null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe . just ( 1 ) . flatMap ( Functions . justFunction ( Maybe . < Integer > empty ( ) ) , Functions . justFunction ( Maybe . just ( 1 ) ) , Functions . justSupplier ( Maybe . just ( 1 ) ) ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . flatMap ( Functions . justFunction ( Maybe . < Integer > error ( new TestException ( ) ) ) , Functions . justFunction ( ( Maybe < Integer > ) null ) , Functions . justSupplier ( Maybe . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Maybe < Integer > v ) throws Exception return v . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; ) ; ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . < Integer > empty ( ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . < Integer > empty ( ) , Maybe . just ( 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 ) ; 
Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . < Integer > empty ( ) , Maybe . just ( 2 ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) QueueSubscription < Integer > qs ; @ Override public void onSubscribe ( Subscription s ) qs = ( QueueSubscription < Integer > ) s ; assertEquals ( QueueFuseable . ASYNC , qs . requestFusion ( QueueFuseable . ANY ) ) ; @ Override public void onNext ( Integer value ) assertFalse ( qs . isEmpty ( ) ) ; qs . clear ( ) ; assertTrue ( qs . isEmpty ( ) ) ; qs . cancel ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . < Integer > empty ( ) , Maybe . just ( 2 ) ) . subscribe ( ts ) ; ts . cancel ( ) ; ts . request ( 10 ) ; ts . assertEmpty ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Maybe . mergeArray ( Maybe . < Integer > error ( new TestException ( ) ) , Maybe . < Integer > empty ( ) , Maybe . just ( 2 ) ) . subscribe ( ts ) ; ts . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . mergeArray ( Maybe . < Integer > error ( new TestException ( ) ) , Maybe . just ( 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestSubscriber < Integer > ts = Maybe . mergeArray ( ps1 . singleElement ( ) , ps2 . singleElement ( ) ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertFailure ( Throwable . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Maybe . mergeArray ( new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; observer . onSuccess ( 2 ) ; observer . onSuccess ( 3 ) ; , Maybe . never ( ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . mergeArray ( Maybe . never ( ) , Maybe . never ( ) ) . subscribe ( new FlowableSubscriber < Object > ( ) @ SuppressWarnings ( "rawtypes" ) @ Override public void onSubscribe ( Subscription s ) MergeMaybeObserver o = ( MergeMaybeObserver ) s ; try o . queue . offer ( 1 , 2 ) ; fail ( "Should have thrown" ) ; catch ( UnsupportedOperationException ex ) @ Override public void onNext ( Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; 
Maybe < Integer > [ ] a = new Maybe [ 1024 ] ; Arrays . fill ( a , Maybe . never ( ) ) ; Maybe . mergeArray ( a ) . subscribe ( new FlowableSubscriber < Object > ( ) @ SuppressWarnings ( "rawtypes" ) @ Override public void onSubscribe ( Subscription s ) MergeMaybeObserver o = ( MergeMaybeObserver ) s ; try o . queue . offer ( 1 , 2 ) ; fail ( "Should have thrown" ) ; catch ( UnsupportedOperationException ex ) o . queue . drop ( ) ; @ Override public void onNext ( Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; 
TestHelper . assertBadRequestReported ( Maybe . mergeArray ( MaybeSubject . create ( ) , MaybeSubject . create ( ) ) ) ; 
TestHelper . checkDisposed ( Maybe . mergeArray ( MaybeSubject . create ( ) , MaybeSubject . create ( ) ) ) ; 
Maybe . mergeArray ( Maybe . just ( 1 ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) . doOnSubscribe ( s -> s . request ( Long . MAX_VALUE ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Maybe < Integer > m = Maybe . just ( 1 ) ; assertSame ( m , ( ( ( HasUpstreamMaybeSource < ? > ) m . toFlowable ( ) ) . source ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToFlowable ( new Function < Maybe < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Maybe < Object > m ) throws Exception return m . toFlowable ( ) ; ) ; 
calls ++ ; 
Maybe . just ( 1 ) . doFinally ( this ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls ) ; 
Maybe . empty ( ) . doFinally ( this ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls ) ; 
Maybe . error ( new TestException ( ) ) . doFinally ( this ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Maybe < Object > f ) throws Exception return f . doFinally ( MaybeDoFinallyTest . this ) ; ) ; TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Maybe < Object > f ) throws Exception return f . doFinally ( MaybeDoFinallyTest . this ) . filter ( Functions . alwaysTrue ( ) ) ; ) ; 
Maybe . just ( 1 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls ) ; 
Maybe . empty ( ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls ) ; 
Maybe . error ( new TestException ( ) ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Maybe . just ( 1 ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( 1 ) . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Maybe . just ( 1 ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleElement ( ) . doFinally ( this ) ) ; 
Maybe . just ( 1 ) . hide ( ) . test ( ) . assertResult ( 1 ) ; 
Maybe . empty ( ) . hide ( ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . hide ( ) . test ( ) . assertFailure ( TestException . class ) ; 
assertTrue ( Maybe . just ( 1 ) instanceof ScalarSupplier ) ; assertFalse ( Maybe . just ( 1 ) . hide ( ) instanceof ScalarSupplier ) ; 
TestHelper . checkDisposedMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > m ) throws Exception return m . hide ( ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . hide ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Maybe < Object > f ) throws Exception return f . hide ( ) ; ) ; 
Maybe . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . takeUntil ( Flowable . never ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . takeUntil ( Maybe . never ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . takeUntil ( Flowable . just ( "one" ) ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . takeUntil ( Maybe . just ( "one" ) ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . takeUntil ( Maybe . never ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > m ) throws Exception return m . takeUntil ( Maybe . never ( ) ) ; ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 . singleElement ( ) ) . test ( ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . takeUntil ( pp2 . singleElement ( ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; MaybeSubject < Integer > other = MaybeSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onSuccess ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( 1 ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; MaybeSubject < Integer > other = MaybeSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; MaybeSubject < Integer > other = MaybeSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; MaybeSubject < Integer > other = MaybeSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onSuccess ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; MaybeSubject < Integer > other = MaybeSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; MaybeSubject < Integer > other = MaybeSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; MaybeSubject < Integer > other = MaybeSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertEmpty ( ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; main . onSuccess ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; main . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; other . onNext ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; other . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; other . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
MaybeSubject < Integer > main = MaybeSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertEmpty ( ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > m ) throws Exception return m . map ( Functions . identity ( ) ) ; ) ; 
Maybe . mergeDelayError ( Flowable . just ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Maybe . mergeDelayError ( Flowable . just ( Maybe . just ( 1 ) , Maybe . < Integer > error ( new TestException ( ) ) , Maybe . just ( 3 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 3 ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; @ SuppressWarnings ( "unchecked" ) Maybe < Integer > [ ] sources = new Maybe [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) final int j = i + 1 ; sources [ i ] = Maybe . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception return count . incrementAndGet ( ) - j ; ) . subscribeOn ( Schedulers . io ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) count . set ( 0 ) ; Maybe . mergeDelayError ( Flowable . fromArray ( sources ) , 1 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 0 , 0 , 0 ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; @ SuppressWarnings ( "unchecked" ) Maybe < Integer > [ ] sources = new Maybe [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) final int j = i + 1 ; sources [ i ] = Maybe . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception return count . incrementAndGet ( ) - j ; ) . subscribeOn ( Schedulers . io ( ) ) ; sources [ 1 ] = Maybe . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception throw new TestException ( "" + count . incrementAndGet ( ) ) ; ) . subscribeOn ( Schedulers . io ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) count . set ( 0 ) ; Maybe . mergeDelayError ( Flowable . fromArray ( sources ) , 1 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailureAndMessage ( TestException . class , "2" , 0 , 0 ) ; 
Maybe . mergeDelayError ( Flowable . just ( Maybe . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( 2 ) ; return Single . just ( 1 ) ; ) . toSingle ( ) . test ( ) . assertResult ( 2 ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < String > > ( ) @ Override public SingleSource < String > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( "2" ) ; return Single . just ( "1" ) ; ) . toSingle ( ) . test ( ) . assertResult ( "2" ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return null ; ) . toSingle ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( NullPointerException . class ) . assertErrorMessage ( "The mapper returned a null SingleSource" ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception throw new RuntimeException ( "something went terribly wrong!" ) ; ) . toSingle ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "something went terribly wrong!" ) ; 
RuntimeException exception = new RuntimeException ( "test" ) ; Maybe . error ( exception ) . flatMapSingle ( new Function < Object , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( final Object integer ) throws Exception return Single . just ( new Object ( ) ) ; ) . toSingle ( ) . test ( ) . assertError ( exception ) ; 
Maybe . < Integer > empty ( ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) . toSingle ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) . toSingle ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToSingle ( new Function < Maybe < Integer > , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Maybe < Integer > m ) throws Exception return m . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) . toSingle ( ) ; ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . error ( new TestException ( ) ) ; ) . toSingle ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . fromPublisher ( Flowable . empty ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . fromPublisher ( Flowable . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . fromPublisher ( Flowable . range ( 1 , 5 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . fromPublisher ( Flowable . error ( new TestException ( ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . concat ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , Maybe . just ( 3 ) ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Maybe . concat ( new Iterable < MaybeSource < Object > > ( ) @ Override public Iterator < MaybeSource < Object > > iterator ( ) throw new TestException ( "iterator()" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Maybe . concat ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . < Integer > error ( new TestException ( ) ) , Maybe . just ( 3 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = Maybe . concat ( Arrays . asList ( pp . singleElement ( ) ) ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Maybe . concat ( new CrashingMappedIterable < > ( 100 , 1 , 100 , new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 1 ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
Maybe . concat ( new CrashingMappedIterable < > ( 100 , 100 , 1 , new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 1 ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Maybe . concat ( new CrashingMappedIterable < > ( 100 , 100 , 100 , new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Exception return null ; ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
final int [ ] calls = 0 ; Maybe < Integer > source = Maybe . create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onSuccess ( 1 ) ; ) ; Maybe . concat ( Arrays . asList ( source , source ) ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Maybe < Integer > source = Maybe . create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onSuccess ( 1 ) ; ) ; Maybe . concatDelayError ( Arrays . asList ( source , source ) ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
TestHelper . assertBadRequestReported ( Maybe . concat ( Arrays . asList ( MaybeSubject . create ( ) , MaybeSubject . create ( ) ) ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Maybe . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Callable < Object > callable = new Callable < Object > ( ) @ Override public Object call ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ; Maybe . fromCallable ( callable ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Maybe . fromCallable ( callable ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Maybe < Object > completable = Maybe . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; completable . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Maybe . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final int [ ] counter = 0 ; Maybe < Integer > m = Maybe . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception counter [ 0 ] ++ ; return 0 ; ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof Supplier ) ; assertEquals ( 0 , ( ( Supplier < Void > ) m ) . get ( ) ) ; assertEquals ( 1 , counter [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Integer > to = Maybe . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; return 1 ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Callable < String > func = mock ( Callable . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . call ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Maybe < String > fromCallableObservable = Maybe . fromCallable ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; TestObserver < String > outer = new TestObserver < > ( observer ) ; fromCallableObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . dispose ( ) ; funcLatch . countDown ( ) ; verify ( func ) . call ( ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verifyNoMoreInteractions ( observer ) ; 
Maybe . fromCallable ( ( ) -> 1 ) . test ( true ) . assertEmpty ( ) ; 
Maybe . fromCallable ( ( ) -> 1 ) . test ( ) . assertResult ( 1 ) ; 
Maybe . concatEager ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . concatEager ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . concatEager ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . concatEager ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . concatEager ( Flowable . fromArray ( Maybe . just ( 1 ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . concatEager ( Flowable . fromArray ( Maybe . just ( 1 ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . concatEager ( Flowable . fromArray ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Maybe . concatEagerDelayError ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Maybe . concatEagerDelayError ( Arrays . asList ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Maybe . concatEagerDelayError ( Flowable . fromArray ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Maybe . concatEagerDelayError ( Flowable . fromArray ( Maybe . just ( 1 ) , Maybe . error ( new TestException ( ) ) , Maybe . empty ( ) , Maybe . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Maybe < Integer > m = Maybe . just ( 1 ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof ScalarSupplier ) ; assertEquals ( 1 , ( ( ScalarSupplier < Integer > ) m ) . get ( ) . intValue ( ) ) ; 
Maybe . just ( 1 ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . timeout ( Maybe . timer ( 1 , TimeUnit . DAYS ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
Maybe . never ( ) . timeout ( Maybe . timer ( 1 , TimeUnit . MILLISECONDS ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
Maybe . just ( 1 ) . timeout ( 1 , TimeUnit . DAYS , Maybe . just ( 2 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . timeout ( Maybe . timer ( 1 , TimeUnit . DAYS ) , Maybe . just ( 2 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , Maybe . just ( 2 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 ) ; 
Maybe . never ( ) . timeout ( Maybe . timer ( 1 , TimeUnit . MILLISECONDS ) , Maybe . just ( 2 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 ) ; 
Maybe . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , Maybe . just ( 2 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 ) ; 
Maybe . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
Maybe . just ( 1 ) . timeout ( Flowable . timer ( 1 , TimeUnit . DAYS ) , Maybe . just ( 2 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . never ( ) . timeout ( Flowable . timer ( 1 , TimeUnit . MILLISECONDS ) , Maybe . just ( 2 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 2 ) ; 
Maybe . just ( 1 ) . timeout ( Flowable . timer ( 1 , TimeUnit . DAYS ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . never ( ) . timeout ( Flowable . timer ( 1 , TimeUnit . MILLISECONDS ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) , Maybe . < Integer > error ( new TestException ( ) ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 1 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) , Maybe . < Integer > empty ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 1 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertFailure ( TimeoutException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) ) ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) , Maybe . just ( 1 ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserverEx < Integer > to = pp1 . singleElement ( ) . timeout ( pp2 . singleElement ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertSubscribed ( ) . assertNoValues ( ) ; if ( to . errors ( ) . size ( ) != 0 ) to . assertError ( TimeoutException . class ) . assertNotComplete ( ) ; else to . assertNoErrors ( ) . assertComplete ( ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; new Maybe < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ms . onSuccess ( 2 ) ; observer . onSuccess ( 1 ) ; . timeout ( ms ) . test ( ) . assertFailure ( TimeoutException . class ) ; 
Maybe . just ( 1 ) . isEmpty ( ) . test ( ) . assertResult ( false ) ; 
Maybe . empty ( ) . isEmpty ( ) . test ( ) . assertResult ( true ) ; 
Maybe . error ( new TestException ( ) ) . isEmpty ( ) . test ( ) . assertFailure ( TestException . class ) ; 
assertTrue ( Maybe . just ( 1 ) . isEmpty ( ) . toMaybe ( ) instanceof MaybeIsEmpty ) ; 
Maybe . just ( 1 ) . isEmpty ( ) . toMaybe ( ) . test ( ) . assertResult ( false ) ; 
Maybe . empty ( ) . isEmpty ( ) . toMaybe ( ) . test ( ) . assertResult ( true ) ; 
Maybe . error ( new TestException ( ) ) . isEmpty ( ) . toMaybe ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposedMaybeToSingle ( new Function < Maybe < Object > , SingleSource < Boolean > > ( ) @ Override public SingleSource < Boolean > apply ( Maybe < Object > m ) throws Exception return m . isEmpty ( ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . isEmpty ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToSingle ( new Function < Maybe < Object > , Single < Boolean > > ( ) @ Override public Single < Boolean > apply ( Maybe < Object > f ) throws Exception return f . isEmpty ( ) ; ) ; 
TestHelper . checkDisposedMaybe ( new Function < Maybe < Object > , Maybe < Boolean > > ( ) @ Override public Maybe < Boolean > apply ( Maybe < Object > m ) throws Exception return m . isEmpty ( ) . toMaybe ( ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . isEmpty ( ) . toMaybe ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , Maybe < Boolean > > ( ) @ Override public Maybe < Boolean > apply ( Maybe < Object > f ) throws Exception return f . isEmpty ( ) . toMaybe ( ) ; ) ; 
Maybe . zip ( Maybe . error ( new TestException ( ) ) , Maybe . just ( 1 ) , addString ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . < Integer > error ( new TestException ( ) ) , addString ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Object > to = Maybe . zip ( pp . singleElement ( ) , pp . singleElement ( ) , addString ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . zip ( Maybe . just ( 1 ) , Maybe . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; TestObserver < Object > to = Maybe . zip ( pp0 . singleElement ( ) , pp1 . singleElement ( ) , pp0 . singleElement ( ) , addString3 ) . test ( ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp0 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final TestObserver < Object > to = Maybe . zip ( pp0 . singleElement ( ) , pp1 . singleElement ( ) , addString ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp0 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Maybe . zipArray ( new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , Maybe . just ( 1 ) , null ) . blockingGet ( ) ; 
Maybe . zipArray ( Functions . justFunction ( null ) , Maybe . just ( 1 ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The zipper returned a null value" ) ; 
TestHelper . checkDisposed ( Maybe . zipArray ( v -> v , MaybeSubject . create ( ) , MaybeSubject . create ( ) ) ) ; 
AtomicReference < MaybeObserver < ? super Integer > > ref1 = new AtomicReference < > ( ) ; AtomicReference < MaybeObserver < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Maybe < Integer > m1 = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull MaybeObserver < ? super Integer > observer ) ref1 . set ( observer ) ; ; Maybe < Integer > m2 = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull MaybeObserver < ? super Integer > observer ) ref2 . set ( observer ) ; ; TestObserver < Object [ ] > to = Maybe . zipArray ( v -> v , m1 , m2 ) . test ( ) ; ref1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref2 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref1 . get ( ) . onComplete ( ) ; ref2 . get ( ) . onComplete ( ) ; to . assertResult ( ) ; 
Maybe . zipArray ( v -> Arrays . asList ( v ) , Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 ) ) ; 
Maybe . zipArray ( v -> Arrays . asList ( v ) , Maybe . just ( 1 ) ) . test ( ) . assertResult ( Arrays . asList ( 1 ) ) ; 
AtomicReference < MaybeObserver < ? super Integer > > emitter = new AtomicReference < > ( ) ; TestObserver < List < Object > > to = Maybe . zipArray ( Arrays :: asList , ( MaybeSource < Integer > ) o -> emitter . set ( o ) , Maybe . < Integer > never ( ) ) . test ( ) ; emitter . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; to . dispose ( ) ; emitter . get ( ) . onSuccess ( 1 ) ; to . assertEmpty ( ) ; 
Maybe . just ( 1 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( 2 ) ; return Single . just ( 1 ) ; ) . test ( ) . assertResult ( 2 ) ; 
Maybe . just ( 1 ) . concatMapSingle ( new Function < Integer , SingleSource < String > > ( ) @ Override public SingleSource < String > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( "2" ) ; return Single . just ( "1" ) ; ) . test ( ) . assertResult ( "2" ) ; 
Maybe . just ( 1 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( NullPointerException . class ) . assertErrorMessage ( "The mapper returned a null SingleSource" ) ; 
Maybe . just ( 1 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception throw new RuntimeException ( "something went terribly wrong!" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "something went terribly wrong!" ) ; 
RuntimeException exception = new RuntimeException ( "test" ) ; Maybe . error ( exception ) . concatMapSingle ( new Function < Object , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( final Object integer ) throws Exception return Single . just ( new Object ( ) ) ; ) . test ( ) . assertError ( exception ) ; 
Maybe . < Integer > empty ( ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) . test ( ) . assertNoValues ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Maybe < Integer > m ) throws Exception return m . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) ; ) ; 
Maybe . just ( 1 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . switchIfEmpty ( Single . just ( 2 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . < Integer > empty ( ) . switchIfEmpty ( Single . just ( 2 ) ) . test ( ) . assertResult ( 2 ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . switchIfEmpty ( Single . just ( 2 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . switchIfEmpty ( Single . < Integer > error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp . singleElement ( ) . switchIfEmpty ( Single . just ( 2 ) ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . switchIfEmpty ( Single . just ( 2 ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToSingle ( new Function < Maybe < Integer > , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Maybe < Integer > f ) throws Exception return f . switchIfEmpty ( Single . just ( 2 ) ) ; ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestObserver < Integer > to = pp . singleElement ( ) . switchIfEmpty ( Single . just ( 2 ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
assertSame ( Maybe . empty ( ) , ( ( HasUpstreamMaybeSource ) ( Maybe . < Integer > empty ( ) . switchIfEmpty ( Single . just ( 1 ) ) ) ) . source ( ) ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( 2 ) ; return Single . just ( 1 ) ; ) . test ( ) . assertResult ( 2 ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < String > > ( ) @ Override public SingleSource < String > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( "2" ) ; return Single . just ( "1" ) ; ) . test ( ) . assertResult ( "2" ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( NullPointerException . class ) . assertErrorMessage ( "The mapper returned a null SingleSource" ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception throw new RuntimeException ( "something went terribly wrong!" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "something went terribly wrong!" ) ; 
RuntimeException exception = new RuntimeException ( "test" ) ; Maybe . error ( exception ) . flatMapSingle ( new Function < Object , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( final Object integer ) throws Exception return Single . just ( new Object ( ) ) ; ) . test ( ) . assertError ( exception ) ; 
Maybe . < Integer > empty ( ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) . test ( ) . assertNoValues ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Integer > , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Maybe < Integer > m ) throws Exception return m . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . just ( 2 ) ; ) ; ) ; 
Maybe . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return Single . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Collections . < Integer > emptyList ( ) ; ) . test ( ) . assertResult ( ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . < Integer > empty ( ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 ) ; ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 1 , 100 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 1 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 100 , 1 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 2 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToObservable ( new Function < Maybe < Object > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Maybe < Object > o ) throws Exception return o . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Collections . singleton ( 1 ) ; ) ; ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Collections . singleton ( 1 ) ; ) ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . take ( 500 * 1000 ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . observeOn ( Schedulers . single ( ) ) . take ( 500 * 1000 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Arrays . asList ( 1 , 2 , 3 ) ; ) . subscribe ( new Observer < Integer > ( ) QueueDisposable < Integer > qd ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSubscribe ( Disposable d ) qd = ( QueueDisposable < Integer > ) d ; assertEquals ( QueueFuseable . ASYNC , qd . requestFusion ( QueueFuseable . ANY ) ) ; @ Override public void onNext ( Integer value ) assertFalse ( qd . isEmpty ( ) ) ; qd . clear ( ) ; assertTrue ( qd . isEmpty ( ) ) ; qd . dispose ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception e . onSuccess ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception e . onError ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestHelper . checkDisposed ( Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception e . onSuccess ( 1 ) ; ) ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onSuccess ( 1 ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new MaybeObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) throw new TestException ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onError ( new IOException ( ) ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new MaybeObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onComplete ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new MaybeObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception try e . onSuccess ( 1 ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new MaybeObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) throw new TestException ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception try e . onError ( new IOException ( ) ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new MaybeObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception try e . onComplete ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new MaybeObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Boolean [ ] response = null ; Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > e ) throws Exception e . onSuccess ( 1 ) ; response [ 0 ] = e . tryOnError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( 1 ) ; assertFalse ( response [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Maybe . create ( new MaybeOnSubscribe < Object > ( ) @ Override public void subscribe ( MaybeEmitter < Object > emitter ) throws Exception assertTrue ( emitter . toString ( ) . contains ( MaybeCreate . Emitter . class . getSimpleName ( ) ) ) ; ) . test ( ) . assertEmpty ( ) ; 
Maybe . just ( 1 ) . mergeWith ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final String [ ] name = null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; pp . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception name [ 0 ] = Thread . currentThread ( ) . getName ( ) ; cdl . countDown ( ) ; ) . singleElement ( ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( true ) ; assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; int times = 10 ; while ( times -- > 0 && pp . hasSubscribers ( ) ) Thread . sleep ( 100 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertNotEquals ( Thread . currentThread ( ) . getName ( ) , name [ 0 ] ) ; 
Maybe . just ( 1 ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . < Integer > error ( new TestException ( ) ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Maybe . just ( 1 ) . unsubscribeOn ( Schedulers . single ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > v ) throws Exception return v . unsubscribeOn ( Schedulers . single ( ) ) ; ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Disposable [ ] ds = null ; pp . singleElement ( ) . unsubscribeOn ( Schedulers . computation ( ) ) . subscribe ( new MaybeObserver < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) ds [ 0 ] = d ; @ Override public void onSuccess ( Integer value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) ds [ 0 ] . dispose ( ) ; ; TestHelper . race ( r , r ) ; 
Maybe < Integer > m = Maybe . just ( 1 ) ; assertSame ( m , ( ( ( HasUpstreamMaybeSource < ? > ) m . isEmpty ( ) ) . source ( ) ) ) ; 
Maybe . just ( 1 ) . ofType ( Integer . class ) . test ( ) . assertResult ( 1 ) ; 
TestObserver < Number > to = Maybe . just ( 1 ) . ofType ( Number . class ) . test ( ) ; to . assertResult ( ( Number ) 1 ) ; 
TestObserver < String > to = Maybe . just ( 1 ) . ofType ( String . class ) . test ( ) ; to . assertResult ( ) ; 
TestObserver < Number > to = Maybe . < Integer > error ( new TestException ( ) ) . ofType ( Number . class ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < String > to = Maybe . < Integer > error ( new TestException ( ) ) . ofType ( String . class ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposedMaybe ( new Function < Maybe < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Maybe < Object > m ) throws Exception return m . ofType ( Object . class ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . ofType ( Object . class ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Maybe < Object > f ) throws Exception return f . ofType ( Object . class ) ; ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > m ) throws Exception return m . onTerminateDetach ( ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . onTerminateDetach ( ) ) ; 
Maybe . error ( new TestException ( ) ) . onTerminateDetach ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . empty ( ) . onTerminateDetach ( ) . test ( ) . assertResult ( ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Object > to = new Maybe < Object > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Object > observer ) observer . onSubscribe ( wr . get ( ) ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; to . dispose ( ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertEmpty ( ) ; assertNull ( wr . get ( ) ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Integer > to = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( wr . get ( ) ) ; observer . onComplete ( ) ; observer . onComplete ( ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertResult ( ) ; assertNull ( wr . get ( ) ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Integer > to = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( wr . get ( ) ) ; observer . onError ( new TestException ( ) ) ; observer . onError ( new IOException ( ) ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertFailure ( TestException . class ) ; assertNull ( wr . get ( ) ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Integer > to = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( wr . get ( ) ) ; observer . onSuccess ( 1 ) ; observer . onSuccess ( 2 ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertResult ( 1 ) ; assertNull ( wr . get ( ) ) ; 
assertEquals ( ( Integer ) 1 , Maybe . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . toFuture ( ) . get ( ) ) ; 
assertNull ( Maybe . empty ( ) . subscribeOn ( Schedulers . computation ( ) ) . toFuture ( ) . get ( ) ) ; 
try Maybe . error ( new TestException ( ) ) . subscribeOn ( Schedulers . computation ( ) ) . toFuture ( ) . get ( ) ; fail ( "Should have thrown!" ) ; catch ( ExecutionException ex ) assertTrue ( "" + ex . getCause ( ) , ex . getCause ( ) instanceof TestException ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; Future < Integer > f = ms . toFuture ( ) ; assertTrue ( ms . hasObservers ( ) ) ; f . cancel ( true ) ; assertFalse ( ms . hasObservers ( ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; Future < Integer > f = ms . toFuture ( ) ; assertTrue ( ms . hasObservers ( ) ) ; f . cancel ( false ) ; assertFalse ( ms . hasObservers ( ) ) ; 
Maybe . just ( 1 ) . timestamp ( ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . empty ( ) . timestamp ( ) . test ( ) . assertResult ( ) ; 
Maybe . error ( new TestException ( ) ) . timestamp ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . timestamp ( TimeUnit . SECONDS ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . timestamp ( Schedulers . single ( ) ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Maybe . just ( 1 ) . timestamp ( TimeUnit . SECONDS , Schedulers . single ( ) ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( m -> m . timestamp ( ) ) ; 
TestHelper . checkDisposed ( MaybeSubject . create ( ) . timestamp ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Timed < Integer > > to = ms . timestamp ( scheduler ) . test ( ) ; scheduler . advanceTimeBy ( 1000 , TimeUnit . MILLISECONDS ) ; ms . onSuccess ( 1 ) ; to . assertResult ( new Timed < > ( 1 , 1000L , TimeUnit . MILLISECONDS ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Maybe . fromRunnable ( new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ; Maybe . fromRunnable ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Maybe . fromRunnable ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; final Maybe < Object > maybe = Maybe . fromRunnable ( new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; maybe . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Maybe . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final int [ ] counter = 0 ; Maybe < Void > m = Maybe . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter [ 0 ] ++ ; ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof Supplier ) ; assertNull ( ( ( Supplier < Void > ) m ) . get ( ) ) ; assertEquals ( 1 , counter [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Object > to = Maybe . fromRunnable ( new Runnable ( ) @ Override public void run ( ) cdl1 . countDown ( ) ; try cdl2 . await ( 5 , TimeUnit . SECONDS ) ; catch ( InterruptedException ex ) throw new RuntimeException ( ex ) ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , RuntimeException . class ) ; assertTrue ( errors . get ( 0 ) . toString ( ) , errors . get ( 0 ) . getCause ( ) . getCause ( ) instanceof InterruptedException ) ; finally RxJavaPlugins . reset ( ) ; 
Runnable run = mock ( Runnable . class ) ; Maybe . fromRunnable ( run ) . test ( true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; Maybe . fromRunnable ( new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
return new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer a , Integer b ) throws Exception return a + ":" + b ; ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; , stringCombine ( ) ) . test ( ) . assertResult ( "1:2" ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; , stringCombine ( ) ) . test ( ) . assertResult ( ) ; 
final int [ ] call = 0 ; Maybe . < Integer > empty ( ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception call [ 0 ] ++ ; return Maybe . just ( 1 ) ; , stringCombine ( ) ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , call [ 0 ] ) ; 
final int [ ] call = 0 ; Maybe . < Integer > error ( new TestException ( ) ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception call [ 0 ] ++ ; return Maybe . just ( 1 ) ; , stringCombine ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
final int [ ] call = 0 ; Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception call [ 0 ] ++ ; return Maybe . < Integer > error ( new TestException ( ) ) ; , stringCombine ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , call [ 0 ] ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleElement ( ) . flatMap ( new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . just ( 1 ) ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) throws Exception return b ; ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( new Function < Maybe < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Maybe < Object > v ) throws Exception return v . flatMap ( new Function < Object , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Object v ) throws Exception return Maybe . just ( 1 ) ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) throws Exception return b ; ) ; ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; , stringCombine ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return null ; , stringCombine ( ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 2 ) ; , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Maybe . just ( 1 ) . flatMap ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception to . dispose ( ) ; return Maybe . just ( 2 ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception throw new IllegalStateException ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; 
Maybe . concatArray ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Maybe . concatArrayDelayError ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = Maybe . concatArray ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 2 ) ; ts . assertResult ( 1 , 2 ) ; 
TestSubscriber < Integer > ts = Maybe . concatArrayDelayError ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 2 ) ; ts . assertResult ( 1 , 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = Maybe . concatArray ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = Maybe . concatArrayDelayError ( Maybe . just ( 1 ) , Maybe . just ( 2 ) ) . test ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final MaybeObserver < ? > [ ] o = null ; Maybe . concatArrayDelayError ( Maybe . just ( 1 ) , Maybe . error ( new IOException ( ) ) , new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 2 ) ; o [ 0 ] = observer ; ) . test ( ) . assertFailure ( IOException . class , 1 , 2 ) ; o [ 0 ] . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] calls = 0 ; Maybe < Integer > source = Maybe . create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onSuccess ( 1 ) ; ) ; Maybe . concatArray ( source , source ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Maybe < Integer > source = Maybe . create ( new MaybeOnSubscribe < Integer > ( ) @ Override public void subscribe ( MaybeEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onSuccess ( 1 ) ; ) ; Maybe . concatArrayDelayError ( source , source ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
TestHelper . assertBadRequestReported ( Maybe . concatArray ( MaybeSubject . create ( ) , MaybeSubject . create ( ) ) ) ; 
TestHelper . assertBadRequestReported ( Maybe . concatArrayDelayError ( MaybeSubject . create ( ) , MaybeSubject . create ( ) ) ) ; 
Maybe . concatArray ( Maybe . just ( 1 ) , Maybe . empty ( ) , Maybe . just ( 2 ) , Maybe . empty ( ) , Maybe . empty ( ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = Maybe . concatArray ( ms , ms ) . test ( ) ; ts . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; ts . assertResult ( 1 , 1 ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = Maybe . concatArray ( ms , ms ) . test ( ) ; ts . assertEmpty ( ) ; ms . onComplete ( ) ; ts . assertResult ( ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = Maybe . concatArrayDelayError ( ms , ms ) . test ( ) ; ts . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; ts . assertResult ( 1 , 1 ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = Maybe . concatArrayDelayError ( ms , ms ) . test ( ) ; ts . assertEmpty ( ) ; ms . onComplete ( ) ; ts . assertResult ( ) ; 
Maybe . just ( 1 ) . materialize ( ) . test ( ) . assertResult ( Notification . createOnNext ( 1 ) ) ; 
TestException ex = new TestException ( ) ; Maybe . error ( ex ) . materialize ( ) . test ( ) . assertResult ( Notification . createOnError ( ex ) ) ; 
Maybe . empty ( ) . materialize ( ) . test ( ) . assertResult ( Notification . createOnComplete ( ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToSingle ( new Function < Maybe < Object > , SingleSource < Notification < Object > > > ( ) @ Override public SingleSource < Notification < Object > > apply ( Maybe < Object > v ) throws Exception return v . materialize ( ) ; ) ; 
TestHelper . checkDisposed ( MaybeSubject . create ( ) . materialize ( ) ) ; 
events . add ( "OnComplete" ) ; 
events . add ( t ) ; 
return source . subscribe ( onNext , onError , onComplete , composite ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , Functions . ON_ERROR_MISSING , ( ) -> ) ; assertFalse ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onComplete ( ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; assertEquals ( 0 , composite . size ( ) ) ; 
subscribeAutoDispose ( processor , composite , this , Functions . ON_ERROR_MISSING , ( ) -> ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onComplete ( ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; assertEquals ( 0 , composite . size ( ) ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onError ( new IOException ( ) ) ; assertEquals ( events . toString ( ) , 1 , events . get ( 0 ) ) ; assertTrue ( events . toString ( ) , events . get ( 1 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onComplete ( ) ; assertEquals ( Arrays . < Object > asList ( 1 , "OnComplete" ) , events ) ; assertEquals ( 0 , composite . size ( ) ) ; 
subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onNext ( 1 ) ; assertTrue ( composite . size ( ) > 0 ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; processor . onError ( new IOException ( ) ) ; assertEquals ( events . toString ( ) , 1 , events . get ( 0 ) ) ; assertTrue ( events . toString ( ) , events . get ( 1 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , composite . size ( ) ) ; assertFalse ( processor . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , new Consumer < Object > ( ) @ Override public void accept ( Object t ) throws Exception throw new IOException ( ) ; , this , this ) ; processor . onNext ( 1 ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; assertTrue ( events . toString ( ) , events . get ( 0 ) instanceof IOException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , this , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throws Exception throw new IOException ( t ) ; , this ) ; processor . onError ( new IllegalArgumentException ( ) ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > inners = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( inners , 0 , IllegalArgumentException . class ) ; TestHelper . assertError ( inners , 1 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , t -> throw new IOException ( ) ; , Functions . ON_ERROR_MISSING , ( ) -> ) ; processor . onNext ( 1 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; assertTrue ( errors . get ( 0 ) . getCause ( ) instanceof IOException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , this , this , new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) ; processor . onNext ( 1 ) ; processor . onComplete ( ) ; assertEquals ( Arrays . asList ( 1 ) , events ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 2 ) ; observer . onComplete ( ) ; observer . onError ( new IOException ( ) ) ; , composite , this , this , this ) ; assertEquals ( Arrays . < Object > asList ( 1 , "OnComplete" ) , events ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( new InnerQueuedObserver < > ( null , 1 ) ) ; 
events . add ( "OnComplete" ) ; 
events . add ( t ) ; 
return source . subscribe ( onSuccess , onError , onComplete , composite ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , Functions . ON_ERROR_MISSING , ( ) -> ) ; assertFalse ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onSuccess ( 1 ) ; assertEquals ( 0 , composite . size ( ) ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; 
subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onSuccess ( 1 ) ; assertEquals ( 0 , composite . size ( ) ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onError ( new IOException ( ) ) ; assertTrue ( events . toString ( ) , events . get ( 0 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onComplete ( ) ; assertEquals ( 0 , composite . size ( ) ) ; assertEquals ( Arrays . < Object > asList ( "OnComplete" ) , events ) ; 
subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onError ( new IOException ( ) ) ; assertTrue ( events . toString ( ) , events . get ( 0 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , composite . size ( ) ) ; assertFalse ( processor . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , new Consumer < Object > ( ) @ Override public void accept ( Object t ) throws Exception throw new IOException ( ) ; , this , this ) ; processor . onSuccess ( 1 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , this , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throws Exception throw new IOException ( t ) ; , this ) ; processor . onError ( new IllegalArgumentException ( ) ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > inners = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( inners , 0 , IllegalArgumentException . class ) ; TestHelper . assertError ( inners , 1 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , this , this , new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) ; processor . onComplete ( ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 2 ) ; observer . onComplete ( ) ; observer . onError ( new IOException ( ) ) ; , composite , this , this , this ) ; assertEquals ( Arrays . < Object > asList ( "OnComplete" ) , events ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
fo = new FutureObserver < > ( ) ; 
fo . dispose ( ) ; assertFalse ( fo . isCancelled ( ) ) ; assertFalse ( fo . isDisposed ( ) ) ; assertFalse ( fo . isDone ( ) ) ; for ( int i = 0 ; i < 2 ; i ++ ) fo . cancel ( i == 0 ) ; assertTrue ( fo . isCancelled ( ) ) ; assertTrue ( fo . isDisposed ( ) ) ; assertTrue ( fo . isDone ( ) ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fo . onNext ( 1 ) ; fo . onError ( new TestException ( "First" ) ) ; fo . onError ( new TestException ( "Second" ) ) ; fo . onComplete ( ) ; assertTrue ( fo . isCancelled ( ) ) ; assertTrue ( fo . isDisposed ( ) ) ; assertTrue ( fo . isDone ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
assertFalse ( fo . isDone ( ) ) ; assertFalse ( fo . isCancelled ( ) ) ; fo . cancel ( false ) ; assertTrue ( fo . isDone ( ) ) ; assertTrue ( fo . isCancelled ( ) ) ; try fo . get ( ) ; fail ( "Should have thrown" ) ; catch ( CancellationException ex ) try fo . get ( 1 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown" ) ; catch ( CancellationException ex ) 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fo . onError ( new TestException ( "One" ) ) ; fo . onError ( new TestException ( "Two" ) ) ; try fo . get ( 5 , TimeUnit . MILLISECONDS ) ; catch ( ExecutionException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; assertEquals ( "One" , ex . getCause ( ) . getMessage ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Two" ) ; finally RxJavaPlugins . reset ( ) ; 
fo . onNext ( 1 ) ; fo . onComplete ( ) ; assertEquals ( 1 , fo . get ( 5 , TimeUnit . MILLISECONDS ) . intValue ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Disposable d1 = Disposable . empty ( ) ; fo . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; fo . onSubscribe ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FutureObserver < Integer > fo = new FutureObserver < > ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) fo . cancel ( false ) ; ; TestHelper . race ( r , r ) ; 
Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) fo . onNext ( 1 ) ; fo . onComplete ( ) ; , 100 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , fo . get ( 5 , TimeUnit . SECONDS ) . intValue ( ) ) ; 
RxJavaPlugins . setErrorHandler ( Functions . emptyConsumer ( ) ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FutureObserver < Integer > fo = new FutureObserver < > ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) fo . cancel ( false ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) fo . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; finally RxJavaPlugins . reset ( ) ; 
RxJavaPlugins . setErrorHandler ( Functions . emptyConsumer ( ) ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FutureObserver < Integer > fo = new FutureObserver < > ( ) ; if ( i % 3 == 0 ) fo . onSubscribe ( Disposable . empty ( ) ) ; if ( i % 2 == 0 ) fo . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) fo . cancel ( false ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) fo . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fo . onError ( new TestException ( "One" ) ) ; fo . onComplete ( ) ; try fo . get ( 5 , TimeUnit . MILLISECONDS ) ; catch ( ExecutionException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; assertEquals ( "One" , ex . getCause ( ) . getMessage ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , NoSuchElementException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fo . onComplete ( ) ; fo . onError ( new TestException ( "One" ) ) ; try assertNull ( fo . get ( 5 , TimeUnit . MILLISECONDS ) ) ; catch ( ExecutionException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof NoSuchElementException ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fo . onNext ( 1 ) ; fo . onComplete ( ) ; fo . onError ( new TestException ( "One" ) ) ; assertEquals ( ( Integer ) 1 , fo . get ( 5 , TimeUnit . MILLISECONDS ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fo . cancel ( true ) ; fo . onError ( new TestException ( "One" ) ) ; try fo . get ( 5 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown" ) ; catch ( CancellationException ex ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try fo . cancel ( true ) ; fo . onComplete ( ) ; try fo . get ( 5 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown" ) ; catch ( CancellationException ex ) TestHelper . assertUndeliverable ( errors , 0 , NoSuchElementException . class ) ; finally RxJavaPlugins . reset ( ) ; 
fo . onNext ( 1 ) ; fo . onComplete ( ) ; fo . onComplete ( ) ; assertEquals ( 1 , fo . get ( 5 , TimeUnit . MILLISECONDS ) . intValue ( ) ) ; 
Thread . currentThread ( ) . interrupt ( ) ; fo . get ( ) ; 
Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) fo . onNext ( 1 ) ; fo . onComplete ( ) ; , 500 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , fo . get ( ) . intValue ( ) ) ; 
try fo . get ( 1 , TimeUnit . NANOSECONDS ) ; fail ( "Should have thrown" ) ; catch ( TimeoutException expected ) assertEquals ( timeoutMessage ( 1 , TimeUnit . NANOSECONDS ) , expected . getMessage ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final FutureObserver < Integer > fo = new FutureObserver < > ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) fo . cancel ( false ) ; ; Disposable d = Disposable . empty ( ) ; TestHelper . race ( r , ( ) -> fo . onSubscribe ( d ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; BasicFuseableObserver < Integer , Integer > o = new BasicFuseableObserver < Integer , Integer > ( to ) @ Nullable @ Override public Integer poll ( ) throws Exception return null ; @ Override public int requestFusion ( int mode ) return 0 ; @ Override public void onNext ( Integer value ) @ Override protected boolean beforeDownstream ( ) return false ; ; o . onSubscribe ( Disposable . disposed ( ) ) ; to . assertNotSubscribed ( ) ; o . offer ( 1 ) ; 
BasicFuseableObserver < Integer , Integer > o = new BasicFuseableObserver < Integer , Integer > ( new TestObserver < > ( ) ) @ Nullable @ Override public Integer poll ( ) throws Exception return null ; @ Override public int requestFusion ( int mode ) return 0 ; @ Override public void onNext ( Integer value ) ; o . offer ( 1 , 2 ) ; 
final Future < ? > f = Single . never ( ) . toFuture ( ) ; assertFalse ( f . isCancelled ( ) ) ; assertFalse ( f . isDone ( ) ) ; f . cancel ( true ) ; assertTrue ( f . isCancelled ( ) ) ; assertTrue ( f . isDone ( ) ) ; try f . get ( ) ; fail ( "Should have thrown!" ) ; catch ( CancellationException ex ) catch ( InterruptedException ex ) throw new AssertionError ( ex ) ; catch ( ExecutionException ex ) throw new AssertionError ( ex ) ; try f . get ( 5 , TimeUnit . SECONDS ) ; fail ( "Should have thrown!" ) ; catch ( CancellationException ex ) catch ( InterruptedException ex ) throw new AssertionError ( ex ) ; catch ( ExecutionException ex ) throw new AssertionError ( ex ) ; catch ( TimeoutException ex ) throw new AssertionError ( ex ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Future < ? > f = Single . never ( ) . toFuture ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) f . cancel ( true ) ; ; TestHelper . race ( r , r ) ; 
Future < ? > f = Single . never ( ) . toFuture ( ) ; try f . get ( 100 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown" ) ; catch ( TimeoutException expected ) assertEquals ( timeoutMessage ( 100 , TimeUnit . MILLISECONDS ) , expected . getMessage ( ) ) ; 
Future < Integer > f = Single . just ( 1 ) . toFuture ( ) ; ( ( Disposable ) f ) . dispose ( ) ; assertTrue ( ( ( Disposable ) f ) . isDisposed ( ) ) ; 
Future < ? > f = Single . error ( new TestException ( ) ) . toFuture ( ) ; try f . get ( 5 , TimeUnit . SECONDS ) ; fail ( "Should have thrown" ) ; catch ( ExecutionException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; 
Future < Integer > f = Single . just ( 1 ) . toFuture ( ) ; assertEquals ( 1 , f . get ( 5 , TimeUnit . SECONDS ) . intValue ( ) ) ; 
Future < Integer > f = Single . just ( 1 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . toFuture ( ) ; assertEquals ( 1 , f . get ( 5 , TimeUnit . SECONDS ) . intValue ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Future < ? > f = ps . single ( - 99 ) . toFuture ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) f . cancel ( true ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
RxJavaPlugins . setErrorHandler ( Functions . emptyConsumer ( ) ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Future < ? > f = ps . single ( - 99 ) . toFuture ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) f . cancel ( true ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; finally RxJavaPlugins . reset ( ) ; 
events . add ( "OnComplete" ) ; 
events . add ( t ) ; 
processor . subscribe ( this , this , composite ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onComplete ( ) ; assertEquals ( 0 , composite . size ( ) ) ; assertEquals ( Arrays . < Object > asList ( "OnComplete" ) , events ) ; 
Disposable d = processor . subscribe ( this , this , composite ) ; assertTrue ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onError ( new IOException ( ) ) ; assertTrue ( events . toString ( ) , events . get ( 0 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
processor . subscribe ( this , this , composite ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onComplete ( ) ; assertEquals ( 0 , composite . size ( ) ) ; assertEquals ( Arrays . < Object > asList ( "OnComplete" ) , events ) ; 
processor . subscribe ( this , this , composite ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onError ( new IOException ( ) ) ; assertTrue ( events . toString ( ) , events . get ( 0 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
Disposable d = processor . subscribe ( this , this , composite ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 0 , composite . size ( ) ) ; assertFalse ( processor . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try processor . subscribe ( this , t -> throw new IOException ( t ) ; , composite ) ; processor . onError ( new IllegalArgumentException ( ) ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > inners = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( inners , 0 , IllegalArgumentException . class ) ; TestHelper . assertError ( inners , 1 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try processor . subscribe ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; , this , composite ) ; processor . onComplete ( ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onError ( new IOException ( ) ) ; . subscribe ( this , this , composite ) ; assertEquals ( Arrays . < Object > asList ( "OnComplete" ) , events ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
BlockingMultiObserver < Integer > bmo = new BlockingMultiObserver < > ( ) ; bmo . dispose ( ) ; Disposable d = Disposable . empty ( ) ; bmo . onSubscribe ( d ) ; 
final BlockingMultiObserver < Integer > bmo = new BlockingMultiObserver < > ( ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) bmo . onSuccess ( 1 ) ; , 100 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , bmo . blockingGet ( 0 ) . intValue ( ) ) ; 
final BlockingMultiObserver < Integer > bmo = new BlockingMultiObserver < > ( ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) bmo . onSuccess ( 1 ) ; , 100 , TimeUnit . MILLISECONDS ) ; assertTrue ( bmo . blockingAwait ( 1 , TimeUnit . MINUTES ) ) ; 
final BlockingMultiObserver < Integer > bmo = new BlockingMultiObserver < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try bmo . blockingGet ( 0 ) ; fail ( "Should have thrown" ) ; catch ( RuntimeException ex ) assertTrue ( ex . getCause ( ) instanceof InterruptedException ) ; finally Thread . interrupted ( ) ; 
ConsumerSingleObserver < Integer > o = new ConsumerSingleObserver < > ( Functions . < Integer > emptyConsumer ( ) , Functions . ON_ERROR_MISSING ) ; assertFalse ( o . hasCustomOnError ( ) ) ; 
ConsumerSingleObserver < Integer > o = new ConsumerSingleObserver < > ( Functions . < Integer > emptyConsumer ( ) , Functions . < Throwable > emptyConsumer ( ) ) ; assertTrue ( o . hasCustomOnError ( ) ) ; 
return new QueueDrainObserver < Integer , Integer , Integer > ( to , new SpscArrayQueue < > ( 4 ) ) @ Override public void onNext ( Integer t ) fastPathEmit ( t , false , d ) ; @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void accept ( Observer < ? super Integer > a , Integer v ) super . accept ( a , v ) ; a . onNext ( v ) ; ; 
return new QueueDrainObserver < Integer , Integer , Integer > ( to , new SpscArrayQueue < > ( 4 ) ) @ Override public void onNext ( Integer t ) fastPathOrderedEmit ( t , false , d ) ; @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void accept ( Observer < ? super Integer > a , Integer v ) super . accept ( a , v ) ; a . onNext ( v ) ; ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Disposable d = Disposable . empty ( ) ; QueueDrainObserver < Integer , Integer , Integer > qd = createUnordered ( to , d ) ; to . onSubscribe ( Disposable . empty ( ) ) ; qd . enter ( ) ; qd . onNext ( 1 ) ; to . assertEmpty ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Disposable d = Disposable . empty ( ) ; QueueDrainObserver < Integer , Integer , Integer > qd = createOrdered ( to , d ) ; to . onSubscribe ( Disposable . empty ( ) ) ; qd . enter ( ) ; qd . onNext ( 1 ) ; to . assertEmpty ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Disposable d = Disposable . empty ( ) ; QueueDrainObserver < Integer , Integer , Integer > qd = createOrdered ( to , d ) ; to . onSubscribe ( Disposable . empty ( ) ) ; qd . queue . offer ( 0 ) ; qd . onNext ( 1 ) ; to . assertValuesOnly ( 0 , 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; Disposable d = Disposable . empty ( ) ; final QueueDrainObserver < Integer , Integer , Integer > qd = createUnordered ( to , d ) ; to . onSubscribe ( Disposable . empty ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) qd . onNext ( 1 ) ; ; TestHelper . race ( r1 , r1 ) ; to . assertValuesOnly ( 1 , 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; Disposable d = Disposable . empty ( ) ; final QueueDrainObserver < Integer , Integer , Integer > qd = createOrdered ( to , d ) ; to . onSubscribe ( Disposable . empty ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) qd . onNext ( 1 ) ; ; TestHelper . race ( r1 , r1 ) ; to . assertValuesOnly ( 1 , 1 ) ; 
events . add ( t ) ; 
return source . subscribe ( onSuccess , onError , composite ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , Functions . ON_ERROR_MISSING ) ; assertFalse ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onSuccess ( 1 ) ; assertEquals ( 0 , composite . size ( ) ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; 
subscribeAutoDispose ( processor , composite , this , this ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onSuccess ( 1 ) ; assertEquals ( 0 , composite . size ( ) ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; 
Disposable d = subscribeAutoDispose ( processor , composite , this , this ) ; assertTrue ( d . getClass ( ) . toString ( ) , ( ( LambdaConsumerIntrospection ) d ) . hasCustomOnError ( ) ) ; assertTrue ( composite . size ( ) > 0 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; processor . onError ( new IOException ( ) ) ; assertTrue ( events . toString ( ) , events . get ( 0 ) instanceof IOException ) ; assertEquals ( 0 , composite . size ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , new Consumer < Object > ( ) @ Override public void accept ( Object t ) throws Exception throw new IOException ( ) ; , this ) ; processor . onSuccess ( 1 ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( processor , composite , this , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throws Exception throw new IOException ( t ) ; ) ; processor . onError ( new IllegalArgumentException ( ) ) ; assertTrue ( events . toString ( ) , events . isEmpty ( ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > inners = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( inners , 0 , IllegalArgumentException . class ) ; TestHelper . assertError ( inners , 1 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try subscribeAutoDispose ( new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 2 ) ; observer . onError ( new IOException ( ) ) ; , composite , this , this ) ; assertEquals ( Arrays . < Object > asList ( 1 ) , events ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
CallbackCompletableObserver o = new CallbackCompletableObserver ( Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; assertFalse ( o . hasCustomOnError ( ) ) ; 
CallbackCompletableObserver o = new CallbackCompletableObserver ( Functions . < Throwable > emptyConsumer ( ) , Functions . EMPTY_ACTION ) ; assertTrue ( o . hasCustomOnError ( ) ) ; 
upstream . dispose ( ) ; complete ( value ) ; complete ( value ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Integer > to = new TestObserver < > ( ) ; TakeFirst source = new TakeFirst ( to ) ; source . onSubscribe ( Disposable . empty ( ) ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; source . onNext ( 1 ) ; to . assertResult ( 1 ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; TakeFirst source = new TakeFirst ( to ) ; source . onSubscribe ( Disposable . empty ( ) ) ; source . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; TakeFirst source = new TakeFirst ( to ) ; source . onSubscribe ( Disposable . empty ( ) ) ; source . onComplete ( ) ; to . assertResult ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; TakeFirst source = new TakeFirst ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; assertFalse ( d . isDisposed ( ) ) ; to . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertTrue ( source . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; TakeFirst source = new TakeFirst ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; to . assertFuseable ( ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) ; source . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; source . onComplete ( ) ; assertTrue ( d . isDisposed ( ) ) ; to . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; TakeFirst source = new TakeFirst ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; to . assertFuseable ( ) ; to . assertFusionMode ( QueueFuseable . NONE ) ; source . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; source . onComplete ( ) ; assertTrue ( d . isDisposed ( ) ) ; to . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
this . value = value ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . NONE ) ; TakeLast source = new TakeLast ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; source . onComplete ( ) ; source . onError ( new TestException ( ) ) ; to . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . NONE ) ; TakeLast source = new TakeLast ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; source . onError ( new TestException ( "second" ) ) ; source . onComplete ( ) ; to . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; TakeLast source = new TakeLast ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; source . onComplete ( ) ; source . onError ( new TestException ( ) ) ; to . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; TakeLast source = new TakeLast ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; source . onError ( new TestException ( "second" ) ) ; source . onComplete ( ) ; to . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . NONE ) ; TakeLast source = new TakeLast ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; to . dispose ( ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; TakeLast source = new TakeLast ( new Observer < Integer > ( ) Disposable upstream ; @ Override public void onSubscribe ( Disposable d ) this . upstream = d ; to . onSubscribe ( d ) ; @ Override public void onNext ( Integer value ) to . onNext ( value ) ; upstream . dispose ( ) ; @ Override public void onError ( Throwable e ) to . onError ( e ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; ) ; source . onSubscribe ( Disposable . empty ( ) ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; TakeLast source = new TakeLast ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; source . onComplete ( ) ; to . assertResult ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . NONE ) ; TakeLast source = new TakeLast ( to ) ; Disposable d = Disposable . empty ( ) ; source . onSubscribe ( d ) ; source . onComplete ( ) ; to . assertResult ( ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; TakeLast source = new TakeLast ( new Observer < Integer > ( ) QueueDisposable < Integer > d ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSubscribe ( Disposable d ) this . d = ( QueueDisposable < Integer > ) d ; to . onSubscribe ( d ) ; this . d . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer value ) if ( ! d . isEmpty ( ) ) Integer v = null ; try to . onNext ( d . poll ( ) ) ; v = d . poll ( ) ; catch ( Throwable ex ) to . onError ( ex ) ; assertNull ( v ) ; assertTrue ( d . isEmpty ( ) ) ; @ Override public void onError ( Throwable e ) to . onError ( e ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; ) ; source . onSubscribe ( Disposable . empty ( ) ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertResult ( 1 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; TakeLast source = new TakeLast ( new Observer < Integer > ( ) QueueDisposable < Integer > d ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSubscribe ( Disposable d ) this . d = ( QueueDisposable < Integer > ) d ; to . onSubscribe ( d ) ; this . d . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer value ) d . clear ( ) ; assertTrue ( d . isEmpty ( ) ) ; @ Override public void onError ( Throwable e ) to . onError ( e ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; ) ; source . onSubscribe ( Disposable . empty ( ) ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . NONE ) ; TakeLast source = new TakeLast ( to ) ; TestHelper . assertNoOffer ( source ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; TakeFirst source = new TakeFirst ( new Observer < Integer > ( ) QueueDisposable < Integer > d ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSubscribe ( Disposable d ) this . d = ( QueueDisposable < Integer > ) d ; to . onSubscribe ( d ) ; this . d . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) to . onError ( e ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; ) ; source . onSubscribe ( Disposable . empty ( ) ) ; source . onNext ( 1 ) ; to . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
Queue < Object > q = new ArrayDeque < > ( ) ; BlockingObserver < Object > bo = new BlockingObserver < > ( q ) ; bo . dispose ( ) ; assertEquals ( BlockingObserver . TERMINATED , q . poll ( ) ) ; bo . dispose ( ) ; assertNull ( q . poll ( ) ) ; 
TestHelper . doubleOnSubscribe ( new DisposableLambdaObserver < > ( new TestObserver < > ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try DisposableLambdaObserver < Integer > o = new DisposableLambdaObserver < > ( new TestObserver < > ( ) , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) ; o . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( o . isDisposed ( ) ) ; o . dispose ( ) ; assertTrue ( o . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
BlockingFirstObserver < Integer > bf = new BlockingFirstObserver < > ( ) ; Disposable d = Disposable . empty ( ) ; bf . onSubscribe ( d ) ; bf . onNext ( 1 ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , bf . value . intValue ( ) ) ; assertEquals ( 0 , bf . getCount ( ) ) ; bf . onNext ( 2 ) ; assertEquals ( 1 , bf . value . intValue ( ) ) ; assertEquals ( 0 , bf . getCount ( ) ) ; bf . onError ( new TestException ( ) ) ; assertEquals ( 1 , bf . value . intValue ( ) ) ; assertNull ( bf . error ) ; assertEquals ( 0 , bf . getCount ( ) ) ; 
EmptyCompletableObserver o = new EmptyCompletableObserver ( ) ; assertFalse ( o . hasCustomOnError ( ) ) ; 
FutureMultiObserver < Integer > f = new FutureMultiObserver < > ( ) ; assertTrue ( f . cancel ( true ) ) ; Disposable d = Disposable . empty ( ) ; f . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; 
FutureMultiObserver < Integer > f = new FutureMultiObserver < > ( ) ; Disposable d = Disposable . empty ( ) ; f . onSubscribe ( d ) ; assertTrue ( f . cancel ( true ) ) ; f . onComplete ( ) ; 
q . offer ( 1 ) ; 
q . offer ( 1 , 2 ) ; 
final List < Object > received = new ArrayList < > ( ) ; LambdaObserver < Object > o = new LambdaObserver < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( ) ; ) ; assertFalse ( o . isDisposed ( ) ) ; Observable . just ( 1 ) . subscribe ( o ) ; assertTrue ( received . toString ( ) , received . get ( 0 ) instanceof TestException ) ; assertEquals ( received . toString ( ) , 1 , received . size ( ) ) ; assertTrue ( o . isDisposed ( ) ) ; 
final List < Object > received = new ArrayList < > ( ) ; LambdaObserver < Object > o = new LambdaObserver < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception throw new TestException ( ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception ) ; assertFalse ( o . isDisposed ( ) ) ; Observable . just ( 1 ) . subscribe ( o ) ; assertTrue ( received . toString ( ) , received . get ( 0 ) instanceof TestException ) ; assertEquals ( received . toString ( ) , 1 , received . size ( ) ) ; assertTrue ( o . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final List < Object > received = new ArrayList < > ( ) ; LambdaObserver < Object > o = new LambdaObserver < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception ) ; assertFalse ( o . isDisposed ( ) ) ; Observable . < Integer > error ( new TestException ( "Outer" ) ) . subscribe ( o ) ; assertTrue ( received . toString ( ) , received . isEmpty ( ) ) ; assertTrue ( o . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "Inner" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final List < Object > received = new ArrayList < > ( ) ; LambdaObserver < Object > o = new LambdaObserver < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; , new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception ) ; assertFalse ( o . isDisposed ( ) ) ; Observable . < Integer > empty ( ) . subscribe ( o ) ; assertTrue ( received . toString ( ) , received . isEmpty ( ) ) ; assertTrue ( o . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable < Integer > source = new Observable < Integer > ( ) @ Override public void subscribeActual ( Observer < ? super Integer > observer ) Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; ; final List < Object > received = new ArrayList < > ( ) ; LambdaObserver < Object > o = new LambdaObserver < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception ) ; source . subscribe ( o ) ; assertEquals ( Arrays . asList ( 1 , 100 ) , received ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable < Integer > source = new Observable < Integer > ( ) @ Override public void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; ; final List < Object > received = new ArrayList < > ( ) ; LambdaObserver < Object > o = new LambdaObserver < > ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception received . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception received . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception received . add ( 100 ) ; , new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception ) ; source . subscribe ( o ) ; assertEquals ( Arrays . asList ( 1 , 100 ) , received ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final List < Throwable > errors = new ArrayList < > ( ) ; ps . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception errors . add ( e ) ; ) ; assertTrue ( "No observers?!" , ps . hasObservers ( ) ) ; assertTrue ( "Has errors already?!" , errors . isEmpty ( ) ) ; ps . onNext ( 1 ) ; assertFalse ( "Has observers?!" , ps . hasObservers ( ) ) ; assertFalse ( "No errors?!" , errors . isEmpty ( ) ) ; assertTrue ( errors . toString ( ) , errors . get ( 0 ) instanceof TestException ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final List < Throwable > errors = new ArrayList < > ( ) ; ps . subscribe ( new LambdaObserver < > ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception errors . add ( e ) ; , new Action ( ) @ Override public void run ( ) throws Exception , new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( ) ; ) ) ; assertFalse ( "Has observers?!" , ps . hasObservers ( ) ) ; assertFalse ( "No errors?!" , errors . isEmpty ( ) ) ; assertTrue ( errors . toString ( ) , errors . get ( 0 ) instanceof TestException ) ; 
LambdaObserver < Integer > o = new LambdaObserver < > ( Functions . < Integer > emptyConsumer ( ) , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION , Functions . < Disposable > emptyConsumer ( ) ) ; assertFalse ( o . hasCustomOnError ( ) ) ; 
LambdaObserver < Integer > o = new LambdaObserver < > ( Functions . < Integer > emptyConsumer ( ) , Functions . < Throwable > emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . < Disposable > emptyConsumer ( ) ) ; assertTrue ( o . hasCustomOnError ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final List < Throwable > observerErrors = Collections . synchronizedList ( new ArrayList < > ( ) ) ; LambdaObserver < Integer > o = new LambdaObserver < > ( Functions . < Integer > emptyConsumer ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) observerErrors . add ( t ) ; , Functions . EMPTY_ACTION , Functions . < Disposable > emptyConsumer ( ) ) ; o . dispose ( ) ; o . onError ( new IOException ( ) ) ; o . onError ( new IOException ( ) ) ; assertTrue ( observerErrors . isEmpty ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; DeferredScalarDisposable < Integer > d = new DeferredScalarDisposable < > ( to ) ; to . onSubscribe ( d ) ; assertTrue ( d . tryDispose ( ) ) ; assertFalse ( d . tryDispose ( ) ) ; 
if ( -- crashOnIterator <= 0 ) throw new TestException ( "iterator()" ) ; return new CrashingIterator ( crashOnHasNext , crashOnNext ) ; 
if ( -- crashOnHasNext <= 0 ) throw new TestException ( "hasNext()" ) ; return true ; 
if ( -- crashOnNext <= 0 ) throw new TestException ( "next()" ) ; return count ++ ; 
throw new UnsupportedOperationException ( ) ; 
List < Integer > list = new VolatileSizeArrayList < > ( ) ; assertTrue ( list . isEmpty ( ) ) ; assertEquals ( 0 , list . size ( ) ) ; assertFalse ( list . contains ( 1 ) ) ; assertFalse ( list . remove ( ( Integer ) 1 ) ) ; list = new VolatileSizeArrayList < > ( 16 ) ; assertTrue ( list . add ( 1 ) ) ; assertTrue ( list . addAll ( Arrays . asList ( 3 , 4 , 7 ) ) ) ; list . add ( 1 , 2 ) ; assertTrue ( list . addAll ( 4 , Arrays . asList ( 5 , 6 ) ) ) ; assertTrue ( list . contains ( 2 ) ) ; assertFalse ( list . remove ( ( Integer ) 10 ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) , list ) ; assertFalse ( list . isEmpty ( ) ) ; assertEquals ( 7 , list . size ( ) ) ; Iterator < Integer > it = list . iterator ( ) ; for ( int i = 1 ; i < 8 ; i ++ ) assertEquals ( i , it . next ( ) . intValue ( ) ) ; assertArrayEquals ( new Object [ ] 1 , 2 , 3 , 4 , 5 , 6 , 7 , list . toArray ( ) ) ; assertArrayEquals ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , 6 , 7 , list . toArray ( new Integer [ 7 ] ) ) ; assertTrue ( list . containsAll ( Arrays . asList ( 2 , 4 , 6 ) ) ) ; assertFalse ( list . containsAll ( Arrays . asList ( 2 , 4 , 6 , 10 ) ) ) ; assertFalse ( list . removeAll ( Arrays . asList ( 10 , 11 , 12 ) ) ) ; assertFalse ( list . retainAll ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ) ) ; assertEquals ( 7 , list . size ( ) ) ; for ( int i = 1 ; i < 8 ; i ++ ) assertEquals ( i , list . get ( i - 1 ) . intValue ( ) ) ; for ( int i = 1 ; i < 8 ; i ++ ) assertEquals ( i , list . set ( i - 1 , i ) . intValue ( ) ) ; assertEquals ( 2 , list . indexOf ( 3 ) ) ; assertEquals ( 5 , list . lastIndexOf ( 6 ) ) ; ListIterator < Integer > lit = list . listIterator ( 7 ) ; for ( int i = 7 ; i > 0 ; i -- ) assertEquals ( i , lit . previous ( ) . intValue ( ) ) ; assertEquals ( Arrays . asList ( 3 , 4 , 5 ) , list . subList ( 2 , 5 ) ) ; VolatileSizeArrayList < Integer > list2 = new VolatileSizeArrayList < > ( ) ; list2 . addAll ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ) ; assertNotEquals ( list2 , list ) ; assertNotEquals ( list , list2 ) ; list2 . add ( 7 ) ; assertEquals ( list2 , list ) ; assertEquals ( list , list2 ) ; List < Integer > list3 = new ArrayList < > ( ) ; list3 . addAll ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ) ; assertNotEquals ( list3 , list ) ; assertNotEquals ( list , list3 ) ; list3 . add ( 7 ) ; assertEquals ( list3 , list ) ; assertEquals ( list , list3 ) ; assertEquals ( list . hashCode ( ) , list3 . hashCode ( ) ) ; assertEquals ( list . toString ( ) , list3 . toString ( ) ) ; list . remove ( 0 ) ; assertEquals ( 6 , list . size ( ) ) ; list . clear ( ) ; assertEquals ( 0 , list . size ( ) ) ; assertTrue ( list . isEmpty ( ) ) ; 
errors = TestHelper . trackPluginErrors ( ) ; 
RxJavaPlugins . reset ( ) ; 
TestHelper . checkUtilityClass ( EndConsumerHelper . class ) ; 
Subscriber < Integer > consumer = new DefaultSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; BooleanSubscription sub1 = new BooleanSubscription ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isCancelled ( ) ) ; BooleanSubscription sub2 = new BooleanSubscription ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isCancelled ( ) ) ; assertTrue ( sub2 . isCancelled ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
$EMPTY$
$EMPTY$
$EMPTY$
Subscriber < Integer > consumer = new EndDefaultSubscriber ( ) ; BooleanSubscription sub1 = new BooleanSubscription ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isCancelled ( ) ) ; BooleanSubscription sub2 = new BooleanSubscription ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isCancelled ( ) ) ; assertTrue ( sub2 . isCancelled ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( "io.reactivex.rxjava3.internal.util.EndConsumerHelperTest$EndDefaultSubscriber" ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
Subscriber < Integer > consumer = new DisposableSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; BooleanSubscription sub1 = new BooleanSubscription ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isCancelled ( ) ) ; BooleanSubscription sub2 = new BooleanSubscription ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isCancelled ( ) ) ; assertTrue ( sub2 . isCancelled ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
Subscriber < Integer > consumer = new ResourceSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; BooleanSubscription sub1 = new BooleanSubscription ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isCancelled ( ) ) ; BooleanSubscription sub2 = new BooleanSubscription ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isCancelled ( ) ) ; assertTrue ( sub2 . isCancelled ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
Observer < Integer > consumer = new DefaultObserver < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
Observer < Integer > consumer = new DisposableObserver < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
Observer < Integer > consumer = new ResourceObserver < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
SingleObserver < Integer > consumer = new DisposableSingleObserver < Integer > ( ) @ Override public void onSuccess ( Integer t ) @ Override public void onError ( Throwable t ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
SingleObserver < Integer > consumer = new ResourceSingleObserver < Integer > ( ) @ Override public void onSuccess ( Integer t ) @ Override public void onError ( Throwable t ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
MaybeObserver < Integer > consumer = new DisposableMaybeObserver < Integer > ( ) @ Override public void onSuccess ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
MaybeObserver < Integer > consumer = new ResourceMaybeObserver < Integer > ( ) @ Override public void onSuccess ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
CompletableObserver consumer = new DisposableCompletableObserver ( ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
CompletableObserver consumer = new ResourceCompletableObserver ( ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ; Disposable sub1 = Disposable . empty ( ) ; consumer . onSubscribe ( sub1 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; Disposable sub2 = Disposable . empty ( ) ; consumer . onSubscribe ( sub2 ) ; assertFalse ( sub1 . isDisposed ( ) ) ; assertTrue ( sub2 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; assertEquals ( EndConsumerHelper . composeMessage ( consumer . getClass ( ) . getName ( ) ) , errors . get ( 0 ) . getMessage ( ) ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; 
Disposable d1 = Disposable . empty ( ) ; assertFalse ( EndConsumerHelper . validate ( DisposableHelper . DISPOSED , d1 , getClass ( ) ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; 
BooleanSubscription bs1 = new BooleanSubscription ( ) ; assertFalse ( EndConsumerHelper . validate ( SubscriptionHelper . CANCELLED , bs1 , getClass ( ) ) ) ; assertTrue ( bs1 . isCancelled ( ) ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; 
List < String > result = new ArrayList < > ( ) ; try BufferedReader in = new BufferedReader ( new FileReader ( f ) ) ; try String line ; while ( ( line = in . readLine ( ) ) != null ) result . add ( line ) ; finally in . close ( ) ; catch ( IOException ex ) ex . printStackTrace ( ) ; return result ; 
File [ ] observables = new File ( basepath + "observable/" ) . listFiles ( ) ; int count = 0 ; for ( File f : observables ) if ( ! f . getName ( ) . endsWith ( ".java" ) ) continue ; Class < ? > clazz = Class . forName ( basepackage + "observable." + f . getName ( ) . replace ( ".java" , "" ) ) ; String cn = f . getName ( ) . replace ( ".java" , "" ) . replace ( "Observable" , "Flowable" ) ; File f2 = new File ( basepath + "/flowable/" + cn + ".java" ) ; if ( ! f2 . exists ( ) ) continue ; Class < ? > clazz2 = Class . forName ( basepackage + "flowable." + cn ) ; Set < String > methods2 = new HashSet < > ( ) ; for ( Method m : clazz2 . getMethods ( ) ) methods2 . add ( m . getName ( ) ) ; for ( Method m : clazz . getMethods ( ) ) if ( ! methods2 . contains ( m . getName ( ) ) && ! methods2 . contains ( m . getName ( ) . replace ( "Observable" , "Flowable" ) ) ) count ++ ; System . out . println ( ) ; System . out . print ( "java.lang.RuntimeException: missing > " ) ; System . out . println ( m . getName ( ) ) ; System . out . print ( " at " ) ; System . out . print ( clazz . getName ( ) ) ; System . out . print ( " (" ) ; System . out . print ( clazz . getSimpleName ( ) ) ; System . out . print ( ".java:" ) ; List < String > lines = readAllLines ( f ) ; int j = 1 ; for ( int i = 1 ; i <= lines . size ( ) ; i ++ ) if ( lines . get ( i - 1 ) . contains ( "public void " + m . getName ( ) + "(" ) ) j = i ; System . out . print ( j ) ; System . out . println ( ")" ) ; System . out . print ( " at " ) ; System . out . print ( clazz2 . getName ( ) ) ; System . out . print ( " (" ) ; System . out . print ( clazz2 . getSimpleName ( ) ) ; lines = readAllLines ( f2 ) ; System . out . print ( ".java:" ) ; System . out . print ( lines . size ( ) - 1 ) ; System . out . println ( ")" ) ; System . out . println ( ) ; System . out . println ( count ) ; 
return 1 ; 
return this == o ; 
Value v1 = new Value ( ) ; Value v2 = new Value ( ) ; OpenHashSet < Value > set = new OpenHashSet < > ( ) ; assertTrue ( set . add ( v1 ) ) ; assertFalse ( set . add ( v1 ) ) ; assertFalse ( set . remove ( v2 ) ) ; assertTrue ( set . add ( v2 ) ) ; assertFalse ( set . add ( v2 ) ) ; assertTrue ( set . remove ( v2 ) ) ; assertFalse ( set . remove ( v2 ) ) ; 
final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final Observer [ ] a = null ; final TestObserver to = new TestObserver ( ) ; Observer observer = new Observer ( ) @ Override public void onSubscribe ( Disposable d ) to . onSubscribe ( d ) ; @ Override public void onNext ( Object t ) if ( t . equals ( 1 ) ) HalfSerializer . onNext ( a [ 0 ] , 2 , wip , error ) ; to . onNext ( t ) ; @ Override public void onError ( Throwable t ) to . onError ( t ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; ; a [ 0 ] = observer ; observer . onSubscribe ( Disposable . empty ( ) ) ; HalfSerializer . onNext ( observer , 1 , wip , error ) ; to . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final Observer [ ] a = null ; final TestObserver to = new TestObserver ( ) ; Observer observer = new Observer ( ) @ Override public void onSubscribe ( Disposable d ) to . onSubscribe ( d ) ; @ Override public void onNext ( Object t ) if ( t . equals ( 1 ) ) HalfSerializer . onError ( a [ 0 ] , new TestException ( ) , wip , error ) ; to . onNext ( t ) ; @ Override public void onError ( Throwable t ) to . onError ( t ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; ; a [ 0 ] = observer ; observer . onSubscribe ( Disposable . empty ( ) ) ; HalfSerializer . onNext ( observer , 1 , wip , error ) ; to . assertFailure ( TestException . class , 1 ) ; 
final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final Observer [ ] a = null ; final TestObserver to = new TestObserver ( ) ; Observer observer = new Observer ( ) @ Override public void onSubscribe ( Disposable d ) to . onSubscribe ( d ) ; @ Override public void onNext ( Object t ) if ( t . equals ( 1 ) ) HalfSerializer . onComplete ( a [ 0 ] , wip , error ) ; to . onNext ( t ) ; @ Override public void onError ( Throwable t ) to . onError ( t ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; ; a [ 0 ] = observer ; observer . onSubscribe ( Disposable . empty ( ) ) ; HalfSerializer . onNext ( observer , 1 , wip , error ) ; to . assertResult ( 1 ) ; 
final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final Observer [ ] a = null ; final TestObserver to = new TestObserver ( ) ; Observer observer = new Observer ( ) @ Override public void onSubscribe ( Disposable d ) to . onSubscribe ( d ) ; @ Override public void onNext ( Object t ) to . onNext ( t ) ; @ Override public void onError ( Throwable t ) to . onError ( t ) ; HalfSerializer . onError ( a [ 0 ] , new IOException ( ) , wip , error ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; ; a [ 0 ] = observer ; observer . onSubscribe ( Disposable . empty ( ) ) ; HalfSerializer . onError ( observer , new TestException ( ) , wip , error ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final TestObserver < Integer > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) HalfSerializer . onNext ( to , 1 , wip , error ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) HalfSerializer . onComplete ( to , wip , error ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertComplete ( ) . assertNoErrors ( ) ; assertTrue ( to . values ( ) . size ( ) <= 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) HalfSerializer . onError ( to , ex , wip , error ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) HalfSerializer . onComplete ( to , wip , error ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to . completions ( ) != 0 ) to . assertResult ( ) ; else to . assertFailure ( TestException . class ) ; 
return new Consumer < T > ( ) @ Override public void accept ( T t ) list . add ( t ) ; ; 
return new Supplier < List < T > > ( ) @ Override public List < T > get ( ) return new ArrayList < > ( ) ; ; 
return new BiConsumer < Object , Object > ( ) @ Override public void accept ( Object t1 , Object t2 ) throw e ; ; 
TestHelper . checkUtilityClass ( Pow2 . class ) ; 
for ( int i = 1 ; i > 0 ; i *= 2 ) assertTrue ( Pow2 . isPowerOfTwo ( i ) ) ; assertFalse ( Pow2 . isPowerOfTwo ( 3 ) ) ; assertFalse ( Pow2 . isPowerOfTwo ( 5 ) ) ; assertFalse ( Pow2 . isPowerOfTwo ( 6 ) ) ; assertFalse ( Pow2 . isPowerOfTwo ( 7 ) ) ; 
TestHelper . checkEnum ( HashMapSupplier . class ) ; 
TestHelper . checkEnum ( ArrayListSupplier . class ) ; 
TestHelper . checkEnum ( ErrorMode . class ) ; 
LinkedArrayList list = new LinkedArrayList ( 2 ) ; assertEquals ( 0 , list . size ( ) ) ; list . add ( 1 ) ; assertEquals ( 1 , list . size ( ) ) ; list . add ( 2 ) ; assertEquals ( 2 , list . size ( ) ) ; list . add ( 3 ) ; assertEquals ( 3 , list . size ( ) ) ; assertEquals ( "[1, 2, 3]" , list . toString ( ) ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 2 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( new NonThrowingPredicate < Integer > ( ) @ Override public boolean test ( Integer t2 ) out . add ( t2 ) ; return t2 == 2 ; ) ; assertEquals ( Arrays . asList ( 1 , 2 ) , out ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 2 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( 2 , new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer t1 , Integer t2 ) throws Throwable out . add ( t2 ) ; return t1 . equals ( t2 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 ) , out ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 12 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( new NonThrowingPredicate < Integer > ( ) @ Override public boolean test ( Integer t2 ) out . add ( t2 ) ; return t2 == 2 ; ) ; assertEquals ( Arrays . asList ( 1 , 2 ) , out ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 3 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( new NonThrowingPredicate < Integer > ( ) @ Override public boolean test ( Integer t2 ) out . add ( t2 ) ; return t2 == 2 ; ) ; assertEquals ( Arrays . asList ( 1 , 2 ) , out ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 2 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( new NonThrowingPredicate < Integer > ( ) @ Override public boolean test ( Integer t2 ) out . add ( t2 ) ; return t2 == 3 ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , out ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 4 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( new NonThrowingPredicate < Integer > ( ) @ Override public boolean test ( Integer t2 ) out . add ( t2 ) ; return false ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , out ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 12 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( 2 , new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer t1 , Integer t2 ) throws Throwable out . add ( t2 ) ; return t1 . equals ( t2 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 ) , out ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 3 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( 2 , new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer t1 , Integer t2 ) throws Exception out . add ( t2 ) ; return t1 . equals ( t2 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 ) , out ) ; 
AppendOnlyLinkedArrayList < Integer > list = new AppendOnlyLinkedArrayList < > ( 2 ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; final List < Integer > out = new ArrayList < > ( ) ; list . forEachWhile ( 3 , new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer t1 , Integer t2 ) throws Exception out . add ( t2 ) ; return false ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , out ) ; 
TestHelper . checkUtilityClass ( QueueDrainHelper . class ) ; 
return type + " " + name ; 
TestHelper . checkUtilityClass ( HalfSerializer . class ) ; 
final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final Subscriber [ ] a = null ; final TestSubscriber ts = new TestSubscriber ( ) ; FlowableSubscriber s = new FlowableSubscriber ( ) @ Override public void onSubscribe ( Subscription s ) ts . onSubscribe ( s ) ; @ Override public void onNext ( Object t ) if ( t . equals ( 1 ) ) HalfSerializer . onNext ( a [ 0 ] , 2 , wip , error ) ; ts . onNext ( t ) ; @ Override public void onError ( Throwable t ) ts . onError ( t ) ; @ Override public void onComplete ( ) ts . onComplete ( ) ; ; a [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; HalfSerializer . onNext ( s , 1 , wip , error ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final Subscriber [ ] a = null ; final TestSubscriber ts = new TestSubscriber ( ) ; FlowableSubscriber s = new FlowableSubscriber ( ) @ Override public void onSubscribe ( Subscription s ) ts . onSubscribe ( s ) ; @ Override public void onNext ( Object t ) if ( t . equals ( 1 ) ) HalfSerializer . onError ( a [ 0 ] , new TestException ( ) , wip , error ) ; ts . onNext ( t ) ; @ Override public void onError ( Throwable t ) ts . onError ( t ) ; @ Override public void onComplete ( ) ts . onComplete ( ) ; ; a [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; HalfSerializer . onNext ( s , 1 , wip , error ) ; ts . assertFailure ( TestException . class , 1 ) ; 
final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final Subscriber [ ] a = null ; final TestSubscriber ts = new TestSubscriber ( ) ; FlowableSubscriber s = new FlowableSubscriber ( ) @ Override public void onSubscribe ( Subscription s ) ts . onSubscribe ( s ) ; @ Override public void onNext ( Object t ) if ( t . equals ( 1 ) ) HalfSerializer . onComplete ( a [ 0 ] , wip , error ) ; ts . onNext ( t ) ; @ Override public void onError ( Throwable t ) ts . onError ( t ) ; @ Override public void onComplete ( ) ts . onComplete ( ) ; ; a [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; HalfSerializer . onNext ( s , 1 , wip , error ) ; ts . assertResult ( 1 ) ; 
final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final Subscriber [ ] a = null ; final TestSubscriber ts = new TestSubscriber ( ) ; FlowableSubscriber s = new FlowableSubscriber ( ) @ Override public void onSubscribe ( Subscription s ) ts . onSubscribe ( s ) ; @ Override public void onNext ( Object t ) ts . onNext ( t ) ; @ Override public void onError ( Throwable t ) ts . onError ( t ) ; HalfSerializer . onError ( a [ 0 ] , new IOException ( ) , wip , error ) ; @ Override public void onComplete ( ) ts . onComplete ( ) ; ; a [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; HalfSerializer . onError ( s , new TestException ( ) , wip , error ) ; ts . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) HalfSerializer . onNext ( ts , 1 , wip , error ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) HalfSerializer . onComplete ( ts , wip , error ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertComplete ( ) . assertNoErrors ( ) ; assertTrue ( ts . values ( ) . size ( ) <= 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicInteger wip = new AtomicInteger ( ) ; final AtomicThrowable error = new AtomicThrowable ( ) ; final TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) HalfSerializer . onError ( ts , ex , wip , error ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) HalfSerializer . onComplete ( ts , wip , error ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . completions ( ) != 0 ) ts . assertResult ( ) ; else ts . assertFailure ( TestException . class ) ; 
return "![" + type + "](https://raw.github.com/wiki/ReactiveX/RxJava/images/opmatrix-" + type . toLowerCase ( ) + ".png)" ; 
Map < String , String > classNotes = NOTES_MAP . get ( operatorName ) ; if ( classNotes != null ) return classNotes . get ( clazzName . substring ( 0 , 1 ) ) ; switch ( operatorName ) case "empty" : if ( "Completable" . equals ( clazzName ) ) return "Use [`complete()`](#complete)." ; if ( "Single" . equals ( clazzName ) ) return "Never empty." ; break ; return null ; 
TestHelper . checkUtilityClass ( BlockingHelper . class ) ; 
CountDownLatch cdl = new CountDownLatch ( 1 ) ; Disposable d = Disposable . empty ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try BlockingHelper . awaitForComplete ( cdl , d ) ; catch ( IllegalStateException ex ) assertTrue ( d . isDisposed ( ) ) ; assertTrue ( Thread . interrupted ( ) ) ; 
final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Disposable d = Disposable . empty ( ) ; Schedulers . computation ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) cdl . countDown ( ) ; , 100 , TimeUnit . MILLISECONDS ) ; BlockingHelper . awaitForComplete ( cdl , d ) ; assertFalse ( d . isDisposed ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Disposable d = Disposable . empty ( ) ; assertFalse ( NotificationLite . acceptFull ( NotificationLite . disposable ( d ) , to ) ) ; to . assertSubscribed ( ) ; to . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestException ex = new TestException ( ) ; Object n1 = NotificationLite . error ( ex ) ; assertEquals ( ex . hashCode ( ) , n1 . hashCode ( ) ) ; assertNotEquals ( n1 , NotificationLite . complete ( ) ) ; 
assertTrue ( QueueDrainHelper . isCancelled ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception throw new IOException ( ) ; ) ) ; 
QueueDrainHelper . request ( new Subscription ( ) @ Override public void request ( long n ) assertEquals ( Integer . MAX_VALUE , n ) ; @ Override public void cancel ( ) , Integer . MAX_VALUE ) ; 
QueueDrainHelper . request ( new Subscription ( ) @ Override public void request ( long n ) assertEquals ( Long . MAX_VALUE , n ) ; @ Override public void cancel ( ) , Integer . MIN_VALUE ) ; 
QueueDrainHelper . request ( new Subscription ( ) @ Override public void request ( long n ) assertEquals ( Integer . MAX_VALUE - 1 , n ) ; @ Override public void cancel ( ) , Integer . MAX_VALUE - 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ArrayDeque < Integer > queue = new ArrayDeque < > ( ) ; AtomicLong state = new AtomicLong ( ) ; BooleanSupplier isCancelled = new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; QueueDrainHelper . postComplete ( ts , queue , state , isCancelled ) ; ts . assertResult ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ArrayDeque < Integer > queue = new ArrayDeque < > ( ) ; AtomicLong state = new AtomicLong ( ) ; BooleanSupplier isCancelled = new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; queue . offer ( 1 ) ; state . getAndIncrement ( ) ; QueueDrainHelper . postComplete ( ts , queue , state , isCancelled ) ; ts . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final ArrayDeque < Integer > queue = new ArrayDeque < > ( ) ; final AtomicLong state = new AtomicLong ( ) ; final BooleanSupplier isCancelled = new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; queue . offer ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) QueueDrainHelper . postCompleteRequest ( 1 , ts , queue , state , isCancelled ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) QueueDrainHelper . postComplete ( ts , queue , state , isCancelled ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ArrayDeque < Integer > queue = new ArrayDeque < > ( ) ; AtomicLong state = new AtomicLong ( ) ; BooleanSupplier isCancelled = new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return ts . isCancelled ( ) ; ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; queue . offer ( 1 ) ; state . getAndIncrement ( ) ; ts . cancel ( ) ; QueueDrainHelper . postComplete ( ts , queue , state , isCancelled ) ; ts . assertEmpty ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; ; ArrayDeque < Integer > queue = new ArrayDeque < > ( ) ; AtomicLong state = new AtomicLong ( ) ; BooleanSupplier isCancelled = new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return ts . isCancelled ( ) ; ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; queue . offer ( 1 ) ; state . getAndIncrement ( ) ; QueueDrainHelper . postComplete ( ts , queue , state , isCancelled ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; QueueDrain < Integer , Integer > qd = new QueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return null ; @ Override public boolean enter ( ) return true ; @ Override public long requested ( ) return 0 ; @ Override public long produced ( long n ) return 0 ; @ Override public int leave ( int m ) return 0 ; @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) return false ; ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; q . offer ( 1 ) ; QueueDrainHelper . drainMaxLoop ( q , ts , false , null , qd ) ; ts . assertFailure ( MissingBackpressureException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; QueueDrain < Integer , Integer > qd = new QueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return null ; @ Override public boolean enter ( ) return true ; @ Override public long requested ( ) return 0 ; @ Override public long produced ( long n ) return 0 ; @ Override public int leave ( int m ) return 0 ; @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) return false ; ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; q . offer ( 1 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainHelper . drainMaxLoop ( q , ts , false , d , qd ) ; ts . assertFailure ( MissingBackpressureException . class ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; QueueDrain < Integer , Integer > qd = new QueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return null ; @ Override public boolean enter ( ) return true ; @ Override public long requested ( ) return 1 ; @ Override public long produced ( long n ) return 0 ; @ Override public int leave ( int m ) return 0 ; @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) return false ; ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; q . offer ( 1 ) ; QueueDrainHelper . drainMaxLoop ( q , ts , false , null , qd ) ; ts . assertEmpty ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; QueueDrain < Integer , Integer > qd = new QueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return null ; @ Override public boolean enter ( ) return true ; @ Override public long requested ( ) return 0 ; @ Override public long produced ( long n ) return 0 ; @ Override public int leave ( int m ) return 0 ; @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) return false ; ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; QueueDrainHelper . checkTerminated ( true , true , ts , true , q , qd ) ; ts . assertResult ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; QueueDrain < Integer , Integer > qd = new QueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return null ; @ Override public boolean enter ( ) return true ; @ Override public long requested ( ) return 0 ; @ Override public long produced ( long n ) return 0 ; @ Override public int leave ( int m ) return 0 ; @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) return false ; ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; QueueDrainHelper . checkTerminated ( true , false , ts , true , q , qd ) ; ts . assertEmpty ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; QueueDrain < Integer , Integer > qd = new QueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return new TestException ( ) ; @ Override public boolean enter ( ) return true ; @ Override public long requested ( ) return 0 ; @ Override public long produced ( long n ) return 0 ; @ Override public int leave ( int m ) return 0 ; @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) return false ; ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; QueueDrainHelper . checkTerminated ( true , true , ts , true , q , qd ) ; ts . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; QueueDrain < Integer , Integer > qd = new QueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return new TestException ( ) ; @ Override public boolean enter ( ) return true ; @ Override public long requested ( ) return 0 ; @ Override public long produced ( long n ) return 0 ; @ Override public int leave ( int m ) return 0 ; @ Override public boolean accept ( Subscriber < ? super Integer > a , Integer v ) return false ; ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; QueueDrainHelper . checkTerminated ( true , false , ts , false , q , qd ) ; ts . assertFailure ( TestException . class ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; ObservableQueueDrain < Integer , Integer > qd = new ObservableQueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return null ; @ Override public boolean enter ( ) return true ; @ Override public int leave ( int m ) return 0 ; @ Override public void accept ( Observer < ? super Integer > a , Integer v ) ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; QueueDrainHelper . checkTerminated ( true , true , to , true , q , null , qd ) ; to . assertResult ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; ObservableQueueDrain < Integer , Integer > qd = new ObservableQueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return null ; @ Override public boolean enter ( ) return true ; @ Override public int leave ( int m ) return 0 ; @ Override public void accept ( Observer < ? super Integer > a , Integer v ) ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainHelper . checkTerminated ( true , true , to , true , q , d , qd ) ; to . assertResult ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; ObservableQueueDrain < Integer , Integer > qd = new ObservableQueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return null ; @ Override public boolean enter ( ) return true ; @ Override public int leave ( int m ) return 0 ; @ Override public void accept ( Observer < ? super Integer > a , Integer v ) ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; QueueDrainHelper . checkTerminated ( true , false , to , true , q , null , qd ) ; to . assertEmpty ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; ObservableQueueDrain < Integer , Integer > qd = new ObservableQueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return new TestException ( ) ; @ Override public boolean enter ( ) return true ; @ Override public int leave ( int m ) return 0 ; @ Override public void accept ( Observer < ? super Integer > a , Integer v ) ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; QueueDrainHelper . checkTerminated ( true , true , to , true , q , null , qd ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; ObservableQueueDrain < Integer , Integer > qd = new ObservableQueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return new TestException ( ) ; @ Override public boolean enter ( ) return true ; @ Override public int leave ( int m ) return 0 ; @ Override public void accept ( Observer < ? super Integer > a , Integer v ) ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; QueueDrainHelper . checkTerminated ( true , false , to , false , q , null , qd ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; ObservableQueueDrain < Integer , Integer > qd = new ObservableQueueDrain < Integer , Integer > ( ) @ Override public boolean cancelled ( ) return false ; @ Override public boolean done ( ) return false ; @ Override public Throwable error ( ) return new TestException ( ) ; @ Override public boolean enter ( ) return true ; @ Override public int leave ( int m ) return 0 ; @ Override public void accept ( Observer < ? super Integer > a , Integer v ) ; SpscArrayQueue < Integer > q = new SpscArrayQueue < > ( 32 ) ; Disposable d = Disposable . empty ( ) ; QueueDrainHelper . checkTerminated ( true , false , to , false , q , d , qd ) ; to . assertFailure ( TestException . class ) ; assertTrue ( d . isDisposed ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Queue < Integer > q = new ArrayDeque < > ( ) ; q . offer ( 1 ) ; AtomicLong state = new AtomicLong ( QueueDrainHelper . COMPLETED_MASK ) ; QueueDrainHelper . postComplete ( ts , q , state , new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) ; 
TestHelper . checkUtilityClass ( ExceptionHelper . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; final TestException ex = new TestException ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) assertTrue ( ExceptionHelper . addThrowable ( error , ex ) ) ; ; TestHelper . race ( r , r ) ; 
ExceptionHelper . < Exception > throwIfThrowable ( new InternalError ( ) ) ; 
MergerBiFunction < Integer > merger = new MergerBiFunction < > ( new Comparator < Integer > ( ) @ Override public int compare ( Integer o1 , Integer o2 ) return o1 . compareTo ( o2 ) ; ) ; List < Integer > list = merger . apply ( Collections . < Integer > emptyList ( ) , Arrays . asList ( 3 , 5 ) ) ; assertEquals ( Arrays . asList ( 3 , 5 ) , list ) ; 
MergerBiFunction < Integer > merger = new MergerBiFunction < > ( new Comparator < Integer > ( ) @ Override public int compare ( Integer o1 , Integer o2 ) return o1 . compareTo ( o2 ) ; ) ; List < Integer > list = merger . apply ( Collections . < Integer > emptyList ( ) , Collections . < Integer > emptyList ( ) ) ; assertEquals ( Collections . < Integer > emptyList ( ) , list ) ; 
MergerBiFunction < Integer > merger = new MergerBiFunction < > ( new Comparator < Integer > ( ) @ Override public int compare ( Integer o1 , Integer o2 ) return o1 . compareTo ( o2 ) ; ) ; List < Integer > list = merger . apply ( Arrays . asList ( 2 , 4 ) , Collections . < Integer > emptyList ( ) ) ; assertEquals ( Arrays . asList ( 2 , 4 ) , list ) ; 
MergerBiFunction < Integer > merger = new MergerBiFunction < > ( new Comparator < Integer > ( ) @ Override public int compare ( Integer o1 , Integer o2 ) return o1 . compareTo ( o2 ) ; ) ; List < Integer > list = merger . apply ( Arrays . asList ( 2 , 4 ) , Arrays . asList ( 3 , 5 ) ) ; assertEquals ( Arrays . asList ( 2 , 3 , 4 , 5 ) , list ) ; 
MergerBiFunction < Integer > merger = new MergerBiFunction < > ( new Comparator < Integer > ( ) @ Override public int compare ( Integer o1 , Integer o2 ) return o1 . compareTo ( o2 ) ; ) ; List < Integer > list = merger . apply ( Arrays . asList ( 3 , 5 ) , Arrays . asList ( 2 , 4 ) ) ; assertEquals ( Arrays . asList ( 2 , 3 , 4 , 5 ) , list ) ; 
AtomicThrowable ex = new AtomicThrowable ( ) ; assertFalse ( ex . isTerminated ( ) ) ; assertNull ( ex . terminate ( ) ) ; assertTrue ( ex . isTerminated ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try AtomicThrowable ex = new AtomicThrowable ( ) ; ex . tryTerminateAndReport ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try AtomicThrowable ex = new AtomicThrowable ( ) ; ex . terminate ( ) ; ex . tryTerminateAndReport ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try AtomicThrowable ex = new AtomicThrowable ( ) ; ex . set ( new TestException ( ) ) ; ex . tryTerminateAndReport ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; assertEquals ( 1 , errors . size ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . tryTerminateConsumer ( ts ) ; ts . assertResult ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . set ( new TestException ( ) ) ; ex . tryTerminateConsumer ( ts ) ; ts . assertFailure ( TestException . class ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; ts . onSubscribe ( new BooleanSubscription ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . terminate ( ) ; ex . tryTerminateConsumer ( ts ) ; ts . assertEmpty ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . tryTerminateConsumer ( ( Observer < Object > ) to ) ; to . assertResult ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . set ( new TestException ( ) ) ; ex . tryTerminateConsumer ( ( Observer < Object > ) to ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . terminate ( ) ; ex . tryTerminateConsumer ( ( Observer < Object > ) to ) ; to . assertEmpty ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . tryTerminateConsumer ( ( MaybeObserver < Object > ) to ) ; to . assertResult ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . set ( new TestException ( ) ) ; ex . tryTerminateConsumer ( ( MaybeObserver < Object > ) to ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . terminate ( ) ; ex . tryTerminateConsumer ( ( MaybeObserver < Object > ) to ) ; to . assertEmpty ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . tryTerminateConsumer ( ( SingleObserver < Object > ) to ) ; to . assertEmpty ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . set ( new TestException ( ) ) ; ex . tryTerminateConsumer ( ( SingleObserver < Object > ) to ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . terminate ( ) ; ex . tryTerminateConsumer ( ( SingleObserver < Object > ) to ) ; to . assertEmpty ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . tryTerminateConsumer ( ( CompletableObserver ) to ) ; to . assertResult ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . set ( new TestException ( ) ) ; ex . tryTerminateConsumer ( ( CompletableObserver ) to ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . terminate ( ) ; ex . tryTerminateConsumer ( ( CompletableObserver ) to ) ; to . assertEmpty ( ) ; 
return new Emitter < T > ( ) @ Override public void onNext ( T value ) observer . onNext ( value ) ; @ Override public void onError ( Throwable error ) observer . onError ( error ) ; @ Override public void onComplete ( ) observer . onComplete ( ) ; ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . tryTerminateConsumer ( wrapToEmitter ( to ) ) ; to . assertResult ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . set ( new TestException ( ) ) ; ex . tryTerminateConsumer ( wrapToEmitter ( to ) ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; AtomicThrowable ex = new AtomicThrowable ( ) ; ex . terminate ( ) ; ex . tryTerminateConsumer ( wrapToEmitter ( to ) ) ; to . assertEmpty ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try AtomicThrowable ex = new AtomicThrowable ( ) ; ex . tryAddThrowableOrReport ( new TestException ( ) ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try AtomicThrowable ex = new AtomicThrowable ( ) ; ex . terminate ( ) ; assertFalse ( ex . tryAddThrowableOrReport ( new TestException ( ) ) ) ; assertFalse ( "" + errors , errors . isEmpty ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
if ( -- crashOnIterator <= 0 ) throw new TestException ( "iterator()" ) ; return new CrashingMapperIterator < > ( crashOnHasNext , crashOnNext , mapper ) ; 
if ( -- crashOnHasNext <= 0 ) throw new TestException ( "hasNext()" ) ; return true ; 
if ( -- crashOnNext <= 0 ) throw new TestException ( "next()" ) ; try return mapper . apply ( count ++ ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
throw new UnsupportedOperationException ( ) ; 
TestHelper . checkUtilityClass ( BackpressureHelper . class ) ; 
assertEquals ( 2L , BackpressureHelper . addCap ( 1 , 1 ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . addCap ( 1 , Long . MAX_VALUE - 1 ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . addCap ( 1 , Long . MAX_VALUE ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . addCap ( Long . MAX_VALUE - 1 , Long . MAX_VALUE - 1 ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . addCap ( Long . MAX_VALUE , Long . MAX_VALUE ) ) ; 
assertEquals ( 6 , BackpressureHelper . multiplyCap ( 2 , 3 ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . multiplyCap ( 2 , Long . MAX_VALUE ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . multiplyCap ( Long . MAX_VALUE , Long . MAX_VALUE ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . multiplyCap ( 1L << 32 , 1L << 32 ) ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try AtomicLong requested = new AtomicLong ( 1 ) ; assertEquals ( 0 , BackpressureHelper . produced ( requested , 2 ) ) ; TestHelper . assertError ( list , 0 , IllegalStateException . class , "More produced than requested: -1" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try AtomicLong requested = new AtomicLong ( 1 ) ; assertEquals ( 0 , BackpressureHelper . producedCancel ( requested , 2 ) ) ; TestHelper . assertError ( list , 0 , IllegalStateException . class , "More produced than requested: -1" ) ; finally RxJavaPlugins . reset ( ) ; 
final AtomicLong requested = new AtomicLong ( 1 ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) Runnable r1 = new Runnable ( ) @ Override public void run ( ) BackpressureHelper . produced ( requested , 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) BackpressureHelper . add ( requested , 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
final AtomicLong requested = new AtomicLong ( 1 ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) Runnable r1 = new Runnable ( ) @ Override public void run ( ) BackpressureHelper . produced ( requested , 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) BackpressureHelper . addCancel ( requested , 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestHelper . checkUtilityClass ( BackpressureHelper . class ) ; 
final AtomicLong requested = new AtomicLong ( Long . MIN_VALUE ) ; assertEquals ( Long . MIN_VALUE , BackpressureHelper . addCancel ( requested , 1 ) ) ; assertEquals ( Long . MIN_VALUE , BackpressureHelper . addCancel ( requested , Long . MAX_VALUE ) ) ; requested . set ( 0 ) ; assertEquals ( 0 , BackpressureHelper . addCancel ( requested , Long . MAX_VALUE ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . addCancel ( requested , 1 ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . addCancel ( requested , Long . MAX_VALUE ) ) ; requested . set ( 0 ) ; assertEquals ( 0 , BackpressureHelper . add ( requested , Long . MAX_VALUE ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . add ( requested , 1 ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . add ( requested , Long . MAX_VALUE ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . produced ( requested , 1 ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . produced ( requested , Long . MAX_VALUE ) ) ; 
assertEquals ( Long . MAX_VALUE , BackpressureHelper . multiplyCap ( 3 , Long . MAX_VALUE > > 1 ) ) ; assertEquals ( Long . MAX_VALUE , BackpressureHelper . multiplyCap ( 1 , Long . MAX_VALUE ) ) ; 
TestHelper . checkUtilityClass ( ObjectHelper . class ) ; 
assertEquals ( 1 , ObjectHelper . verifyPositive ( 1 , "param" ) ) ; 
assertEquals ( 1L , ObjectHelper . verifyPositive ( 1L , "param" ) ) ; 
assertEquals ( - 1 , ObjectHelper . verifyPositive ( - 1 , "param" ) ) ; 
assertEquals ( - 1L , ObjectHelper . verifyPositive ( - 1L , "param" ) ) ; 
TestHelper . checkUtilityClass ( Functions . class ) ; 
try Method m = Functions . HashSetSupplier . class . getMethod ( "values" ) ; m . setAccessible ( true ) ; Method e = Functions . HashSetSupplier . class . getMethod ( "valueOf" , String . class ) ; e . setAccessible ( true ) ; for ( Enum < HashSetSupplier > o : ( Enum < HashSetSupplier > [ ] ) m . invoke ( null ) ) assertSame ( o , e . invoke ( null , o . name ( ) ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
try Method m = Functions . NaturalComparator . class . getMethod ( "values" ) ; m . setAccessible ( true ) ; Method e = Functions . NaturalComparator . class . getMethod ( "valueOf" , String . class ) ; e . setAccessible ( true ) ; for ( Enum < NaturalComparator > o : ( Enum < NaturalComparator > [ ] ) m . invoke ( null ) ) assertSame ( o , e . invoke ( null , o . name ( ) ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
BooleanSupplier s = new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ; assertTrue ( Functions . predicateReverseFor ( s ) . test ( 1 ) ) ; s = new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return true ; ; assertFalse ( Functions . predicateReverseFor ( s ) . test ( 1 ) ) ; 
Functions . toFunction ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throws Exception return null ; ) . apply ( new Object [ 20 ] ) ; 
Functions . toFunction ( new Function3 < Integer , Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 , Integer t3 ) throws Exception return null ; ) . apply ( new Object [ 20 ] ) ; 
Functions . toFunction ( new Function4 < Integer , Integer , Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 ) throws Exception return null ; ) . apply ( new Object [ 20 ] ) ; 
Functions . toFunction ( new Function5 < Integer , Integer , Integer , Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 ) throws Exception return null ; ) . apply ( new Object [ 20 ] ) ; 
Functions . toFunction ( new Function6 < Integer , Integer , Integer , Integer , Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 ) throws Exception return null ; ) . apply ( new Object [ 20 ] ) ; 
Functions . toFunction ( new Function7 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 ) throws Exception return null ; ) . apply ( new Object [ 20 ] ) ; 
Functions . toFunction ( new Function8 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 , Integer t8 ) throws Exception return null ; ) . apply ( new Object [ 20 ] ) ; 
Functions . toFunction ( new Function9 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 , Integer t8 , Integer t9 ) throws Exception return null ; ) . apply ( new Object [ 20 ] ) ; 
assertEquals ( "IdentityFunction" , Functions . identity ( ) . toString ( ) ) ; 
assertEquals ( "EmptyAction" , Functions . EMPTY_ACTION . toString ( ) ) ; 
assertEquals ( "EmptyRunnable" , Functions . EMPTY_RUNNABLE . toString ( ) ) ; 
assertEquals ( "EmptyConsumer" , Functions . EMPTY_CONSUMER . toString ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Functions . ERROR_CONSUMER . accept ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; assertEquals ( errors . toString ( ) , 1 , errors . size ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Completable . fromCompletionStage ( CompletableFuture . completedFuture ( 1 ) ) . test ( ) . assertResult ( ) ; 
Completable . fromCompletionStage ( CompletableFuture . completedFuture ( null ) ) . test ( ) . assertResult ( ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; cf . completeExceptionally ( new TestException ( ) ) ; Completable . fromCompletionStage ( cf ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . fromCompletionStage ( CompletableFuture . < Integer > completedFuture ( null ) ) . test ( ) . assertResult ( ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; TestObserver < Void > to = Completable . fromCompletionStage ( cf ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; cf . complete ( 1 ) ; to . assertEmpty ( ) ; 
TestHelper . checkDisposed ( Completable . fromCompletionStage ( new CompletableFuture < > ( ) ) ) ; 
CompletableFuture < Long > cf = new CompletableFuture < > ( ) ; cf . completeExceptionally ( new TestException ( ) ) ; return Flowable . fromCompletionStage ( cf ) ; 
return 1 ; 
try ( Stream < Integer > stream = Observable . < Integer > empty ( ) . blockingStream ( ) ) assertEquals ( 0 , stream . toArray ( ) . length ) ; 
try ( Stream < Integer > stream = Observable . just ( 1 ) . blockingStream ( ) ) assertArrayEquals ( new Integer [ ] 1 , stream . toArray ( Integer [ ] :: new ) ) ; 
try ( Stream < Integer > stream = Observable . range ( 1 , 5 ) . blockingStream ( ) ) assertArrayEquals ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , stream . toArray ( Integer [ ] :: new ) ) ; 
try ( Stream < Integer > stream = Observable . range ( 1 , 5 ) . blockingStream ( 1 ) ) assertArrayEquals ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , stream . toArray ( Integer [ ] :: new ) ) ; 
try ( Stream < Integer > stream = Observable . range ( 1 , 1000 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingStream ( ) ) List < Integer > list = stream . collect ( Collectors . toList ( ) ) ; assertEquals ( 1000 , list . size ( ) ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) assertEquals ( i , list . get ( i - 1 ) . intValue ( ) ) ; 
try ( Stream < Integer > stream = Observable . range ( 1 , 1000 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingStream ( 1 ) ) List < Integer > list = stream . collect ( Collectors . toList ( ) ) ; assertEquals ( 1000 , list . size ( ) ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) assertEquals ( i , list . get ( i - 1 ) . intValue ( ) ) ; 
try ( Stream < Integer > stream = Observable . < Integer > error ( new TestException ( ) ) . blockingStream ( ) ) stream . toArray ( Integer [ ] :: new ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onNext ( 3 ) ; up . onNext ( 4 ) ; up . onNext ( 5 ) ; try ( Stream < Integer > stream = up . blockingStream ( ) ) assertArrayEquals ( new Integer [ ] 1 , 2 , 3 , stream . limit ( 3 ) . toArray ( Integer [ ] :: new ) ) ; assertFalse ( up . hasSubscribers ( ) ) ; 
Maybe . fromOptional ( Optional . of ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Maybe . fromOptional ( Optional . empty ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . hide ( ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . flatMapStream ( v -> Stream . of ( v + 1 , v + 2 , v + 3 , v + 4 , v + 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMapStream ( v -> Stream . of ( v + 1 , v + 2 , v + 3 , v + 4 , v + 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
Flowable . error ( new TestException ( ) ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . fromCallable ( ( ) -> throw new TestException ( ) ; ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . hide ( ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . flatMapStream ( v -> IntStream . range ( v * 10 , v * 10 + 5 ) . boxed ( ) ) . test ( ) . assertResult ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 , 30 , 31 , 32 , 33 , 34 , 40 , 41 , 42 , 43 , 44 , 50 , 51 , 52 , 53 , 54 ) ; 
Flowable . range ( 1 , 5 ) . hide ( ) . flatMapStream ( v -> IntStream . range ( v * 10 , v * 10 + 5 ) . boxed ( ) ) . test ( ) . assertResult ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 , 30 , 31 , 32 , 33 , 34 , 40 , 41 , 42 , 43 , 44 , 50 , 51 , 52 , 53 , 54 ) ; 
Flowable . range ( 1 , 5 ) . flatMapStream ( v -> Stream . of ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 5 ) . flatMapStream ( v -> IntStream . range ( v * 10 , v * 10 + 5 ) . boxed ( ) ) . take ( 12 ) . test ( ) . assertResult ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 , 30 , 31 ) ; 
Flowable . range ( 1 , 5 ) . hide ( ) . flatMapStream ( v -> IntStream . range ( v * 10 , v * 10 + 5 ) . boxed ( ) ) . take ( 12 ) . test ( ) . assertResult ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 , 30 , 31 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; AtomicInteger calls = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = pp . flatMapStream ( v -> Stream . of ( v + 1 , v + 2 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . test ( 1 ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 2 ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertEquals ( 1 , calls . get ( ) ) ; 
TestHelper . withErrorTracking ( errors -> PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . flatMapStream ( v -> Stream . of ( v + 1 , v + 2 ) . onClose ( ( ) -> throw new TestException ( ) ; ) ) . test ( 1 ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 2 ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Flowable . range ( 1 , 1000 ) . flatMapStream ( v -> IntStream . range ( v * 1000 , v * 1000 + 1000 ) . boxed ( ) ) . test ( ) . assertValueCount ( 1_000_000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 1000 ) . hide ( ) . flatMapStream ( v -> IntStream . range ( v * 1000 , v * 1000 + 1000 ) . boxed ( ) ) . test ( ) . assertValueCount ( 1_000_000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
for ( int n = 1 ; n < 2048 ; n *= 2 ) Flowable . range ( 1 , 1000 ) . flatMapStream ( v -> IntStream . range ( v * 1000 , v * 1000 + 1000 ) . boxed ( ) ) . rebatchRequests ( n ) . test ( ) . withTag ( "rebatch: " + n ) . assertValueCount ( 1_000_000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
for ( int n = 1 ; n < 2048 ; n *= 2 ) Flowable . range ( 1 , 1000 ) . hide ( ) . flatMapStream ( v -> IntStream . range ( v * 1000 , v * 1000 + 1000 ) . boxed ( ) ) . rebatchRequests ( n ) . test ( ) . withTag ( "rebatch: " + n ) . assertValueCount ( 1_000_000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) ) ; 
TestHelper . assertBadRequestReported ( UnicastProcessor . create ( ) . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) ) ; 
TestHelper . withErrorTracking ( errors -> new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; s . onError ( new TestException ( ) ) ; . flatMapStream ( v -> Stream . of ( 1 , 2 ) , 1 ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapStream ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapStream ( v -> null ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapStream ( v -> Stream . of ( 1 , null ) ) . test ( ) . assertFailure ( NullPointerException . class , 1 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapStream ( v -> Stream . generate ( ( ) -> throw new TestException ( ) ; ) ) . test ( ) . assertFailure ( TestException . class ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapStream ( v -> Stream . generate ( ( ) -> if ( counter . getAndIncrement ( ) == 0 ) return 1 ; throw new TestException ( ) ; ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
TestHelper . withErrorTracking ( errors -> PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; TestSubscriber < Integer > ts = pp . hide ( ) . concatMapStream ( v -> if ( counter . getAndIncrement ( ) == 0 ) return Stream . of ( 1 , 2 ) ; pp . onError ( new IOException ( ) ) ; throw new TestException ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; ts . assertFailure ( IOException . class , 1 , 2 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Flowable . range ( 1 , 5 ) . hide ( ) . concatMapStream ( v -> Stream . of ( v ) , 1 ) . test ( 0 ) . assertEmpty ( ) . requestMore ( 5 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; @ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) ts . cancel ( ) ; return 1 ; ) ; Flowable . just ( 1 ) . hide ( ) . concatMapStream ( v -> stream ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestSubscriber < Integer > ts = up . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) . test ( ) ; assertTrue ( up . hasSubscribers ( ) ) ; up . onNext ( 1 ) ; ts . assertValuesOnly ( 1 , 2 ) ; up . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestSubscriber < Integer > ts = up . map ( v -> v + 1 ) . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) . test ( ) ; assertTrue ( up . hasSubscribers ( ) ) ; up . onNext ( 1 ) ; ts . assertValuesOnly ( 1 , 2 ) ; up . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestSubscriber < Integer > ts = up . map ( v -> throw new TestException ( ) ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) . test ( ) ; assertTrue ( up . hasSubscribers ( ) ) ; up . onNext ( 1 ) ; assertFalse ( up . hasSubscribers ( ) ) ; ts . assertFailure ( TestException . class ) ; 
Maybe . just ( 1 ) . flattenStreamAsFlowable ( Stream :: of ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( 2 , 3 , 4 , 5 , 6 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( 2 , 3 , 4 , 5 , 6 ) ) . take ( 3 ) . test ( ) . assertResult ( 2 , 3 , 4 ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Stream < ? extends Integer > > f = mock ( Function . class ) ; Maybe . < Integer > empty ( ) . flattenStreamAsFlowable ( f ) . test ( ) . assertResult ( ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Stream < ? extends Integer > > f = mock ( Function . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . flattenStreamAsFlowable ( f ) . test ( ) . assertFailure ( TestException . class ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Maybe . never ( ) . flattenStreamAsFlowable ( Stream :: of ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToFlowable ( m -> m . flattenStreamAsFlowable ( Stream :: of ) ) ; 
TestHelper . assertBadRequestReported ( MaybeSubject . create ( ) . flattenStreamAsFlowable ( Stream :: of ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( v ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 ) ; 
Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> IntStream . rangeClosed ( 1 , 5 ) . boxed ( ) ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 , 4 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> IntStream . rangeClosed ( 1 , 5 ) . boxed ( ) ) . rebatchRequests ( 1 ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 , 4 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; ms . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
AtomicReference < QueueSubscription < Integer > > qsr = new AtomicReference < > ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; ms . flattenStreamAsFlowable ( Stream :: of ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override @ SuppressWarnings ( "unchecked" ) public void onSubscribe ( @ NonNull Subscription s ) qsr . set ( ( QueueSubscription < Integer > ) s ) ; ) ; QueueSubscription < Integer > qs = qsr . get ( ) ; assertEquals ( QueueFuseable . ASYNC , qs . requestFusion ( QueueFuseable . ASYNC ) ) ; assertTrue ( qs . isEmpty ( ) ) ; assertNull ( qs . poll ( ) ) ; ms . onSuccess ( 1 ) ; assertFalse ( qs . isEmpty ( ) ) ; assertEquals ( 1 , qs . poll ( ) . intValue ( ) ) ; assertTrue ( qs . isEmpty ( ) ) ; assertNull ( qs . poll ( ) ) ; qs . cancel ( ) ; assertTrue ( qs . isEmpty ( ) ) ; assertNull ( qs . poll ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) Subscription upstream ; @ Override public void onSubscribe ( @ NonNull Subscription s ) ts . onSubscribe ( new BooleanSubscription ( ) ) ; upstream = s ; s . request ( 1 ) ; @ Override public void onNext ( Integer t ) ts . onNext ( t ) ; upstream . request ( 1 ) ; @ Override public void onError ( Throwable t ) ts . onError ( t ) ; @ Override public void onComplete ( ) ts . onComplete ( ) ; ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . withErrorTracking ( errors -> Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( v ) . onClose ( ( ) -> throw new TestException ( ) ; ) ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ > 0 ) throw new TestException ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) . test ( ) . assertFailure ( TestException . class ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ > 0 ) ts . cancel ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) . subscribeWith ( ts ) . assertValuesOnly ( 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) ts . cancel ( ) ; return 1 ; ) ; Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) . subscribeWith ( ts ) . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ms . flattenStreamAsFlowable ( Stream :: of ) . subscribe ( ts ) ; Runnable r1 = ( ) -> ms . onSuccess ( 1 ) ; Runnable r2 = ( ) -> ts . request ( 1 ) ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 ) ; 
Single . just ( 1 ) . mapOptional ( Optional :: of ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . mapOptional ( v -> Optional . empty ( ) ) . test ( ) . assertResult ( ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Optional < ? extends Integer > > f = mock ( Function . class ) ; Single . < Integer > error ( new TestException ( ) ) . mapOptional ( f ) . test ( ) . assertFailure ( TestException . class ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
Single . just ( 1 ) . mapOptional ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Single . never ( ) . mapOptional ( Optional :: of ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToMaybe ( m -> m . mapOptional ( Optional :: of ) ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 ) ) ) ; 
for ( int i = 1 ; i < 32 ; i ++ ) Flowable . range ( 1 , 1000 ) . parallel ( i ) . flatMapStream ( v -> Stream . of ( v , v + 1 ) ) . sequential ( ) . test ( ) . withTag ( "Parallelism: " + i ) . assertValueCount ( 2000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
for ( int i = 1 ; i < 32 ; i ++ ) Flowable . range ( 1 , 1000 ) . parallel ( i ) . flatMapStream ( v -> Stream . of ( ) ) . sequential ( ) . test ( ) . withTag ( "Parallelism: " + i ) . assertResult ( ) ; 
for ( int i = 1 ; i < 32 ; i ++ ) Flowable . range ( 1 , 1000 ) . parallel ( i ) . flatMapStream ( v -> v % 2 == 0 ? Stream . of ( v ) : Stream . of ( ) ) . sequential ( ) . test ( ) . withTag ( "Parallelism: " + i ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
calls ++ ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . mapOptional ( Optional :: of , e ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . < Integer > error ( new TestException ( ) ) . parallel ( 1 ) . mapOptional ( Optional :: of , e ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . mapOptional ( Optional :: of , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . < Integer > error ( new TestException ( ) ) . parallel ( 1 ) . mapOptional ( Optional :: of , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , ParallelFailureHandling . ERROR ) . sequential ( ) . test ( ) . assertFailure ( ArithmeticException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , ParallelFailureHandling . STOP ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( new Function < Integer , Optional < ? extends Integer > > ( ) int count ; @ Override public Optional < ? extends Integer > apply ( Integer v ) throws Exception if ( count ++ == 1 ) return Optional . of ( - 1 ) ; return Optional . of ( 1 / v ) ; , ParallelFailureHandling . RETRY ) . sequential ( ) . test ( ) . assertResult ( - 1 , 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception return n < 5 ? ParallelFailureHandling . RETRY : ParallelFailureHandling . SKIP ; ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , ParallelFailureHandling . SKIP ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , ArithmeticException . class , TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . mapOptional ( Optional :: of , ParallelFailureHandling . ERROR ) . sequential ( ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( ArithmeticException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , ParallelFailureHandling . STOP ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( new Function < Integer , Optional < ? extends Integer > > ( ) int count ; @ Override public Optional < ? extends Integer > apply ( Integer v ) throws Exception if ( count ++ == 1 ) return Optional . of ( - 1 ) ; return Optional . of ( 1 / v ) ; , ParallelFailureHandling . RETRY ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( - 1 , 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception return n < 5 ? ParallelFailureHandling . RETRY : ParallelFailureHandling . SKIP ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , ParallelFailureHandling . SKIP ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 0 , 2 ) . parallel ( 1 ) . mapOptional ( v -> Optional . of ( 1 / v ) , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , ArithmeticException . class , TestException . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . just ( 1 ) . parallel ( 1 ) . mapOptional ( Optional :: of , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . mapOptional ( Optional :: of , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkEnum ( ParallelFailureHandling . class ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> Optional . empty ( ) , ParallelFailureHandling . SKIP ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> Optional . empty ( ) , ParallelFailureHandling . SKIP ) . filter ( v -> true ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> v % 2 == 0 ? Optional . of ( v ) : Optional . empty ( ) , ParallelFailureHandling . SKIP ) . sequential ( ) . test ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> v % 2 == 0 ? Optional . of ( v ) : Optional . empty ( ) , ParallelFailureHandling . SKIP ) . filter ( v -> true ) . sequential ( ) . test ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> v % 2 == 0 ? Optional . of ( v ) : Optional . empty ( ) , ParallelFailureHandling . SKIP ) . filter ( v -> v % 4 == 0 ) . sequential ( ) . test ( ) . assertValueCount ( 250 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . range ( 1 , 10 ) . parallel ( ) . mapOptional ( Optional :: of , ParallelFailureHandling . SKIP ) ) ; 
TestHelper . checkDoubleOnSubscribeParallel ( p -> p . mapOptional ( Optional :: of , ParallelFailureHandling . ERROR ) ) ; TestHelper . checkDoubleOnSubscribeParallel ( p -> p . mapOptional ( Optional :: of , ParallelFailureHandling . ERROR ) . filter ( v -> true ) ) ; 
Maybe . just ( 1 ) . mapOptional ( Optional :: of ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . mapOptional ( v -> Optional . empty ( ) ) . test ( ) . assertResult ( ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Optional < ? extends Integer > > f = mock ( Function . class ) ; Maybe . < Integer > empty ( ) . mapOptional ( f ) . test ( ) . assertResult ( ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Optional < ? extends Integer > > f = mock ( Function . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . mapOptional ( f ) . test ( ) . assertFailure ( TestException . class ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
Maybe . just ( 1 ) . mapOptional ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Maybe . never ( ) . mapOptional ( Optional :: of ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybe ( m -> m . mapOptional ( Optional :: of ) ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Maybe . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Flowable . just ( 1 ) . hide ( ) . flatMapStream ( v -> stream ) ; 
Observable . empty ( ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( ) ; 
Observable . empty ( ) . hide ( ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( ) ; 
Observable . just ( 1 ) . flatMapStream ( v -> Stream . of ( v + 1 , v + 2 , v + 3 , v + 4 , v + 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
Observable . just ( 1 ) . hide ( ) . flatMapStream ( v -> Stream . of ( v + 1 , v + 2 , v + 3 , v + 4 , v + 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
Observable . error ( new TestException ( ) ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . fromCallable ( ( ) -> throw new TestException ( ) ; ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . hide ( ) . flatMapStream ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 5 ) . flatMapStream ( v -> IntStream . range ( v * 10 , v * 10 + 5 ) . boxed ( ) ) . test ( ) . assertResult ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 , 30 , 31 , 32 , 33 , 34 , 40 , 41 , 42 , 43 , 44 , 50 , 51 , 52 , 53 , 54 ) ; 
Observable . range ( 1 , 5 ) . hide ( ) . flatMapStream ( v -> IntStream . range ( v * 10 , v * 10 + 5 ) . boxed ( ) ) . test ( ) . assertResult ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 , 30 , 31 , 32 , 33 , 34 , 40 , 41 , 42 , 43 , 44 , 50 , 51 , 52 , 53 , 54 ) ; 
Observable . range ( 1 , 5 ) . flatMapStream ( v -> Stream . of ( ) ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 5 ) . flatMapStream ( v -> IntStream . range ( v * 10 , v * 10 + 5 ) . boxed ( ) ) . take ( 12 ) . test ( ) . assertResult ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 , 30 , 31 ) ; 
Observable . range ( 1 , 5 ) . hide ( ) . flatMapStream ( v -> IntStream . range ( v * 10 , v * 10 + 5 ) . boxed ( ) ) . take ( 12 ) . test ( ) . assertResult ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 , 30 , 31 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; AtomicInteger calls = new AtomicInteger ( ) ; TestObserver < Integer > to = ps . flatMapStream ( v -> Stream . of ( v + 1 , v + 2 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . take ( 1 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 2 ) ; assertFalse ( ps . hasObservers ( ) ) ; assertEquals ( 1 , calls . get ( ) ) ; 
TestHelper . withErrorTracking ( errors -> PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMapStream ( v -> Stream . of ( v + 1 , v + 2 ) . onClose ( ( ) -> throw new TestException ( ) ; ) ) . take ( 1 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 2 ) ; assertFalse ( ps . hasObservers ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Observable . range ( 1 , 1000 ) . flatMapStream ( v -> IntStream . range ( v * 1000 , v * 1000 + 1000 ) . boxed ( ) ) . test ( ) . assertValueCount ( 1_000_000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . range ( 1 , 1000 ) . hide ( ) . flatMapStream ( v -> IntStream . range ( v * 1000 , v * 1000 + 1000 ) . boxed ( ) ) . test ( ) . assertValueCount ( 1_000_000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( f -> f . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapStream ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapStream ( v -> null ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapStream ( v -> Stream . of ( 1 , null ) ) . test ( ) . assertFailure ( NullPointerException . class , 1 ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapStream ( v -> Stream . generate ( ( ) -> throw new TestException ( ) ; ) ) . test ( ) . assertFailure ( TestException . class ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapStream ( v -> Stream . generate ( ( ) -> if ( counter . getAndIncrement ( ) == 0 ) return 1 ; throw new TestException ( ) ; ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
TestHelper . withErrorTracking ( errors -> PublishSubject < Integer > ps = PublishSubject . create ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; TestObserver < Integer > to = ps . hide ( ) . concatMapStream ( v -> if ( counter . getAndIncrement ( ) == 0 ) return Stream . of ( 1 , 2 ) ; ps . onError ( new IOException ( ) ) ; throw new TestException ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; to . assertFailure ( IOException . class , 1 , 2 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; @ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) to . dispose ( ) ; return 1 ; ) ; Observable . just ( 1 ) . hide ( ) . concatMapStream ( v -> stream ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; @ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) to . dispose ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Observable . just ( 1 ) . hide ( ) . concatMapStream ( v -> stream ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) . test ( ) ; assertTrue ( us . hasObservers ( ) ) ; us . onNext ( 1 ) ; to . assertValuesOnly ( 1 , 2 ) ; us . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . map ( v -> v + 1 ) . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) . test ( ) ; assertTrue ( us . hasObservers ( ) ) ; us . onNext ( 1 ) ; to . assertValuesOnly ( 1 , 2 ) ; us . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . map ( v -> throw new TestException ( ) ; ) . compose ( TestHelper . observableStripBoundary ( ) ) . flatMapStream ( v -> Stream . of ( 1 , 2 ) ) . test ( ) ; assertTrue ( us . hasObservers ( ) ) ; us . onNext ( 1 ) ; assertFalse ( us . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . flatMapStream ( v -> Stream . of ( 1 ) ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onComplete ( ) ; . flatMapStream ( v -> calls . getAndIncrement ( ) ; throw new TestException ( ) ; ) . take ( 1 ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onComplete ( ) ; . flatMapStream ( v -> calls . getAndIncrement ( ) ; return Stream . of ( 1 ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
Flowable . fromCompletionStage ( CompletableFuture . completedFuture ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; cf . completeExceptionally ( new TestException ( ) ) ; Flowable . fromCompletionStage ( cf ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . fromCompletionStage ( CompletableFuture . < Integer > completedFuture ( null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; TestSubscriber < Integer > ts = Flowable . fromCompletionStage ( cf ) . test ( ) ; ts . assertEmpty ( ) ; ts . cancel ( ) ; cf . complete ( 1 ) ; ts . assertEmpty ( ) ; 
Integer v = Single . just ( 1 ) . toCompletionStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
SingleSubject < Integer > source = SingleSubject . create ( ) ; CompletableFuture < Integer > cf = source . toCompletionStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
SingleSubject < Integer > source = SingleSubject . create ( ) ; CompletableFuture < Integer > cf = source . toCompletionStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
SingleSubject < Integer > source = SingleSubject . create ( ) ; CompletableFuture < Integer > cf = source . toCompletionStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Single . < Integer > error ( new TestException ( ) ) . toCompletionStage ( ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; observer . onError ( new TestException ( ) ) ; . toCompletionStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; . toCompletionStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
return Flowable . just ( 1 ) . < Integer > mapOptional ( v -> null ) . onBackpressureDrop ( ) ; 
Integer v = Flowable . just ( 1 ) . firstOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
TestHelper . assertError ( Flowable . < Integer > empty ( ) . firstOrErrorStage ( ) . toCompletableFuture ( ) , NoSuchElementException . class ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; Integer v = source . firstOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . firstOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . firstOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . firstOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Flowable . < Integer > error ( new TestException ( ) ) . firstOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; . firstOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; . firstOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Integer v = Flowable . just ( 1 ) . singleOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
TestHelper . assertError ( Flowable . < Integer > empty ( ) . singleOrErrorStage ( ) . toCompletableFuture ( ) , NoSuchElementException . class ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . create ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( source . singleOrErrorStage ( ) . toCompletableFuture ( ) , IllegalArgumentException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . singleOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . singleOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . singleOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Flowable . < Integer > error ( new TestException ( ) ) . singleOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; . singleOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; . singleOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Integer v = Flowable . just ( 1 ) . lastOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Flowable . range ( 1 , 5 ) . lastOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 5 , v ) ; 
TestHelper . assertError ( Flowable . < Integer > empty ( ) . lastOrErrorStage ( ) . toCompletableFuture ( ) , NoSuchElementException . class ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . lastOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . lastOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . lastOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Flowable . < Integer > error ( new TestException ( ) ) . lastOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; . lastOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; . lastOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Observable . fromCompletionStage ( CompletableFuture . completedFuture ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; cf . completeExceptionally ( new TestException ( ) ) ; Observable . fromCompletionStage ( cf ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . fromCompletionStage ( CompletableFuture . < Integer > completedFuture ( null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; TestObserver < Integer > to = Observable . fromCompletionStage ( cf ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; cf . complete ( 1 ) ; to . assertEmpty ( ) ; 
Flowable . range ( 1 , 5 ) . collect ( Collectors . toList ( ) ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Flowable . empty ( ) . collect ( Collectors . toList ( ) ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Flowable . error ( new TestException ( ) ) . collect ( Collectors . toList ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) throw new TestException ( ) ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
Flowable . range ( 1 , 5 ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> throw new TestException ( ) ; ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Flowable < Integer > source = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ; source . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . collect ( Collectors . toList ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToSingle ( f -> f . collect ( Collectors . toList ( ) ) ) ; 
Flowable . range ( 1 , 5 ) . collect ( Collectors . toList ( ) ) . toFlowable ( ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Flowable . empty ( ) . collect ( Collectors . toList ( ) ) . toFlowable ( ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Flowable . error ( new TestException ( ) ) . collect ( Collectors . toList ( ) ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) throw new TestException ( ) ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
Flowable . range ( 1 , 5 ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> throw new TestException ( ) ; ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Flowable < Integer > source = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ; source . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . collect ( Collectors . toList ( ) ) . toFlowable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . collect ( Collectors . toList ( ) ) . toFlowable ( ) ) ; 
Observable . fromOptional ( Optional . of ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . fromOptional ( Optional . empty ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . fromCompletionStage ( CompletableFuture . completedFuture ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; cf . completeExceptionally ( new TestException ( ) ) ; Maybe . fromCompletionStage ( cf ) . test ( ) . assertFailure ( TestException . class ) ; 
Maybe . fromCompletionStage ( CompletableFuture . < Integer > completedFuture ( null ) ) . test ( ) . assertResult ( ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; TestObserver < Integer > to = Maybe . fromCompletionStage ( cf ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; cf . complete ( 1 ) ; to . assertEmpty ( ) ; 
TestHelper . checkDisposed ( Maybe . fromCompletionStage ( new CompletableFuture < > ( ) ) ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Flowable . just ( 1 ) . flatMapStream ( v -> stream ) ; 
Single . just ( 1 ) . flattenStreamAsObservable ( Stream :: of ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . of ( ) ) . test ( ) . assertResult ( ) ; 
Single . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . of ( 2 , 3 , 4 , 5 , 6 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
Single . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . of ( 2 , 3 , 4 , 5 , 6 ) ) . take ( 3 ) . test ( ) . assertResult ( 2 , 3 , 4 ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Stream < ? extends Integer > > f = mock ( Function . class ) ; Single . < Integer > error ( new TestException ( ) ) . flattenStreamAsObservable ( f ) . test ( ) . assertFailure ( TestException . class ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
Single . just ( 1 ) . flattenStreamAsObservable ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Single . never ( ) . flattenStreamAsObservable ( Stream :: of ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToObservable ( m -> m . flattenStreamAsObservable ( Stream :: of ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; Single . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . < Integer > of ( ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; Single . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . < Integer > of ( v ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; Single . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . SYNC ) ; Single . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; ss . flattenStreamAsObservable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertEmpty ( ) ; ss . onSuccess ( 1 ) ; to . assertResult ( 1 , 2 , 3 ) ; 
AtomicReference < QueueDisposable < Integer > > qdr = new AtomicReference < > ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; ss . flattenStreamAsObservable ( Stream :: of ) . subscribe ( new Observer < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override @ SuppressWarnings ( "unchecked" ) public void onSubscribe ( Disposable d ) qdr . set ( ( QueueDisposable < Integer > ) d ) ; ) ; QueueDisposable < Integer > qd = qdr . get ( ) ; assertEquals ( QueueFuseable . ASYNC , qd . requestFusion ( QueueFuseable . ASYNC ) ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; ss . onSuccess ( 1 ) ; assertFalse ( qd . isEmpty ( ) ) ; assertEquals ( 1 , qd . poll ( ) . intValue ( ) ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; qd . dispose ( ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; 
AtomicReference < QueueDisposable < Integer > > qdr = new AtomicReference < > ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; ss . flattenStreamAsObservable ( v -> Stream . of ( v , v + 1 ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override @ SuppressWarnings ( "unchecked" ) public void onSubscribe ( Disposable d ) qdr . set ( ( QueueDisposable < Integer > ) d ) ; ) ; QueueDisposable < Integer > qd = qdr . get ( ) ; assertEquals ( QueueFuseable . ASYNC , qd . requestFusion ( QueueFuseable . ASYNC ) ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; ss . onSuccess ( 1 ) ; assertFalse ( qd . isEmpty ( ) ) ; assertEquals ( 1 , qd . poll ( ) . intValue ( ) ) ; assertFalse ( qd . isEmpty ( ) ) ; assertEquals ( 2 , qd . poll ( ) . intValue ( ) ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; qd . dispose ( ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; 
TestHelper . withErrorTracking ( errors -> Single . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . of ( v ) . onClose ( ( ) -> throw new TestException ( ) ; ) ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ > 0 ) throw new TestException ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Single . just ( 1 ) . flattenStreamAsObservable ( v -> stream ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; ) ; Single . just ( 1 ) . flattenStreamAsObservable ( v -> stream ) . test ( ) . assertFailure ( TestException . class ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ > 0 ) to . dispose ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Single . just ( 1 ) . flattenStreamAsObservable ( v -> stream ) . subscribeWith ( to ) . assertValuesOnly ( 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) to . dispose ( ) ; return 1 ; ) ; Single . just ( 1 ) . flattenStreamAsObservable ( v -> stream ) . subscribeWith ( to ) . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; ss . flattenStreamAsObservable ( Stream :: of ) . subscribe ( to ) ; Runnable r1 = ( ) -> ss . onSuccess ( 1 ) ; Runnable r2 = ( ) -> to . dispose ( ) ; TestHelper . race ( r1 , r2 ) ; 
Object v = Completable . complete ( ) . toCompletionStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertNull ( v ) ; 
CompletableSubject source = CompletableSubject . create ( ) ; CompletableFuture < Object > cf = source . toCompletionStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
CompletableSubject source = CompletableSubject . create ( ) ; CompletableFuture < Object > cf = source . toCompletionStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( 1 , cf . get ( ) ) ; 
CompletableSubject source = CompletableSubject . create ( ) ; CompletableFuture < Object > cf = source . toCompletionStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Object > cf = Completable . error ( new TestException ( ) ) . toCompletionStage ( null ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Object v = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . toCompletionStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertNull ( v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Object v = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; . toCompletionStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertNull ( v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Flowable . just ( 1 ) . hide ( ) . flatMapStream ( v -> stream ) ; 
Integer v = Observable . just ( 1 ) . firstStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Observable . < Integer > empty ( ) . firstStage ( 2 ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 2 , v ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . createDefault ( 1 ) ; Integer v = source . firstStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . firstStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . firstStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . firstStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Observable . < Integer > error ( new TestException ( ) ) . firstStage ( null ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . firstStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; . firstStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Integer v = Observable . just ( 1 ) . singleStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Observable . < Integer > empty ( ) . singleStage ( 2 ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 2 , v ) ; 
ReplaySubject < Integer > source = ReplaySubject . create ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( source . singleStage ( null ) . toCompletableFuture ( ) , IllegalArgumentException . class ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . singleStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . singleStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . singleStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Observable . < Integer > error ( new TestException ( ) ) . singleStage ( null ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . singleStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; . singleStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Integer v = Observable . just ( 1 ) . lastStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Observable . range ( 1 , 5 ) . lastStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 5 , v ) ; 
Integer v = Observable . < Integer > empty ( ) . lastStage ( 2 ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 2 , v ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . lastStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . lastStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . lastStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Observable . < Integer > error ( new TestException ( ) ) . lastStage ( null ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . lastStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; . lastStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Flowable . just ( 1 ) . hide ( ) . flatMapStream ( v -> stream ) ; 
TestSubscriberEx < List < Integer > > ts = Flowable . range ( 1 , 5 ) . parallel ( ) . collect ( Collectors . toList ( ) ) . subscribeWith ( new TestSubscriberEx < > ( ) ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertEquals ( 5 , ts . values ( ) . get ( 0 ) . size ( ) ) ; assertTrue ( ts . values ( ) . get ( 0 ) . containsAll ( set ( 5 ) ) ) ; 
Flowable . empty ( ) . parallel ( ) . collect ( Collectors . toList ( ) ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Flowable . error ( new TestException ( ) ) . parallel ( ) . collect ( Collectors . toList ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) throw new TestException ( ) ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . parallel ( ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> throw new TestException ( ) ; ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 1 ; i < 32 ; i ++ ) TestSubscriber < List < Integer > > ts = Flowable . range ( 1 , 1000 ) . parallel ( i ) . runOn ( Schedulers . computation ( ) ) . collect ( Collectors . toList ( ) ) . test ( ) . withTag ( "Parallelism: " + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertEquals ( 1000 , ts . values ( ) . get ( 0 ) . size ( ) ) ; assertTrue ( ts . values ( ) . get ( 0 ) . containsAll ( set ( 1000 ) ) ) ; 
for ( int i = 1 ; i < 32 ; i ++ ) TestSubscriber < List < Integer > > ts = Flowable . range ( 1 , 1000 ) . hide ( ) . parallel ( i ) . runOn ( Schedulers . computation ( ) ) . collect ( Collectors . toList ( ) ) . test ( ) . withTag ( "Parallelism: " + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertEquals ( 1000 , ts . values ( ) . get ( 0 ) . size ( ) ) ; assertTrue ( ts . values ( ) . get ( 0 ) . containsAll ( set ( 1000 ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . collect ( Collectors . toList ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
long n = 1_000 ; for ( int i = 1 ; i < 32 ; i ++ ) Flowable . rangeLong ( 1 , n ) . parallel ( i ) . runOn ( Schedulers . computation ( ) ) . collect ( Collectors . summingLong ( v -> v ) ) . test ( ) . withTag ( "Parallelism: " + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( n * ( n + 1 ) / 2 ) ; 
long n = 1_000_000 ; Flowable . rangeLong ( 1 , n ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . collect ( Collectors . summingLong ( v -> v ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( n * ( n + 1 ) / 2 ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Flowable . just ( 1 ) . flatMapStream ( v -> stream ) ; 
try ( Stream < Integer > stream = Flowable . < Integer > empty ( ) . blockingStream ( ) ) assertEquals ( 0 , stream . toArray ( ) . length ) ; 
try ( Stream < Integer > stream = Flowable . just ( 1 ) . blockingStream ( ) ) assertArrayEquals ( new Integer [ ] 1 , stream . toArray ( Integer [ ] :: new ) ) ; 
try ( Stream < Integer > stream = Flowable . range ( 1 , 5 ) . blockingStream ( ) ) assertArrayEquals ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , stream . toArray ( Integer [ ] :: new ) ) ; 
try ( Stream < Integer > stream = Flowable . range ( 1 , 5 ) . blockingStream ( 1 ) ) assertArrayEquals ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , stream . toArray ( Integer [ ] :: new ) ) ; 
try ( Stream < Integer > stream = Flowable . range ( 1 , 1000 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingStream ( ) ) List < Integer > list = stream . collect ( Collectors . toList ( ) ) ; assertEquals ( 1000 , list . size ( ) ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) assertEquals ( i , list . get ( i - 1 ) . intValue ( ) ) ; 
try ( Stream < Integer > stream = Flowable . range ( 1 , 1000 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingStream ( 1 ) ) List < Integer > list = stream . collect ( Collectors . toList ( ) ) ; assertEquals ( 1000 , list . size ( ) ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) assertEquals ( i , list . get ( i - 1 ) . intValue ( ) ) ; 
try ( Stream < Integer > stream = Flowable . < Integer > error ( new TestException ( ) ) . blockingStream ( ) ) stream . toArray ( Integer [ ] :: new ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onNext ( 3 ) ; up . onNext ( 4 ) ; up . onNext ( 5 ) ; try ( Stream < Integer > stream = up . blockingStream ( ) ) assertArrayEquals ( new Integer [ ] 1 , 2 , 3 , stream . limit ( 3 ) . toArray ( Integer [ ] :: new ) ) ; assertFalse ( up . hasSubscribers ( ) ) ; 
return 1 ; 
Flowable . fromStream ( Stream . < Integer > of ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . fromStream ( Stream . < Integer > of ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . fromStream ( Stream . < Integer > of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . fromStream ( Stream . < Integer > of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 1 ) . assertValuesOnly ( 1 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 ) . requestMore ( 2 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable < Integer > source = Flowable . fromStream ( Stream . < Integer > of ( 1 , 2 , 3 , 4 , 5 ) ) ; source . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; source . test ( ) . assertFailure ( IllegalStateException . class ) ; 
Flowable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . fromStream ( Stream . < Integer > of ( ) ) . filter ( v -> true ) . test ( ) . assertResult ( ) ; 
Flowable . fromStream ( Stream . < Integer > of ( 1 ) ) . filter ( v -> true ) . test ( ) . assertResult ( 1 ) ; 
Flowable . fromStream ( Stream . < Integer > of ( 1 , 2 , 3 , 4 , 5 ) ) . filter ( v -> true ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . fromStream ( Stream . < Integer > of ( 1 , 2 , 3 , 4 , 5 ) ) . filter ( v -> true ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 1 ) . assertValuesOnly ( 1 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 ) . requestMore ( 2 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . filter ( v -> v % 2 == 0 ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
Flowable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . filter ( v -> true ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
AtomicReference < SimpleQueue < ? > > queue = new AtomicReference < > ( ) ; Flowable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( @ NonNull Subscription s ) queue . set ( ( SimpleQueue < ? > ) s ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; SimpleQueue < ? > q = queue . get ( ) ; TestHelper . assertNoOffer ( q ) ; assertFalse ( q . isEmpty ( ) ) ; q . clear ( ) ; assertNull ( q . poll ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; q . clear ( ) ; assertNull ( q . poll ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; 
AtomicReference < SimpleQueue < ? > > queue = new AtomicReference < > ( ) ; AtomicInteger calls = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . of ( 1 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( @ NonNull Subscription s ) queue . set ( ( SimpleQueue < ? > ) s ) ; ( ( QueueSubscription < ? > ) s ) . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; SimpleQueue < ? > q = queue . get ( ) ; assertFalse ( q . isEmpty ( ) ) ; assertEquals ( 1 , q . poll ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; assertEquals ( 1 , calls . get ( ) ) ; 
Flowable . fromStream ( Stream . of ( ( Integer ) null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable . fromStream ( Stream . of ( ( Integer ) null ) ) . filter ( v -> true ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . subscribeWith ( ts ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . subscribeWith ( ts ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . fromStream ( IntStream . rangeClosed ( 1 , 1000 ) . boxed ( ) ) . parallel ( ) . runOn ( Schedulers . computation ( ) , 1 ) . map ( v -> v + 1 ) . sequential ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . withErrorTracking ( errors -> Stream < Integer > stream = Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> throw new TestException ( ) ; ) ; Flowable . fromStream ( stream ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Stream < Integer > stream = Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> throw new TestException ( ) ; ) ; Flowable . fromStream ( stream ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
AtomicInteger v = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . < Integer > generate ( ( ) -> int value = v . getAndIncrement ( ) ; if ( value == 1 ) throw new TestException ( ) ; return value ; ) ) . test ( ) . assertFailure ( TestException . class , 0 ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . < Integer > generate ( ( ) -> int value = counter . getAndIncrement ( ) ; if ( value == 1 ) throw new TestException ( ) ; return value ; ) ) . filter ( v -> true ) . test ( ) . assertFailure ( TestException . class , 0 ) ; 
requestOneByOneBase ( false ) ; 
requestOneByOneBase ( true ) ; 
requestRaceBase ( false ) ; 
requestRaceBase ( true ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . of ( ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . < Integer > generate ( ( ) -> int value = counter . getAndIncrement ( ) ; if ( value == 1 ) throw new TestException ( ) ; return value ; ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . test ( ) . assertFailure ( TestException . class , 0 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . filter ( v -> true ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . filter ( v -> true ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; Flowable . fromStream ( Stream . < Integer > generate ( ( ) -> int value = counter . getAndIncrement ( ) ; if ( value == 1 ) throw new TestException ( ) ; return value ; ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . filter ( v -> true ) . test ( ) . assertFailure ( TestException . class , 0 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . fromStream ( Stream . of ( 1 ) ) ) ; 
return 0 ; 
Single . fromCompletionStage ( CompletableFuture . completedFuture ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; cf . completeExceptionally ( new TestException ( ) ) ; Single . fromCompletionStage ( cf ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . fromCompletionStage ( CompletableFuture . < Integer > completedFuture ( null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
CompletableFuture < Integer > cf = new CompletableFuture < > ( ) ; TestObserver < Integer > to = Single . fromCompletionStage ( cf ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; cf . complete ( 1 ) ; to . assertEmpty ( ) ; 
TestHelper . checkDisposed ( Single . fromCompletionStage ( new CompletableFuture < > ( ) ) ) ; 
Integer v = Flowable . just ( 1 ) . firstStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Flowable . < Integer > empty ( ) . firstStage ( 2 ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 2 , v ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; Integer v = source . firstStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . firstStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . firstStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . firstStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Flowable . < Integer > error ( new TestException ( ) ) . firstStage ( null ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; . firstStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; . firstStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Integer v = Flowable . just ( 1 ) . singleStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Flowable . < Integer > empty ( ) . singleStage ( 2 ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 2 , v ) ; 
ReplayProcessor < Integer > source = ReplayProcessor . create ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( source . singleStage ( null ) . toCompletableFuture ( ) , IllegalArgumentException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . singleStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . singleStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . singleStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Flowable . < Integer > error ( new TestException ( ) ) . singleStage ( null ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; . singleStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; . singleStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Integer v = Flowable . just ( 1 ) . lastStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Flowable . range ( 1 , 5 ) . lastStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 5 , v ) ; 
Integer v = Flowable . < Integer > empty ( ) . lastStage ( 2 ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 2 , v ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . lastStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . lastStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; CompletableFuture < Integer > cf = source . lastStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasSubscribers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasSubscribers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Flowable . < Integer > error ( new TestException ( ) ) . lastStage ( null ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; . lastStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; . lastStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Flowable . just ( 1 ) . flatMapStream ( v -> stream ) ; 
Flowable . range ( 1 , 10 ) . parallel ( ) . mapOptional ( Optional :: of ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 3 == 0 ; ) . sequential ( ) . test ( ) . assertResult ( 6 ) ; 
Flowable . range ( 1 , 10 ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . mapOptional ( Optional :: of ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 3 == 0 ; ) . sequential ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 6 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . mapOptional ( Optional :: of ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . mapOptional ( Optional :: of ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . error ( new TestException ( ) ) . parallel ( ) . mapOptional ( Optional :: of ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . parallel ( ) . mapOptional ( v -> throw new TestException ( ) ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . parallel ( ) . mapOptional ( v -> throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . mapOptional ( v -> throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> Optional . empty ( ) ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> Optional . empty ( ) ) . filter ( v -> true ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> v % 2 == 0 ? Optional . of ( v ) : Optional . empty ( ) ) . sequential ( ) . test ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( ) . mapOptional ( v -> v % 2 == 0 ? Optional . of ( v ) : Optional . empty ( ) ) . filter ( v -> true ) . sequential ( ) . test ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . range ( 1 , 10 ) . parallel ( ) . mapOptional ( Optional :: of ) ) ; 
TestHelper . checkDoubleOnSubscribeParallel ( p -> p . mapOptional ( Optional :: of ) ) ; TestHelper . checkDoubleOnSubscribeParallel ( p -> p . mapOptional ( Optional :: of ) . filter ( v -> true ) ) ; 
Integer v = Observable . just ( 1 ) . firstOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
TestHelper . assertError ( Observable . < Integer > empty ( ) . firstOrErrorStage ( ) . toCompletableFuture ( ) , NoSuchElementException . class ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . createDefault ( 1 ) ; Integer v = source . firstOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . firstOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . firstOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . firstOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Observable . < Integer > error ( new TestException ( ) ) . firstOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . firstOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; . firstOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Integer v = Observable . just ( 1 ) . singleOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
TestHelper . assertError ( Observable . < Integer > empty ( ) . singleOrErrorStage ( ) . toCompletableFuture ( ) , NoSuchElementException . class ) ; 
ReplaySubject < Integer > source = ReplaySubject . create ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( source . singleOrErrorStage ( ) . toCompletableFuture ( ) , IllegalArgumentException . class ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . singleOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . singleOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . singleOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Observable . < Integer > error ( new TestException ( ) ) . singleOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . singleOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; . singleOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Integer v = Observable . just ( 1 ) . lastOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Observable . range ( 1 , 5 ) . lastOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 5 , v ) ; 
TestHelper . assertError ( Observable . < Integer > empty ( ) . lastOrErrorStage ( ) . toCompletableFuture ( ) , NoSuchElementException . class ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . lastOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . lastOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; CompletableFuture < Integer > cf = source . lastOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Observable . < Integer > error ( new TestException ( ) ) . lastOrErrorStage ( ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . lastOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; . lastOrErrorStage ( ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( v -> Optional . < Integer > empty ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . mapOptional ( MODULO ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . mapOptional ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . mapOptional ( v -> null ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
Flowable < Integer > source = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; ; source . mapOptional ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 , 4 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( v -> Optional . empty ( ) ) . test ( 1L ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . mapOptional ( MODULO ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 2 , 4 ) . requestMore ( 2 ) . assertValuesOnly ( 2 , 4 , 6 , 8 ) . requestMore ( 1 ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . mapOptional ( Optional :: of ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . mapOptional ( Optional :: of ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( v -> Optional . empty ( ) ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . mapOptional ( v -> Optional . empty ( ) ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . mapOptional ( v -> Optional . empty ( ) ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . mapOptional ( MODULO ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; up . mapOptional ( MODULO ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; up . mapOptional ( MODULO ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . filter ( v -> true ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( v -> Optional . < Integer > empty ( ) ) . filter ( v -> true ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . mapOptional ( MODULO ) . filter ( v -> true ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . mapOptional ( v -> throw new TestException ( ) ; ) . filter ( v -> true ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . mapOptional ( v -> null ) . filter ( v -> true ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
Flowable < Integer > source = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; ; source . mapOptional ( v -> throw new TestException ( ) ; ) . filter ( v -> true ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . filter ( v -> true ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 , 4 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( v -> Optional . empty ( ) ) . filter ( v -> true ) . test ( 1L ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . mapOptional ( MODULO ) . filter ( v -> true ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 2 , 4 ) . requestMore ( 2 ) . assertValuesOnly ( 2 , 4 , 6 , 8 ) . requestMore ( 1 ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . mapOptional ( Optional :: of ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . mapOptional ( Optional :: of ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . mapOptional ( v -> Optional . empty ( ) ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . mapOptional ( v -> Optional . empty ( ) ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . mapOptional ( v -> Optional . empty ( ) ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . mapOptional ( MODULO ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; up . mapOptional ( MODULO ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; up . mapOptional ( MODULO ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . empty ( ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . filter ( v -> true ) . mapOptional ( Optional :: of ) . filter ( v -> true ) . subscribe ( ts ) ; ts . assertResult ( ) ; 
Maybe . just ( 1 ) . flattenStreamAsObservable ( Stream :: of ) . test ( ) . assertResult ( 1 ) ; 
Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . of ( ) ) . test ( ) . assertResult ( ) ; 
Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . of ( 2 , 3 , 4 , 5 , 6 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . of ( 2 , 3 , 4 , 5 , 6 ) ) . take ( 3 ) . test ( ) . assertResult ( 2 , 3 , 4 ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Stream < ? extends Integer > > f = mock ( Function . class ) ; Maybe . < Integer > empty ( ) . flattenStreamAsObservable ( f ) . test ( ) . assertResult ( ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Stream < ? extends Integer > > f = mock ( Function . class ) ; Maybe . < Integer > error ( new TestException ( ) ) . flattenStreamAsObservable ( f ) . test ( ) . assertFailure ( TestException . class ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Maybe . never ( ) . flattenStreamAsObservable ( Stream :: of ) ) ; 
TestHelper . checkDoubleOnSubscribeMaybeToObservable ( m -> m . flattenStreamAsObservable ( Stream :: of ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . < Integer > of ( ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . < Integer > of ( v ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . SYNC ) ; Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; ms . flattenStreamAsObservable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; to . assertResult ( 1 , 2 , 3 ) ; 
AtomicReference < QueueDisposable < Integer > > qdr = new AtomicReference < > ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; ms . flattenStreamAsObservable ( Stream :: of ) . subscribe ( new Observer < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override @ SuppressWarnings ( "unchecked" ) public void onSubscribe ( Disposable d ) qdr . set ( ( QueueDisposable < Integer > ) d ) ; ) ; QueueDisposable < Integer > qd = qdr . get ( ) ; assertEquals ( QueueFuseable . ASYNC , qd . requestFusion ( QueueFuseable . ASYNC ) ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; ms . onSuccess ( 1 ) ; assertFalse ( qd . isEmpty ( ) ) ; assertEquals ( 1 , qd . poll ( ) . intValue ( ) ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; qd . dispose ( ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; 
AtomicReference < QueueDisposable < Integer > > qdr = new AtomicReference < > ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; ms . flattenStreamAsObservable ( v -> Stream . of ( v , v + 1 ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override @ SuppressWarnings ( "unchecked" ) public void onSubscribe ( Disposable d ) qdr . set ( ( QueueDisposable < Integer > ) d ) ; ) ; QueueDisposable < Integer > qd = qdr . get ( ) ; assertEquals ( QueueFuseable . ASYNC , qd . requestFusion ( QueueFuseable . ASYNC ) ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; ms . onSuccess ( 1 ) ; assertFalse ( qd . isEmpty ( ) ) ; assertEquals ( 1 , qd . poll ( ) . intValue ( ) ) ; assertFalse ( qd . isEmpty ( ) ) ; assertEquals ( 2 , qd . poll ( ) . intValue ( ) ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; qd . dispose ( ) ; assertTrue ( qd . isEmpty ( ) ) ; assertNull ( qd . poll ( ) ) ; 
TestHelper . withErrorTracking ( errors -> Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> Stream . of ( v ) . onClose ( ( ) -> throw new TestException ( ) ; ) ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ > 0 ) throw new TestException ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> stream ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; ) ; Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> stream ) . test ( ) . assertFailure ( TestException . class ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ > 0 ) to . dispose ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> stream ) . subscribeWith ( to ) . assertValuesOnly ( 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) to . dispose ( ) ; return 1 ; ) ; Maybe . just ( 1 ) . flattenStreamAsObservable ( v -> stream ) . subscribeWith ( to ) . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; ms . flattenStreamAsObservable ( Stream :: of ) . subscribe ( to ) ; Runnable r1 = ( ) -> ms . onSuccess ( 1 ) ; Runnable r2 = ( ) -> to . dispose ( ) ; TestHelper . race ( r1 , r2 ) ; 
Integer v = Maybe . just ( 1 ) . toCompletionStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; 
Integer v = Maybe . < Integer > empty ( ) . toCompletionStage ( 2 ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 2 , v ) ; 
CompletableFuture < Integer > cf = Maybe . < Integer > empty ( ) . toCompletionStage ( ) . toCompletableFuture ( ) ; TestHelper . assertError ( cf , NoSuchElementException . class ) ; 
MaybeSubject < Integer > source = MaybeSubject . create ( ) ; CompletableFuture < Integer > cf = source . toCompletionStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . cancel ( true ) ; assertTrue ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; 
MaybeSubject < Integer > source = MaybeSubject . create ( ) ; CompletableFuture < Integer > cf = source . toCompletionStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . complete ( 1 ) ; assertTrue ( cf . isDone ( ) ) ; assertFalse ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; assertEquals ( ( Integer ) 1 , cf . get ( ) ) ; 
MaybeSubject < Integer > source = MaybeSubject . create ( ) ; CompletableFuture < Integer > cf = source . toCompletionStage ( null ) . toCompletableFuture ( ) ; assertTrue ( source . hasObservers ( ) ) ; cf . completeExceptionally ( new TestException ( ) ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; assertFalse ( source . hasObservers ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
CompletableFuture < Integer > cf = Maybe . < Integer > error ( new TestException ( ) ) . toCompletionStage ( null ) . toCompletableFuture ( ) ; assertTrue ( cf . isDone ( ) ) ; assertTrue ( cf . isCompletedExceptionally ( ) ) ; assertFalse ( cf . isCancelled ( ) ) ; TestHelper . assertError ( cf , TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . toCompletionStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Integer v = new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; . toCompletionStage ( null ) . toCompletableFuture ( ) . get ( ) ; assertEquals ( ( Integer ) 1 , v ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; ) ; 
return Flowable . < Integer > error ( new TestException ( ) ) . collect ( Collectors . toList ( ) ) . toFlowable ( ) ; 
return 1 ; 
Observable . fromStream ( Stream . < Integer > of ( ) ) . test ( ) . assertResult ( ) ; 
Observable . fromStream ( Stream . < Integer > of ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . fromStream ( Stream . < Integer > of ( 1 , 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable < Integer > source = Observable . fromStream ( Stream . < Integer > of ( 1 , 2 , 3 , 4 , 5 ) ) ; source . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; source . test ( ) . assertFailure ( IllegalStateException . class ) ; 
Observable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . fromStream ( Stream . < Integer > of ( ) ) . filter ( v -> true ) . test ( ) . assertResult ( ) ; 
Observable . fromStream ( Stream . < Integer > of ( 1 ) ) . filter ( v -> true ) . test ( ) . assertResult ( 1 ) ; 
Observable . fromStream ( Stream . < Integer > of ( 1 , 2 , 3 , 4 , 5 ) ) . filter ( v -> true ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . filter ( v -> v % 2 == 0 ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
Observable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . filter ( v -> true ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
AtomicReference < SimpleQueue < ? > > queue = new AtomicReference < > ( ) ; Observable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( @ NonNull Disposable d ) queue . set ( ( SimpleQueue < ? > ) d ) ; ( ( QueueDisposable < ? > ) d ) . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; SimpleQueue < ? > q = queue . get ( ) ; TestHelper . assertNoOffer ( q ) ; assertFalse ( q . isEmpty ( ) ) ; q . clear ( ) ; assertNull ( q . poll ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; q . clear ( ) ; assertNull ( q . poll ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; 
AtomicReference < SimpleQueue < ? > > queue = new AtomicReference < > ( ) ; AtomicInteger calls = new AtomicInteger ( ) ; Observable . fromStream ( Stream . of ( 1 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( @ NonNull Disposable d ) queue . set ( ( SimpleQueue < ? > ) d ) ; ( ( QueueDisposable < ? > ) d ) . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; SimpleQueue < ? > q = queue . get ( ) ; assertFalse ( q . isEmpty ( ) ) ; assertEquals ( 1 , q . poll ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicReference < SimpleQueue < ? > > queue = new AtomicReference < > ( ) ; AtomicInteger calls = new AtomicInteger ( ) ; Observable . fromStream ( Stream . of ( 1 , 2 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( @ NonNull Disposable d ) queue . set ( ( SimpleQueue < ? > ) d ) ; ( ( QueueDisposable < ? > ) d ) . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; SimpleQueue < ? > q = queue . get ( ) ; assertFalse ( q . isEmpty ( ) ) ; assertEquals ( 1 , q . poll ( ) ) ; assertFalse ( q . isEmpty ( ) ) ; assertEquals ( 2 , q . poll ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; assertEquals ( 1 , calls . get ( ) ) ; 
Observable . fromStream ( Stream . of ( ( Integer ) null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . fromStream ( Stream . of ( ( Integer ) null ) ) . filter ( v -> true ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; Observable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . subscribeWith ( to ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Observable . fromStream ( IntStream . rangeClosed ( 1 , 10 ) . boxed ( ) ) . subscribeWith ( to ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestHelper . withErrorTracking ( errors -> Stream < Integer > stream = Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> throw new TestException ( ) ; ) ; Observable . fromStream ( stream ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Stream < Integer > stream = Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> throw new TestException ( ) ; ) ; Observable . fromStream ( stream ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
AtomicInteger v = new AtomicInteger ( ) ; Observable . fromStream ( Stream . < Integer > generate ( ( ) -> int value = v . getAndIncrement ( ) ; if ( value == 1 ) throw new TestException ( ) ; return value ; ) ) . test ( ) . assertFailure ( TestException . class , 0 ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; Observable . fromStream ( Stream . < Integer > generate ( ( ) -> int value = counter . getAndIncrement ( ) ; if ( value == 1 ) throw new TestException ( ) ; return value ; ) ) . filter ( v -> true ) . test ( ) . assertFailure ( TestException . class , 0 ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Observable . fromStream ( Stream . of ( ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Observable . fromStream ( Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Observable . fromStream ( Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; Observable . fromStream ( Stream . < Integer > generate ( ( ) -> int value = counter . getAndIncrement ( ) ; if ( value == 1 ) throw new TestException ( ) ; return value ; ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . test ( ) . assertFailure ( TestException . class , 0 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Observable . fromStream ( Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . filter ( v -> true ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; Observable . fromStream ( Stream . of ( 1 , 2 , 3 , 4 , 5 ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . filter ( v -> true ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
AtomicInteger calls = new AtomicInteger ( ) ; AtomicInteger counter = new AtomicInteger ( ) ; Observable . fromStream ( Stream . < Integer > generate ( ( ) -> int value = counter . getAndIncrement ( ) ; if ( value == 1 ) throw new TestException ( ) ; return value ; ) . onClose ( ( ) -> calls . getAndIncrement ( ) ) ) . filter ( v -> true ) . test ( ) . assertFailure ( TestException . class , 0 ) ; assertEquals ( 1 , calls . get ( ) ) ; 
TestHelper . checkDisposed ( Observable . fromStream ( Stream . of ( 1 ) ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; @ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) to . dispose ( ) ; return 1 ; ) ; Observable . fromStream ( stream ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; @ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int calls ; @ Override public boolean hasNext ( ) if ( ++ calls == 1 ) to . dispose ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Observable . fromStream ( stream ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
Observable . range ( 1 , 5 ) . collect ( Collectors . toList ( ) ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Observable . empty ( ) . collect ( Collectors . toList ( ) ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Observable . error ( new TestException ( ) ) . collect ( Collectors . toList ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 5 ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) throw new TestException ( ) ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
Observable . range ( 1 , 5 ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> throw new TestException ( ) ; ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Observable < Integer > source = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; ; source . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . collect ( Collectors . toList ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservableToSingle ( f -> f . collect ( Collectors . toList ( ) ) ) ; 
Observable . range ( 1 , 5 ) . collect ( Collectors . toList ( ) ) . toObservable ( ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Observable . empty ( ) . collect ( Collectors . toList ( ) ) . toObservable ( ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Observable . error ( new TestException ( ) ) . collect ( Collectors . toList ( ) ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 5 ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) throw new TestException ( ) ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
BehaviorProcessor < Integer > source = BehaviorProcessor . createDefault ( 1 ) ; source . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; 
Observable . range ( 1 , 5 ) . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> throw new TestException ( ) ; ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Observable < Integer > source = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; ; source . collect ( new Collector < Integer , Integer , Integer > ( ) @ Override public Supplier < Integer > supplier ( ) return ( ) -> 1 ; @ Override public BiConsumer < Integer , Integer > accumulator ( ) return ( a , b ) -> throw new TestException ( ) ; ; @ Override public BinaryOperator < Integer > combiner ( ) return ( a , b ) -> a + b ; @ Override public Function < Integer , Integer > finisher ( ) return a -> a ; @ Override public Set < Characteristics > characteristics ( ) return Collections . emptySet ( ) ; ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . collect ( Collectors . toList ( ) ) . toObservable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( f -> f . collect ( Collectors . toList ( ) ) . toObservable ( ) ) ; 
Observable . range ( 1 , 5 ) . collect ( Collectors . toList ( ) ) . toObservable ( ) . take ( 1 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
TestObserver < List < Integer > > to = Observable . range ( 1 , 5 ) . concatWith ( Observable . never ( ) ) . collect ( Collectors . toList ( ) ) . test ( ) ; to . dispose ( ) ; to . assertEmpty ( ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Single . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) ; 
Flowable . fromOptional ( Optional . of ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . fromOptional ( Optional . empty ( ) ) . test ( ) . assertResult ( ) ; 
Single . just ( 1 ) . flattenStreamAsFlowable ( Stream :: of ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( ) ) . test ( ) . assertResult ( ) ; 
Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( 2 , 3 , 4 , 5 , 6 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( 2 , 3 , 4 , 5 , 6 ) ) . take ( 3 ) . test ( ) . assertResult ( 2 , 3 , 4 ) ; 
@ SuppressWarnings ( "unchecked" ) Function < ? super Integer , Stream < ? extends Integer > > f = mock ( Function . class ) ; Single . < Integer > error ( new TestException ( ) ) . flattenStreamAsFlowable ( f ) . test ( ) . assertFailure ( TestException . class ) ; verify ( f , never ( ) ) . apply ( any ( ) ) ; 
Single . just ( 1 ) . flattenStreamAsFlowable ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Single . never ( ) . flattenStreamAsFlowable ( Stream :: of ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToFlowable ( m -> m . flattenStreamAsFlowable ( Stream :: of ) ) ; 
TestHelper . assertBadRequestReported ( SingleSubject . create ( ) . flattenStreamAsFlowable ( Stream :: of ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( v ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 ) ; 
Single . just ( 1 ) . flattenStreamAsFlowable ( v -> IntStream . rangeClosed ( 1 , 5 ) . boxed ( ) ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 , 4 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Single . just ( 1 ) . flattenStreamAsFlowable ( v -> IntStream . rangeClosed ( 1 , 5 ) . boxed ( ) ) . rebatchRequests ( 1 ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 , 3 , 4 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; ss . flattenStreamAsFlowable ( v -> Stream . < Integer > of ( v , v + 1 , v + 2 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertEmpty ( ) ; ss . onSuccess ( 1 ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
AtomicReference < QueueSubscription < Integer > > qsr = new AtomicReference < > ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; ss . flattenStreamAsFlowable ( Stream :: of ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override @ SuppressWarnings ( "unchecked" ) public void onSubscribe ( @ NonNull Subscription s ) qsr . set ( ( QueueSubscription < Integer > ) s ) ; ) ; QueueSubscription < Integer > qs = qsr . get ( ) ; assertEquals ( QueueFuseable . ASYNC , qs . requestFusion ( QueueFuseable . ASYNC ) ) ; assertTrue ( qs . isEmpty ( ) ) ; assertNull ( qs . poll ( ) ) ; ss . onSuccess ( 1 ) ; assertFalse ( qs . isEmpty ( ) ) ; assertEquals ( 1 , qs . poll ( ) . intValue ( ) ) ; assertTrue ( qs . isEmpty ( ) ) ; assertNull ( qs . poll ( ) ) ; qs . cancel ( ) ; assertTrue ( qs . isEmpty ( ) ) ; assertNull ( qs . poll ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( 1 , 2 , 3 , 4 , 5 ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) Subscription upstream ; @ Override public void onSubscribe ( @ NonNull Subscription s ) ts . onSubscribe ( new BooleanSubscription ( ) ) ; upstream = s ; s . request ( 1 ) ; @ Override public void onNext ( Integer t ) ts . onNext ( t ) ; upstream . request ( 1 ) ; @ Override public void onError ( Throwable t ) ts . onError ( t ) ; @ Override public void onComplete ( ) ts . onComplete ( ) ; ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . withErrorTracking ( errors -> Single . just ( 1 ) . flattenStreamAsFlowable ( v -> Stream . of ( v ) . onClose ( ( ) -> throw new TestException ( ) ; ) ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ > 0 ) throw new TestException ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) . test ( ) . assertFailure ( TestException . class ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ > 0 ) ts . cancel ( ) ; return true ; @ Override public Integer next ( ) return 1 ; ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) . subscribeWith ( ts ) . assertValuesOnly ( 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Stream < Integer > stream = mock ( Stream . class ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; when ( stream . iterator ( ) ) . thenReturn ( new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) ts . cancel ( ) ; return 1 ; ) ; Single . just ( 1 ) . flattenStreamAsFlowable ( v -> stream ) . subscribeWith ( ts ) . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ss . flattenStreamAsFlowable ( Stream :: of ) . subscribe ( ts ) ; Runnable r1 = ( ) -> ss . onSuccess ( 1 ) ; Runnable r2 = ( ) -> ts . request ( 1 ) ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 ) ; 
Stream < Integer > stream = Stream . of ( 1 ) ; stream . forEach ( v -> ) ; return Flowable . fromStream ( stream ) ; 
Observable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . mapOptional ( v -> Optional . < Integer > empty ( ) ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 10 ) . mapOptional ( MODULO ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . createDefault ( 1 ) ; source . mapOptional ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasObservers ( ) ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . createDefault ( 1 ) ; source . mapOptional ( v -> null ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertFalse ( source . hasObservers ( ) ) ; 
Observable < Integer > source = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; ; source . mapOptional ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . mapOptional ( Optional :: of ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . mapOptional ( Optional :: of ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . mapOptional ( v -> Optional . empty ( ) ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . mapOptional ( v -> Optional . empty ( ) ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . mapOptional ( v -> Optional . empty ( ) ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; 
Observable . range ( 1 , 10 ) . mapOptional ( MODULO ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; us . mapOptional ( MODULO ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; us . mapOptional ( MODULO ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
Observable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . filter ( v -> true ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . mapOptional ( v -> Optional . < Integer > empty ( ) ) . filter ( v -> true ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 10 ) . mapOptional ( MODULO ) . filter ( v -> true ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . createDefault ( 1 ) ; source . mapOptional ( v -> throw new TestException ( ) ; ) . filter ( v -> true ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( source . hasObservers ( ) ) ; 
BehaviorSubject < Integer > source = BehaviorSubject . createDefault ( 1 ) ; source . mapOptional ( v -> null ) . filter ( v -> true ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertFalse ( source . hasObservers ( ) ) ; 
Observable < Integer > source = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; ; source . mapOptional ( v -> throw new TestException ( ) ; ) . filter ( v -> true ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 5 ) . mapOptional ( Optional :: of ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . mapOptional ( Optional :: of ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . mapOptional ( Optional :: of ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . mapOptional ( v -> Optional . empty ( ) ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . mapOptional ( v -> Optional . empty ( ) ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . mapOptional ( v -> Optional . empty ( ) ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; 
Observable . range ( 1 , 10 ) . mapOptional ( MODULO ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; us . mapOptional ( MODULO ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; us . mapOptional ( MODULO ) . filter ( v -> true ) . to ( TestHelper . testConsumer ( false , QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
ArrayCompositeDisposable acd = new ArrayCompositeDisposable ( 2 ) ; Disposable d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; assertTrue ( acd . setResource ( 0 , d1 ) ) ; assertTrue ( acd . setResource ( 1 , d2 ) ) ; Disposable d3 = Disposable . empty ( ) ; Disposable d4 = Disposable . empty ( ) ; acd . replaceResource ( 0 , d3 ) ; acd . replaceResource ( 1 , d4 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertFalse ( d2 . isDisposed ( ) ) ; acd . setResource ( 0 , d1 ) ; acd . setResource ( 1 , d2 ) ; assertTrue ( d3 . isDisposed ( ) ) ; assertTrue ( d4 . isDisposed ( ) ) ; assertFalse ( acd . isDisposed ( ) ) ; acd . dispose ( ) ; acd . dispose ( ) ; assertTrue ( acd . isDisposed ( ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; Disposable d5 = Disposable . empty ( ) ; Disposable d6 = Disposable . empty ( ) ; assertFalse ( acd . setResource ( 0 , d5 ) ) ; acd . replaceResource ( 1 , d6 ) ; assertTrue ( d5 . isDisposed ( ) ) ; assertTrue ( d6 . isDisposed ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ArrayCompositeDisposable acd = new ArrayCompositeDisposable ( 2 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) acd . dispose ( ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ArrayCompositeDisposable acd = new ArrayCompositeDisposable ( 2 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) acd . replaceResource ( 0 , Disposable . empty ( ) ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ArrayCompositeDisposable acd = new ArrayCompositeDisposable ( 2 ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) acd . setResource ( 0 , Disposable . empty ( ) ) ; ; TestHelper . race ( r , r ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Cancellable c = new Cancellable ( ) @ Override public void cancel ( ) throws Exception count . getAndIncrement ( ) ; ; CancellableDisposable cd = new CancellableDisposable ( c ) ; assertFalse ( cd . isDisposed ( ) ) ; cd . dispose ( ) ; cd . dispose ( ) ; assertTrue ( cd . isDisposed ( ) ) ; assertEquals ( 1 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Cancellable c = new Cancellable ( ) @ Override public void cancel ( ) throws Exception count . getAndIncrement ( ) ; throw new TestException ( ) ; ; CancellableDisposable cd = new CancellableDisposable ( c ) ; assertFalse ( cd . isDisposed ( ) ) ; List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try cd . dispose ( ) ; cd . dispose ( ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; assertTrue ( cd . isDisposed ( ) ) ; assertEquals ( 1 , count . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicInteger count = new AtomicInteger ( ) ; Cancellable c = new Cancellable ( ) @ Override public void cancel ( ) throws Exception count . getAndIncrement ( ) ; ; final CancellableDisposable cd = new CancellableDisposable ( c ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; TestHelper . race ( r , r ) ; assertEquals ( 1 , count . get ( ) ) ; 
TestHelper . assertNoOffer ( EmptyDisposable . INSTANCE ) ; 
assertEquals ( QueueFuseable . NONE , EmptyDisposable . INSTANCE . requestFusion ( QueueFuseable . SYNC ) ) ; assertEquals ( QueueFuseable . ASYNC , EmptyDisposable . INSTANCE . requestFusion ( QueueFuseable . ASYNC ) ) ; 
assertEquals ( 2 , EmptyDisposable . values ( ) . length ) ; assertNotNull ( EmptyDisposable . valueOf ( "INSTANCE" ) ) ; assertNotNull ( EmptyDisposable . valueOf ( "NEVER" ) ) ; 
assertEquals ( 1 , DisposableHelper . values ( ) . length ) ; assertNotNull ( DisposableHelper . valueOf ( "DISPOSED" ) ) ; 
assertTrue ( DisposableHelper . DISPOSED . isDisposed ( ) ) ; DisposableHelper . DISPOSED . dispose ( ) ; assertTrue ( DisposableHelper . DISPOSED . isDisposed ( ) ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try assertFalse ( DisposableHelper . validate ( null , null ) ) ; TestHelper . assertError ( list , 0 , NullPointerException . class , "next is null" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Disposable > d = new AtomicReference < > ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) DisposableHelper . dispose ( d ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Disposable > d = new AtomicReference < > ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) DisposableHelper . replace ( d , Disposable . empty ( ) ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final AtomicReference < Disposable > d = new AtomicReference < > ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) DisposableHelper . set ( d , Disposable . empty ( ) ) ; ; TestHelper . race ( r , r ) ; 
final AtomicReference < Disposable > d = new AtomicReference < > ( ) ; DisposableHelper . dispose ( d ) ; assertFalse ( DisposableHelper . set ( d , null ) ) ; assertFalse ( DisposableHelper . replace ( d , null ) ) ; 
Disposable u = Disposable . empty ( ) ; final AtomicReference < Disposable > d = new AtomicReference < > ( u ) ; DisposableHelper . dispose ( d ) ; assertTrue ( u . isDisposed ( ) ) ; 
AtomicReference < Disposable > ref = new AtomicReference < > ( ) ; Disposable d1 = Disposable . empty ( ) ; assertTrue ( DisposableHelper . trySet ( ref , d1 ) ) ; Disposable d2 = Disposable . empty ( ) ; assertFalse ( DisposableHelper . trySet ( ref , d2 ) ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertFalse ( d2 . isDisposed ( ) ) ; DisposableHelper . dispose ( ref ) ; Disposable d3 = Disposable . empty ( ) ; assertFalse ( DisposableHelper . trySet ( ref , d3 ) ) ; assertTrue ( d3 . isDisposed ( ) ) ; 
Disposable d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; ListCompositeDisposable lcd = new ListCompositeDisposable ( d1 , d2 ) ; lcd . clear ( ) ; assertFalse ( lcd . isDisposed ( ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; d1 = Disposable . empty ( ) ; d2 = Disposable . empty ( ) ; lcd . addAll ( d1 , d2 ) ; lcd . dispose ( ) ; assertTrue ( lcd . isDisposed ( ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; 
Disposable d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; ListCompositeDisposable lcd = new ListCompositeDisposable ( Arrays . asList ( d1 , d2 ) ) ; lcd . clear ( ) ; assertFalse ( lcd . isDisposed ( ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; d1 = Disposable . empty ( ) ; d2 = Disposable . empty ( ) ; lcd . add ( d1 ) ; lcd . addAll ( d2 ) ; lcd . dispose ( ) ; assertTrue ( lcd . isDisposed ( ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; 
ListCompositeDisposable lcd = new ListCompositeDisposable ( ) ; assertFalse ( lcd . isDisposed ( ) ) ; lcd . clear ( ) ; assertFalse ( lcd . isDisposed ( ) ) ; lcd . dispose ( ) ; lcd . dispose ( ) ; lcd . clear ( ) ; assertTrue ( lcd . isDisposed ( ) ) ; 
ListCompositeDisposable lcd = new ListCompositeDisposable ( ) ; lcd . dispose ( ) ; Disposable d = Disposable . empty ( ) ; assertFalse ( lcd . add ( d ) ) ; assertTrue ( d . isDisposed ( ) ) ; d = Disposable . empty ( ) ; assertFalse ( lcd . addAll ( d ) ) ; assertTrue ( d . isDisposed ( ) ) ; 
Disposable d = new Disposable ( ) @ Override public void dispose ( ) throw new TestException ( ) ; @ Override public boolean isDisposed ( ) return false ; ; ListCompositeDisposable lcd = new ListCompositeDisposable ( d , d ) ; try lcd . dispose ( ) ; fail ( "Should have thrown!" ) ; catch ( CompositeException ex ) List < Throwable > list = ex . getExceptions ( ) ; TestHelper . assertError ( list , 0 , TestException . class ) ; TestHelper . assertError ( list , 1 , TestException . class ) ; lcd = new ListCompositeDisposable ( d ) ; try lcd . dispose ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException ex ) 
ListCompositeDisposable lcd = new ListCompositeDisposable ( ) ; Disposable d = Disposable . empty ( ) ; lcd . add ( d ) ; assertTrue ( lcd . delete ( d ) ) ; assertFalse ( d . isDisposed ( ) ) ; lcd . add ( d ) ; assertTrue ( lcd . remove ( d ) ) ; assertTrue ( d . isDisposed ( ) ) ; assertFalse ( lcd . remove ( d ) ) ; assertFalse ( lcd . delete ( d ) ) ; lcd = new ListCompositeDisposable ( ) ; assertFalse ( lcd . remove ( d ) ) ; assertFalse ( lcd . delete ( d ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . add ( Disposable . empty ( ) ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . addAll ( Disposable . empty ( ) ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . remove ( d1 ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . delete ( d1 ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . clear ( ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . add ( Disposable . empty ( ) ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . addAll ( Disposable . empty ( ) ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . remove ( d1 ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . delete ( d1 ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ListCompositeDisposable cd = new ListCompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . clear ( ) ; ; TestHelper . race ( run , run2 ) ; 
TestHelper . assertNoOffer ( new CancellableQueueFuseable < > ( ) ) ; 
CancellableQueueFuseable < Object > qs = new CancellableQueueFuseable < > ( ) ; assertNull ( qs . poll ( ) ) ; qs . clear ( ) ; assertNull ( qs . poll ( ) ) ; 
CancellableQueueFuseable < Object > qs = new CancellableQueueFuseable < > ( ) ; assertFalse ( qs . isDisposed ( ) ) ; qs . cancel ( ) ; assertTrue ( qs . isDisposed ( ) ) ; qs . cancel ( ) ; assertTrue ( qs . isDisposed ( ) ) ; 
CancellableQueueFuseable < Object > qs = new CancellableQueueFuseable < > ( ) ; assertFalse ( qs . isDisposed ( ) ) ; qs . dispose ( ) ; assertTrue ( qs . isDisposed ( ) ) ; qs . dispose ( ) ; assertTrue ( qs . isDisposed ( ) ) ; 
AbstractEmptyQueueFuseable < Object > qs = new AbstractEmptyQueueFuseable < Object > ( ) ; assertFalse ( qs . isDisposed ( ) ) ; qs . cancel ( ) ; 
AbstractEmptyQueueFuseable < Object > qs = new AbstractEmptyQueueFuseable < Object > ( ) ; assertFalse ( qs . isDisposed ( ) ) ; qs . dispose ( ) ; 
return 1 ; 
return 1 ; 
return 1 ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; mp . start ( ) ; mp . onError ( new TestException ( ) ) ; return mp ; 
return Executors . newCachedThreadPool ( ) ; 
return 1 ; 
return 1024 ; 
return 1024 * 1024 ; 
return 1 ; 
return 1 ; 
if ( SubscriptionHelper . setOnce ( upstream , s ) ) actual . onSubscribe ( this ) ; 
upstream . lazySet ( SubscriptionHelper . CANCELLED ) ; actual . onError ( t ) ; 
upstream . lazySet ( SubscriptionHelper . CANCELLED ) ; actual . onComplete ( ) ; 
RefCountSubscriber < T > rcs = new RefCountSubscriber < > ( s , this ) ; if ( ! add ( rcs ) ) EmptySubscription . error ( new IllegalStateException ( "RefCountProcessor terminated" ) , s ) ; return ; actual . subscribe ( rcs ) ; 
return actual . hasComplete ( ) ; 
return actual . hasThrowable ( ) ; 
return actual . getThrowable ( ) ; 
return actual . hasSubscribers ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; 
lazySet ( true ) ; upstream . cancel ( ) ; parent . remove ( this ) ; 
this . upstream = s ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
return 0 ; 
return 0 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1 ; 
return 1L ; 
MulticastProcessor < Integer > mp = MulticastProcessor . create ( ) ; mp . start ( ) ; mp . onError ( new TestException ( ) ) ; return mp ; 
return Executors . newCachedThreadPool ( ) ; 
return 1 ; 
return 1024 ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onError ( new TestException ( ) ) ; return up ; 
return Executors . newCachedThreadPool ( ) ; 
return 1 ; 
return 1024 ; 
return 1 ; 
return Flowable . fromSupplier ( new Supplier < Long > ( ) @ Override public Long get ( ) throws Throwable throw new TestException ( ) ; ) ; 
return 1 ; 
return Flowable . fromCallable ( new Callable < Long > ( ) @ Override public Long call ( ) throws Exception throw new TestException ( ) ; ) ; 
return 1 ; 
return Flowable . error ( new TestException ( ) ) ; 
return 1024 ; 
return new FiniteRangeIterator ( end ) ; 
return count != end ; 
long c = count ; if ( c != end ) count = c + 1 ; return c ; throw new NoSuchElementException ( ) ; 
throw new UnsupportedOperationException ( ) ; 
return new InfiniteRangeIterator ( ) ; 
return true ; 
return count ++ ; 
throw new UnsupportedOperationException ( ) ; 
return 1 ; 
return 1 ; 
List < String > values = Observable . just ( "one" , "two" ) . startWithArray ( "zero" ) . toList ( ) . blockingGet ( ) ; assertEquals ( "zero" , values . get ( 0 ) ) ; assertEquals ( "two" , values . get ( 2 ) ) ; 
List < String > li = new ArrayList < > ( ) ; li . add ( "alpha" ) ; li . add ( "beta" ) ; List < String > values = Observable . just ( "one" , "two" ) . startWithIterable ( li ) . toList ( ) . blockingGet ( ) ; assertEquals ( "alpha" , values . get ( 0 ) ) ; assertEquals ( "beta" , values . get ( 1 ) ) ; assertEquals ( "one" , values . get ( 2 ) ) ; assertEquals ( "two" , values . get ( 3 ) ) ; 
List < String > li = new ArrayList < > ( ) ; li . add ( "alpha" ) ; li . add ( "beta" ) ; List < String > values = Observable . just ( "one" , "two" ) . startWith ( Observable . fromIterable ( li ) ) . toList ( ) . blockingGet ( ) ; assertEquals ( "alpha" , values . get ( 0 ) ) ; assertEquals ( "beta" , values . get ( 1 ) ) ; assertEquals ( "one" , values . get ( 2 ) ) ; assertEquals ( "two" , values . get ( 3 ) ) ; 
Observable . just ( 1 ) . startWithArray ( ) . test ( ) . assertResult ( 1 ) ; 
ObservableEventStream . getEventStream ( "HTTP-ClusterB" , 20 ) . scan ( new HashMap < > ( ) , new BiFunction < HashMap < String , String > , Event , HashMap < String , String > > ( ) @ Override public HashMap < String , String > apply ( HashMap < String , String > accum , Event perInstanceEvent ) accum . put ( "instance" , perInstanceEvent . instanceId ) ; return accum ; ) . take ( 10 ) . blockingForEach ( new Consumer < HashMap < String , String > > ( ) @ Override public void accept ( HashMap < String , String > pv ) System . out . println ( pv ) ; ) ; Thread . sleep ( 200 ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Throwable > caughtError = new AtomicReference < > ( ) ; Observable < Long > o = Observable . interval ( 50 , TimeUnit . MILLISECONDS ) ; Observer < Long > observer = new DefaultObserver < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) System . out . println ( "error: " + e ) ; caughtError . set ( e ) ; latch . countDown ( ) ; @ Override public void onNext ( Long args ) throw new RuntimeException ( "forced failure" ) ; ; o . safeSubscribe ( observer ) ; latch . await ( 2000 , TimeUnit . MILLISECONDS ) ; assertNotNull ( caughtError . get ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Throwable > caughtError = new AtomicReference < > ( ) ; Observable < Long > o = Observable . interval ( 50 , TimeUnit . MILLISECONDS ) ; Observer < Long > observer = new DefaultObserver < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) System . out . println ( "error: " + e ) ; caughtError . set ( e ) ; latch . countDown ( ) ; @ Override public void onNext ( Long args ) throw new RuntimeException ( "forced failure" ) ; ; o . observeOn ( Schedulers . newThread ( ) ) . safeSubscribe ( observer ) ; latch . await ( 2000 , TimeUnit . MILLISECONDS ) ; assertNotNull ( caughtError . get ( ) ) ; 
Observable . amb ( new Iterable < Observable < Object > > ( ) @ Override public Iterator < Observable < Object > > iterator ( ) return null ; ) . test ( ) . assertError ( NullPointerException . class ) ; 
Observable . amb ( Arrays . asList ( Observable . never ( ) , null ) ) . test ( ) . assertError ( NullPointerException . class ) ; 
Observable . combineLatest ( new Iterable < Observable < Object > > ( ) @ Override public Iterator < Observable < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , 128 ) . blockingLast ( ) ; 
Observable . combineLatest ( Arrays . asList ( Observable . never ( ) , null ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , 128 ) . blockingLast ( ) ; 
Observable . combineLatest ( Arrays . asList ( just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return null ; , 128 ) . blockingLast ( ) ; 
Observable . combineLatestDelayError ( new Iterable < Observable < Object > > ( ) @ Override public Iterator < Observable < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , 128 ) . blockingLast ( ) ; 
Observable . combineLatestDelayError ( Arrays . asList ( Observable . never ( ) , null ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , 128 ) . blockingLast ( ) ; 
Observable . combineLatestDelayError ( Arrays . asList ( just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return null ; , 128 ) . blockingLast ( ) ; 
Observable . concat ( new Iterable < Observable < Object > > ( ) @ Override public Iterator < Observable < Object > > iterator ( ) return null ; ) . blockingLast ( ) ; 
Observable . concat ( Arrays . asList ( just1 , null ) ) . blockingLast ( ) ; 
Observable . concatArray ( just1 , null ) . blockingLast ( ) ; 
Observable . defer ( new Supplier < Observable < Object > > ( ) @ Override public Observable < Object > get ( ) return null ; ) . blockingLast ( ) ; 
Observable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return null ; ) . blockingSubscribe ( ) ; 
Observable . fromArray ( 1 , null ) . blockingLast ( ) ; 
Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return null ; ) . blockingLast ( ) ; 
FutureTask < Object > f = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; f . run ( ) ; TestObserver < Object > to = new TestObserver < > ( ) ; Observable . fromFuture ( f ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( NullPointerException . class ) ; 
FutureTask < Object > f = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; f . run ( ) ; Observable . fromFuture ( f , 1 , TimeUnit . SECONDS ) . blockingLast ( ) ; 
Observable . fromIterable ( new Iterable < Object > ( ) @ Override public Iterator < Object > iterator ( ) return null ; ) . blockingLast ( ) ; 
Observable . fromIterable ( Arrays . asList ( 1 , null ) ) . blockingLast ( ) ; 
Observable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > s ) s . onNext ( null ) ; ) . blockingLast ( ) ; 
BiConsumer < Integer , Emitter < Integer > > generator = new BiConsumer < Integer , Emitter < Integer > > ( ) @ Override public void accept ( Integer s , Emitter < Integer > o ) o . onComplete ( ) ; ; Observable . generate ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return null ; , generator ) . blockingSubscribe ( ) ; 
Observable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; , new BiFunction < Object , Emitter < Object > , Object > ( ) @ Override public Object apply ( Object s , Emitter < Object > o ) o . onComplete ( ) ; return s ; ) . blockingSubscribe ( ) ; 
Observable . interval ( 1 , TimeUnit . SECONDS , null ) ; 
@ SuppressWarnings ( "rawtypes" ) Class < Observable > clazz = Observable . class ; for ( int argCount = 1 ; argCount < 10 ; argCount ++ ) for ( int argNull = 1 ; argNull <= argCount ; argNull ++ ) Class < ? > [ ] params = new Class [ argCount ] ; Arrays . fill ( params , Object . class ) ; Object [ ] values = new Object [ argCount ] ; Arrays . fill ( values , 1 ) ; values [ argNull - 1 ] = null ; Method m = clazz . getMethod ( "just" , params ) ; try m . invoke ( null , values ) ; Assert . fail ( "No exception for argCount " + argCount + " / argNull " + argNull ) ; catch ( InvocationTargetException ex ) if ( ! ( ex . getCause ( ) instanceof NullPointerException ) ) Assert . fail ( "Unexpected exception for argCount " + argCount + " / argNull " + argNull + ": " + ex ) ; 
Observable . merge ( new Iterable < Observable < Object > > ( ) @ Override public Iterator < Observable < Object > > iterator ( ) return null ; , 128 , 128 ) . blockingLast ( ) ; 
Observable . merge ( Arrays . asList ( just1 , null ) , 128 , 128 ) . blockingLast ( ) ; 
Observable . mergeDelayError ( new Iterable < Observable < Object > > ( ) @ Override public Iterator < Observable < Object > > iterator ( ) return null ; , 128 , 128 ) . blockingLast ( ) ; 
Observable . mergeDelayError ( Arrays . asList ( just1 , null ) , 128 , 128 ) . blockingLast ( ) ; 
Observable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , new Function < Object , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Object d ) return null ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) ) . blockingLast ( ) ; 
Observable . zip ( new Iterable < Observable < Object > > ( ) @ Override public Iterator < Observable < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingLast ( ) ; 
Observable . zip ( Arrays . asList ( just1 , just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) return null ; ) . blockingLast ( ) ; 
Observable . zip ( new Iterable < Observable < Object > > ( ) @ Override public Iterator < Observable < Object > > iterator ( ) return null ; , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) return 1 ; , true , 128 ) . blockingLast ( ) ; 
Observable . zip ( Arrays . asList ( just1 , just1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) return null ; , true , 128 ) . blockingLast ( ) ; 
just1 . buffer ( 1 , 1 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . buffer ( 1L , 1L , TimeUnit . SECONDS , Schedulers . single ( ) , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . buffer ( just1 , new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . buffer ( just1 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . collect ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; , new BiConsumer < Object , Integer > ( ) @ Override public void accept ( Object a , Integer b ) ) . blockingGet ( ) ; 
just1 . collect ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , null ) ; 
just1 . concatMap ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . concatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . concatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) return new Iterable < Object > ( ) @ Override public Iterator < Object > iterator ( ) return null ; ; ) . blockingSubscribe ( ) ; 
just1 . debounce ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . delay ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . delay ( just1 , new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . distinct ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Supplier < Collection < Object > > ( ) @ Override public Collection < Object > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . distinct ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
Observable . range ( 1 , 2 ) . distinctUntilChanged ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . test ( ) . assertResult ( 1 ) ; 
just1 . flatMap ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return null ; , new Function < Throwable , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Throwable e ) return just1 ; , new Supplier < Observable < Integer > > ( ) @ Override public Observable < Integer > get ( ) return just1 ; ) . blockingSubscribe ( ) ; 
just1 . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return just1 ; , new Function < Throwable , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Throwable e ) return just1 ; , new Supplier < Observable < Integer > > ( ) @ Override public Observable < Integer > get ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . flatMap ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer a , Object b ) return 1 ; ) . blockingSubscribe ( ) ; 
just1 . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return just1 ; , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . flatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) return new Iterable < Object > ( ) @ Override public Iterator < Object > iterator ( ) return null ; ; ) . blockingSubscribe ( ) ; 
just1 . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Arrays . asList ( 1 , null ) ; ) . blockingSubscribe ( ) ; 
just1 . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Arrays . asList ( 1 ) ; , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . groupBy ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . groupBy ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . lift ( new ObservableOperator < Object , Integer > ( ) @ Override public Observer < ? super Integer > apply ( Observer < ? super Object > observer ) return null ; ) . blockingSubscribe ( ) ; 
just1 . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
Observable . error ( new TestException ( ) ) . onErrorResumeNext ( new Function < Throwable , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Throwable e ) return null ; ) . blockingSubscribe ( ) ; 
Observable . error ( new TestException ( ) ) . onErrorReturn ( new Function < Throwable , Object > ( ) @ Override public Object apply ( Throwable e ) return null ; ) . blockingSubscribe ( ) ; 
just1 . publish ( new Function < Observable < Integer > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Integer > v ) return null ; ) . blockingSubscribe ( ) ; 
Observable . just ( 1 , 1 ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return null ; ) . blockingGet ( ) ; 
just1 . reduce ( 1 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return null ; ) . blockingGet ( ) ; 
just1 . reduceWith ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) return 1 ; ) . blockingGet ( ) ; 
just1 . repeatWhen ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . replay ( new Function < Observable < Integer > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Integer > o ) return null ; ) . blockingSubscribe ( ) ; 
just1 . replay ( new Function < Observable < Integer > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Integer > v ) return null ; , 1 , 1 , TimeUnit . SECONDS ) . blockingSubscribe ( ) ; 
just1 . replay ( new Function < Observable < Integer > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Integer > v ) return null ; , 1 , TimeUnit . SECONDS , Schedulers . single ( ) ) . blockingSubscribe ( ) ; 
Observable . error ( new TestException ( ) ) . retryWhen ( new Function < Observable < ? extends Throwable > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < ? extends Throwable > f ) return null ; ) . blockingSubscribe ( ) ; 
Observable . just ( 1 , 1 ) . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . scan ( 1 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . scanWith ( new Supplier < Object > ( ) @ Override public Object get ( ) return null ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) return 1 ; ) . blockingSubscribe ( ) ; 
just1 . scanWith ( new Supplier < Object > ( ) @ Override public Object get ( ) return 1 ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . startWithIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return null ; ) . blockingSubscribe ( ) ; 
just1 . startWithIterable ( Arrays . asList ( 1 , null ) ) . blockingSubscribe ( ) ; 
just1 . switchMap ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . timeout ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
Observable . just ( 1 , 1 ) . timeout ( Observable . never ( ) , new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) return null ; ) . blockingGet ( ) ; 
just1 . toMap ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingGet ( ) ; 
just1 . toMap ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Supplier < Map < Object , Object > > ( ) @ Override public Map < Object , Object > get ( ) return null ; ) . blockingGet ( ) ; 
just1 . toMap ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return null ; ) . blockingGet ( ) ; 
just1 . toMultimap ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return v ; , new Supplier < Map < Object , Collection < Object > > > ( ) @ Override public Map < Object , Collection < Object > > get ( ) return null ; ) . blockingGet ( ) ; 
just1 . toMultimap ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; , new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; , new Supplier < Map < Integer , Collection < Integer > > > ( ) @ Override public Map < Integer , Collection < Integer > > get ( ) return new HashMap < > ( ) ; , new Function < Integer , Collection < Integer > > ( ) @ Override public Collection < Integer > apply ( Integer v ) return null ; ) . blockingGet ( ) ; 
Observable . never ( ) . window ( just1 , new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) return null ; ) . blockingSubscribe ( ) ; 
just1 . withLatestFrom ( just1 , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . zipWith ( Arrays . asList ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
just1 . zipWith ( new Iterable < Object > ( ) @ Override public Iterator < Object > iterator ( ) return null ; , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer a , Object b ) return 1 ; ) . blockingSubscribe ( ) ; 
Observable . just ( 1 , 2 ) . zipWith ( Arrays . asList ( 1 , null ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return 1 ; ) . blockingSubscribe ( ) ; 
just1 . zipWith ( just1 , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) return null ; ) . blockingSubscribe ( ) ; 
Observable . < Movie > just ( new HorrorMovie ( ) ) ; Observable . < Movie > fromIterable ( new ArrayList < HorrorMovie > ( ) ) ; 
Comparator < Media > sortFunction = new Comparator < Media > ( ) @ Override public int compare ( Media t1 , Media t2 ) return 1 ; ; Observable < Media > o = Observable . just ( new Movie ( ) , new TVSeason ( ) , new Album ( ) ) ; o . toSortedList ( sortFunction ) ; Observable < Movie > o2 = Observable . just ( new Movie ( ) , new ActionMovie ( ) , new HorrorMovie ( ) ) ; o2 . toSortedList ( sortFunction ) ; 
Observable < Movie > movies = Observable . just ( new HorrorMovie ( ) , new ActionMovie ( ) , new Movie ( ) ) ; TestObserverEx < String > to = new TestObserverEx < > ( ) ; movies . groupBy ( new Function < Movie , Object > ( ) @ Override public Object apply ( Movie v ) return v . getClass ( ) ; ) . doOnNext ( new Consumer < GroupedObservable < Object , Movie > > ( ) @ Override public void accept ( GroupedObservable < Object , Movie > g ) System . out . println ( g . getKey ( ) ) ; ) . flatMap ( new Function < GroupedObservable < Object , Movie > , Observable < String > > ( ) @ Override public Observable < String > apply ( GroupedObservable < Object , Movie > g ) return g . doOnNext ( new Consumer < Movie > ( ) @ Override public void accept ( Movie pv ) System . out . println ( pv ) ; ) . compose ( new ObservableTransformer < Movie , Movie > ( ) @ Override public Observable < Movie > apply ( Observable < Movie > m ) return m . concatWith ( Observable . just ( new ActionMovie ( ) ) ) ; ) . map ( new Function < Movie , String > ( ) @ Override public String apply ( Movie v ) return v . toString ( ) ; ) ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; assertEquals ( 6 , to . values ( ) . size ( ) ) ; 
Observable < HorrorMovie > movie = Observable . just ( new HorrorMovie ( ) ) ; Observable < Movie > movie2 = movie . compose ( new ObservableTransformer < HorrorMovie , Movie > ( ) @ Override public Observable < Movie > apply ( Observable < HorrorMovie > t ) return Observable . just ( new Movie ( ) ) ; ) ; 
Observable < Movie > movie = Observable . < Movie > just ( new HorrorMovie ( ) ) ; Observable < HorrorMovie > movie2 = movie . compose ( new ObservableTransformer < Movie , HorrorMovie > ( ) @ Override public Observable < HorrorMovie > apply ( Observable < Movie > t ) return Observable . just ( new HorrorMovie ( ) ) ; ) ; 
Observable < Movie > movie = Observable . < Movie > just ( new HorrorMovie ( ) ) ; Observable < HorrorMovie > movie2 = movie . compose ( new ObservableTransformer < Movie , HorrorMovie > ( ) @ Override public Observable < HorrorMovie > apply ( Observable < Movie > t ) return Observable . just ( new HorrorMovie ( ) ) . map ( new Function < HorrorMovie , HorrorMovie > ( ) @ Override public HorrorMovie apply ( HorrorMovie v ) return v ; ) ; ) ; 
Observable < HorrorMovie > movie = Observable . just ( new HorrorMovie ( ) ) ; Observable < HorrorMovie > movie2 = movie . compose ( new ObservableTransformer < HorrorMovie , HorrorMovie > ( ) @ Override public Observable < HorrorMovie > apply ( Observable < HorrorMovie > t1 ) return t1 . map ( new Function < HorrorMovie , HorrorMovie > ( ) @ Override public HorrorMovie apply ( HorrorMovie v ) return v ; ) ; ) ; 
List < Movie > list1 = Arrays . asList ( new Movie ( ) , new HorrorMovie ( ) , new ActionMovie ( ) ) ; List < Movie > list2 = Arrays . asList ( new ActionMovie ( ) , new Movie ( ) , new HorrorMovie ( ) , new ActionMovie ( ) ) ; Observable < List < Movie > > movies = Observable . just ( list1 , list2 ) ; movies . compose ( deltaTransformer ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) ; int value = o . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . toObservable ( ) . blockingSingle ( ) ; assertEquals ( 6 , value ) ; 
Observable < Movie > horrorMovies = Observable . < Movie > just ( new HorrorMovie ( ) ) ; Observable < Movie > reduceResult = horrorMovies . scan ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) . takeLast ( 1 ) ; Observable < Movie > reduceResult2 = horrorMovies . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) . toObservable ( ) ; assertNotNull ( reduceResult2 ) ; 
Observable < Movie > horrorMovies = Observable . < Movie > just ( new HorrorMovie ( ) ) ; Observable < Movie > reduceResult2 = horrorMovies . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) . toObservable ( ) ; assertNotNull ( reduceResult2 ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) ; int value = o . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . blockingGet ( ) ; assertEquals ( 6 , value ) ; 
Observable < Movie > horrorMovies = Observable . < Movie > just ( new HorrorMovie ( ) ) ; Observable < Movie > reduceResult = horrorMovies . scan ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) . takeLast ( 1 ) ; Maybe < Movie > reduceResult2 = horrorMovies . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) ; assertNotNull ( reduceResult2 ) ; 
Observable < Movie > horrorMovies = Observable . < Movie > just ( new HorrorMovie ( ) ) ; Maybe < Movie > reduceResult2 = horrorMovies . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) ; assertNotNull ( reduceResult2 ) ; 
Observable < Movie > horrorMovies = Observable . < Movie > just ( new HorrorMovie ( ) ) ; libraryFunctionActingOnMovieObservables ( horrorMovies ) ; 
obs . reduce ( new BiFunction < Movie , Movie , Movie > ( ) @ Override public Movie apply ( Movie t1 , Movie t2 ) return t2 ; ) ; 
final AtomicInteger c = new AtomicInteger ( ) ; Observable . just ( 1 , 2 , 3 , 4 ) . take ( 2 ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onStart ( ) c . incrementAndGet ( ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) ) ; assertEquals ( 1 , c . get ( ) ) ; 
final AtomicInteger c = new AtomicInteger ( ) ; Observable . just ( 1 , 2 , 3 , 4 ) . take ( 2 ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onStart ( ) c . incrementAndGet ( ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) ) ; assertEquals ( 1 , c . get ( ) ) ; 
final AtomicInteger c = new AtomicInteger ( ) ; Observable . just ( 1 , 2 , 3 , 4 ) . lift ( new ObservableOperator < Integer , Integer > ( ) @ Override public Observer < ? super Integer > apply ( final Observer < ? super Integer > child ) return new DefaultObserver < Integer > ( ) @ Override public void onStart ( ) c . incrementAndGet ( ) ; @ Override public void onComplete ( ) child . onComplete ( ) ; @ Override public void onError ( Throwable e ) child . onError ( e ) ; @ Override public void onNext ( Integer t ) child . onNext ( t ) ; ; ) . subscribe ( ) ; assertEquals ( 1 , c . get ( ) ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Observable . just ( 1 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 ) , list ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Observable . < Integer > error ( new TestException ( ) ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 100 ) , list ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . test ( true ) ; assertFalse ( ps . hasObservers ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . safeSubscribe ( new SafeObserver < > ( to ) ) ; to . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . test ( false ) ; assertTrue ( ps . hasObservers ( ) ) ; 
RxJavaPlugins . setOnObservableSubscribe ( new BiFunction < Observable , Observer , Observer > ( ) @ Override public Observer apply ( Observable a , Observer b ) throws Exception return null ; ) ; try try Observable . just ( 1 ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertEquals ( "The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins" , ex . getMessage ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
throw new IllegalArgumentException ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try try new BadObservable ( ) . test ( ) ; fail ( "Should have thrown!" ) ; catch ( NullPointerException ex ) if ( ! ( ex . getCause ( ) instanceof IllegalArgumentException ) ) fail ( ex . toString ( ) + ": Should be NPE(IAE)" ) ; TestHelper . assertError ( list , 0 , IllegalArgumentException . class ) ; finally RxJavaPlugins . reset ( ) ; 
w = TestHelper . mockObserver ( ) ; wo = TestHelper . mockSingleObserver ( ) ; wm = TestHelper . mockMaybeObserver ( ) ; 
String [ ] items = new String [ ] "one" , "two" , "three" ; assertEquals ( ( Long ) 3L , Observable . fromArray ( items ) . count ( ) . blockingGet ( ) ) ; assertEquals ( "two" , Observable . fromArray ( items ) . skip ( 1 ) . take ( 1 ) . blockingSingle ( ) ) ; assertEquals ( "three" , Observable . fromArray ( items ) . takeLast ( 1 ) . blockingSingle ( ) ) ; 
ArrayList < String > items = new ArrayList < > ( ) ; items . add ( "one" ) ; items . add ( "two" ) ; items . add ( "three" ) ; assertEquals ( ( Long ) 3L , Observable . fromIterable ( items ) . count ( ) . blockingGet ( ) ) ; assertEquals ( "two" , Observable . fromIterable ( items ) . skip ( 1 ) . take ( 1 ) . blockingSingle ( ) ) ; assertEquals ( "three" , Observable . fromIterable ( items ) . takeLast ( 1 ) . blockingSingle ( ) ) ; 
Observable < String > items = Observable . just ( "one" , "two" , "three" ) ; assertEquals ( ( Long ) 3L , items . count ( ) . blockingGet ( ) ) ; assertEquals ( "two" , items . skip ( 1 ) . take ( 1 ) . blockingSingle ( ) ) ; assertEquals ( "three" , items . takeLast ( 1 ) . blockingSingle ( ) ) ; 
Observable < String > items = Observable . just ( "one" ) ; assertEquals ( ( Long ) 1L , items . count ( ) . blockingGet ( ) ) ; assertEquals ( "one" , items . takeLast ( 1 ) . blockingSingle ( ) ) ; 
Observable < String > o = Observable . just ( "one" , "two" , "three" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > o = Observable . just ( "a" , "b" , "c" , "d" ) ; o . count ( ) . toObservable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyLong ( ) ) ; verify ( w ) . onNext ( 4L ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > o = Observable . empty ( ) ; o . count ( ) . toObservable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyLong ( ) ) ; verify ( w ) . onNext ( 0L ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > o = Observable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new RuntimeException ( ) ; ) ; o . count ( ) . toObservable ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onComplete ( ) ; verify ( w , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; 
Observable < String > o = Observable . just ( "a" , "b" , "c" , "d" ) ; o . count ( ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyLong ( ) ) ; verify ( wo ) . onSuccess ( 4L ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > o = Observable . empty ( ) ; o . count ( ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyLong ( ) ) ; verify ( wo ) . onSuccess ( 0L ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > o = Observable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new RuntimeException ( ) ; ) ; o . count ( ) . subscribe ( wo ) ; verify ( wo , never ( ) ) . onSuccess ( anyInt ( ) ) ; verify ( wo , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; 
Observable < Integer > o = Observable . just ( 1 , 3 , 5 , 4 , 6 , 3 ) ; o . filter ( IS_EVEN ) . take ( 1 ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( 4 ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . just ( 1 , 3 , 5 , 7 , 9 , 7 , 5 , 3 , 1 ) ; o . filter ( IS_EVEN ) . take ( 1 ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) ; o . take ( 1 ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( 1 ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . empty ( ) ; o . take ( 1 ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . empty ( ) ; o . firstElement ( ) . subscribe ( wm ) ; verify ( wm , never ( ) ) . onSuccess ( anyInt ( ) ) ; verify ( wm ) . onComplete ( ) ; verify ( wm , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . just ( 1 , 3 , 5 , 7 , 9 , 7 , 5 , 3 , 1 ) ; o . filter ( IS_EVEN ) . firstElement ( ) . subscribe ( wm ) ; verify ( wm , never ( ) ) . onSuccess ( anyInt ( ) ) ; verify ( wm ) . onComplete ( ) ; verify ( wm , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 ) ; o . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . subscribe ( wm ) ; verify ( wm , times ( 1 ) ) . onSuccess ( anyInt ( ) ) ; verify ( wm ) . onSuccess ( 10 ) ; verify ( wm , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( wm , never ( ) ) . onComplete ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 ) ; o . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . toObservable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( 10 ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w ) . onComplete ( ) ; 
Observable < Integer > o = Observable . range ( 1 , 0 ) ; o . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . toObservable ( ) . test ( ) . assertResult ( ) ; 
Observable < Integer > o = Observable . range ( 1 , 0 ) ; int value = o . reduce ( 1 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . blockingGet ( ) ; assertEquals ( 1 , value ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 ) ; o . reduce ( 50 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyInt ( ) ) ; verify ( wo ) . onSuccess ( 60 ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 ) ; o . reduce ( 50 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . toObservable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( 60 ) ; 
Observable < Integer > obs = Observable . just ( 1 ) ; Observable < Integer > chained = obs . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; chained . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 0 ) ) . onError ( any ( Throwable . class ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Observable . just ( "1" , "2" , "three" , "4" ) . subscribeOn ( Schedulers . newThread ( ) ) . safeSubscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) error . set ( e ) ; System . out . println ( "error" ) ; e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String v ) int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; ) ; latch . await ( ) ; assertEquals ( 2 , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) fail ( "It should be a NumberFormatException" ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Observable . just ( "1" , "2" , "three" , "4" ) . safeSubscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; @ Override public void onError ( Throwable e ) error . set ( e ) ; System . out . println ( "error" ) ; e . printStackTrace ( ) ; @ Override public void onNext ( String v ) int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; ) ; assertEquals ( 2 , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) fail ( "It should be a NumberFormatException" ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Observable . just ( "1" , "2" ) . concatWith ( Observable . < String > error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new NumberFormatException ( ) ; ) ) . subscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; @ Override public void onError ( Throwable e ) error . set ( e ) ; System . out . println ( "error" ) ; e . printStackTrace ( ) ; @ Override public void onNext ( String v ) System . out . println ( v ) ; count . incrementAndGet ( ) ; ) ; assertEquals ( 2 , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) fail ( "It should be a NumberFormatException" ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; ConnectableObservable < String > connectable = Observable . < String > unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; count . incrementAndGet ( ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) observer . onNext ( "first" ) ; observer . onNext ( "last" ) ; observer . onComplete ( ) ; ) . start ( ) ; ) . takeLast ( 1 ) . publish ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; connectable . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String value ) assertEquals ( "last" , value ) ; latch . countDown ( ) ; ) ; connectable . subscribe ( ) ; Disposable subscription = connectable . connect ( ) ; assertTrue ( latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) ; assertEquals ( 1 , count . get ( ) ) ; subscription . dispose ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; ConnectableObservable < String > o = Observable . < String > unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; observer . onNext ( "one" ) ; observer . onComplete ( ) ; ) . start ( ) ; ) . replay ( ) ; Disposable connection = o . connect ( ) ; try final CountDownLatch latch = new CountDownLatch ( 2 ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; finally connection . dispose ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < String > o = Observable . < String > unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; observer . onNext ( "one" ) ; observer . onComplete ( ) ; ) . start ( ) ; ) . cache ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < String > o = Observable . < String > unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; observer . onNext ( "one" ) ; observer . onComplete ( ) ; ) . start ( ) ; ) . cacheWithInitialCapacity ( 1 ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Observable . just ( "1" , "2" , "three" , "4" ) . take ( 3 ) . safeSubscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; @ Override public void onError ( Throwable e ) error . set ( e ) ; System . out . println ( "error" ) ; e . printStackTrace ( ) ; @ Override public void onNext ( String v ) int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; ) ; assertEquals ( 2 , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) fail ( "It should be a NumberFormatException" ) ; 
Observable < String > o = Observable . just ( 1 , "abc" , false , 2L ) . ofType ( String . class ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( "abc" ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( 2L ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
ArrayList < Integer > l1 = new ArrayList < > ( ) ; l1 . add ( 1 ) ; LinkedList < Integer > l2 = new LinkedList < > ( ) ; l2 . add ( 2 ) ; @ SuppressWarnings ( "rawtypes" ) Observable < List > o = Observable . < Object > just ( l1 , l2 , "123" ) . ofType ( List . class ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( l1 ) ; verify ( observer , times ( 1 ) ) . onNext ( l2 ) ; verify ( observer , never ( ) ) . onNext ( "123" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Boolean > o = Observable . just ( "a" , "b" , "c" ) . contains ( "b" ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Boolean > o = Observable . just ( "a" , "b" ) . contains ( "c" ) . toObservable ( ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Boolean > o = Observable . < String > empty ( ) . contains ( "a" ) . toObservable ( ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Single < Boolean > o = Observable . just ( "a" , "b" , "c" ) . contains ( "b" ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Single < Boolean > o = Observable . just ( "a" , "b" ) . contains ( "c" ) ; SingleObserver < Object > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Single < Boolean > o = Observable . < String > empty ( ) . contains ( "a" ) ; SingleObserver < Object > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Completable o = Observable . just ( 1 , 2 , 3 ) . ignoreElements ( ) ; CompletableObserver observer = TestHelper . mockCompletableObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) . ignoreElements ( ) . toObservable ( ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > o = Observable . fromArray ( 1 , 2 ) . subscribeOn ( scheduler ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > o = Observable . just ( 3 , 4 ) . startWithIterable ( Arrays . asList ( 1 , 2 ) ) . subscribeOn ( scheduler ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > o = Observable . range ( 3 , 4 ) . subscribeOn ( scheduler ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 6 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . mergeWith ( Observable . just ( 2 ) ) . subscribe ( to ) ; to . assertValues ( 1 , 2 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . concatWith ( Observable . just ( 2 ) ) . subscribe ( to ) ; to . assertValues ( 1 , 2 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . ambWith ( Observable . just ( 2 ) ) . subscribe ( to ) ; to . assertValue ( 1 ) ; 
final int expectedCount = 3 ; final AtomicInteger count = new AtomicInteger ( ) ; for ( int i = 0 ; i < expectedCount ; i ++ ) Observable . just ( Boolean . TRUE , Boolean . FALSE ) . takeWhile ( new Predicate < Boolean > ( ) @ Override public boolean test ( Boolean v ) return v ; ) . toList ( ) . doOnSuccess ( new Consumer < List < Boolean > > ( ) @ Override public void accept ( List < Boolean > booleans ) count . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( expectedCount , count . get ( ) ) ; 
TestObserverEx < String > to = new TestObserverEx < > ( ) ; Observable . just ( 1 , 2 , 3 ) . compose ( new ObservableTransformer < Integer , String > ( ) @ Override public Observable < String > apply ( Observable < Integer > t1 ) return t1 . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer v ) return String . valueOf ( v ) ; ) ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; to . assertValues ( "1" , "2" , "3" ) ; 
Subject < Object > subject = ReplaySubject . create ( ) ; Observable . error ( new RuntimeException ( "oops" ) ) . materialize ( ) . delay ( 1 , TimeUnit . SECONDS ) . dematerialize ( Functions . < Notification < Object > > identity ( ) ) . subscribe ( subject ) ; subject . subscribe ( ) ; subject . materialize ( ) . blockingFirst ( ) ; System . out . println ( "Done" ) ; 
assertEquals ( Observable . empty ( ) , Observable . empty ( ) ) ; 
Observable . < Integer > empty ( ) . subscribe ( w ) ; verify ( w ) . onComplete ( ) ; verify ( w , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; final Object value = new Object ( ) ; Object returned = Observable . just ( value ) . to ( new ObservableConverter < Object , Object > ( ) @ Override public Object apply ( Observable < Object > onSubscribe ) onSubscribe . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; to . assertValue ( value ) ; return to . values ( ) . get ( 0 ) ; ) ; assertSame ( returned , value ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; final Object value = new Object ( ) ; Object returned = Observable . just ( value ) . to ( new ObservableConverter < Object , Object > ( ) @ Override public Object apply ( Observable < Object > onSubscribe ) onSubscribe . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; to . assertValue ( value ) ; return to . values ( ) . get ( 0 ) ; ) ; assertSame ( returned , value ) ; 
Observable . just ( 1 ) . to ( new ObservableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Observable < Integer > v ) return v . toFlowable ( BackpressureStrategy . MISSING ) ; ) . test ( ) . assertResult ( 1 ) ; 
List < Integer > list = Observable . range ( 1 , 5 ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . range ( v , 2 ) ; ) . toList ( ) . blockingGet ( ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) , list ) ; 
Observable . just ( 1 ) . single ( 100 ) . test ( ) . assertResult ( 1 ) ; Observable . empty ( ) . single ( 100 ) . test ( ) . assertResult ( 100 ) ; 
Observable . just ( 1 ) . single ( 100 ) . toObservable ( ) . test ( ) . assertResult ( 1 ) ; Observable . empty ( ) . single ( 100 ) . toObservable ( ) . test ( ) . assertResult ( 100 ) ; 
final List < Observable < Integer > > observables = Arrays . asList ( Observable . just ( 1 , 2 , 3 ) , Observable . just ( 1 , 2 , 3 ) ) ; Observable . zip ( observables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] o ) throws Exception int sum = 0 ; for ( Object i : o ) sum += ( Integer ) i ; return sum ; ) . test ( ) . assertResult ( 2 , 4 , 6 ) ; 
final List < Observable < Integer > > observables = Arrays . asList ( Observable . just ( 1 , 2 , 3 ) , Observable . just ( 1 , 2 , 3 ) ) ; Observable . combineLatest ( observables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( final Object [ ] o ) throws Exception int sum = 1 ; for ( Object i : o ) sum *= ( Integer ) i ; return sum ; ) . test ( ) . assertResult ( 3 , 6 , 9 ) ; 
Observable < String > o1 = Observable . just ( "one" , "two" ) ; Observable < String > o2 = Observable . just ( "three" , "four" ) ; List < String > values = Observable . concat ( o1 , o2 ) . toList ( ) . blockingGet ( ) ; assertEquals ( "one" , values . get ( 0 ) ) ; assertEquals ( "two" , values . get ( 1 ) ) ; assertEquals ( "three" , values . get ( 2 ) ) ; assertEquals ( "four" , values . get ( 3 ) ) ; 
Observable < String > o1 = Observable . just ( "one" , "two" ) ; Observable < String > o2 = Observable . just ( "three" , "four" ) ; Observable < String > o3 = Observable . just ( "five" , "six" ) ; Observable < Observable < String > > os = Observable . just ( o1 , o2 , o3 ) ; List < String > values = Observable . concat ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( "one" , values . get ( 0 ) ) ; assertEquals ( "two" , values . get ( 1 ) ) ; assertEquals ( "three" , values . get ( 2 ) ) ; assertEquals ( "four" , values . get ( 3 ) ) ; assertEquals ( "five" , values . get ( 4 ) ) ; assertEquals ( "six" , values . get ( 5 ) ) ; 
Observable < String > o1 = Observable . just ( "one" , "two" ) ; Observable < String > o2 = Observable . just ( "three" , "four" ) ; Observable < String > o3 = Observable . just ( "five" , "six" ) ; Iterable < Observable < String > > is = Arrays . asList ( o1 , o2 , o3 ) ; List < String > values = Observable . concat ( Observable . fromIterable ( is ) ) . toList ( ) . blockingGet ( ) ; assertEquals ( "one" , values . get ( 0 ) ) ; assertEquals ( "two" , values . get ( 1 ) ) ; assertEquals ( "three" , values . get ( 2 ) ) ; assertEquals ( "four" , values . get ( 3 ) ) ; assertEquals ( "five" , values . get ( 4 ) ) ; assertEquals ( "six" , values . get ( 5 ) ) ; 
HorrorMovie horrorMovie1 = new HorrorMovie ( ) ; Movie movie = new Movie ( ) ; Media media = new Media ( ) ; HorrorMovie horrorMovie2 = new HorrorMovie ( ) ; Observable < Media > o1 = Observable . < Media > just ( horrorMovie1 , movie ) ; Observable < Media > o2 = Observable . just ( media , horrorMovie2 ) ; Observable < Observable < Media > > os = Observable . just ( o1 , o2 ) ; List < Media > values = Observable . concat ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( horrorMovie1 , values . get ( 0 ) ) ; assertEquals ( movie , values . get ( 1 ) ) ; assertEquals ( media , values . get ( 2 ) ) ; assertEquals ( horrorMovie2 , values . get ( 3 ) ) ; assertEquals ( 4 , values . size ( ) ) ; 
HorrorMovie horrorMovie1 = new HorrorMovie ( ) ; Movie movie = new Movie ( ) ; Media media1 = new Media ( ) ; Media media2 = new Media ( ) ; HorrorMovie horrorMovie2 = new HorrorMovie ( ) ; Observable < Media > o1 = Observable . just ( horrorMovie1 , movie , media1 ) ; Observable < Media > o2 = Observable . just ( media2 , horrorMovie2 ) ; Observable < Observable < Media > > os = Observable . just ( o1 , o2 ) ; List < Media > values = Observable . concat ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( horrorMovie1 , values . get ( 0 ) ) ; assertEquals ( movie , values . get ( 1 ) ) ; assertEquals ( media1 , values . get ( 2 ) ) ; assertEquals ( media2 , values . get ( 3 ) ) ; assertEquals ( horrorMovie2 , values . get ( 4 ) ) ; assertEquals ( 5 , values . size ( ) ) ; 
HorrorMovie horrorMovie1 = new HorrorMovie ( ) ; Movie movie = new Movie ( ) ; Media media = new Media ( ) ; HorrorMovie horrorMovie2 = new HorrorMovie ( ) ; Observable < Movie > o1 = Observable . just ( horrorMovie1 , movie ) ; Observable < Media > o2 = Observable . just ( media , horrorMovie2 ) ; List < Media > values = Observable . concat ( o1 , o2 ) . toList ( ) . blockingGet ( ) ; assertEquals ( horrorMovie1 , values . get ( 0 ) ) ; assertEquals ( movie , values . get ( 1 ) ) ; assertEquals ( media , values . get ( 2 ) ) ; assertEquals ( horrorMovie2 , values . get ( 3 ) ) ; assertEquals ( 4 , values . size ( ) ) ; 
final HorrorMovie horrorMovie1 = new HorrorMovie ( ) ; final Movie movie = new Movie ( ) ; Media media = new Media ( ) ; HorrorMovie horrorMovie2 = new HorrorMovie ( ) ; Observable < Movie > o1 = Observable . unsafeCreate ( new ObservableSource < Movie > ( ) @ Override public void subscribe ( Observer < ? super Movie > o ) o . onNext ( horrorMovie1 ) ; o . onNext ( movie ) ; o . onComplete ( ) ; ) ; Observable < Media > o2 = Observable . just ( media , horrorMovie2 ) ; List < Media > values = Observable . concat ( o1 , o2 ) . toList ( ) . blockingGet ( ) ; assertEquals ( horrorMovie1 , values . get ( 0 ) ) ; assertEquals ( movie , values . get ( 1 ) ) ; assertEquals ( media , values . get ( 2 ) ) ; assertEquals ( horrorMovie2 , values . get ( 3 ) ) ; assertEquals ( 4 , values . size ( ) ) ; 
Observable < HorrorMovie > horrors = Observable . just ( new HorrorMovie ( ) ) ; Observable < Observable < HorrorMovie > > metaHorrors = Observable . just ( horrors ) ; Observable . < Media > merge ( metaHorrors ) ; 
Observable < Media > o1 = Observable . < Media > just ( new HorrorMovie ( ) , new Movie ( ) ) ; Observable < Media > o2 = Observable . just ( new Media ( ) , new HorrorMovie ( ) ) ; Observable < Observable < Media > > os = Observable . just ( o1 , o2 ) ; List < Media > values = Observable . merge ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( 4 , values . size ( ) ) ; 
Observable < Media > o1 = Observable . just ( new HorrorMovie ( ) , new Movie ( ) , new Media ( ) ) ; Observable < Media > o2 = Observable . just ( new Media ( ) , new HorrorMovie ( ) ) ; Observable < Observable < Media > > os = Observable . just ( o1 , o2 ) ; List < Media > values = Observable . merge ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( 5 , values . size ( ) ) ; 
Observable < Movie > o1 = Observable . just ( new HorrorMovie ( ) , new Movie ( ) ) ; Observable < Media > o2 = Observable . just ( new Media ( ) , new HorrorMovie ( ) ) ; List < Media > values = Observable . merge ( o1 , o2 ) . toList ( ) . blockingGet ( ) ; assertTrue ( values . get ( 0 ) instanceof HorrorMovie ) ; assertTrue ( values . get ( 1 ) instanceof Movie ) ; assertNotNull ( values . get ( 2 ) ) ; assertTrue ( values . get ( 3 ) instanceof HorrorMovie ) ; 
Observable < Movie > o1 = Observable . defer ( new Supplier < Observable < Movie > > ( ) @ Override public Observable < Movie > get ( ) return Observable . just ( new HorrorMovie ( ) , new Movie ( ) ) ; ) ; Observable < Media > o2 = Observable . just ( new Media ( ) , new HorrorMovie ( ) ) ; List < Media > values = Observable . merge ( o1 , o2 ) . toList ( ) . blockingGet ( ) ; assertTrue ( values . get ( 0 ) instanceof HorrorMovie ) ; assertTrue ( values . get ( 1 ) instanceof Movie ) ; assertNotNull ( values . get ( 2 ) ) ; assertTrue ( values . get ( 3 ) instanceof HorrorMovie ) ; 
final AtomicReference < String > r = new AtomicReference < > ( ) ; String output = Observable . just ( "one" ) . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String v ) r . set ( v ) ; ) . blockingSingle ( ) ; assertEquals ( "one" , output ) ; assertEquals ( "one" , r . get ( ) ) ; 
final AtomicReference < Throwable > r = new AtomicReference < > ( ) ; Throwable t = null ; try Observable . < String > error ( new RuntimeException ( "an error" ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) r . set ( v ) ; ) . blockingSingle ( ) ; fail ( "expected exception, not a return value" ) ; catch ( Throwable e ) t = e ; assertNotNull ( t ) ; assertEquals ( t , r . get ( ) ) ; 
final AtomicBoolean r = new AtomicBoolean ( ) ; String output = Observable . just ( "one" ) . doOnComplete ( new Action ( ) @ Override public void run ( ) r . set ( true ) ; ) . blockingSingle ( ) ; assertEquals ( "one" , output ) ; assertTrue ( r . get ( ) ) ; 
final AtomicBoolean r = new AtomicBoolean ( ) ; String output = Observable . just ( "one" ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) r . set ( true ) ; ) . blockingSingle ( ) ; assertEquals ( "one" , output ) ; assertTrue ( r . get ( ) ) ; 
final AtomicBoolean r = new AtomicBoolean ( ) ; Observable . < String > error ( new TestException ( ) ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) r . set ( true ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( r . get ( ) ) ; 
Observable . range ( 1 , 10 ) . to ( TestHelper . < Integer > testConsumer ( QueueFuseable . ANY , false ) ) . assertFusionMode ( QueueFuseable . SYNC ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . fromArray ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . to ( TestHelper . < Integer > testConsumer ( QueueFuseable . ANY , false ) ) . assertFusionMode ( QueueFuseable . SYNC ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) . to ( TestHelper . < Integer > testConsumer ( QueueFuseable . ANY , false ) ) . assertFusionMode ( QueueFuseable . SYNC ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . range ( 1 , 10 ) . hide ( ) . to ( TestHelper . < Integer > testConsumer ( QueueFuseable . ANY , false ) ) . assertNotFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . fromArray ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . hide ( ) . to ( TestHelper . < Integer > testConsumer ( QueueFuseable . ANY , false ) ) . assertNotFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) . hide ( ) . to ( TestHelper . < Integer > testConsumer ( QueueFuseable . ANY , false ) ) . assertNotFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable < HorrorMovie > horrors = Observable . just ( new HorrorMovie ( ) ) ; Observable < CoolRating > ratings = Observable . just ( new CoolRating ( ) ) ; Observable . < Movie , CoolRating , Result > combineLatest ( horrors , ratings , combine ) . blockingForEach ( action ) ; Observable . < Movie , CoolRating , Result > combineLatest ( horrors , ratings , combine ) . blockingForEach ( action ) ; Observable . < Media , Rating , ExtendedResult > combineLatest ( horrors , ratings , combine ) . blockingForEach ( extendedAction ) ; Observable . < Media , Rating , Result > combineLatest ( horrors , ratings , combine ) . blockingForEach ( action ) ; Observable . < Media , Rating , ExtendedResult > combineLatest ( horrors , ratings , combine ) . blockingForEach ( action ) ; Observable . < Movie , CoolRating , Result > combineLatest ( horrors , ratings , combine ) ; 
s . onNext ( randomEvent ( type , numInstances ) ) ; try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; s . onError ( e ) ; 
Observer < Integer > observer = TestHelper . mockObserver ( ) ; TestScheduler s = new TestScheduler ( ) ; PublishSubject < Integer > o = PublishSubject . create ( ) ; o . throttleLast ( 500 , TimeUnit . MILLISECONDS , s ) . subscribe ( observer ) ; s . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; s . advanceTimeTo ( 501 , TimeUnit . MILLISECONDS ) ; o . onNext ( 3 ) ; s . advanceTimeTo ( 600 , TimeUnit . MILLISECONDS ) ; o . onNext ( 4 ) ; s . advanceTimeTo ( 700 , TimeUnit . MILLISECONDS ) ; o . onNext ( 5 ) ; o . onNext ( 6 ) ; s . advanceTimeTo ( 1001 , TimeUnit . MILLISECONDS ) ; o . onNext ( 7 ) ; s . advanceTimeTo ( 1501 , TimeUnit . MILLISECONDS ) ; o . onComplete ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onNext ( 2 ) ; inOrder . verify ( observer ) . onNext ( 6 ) ; inOrder . verify ( observer ) . onNext ( 7 ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observer < Integer > observer = TestHelper . mockObserver ( ) ; TestScheduler s = new TestScheduler ( ) ; PublishSubject < Integer > o = PublishSubject . create ( ) ; o . throttleWithTimeout ( 500 , TimeUnit . MILLISECONDS , s ) . subscribe ( observer ) ; s . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; s . advanceTimeTo ( 501 , TimeUnit . MILLISECONDS ) ; o . onNext ( 3 ) ; s . advanceTimeTo ( 600 , TimeUnit . MILLISECONDS ) ; o . onNext ( 4 ) ; s . advanceTimeTo ( 700 , TimeUnit . MILLISECONDS ) ; o . onNext ( 5 ) ; o . onNext ( 6 ) ; s . advanceTimeTo ( 1300 , TimeUnit . MILLISECONDS ) ; o . onNext ( 7 ) ; s . advanceTimeTo ( 1800 , TimeUnit . MILLISECONDS ) ; o . onComplete ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onNext ( 2 ) ; inOrder . verify ( observer ) . onNext ( 6 ) ; inOrder . verify ( observer ) . onNext ( 7 ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable . just ( 1 ) . throttleWithTimeout ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . merge ( ObservableEventStream . getEventStream ( "HTTP-ClusterA" , 50 ) , ObservableEventStream . getEventStream ( "HTTP-ClusterB" , 20 ) ) . groupBy ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return event . type ; ) . take ( 1 ) . blockingForEach ( new Consumer < GroupedObservable < String , Event > > ( ) @ Override public void accept ( GroupedObservable < String , Event > v ) System . out . println ( v ) ; v . take ( 1 ) . subscribe ( ) ; ) ; System . out . println ( "**** finished" ) ; Thread . sleep ( 200 ) ; 
Observable . merge ( ObservableEventStream . getEventStream ( "HTTP-ClusterA" , 50 ) , ObservableEventStream . getEventStream ( "HTTP-ClusterB" , 20 ) ) . groupBy ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return event . type ; ) . flatMap ( new Function < GroupedObservable < String , Event > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( GroupedObservable < String , Event > g ) return g . map ( new Function < Event , Object > ( ) @ Override public Object apply ( Event event ) return event . instanceId + " - " + event . values . get ( "count200" ) ; ) ; ) . take ( 20 ) . blockingForEach ( new Consumer < Object > ( ) @ Override public void accept ( Object pv ) System . out . println ( pv ) ; ) ; System . out . println ( "**** finished" ) ; Thread . sleep ( 200 ) ; 
ObservableEventStream . getEventStream ( "HTTP-ClusterB" , 20 ) . groupBy ( new Function < Event , String > ( ) @ Override public String apply ( Event e ) return e . instanceId ; ) . flatMap ( new Function < GroupedObservable < String , Event > , Observable < HashMap < String , String > > > ( ) @ Override public Observable < HashMap < String , String > > apply ( final GroupedObservable < String , Event > ge ) return ge . scan ( new HashMap < > ( ) , new BiFunction < HashMap < String , String > , Event , HashMap < String , String > > ( ) @ Override public HashMap < String , String > apply ( HashMap < String , String > accum , Event perInstanceEvent ) synchronized ( accum ) accum . put ( "instance" , ge . getKey ( ) ) ; return accum ; ) ; ) . take ( 10 ) . blockingForEach ( new Consumer < Object > ( ) @ Override public void accept ( Object pv ) synchronized ( pv ) System . out . println ( pv ) ; ) ; System . out . println ( "**** finished" ) ; Thread . sleep ( 200 ) ; 
Observable < HorrorMovie > horrors = Observable . just ( new HorrorMovie ( ) ) ; Observable < CoolRating > ratings = Observable . just ( new CoolRating ( ) ) ; Observable . < Movie , CoolRating , Result > zip ( horrors , ratings , combine ) . blockingForEach ( action ) ; Observable . < Movie , CoolRating , Result > zip ( horrors , ratings , combine ) . blockingForEach ( action ) ; Observable . < Media , Rating , ExtendedResult > zip ( horrors , ratings , combine ) . blockingForEach ( extendedAction ) ; Observable . < Media , Rating , Result > zip ( horrors , ratings , combine ) . blockingForEach ( action ) ; Observable . < Media , Rating , ExtendedResult > zip ( horrors , ratings , combine ) . blockingForEach ( action ) ; Observable . < Movie , CoolRating , Result > zip ( horrors , ratings , combine ) ; 
final Object invoked = new Object ( ) ; Collection < Observable < Object > > observables = Collections . emptyList ( ) ; Observable < Object > result = Observable . zip ( observables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] args ) System . out . println ( "received: " + args ) ; Assert . assertEquals ( "No argument should have been passed" , 0 , args . length ) ; return invoked ; ) ; assertSame ( invoked , result . blockingLast ( ) ) ; 
Observable . just ( 1 ) . zipWith ( Observable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true ) . test ( ) . assertResult ( 3 ) ; 
Observable . just ( 1 ) . zipWith ( Observable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true , 16 ) . test ( ) . assertResult ( 3 ) ; 
final ArrayList < List < Integer > > lists = new ArrayList < > ( ) ; Observable . concat ( Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . window ( 3 ) . map ( new Function < Observable < Integer > , Observable < List < Integer > > > ( ) @ Override public Observable < List < Integer > > apply ( Observable < Integer > xs ) return xs . toList ( ) . toObservable ( ) ; ) ) . blockingForEach ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > xs ) lists . add ( xs ) ; ) ; assertArrayEquals ( lists . get ( 0 ) . toArray ( new Integer [ 3 ] ) , new Integer [ ] 1 , 2 , 3 ) ; assertArrayEquals ( lists . get ( 1 ) . toArray ( new Integer [ 3 ] ) , new Integer [ ] 4 , 5 , 6 ) ; assertEquals ( 2 , lists . size ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = ps . window ( 5 , TimeUnit . SECONDS , scheduler , 2 ) . flatMapSingle ( new Function < Observable < Integer > , SingleSource < List < Integer > > > ( ) @ Override public SingleSource < List < Integer > > apply ( Observable < Integer > v ) throws Throwable return v . toList ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; to . assertValueCount ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ps . onNext ( 3 ) ; scheduler . advanceTimeBy ( 6 , TimeUnit . SECONDS ) ; to . assertValueCount ( 2 ) ; ps . onNext ( 4 ) ; ps . onNext ( 5 ) ; to . assertValueCount ( 3 ) ; ps . onNext ( 4 ) ; scheduler . advanceTimeBy ( 6 , TimeUnit . SECONDS ) ; to . assertValueCount ( 4 ) . assertNoErrors ( ) . assertNotComplete ( ) ; to . dispose ( ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . flatMapIterable ( v -> Arrays . asList ( 1 , 2 , 3 ) ) ) ; 
for ( int i = 1 ; i < 32 ; i ++ ) Flowable . range ( 1 , 1000 ) . parallel ( i ) . flatMapIterable ( v -> Arrays . asList ( v , v + 1 ) ) . sequential ( ) . test ( ) . withTag ( "Parallelism: " + i ) . assertValueCount ( 2000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
for ( int i = 1 ; i < 32 ; i ++ ) Flowable . range ( 1 , 1000 ) . parallel ( i ) . flatMapIterable ( v -> Arrays . asList ( ) ) . sequential ( ) . test ( ) . withTag ( "Parallelism: " + i ) . assertResult ( ) ; 
for ( int i = 1 ; i < 32 ; i ++ ) Flowable . range ( 1 , 1000 ) . parallel ( i ) . flatMapIterable ( v -> v % 2 == 0 ? Arrays . asList ( v ) : Arrays . asList ( ) ) . sequential ( ) . test ( ) . withTag ( "Parallelism: " + i ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
calls ++ ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . doOnNext ( this , e ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( calls , 1 ) ; calls = 0 ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . < Integer > error ( new TestException ( ) ) . parallel ( 1 ) . doOnNext ( this , e ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( calls , 0 ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . doOnNext ( this , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( calls , 1 ) ; calls = 0 ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . < Integer > error ( new TestException ( ) ) . parallel ( 1 ) . doOnNext ( this , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( calls , 0 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , ParallelFailureHandling . ERROR ) . sequential ( ) . test ( ) . assertFailure ( ArithmeticException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , ParallelFailureHandling . STOP ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) int count ; @ Override public void accept ( Integer v ) throws Exception if ( count ++ == 1 ) return ; if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , ParallelFailureHandling . RETRY ) . sequential ( ) . test ( ) . assertResult ( 0 , 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception return n < 5 ? ParallelFailureHandling . RETRY : ParallelFailureHandling . SKIP ; ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , ParallelFailureHandling . SKIP ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , ArithmeticException . class , TestException . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . just ( 1 ) . parallel ( 1 ) . doOnNext ( Functions . emptyConsumer ( ) , ParallelFailureHandling . ERROR ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . doOnNext ( Functions . emptyConsumer ( ) , ParallelFailureHandling . ERROR ) . sequential ( ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( ArithmeticException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , ParallelFailureHandling . STOP ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) int count ; @ Override public void accept ( Integer v ) throws Exception if ( count ++ == 1 ) return ; if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , ParallelFailureHandling . RETRY ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 0 , 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception return n < 5 ? ParallelFailureHandling . RETRY : ParallelFailureHandling . SKIP ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , ParallelFailureHandling . SKIP ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 0 , 2 ) . parallel ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( 1 / v < 0 ) System . out . println ( "Should not happen!" ) ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , ArithmeticException . class , TestException . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . just ( 1 ) . parallel ( 1 ) . doOnNext ( Functions . emptyConsumer ( ) , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . doOnNext ( Functions . emptyConsumer ( ) , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> ParallelFlowable . fromArray ( f ) . doOnNext ( v -> , ParallelFailureHandling . SKIP ) . sequential ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> ParallelFlowable . fromArray ( f ) . doOnNext ( v -> , ParallelFailureHandling . SKIP ) . filter ( v -> true , ParallelFailureHandling . SKIP ) . sequential ( ) ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . map ( Functions . identity ( ) ) ) ; 
Flowable . range ( 1 , 10 ) . parallel ( ) . map ( Functions . < Integer > identity ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 3 == 0 ; ) . sequential ( ) . test ( ) . assertResult ( 6 ) ; 
Flowable . range ( 1 , 10 ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . map ( Functions . < Integer > identity ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 3 == 0 ; ) . sequential ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 6 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . map ( Functions . < Object > identity ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . map ( Functions . < Object > identity ( ) ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . error ( new TestException ( ) ) . parallel ( ) . map ( Functions . < Object > identity ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . parallel ( ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . parallel ( ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . range ( 1 , 10 ) . parallel ( ) . map ( v -> v ) ) ; 
TestHelper . checkDoubleOnSubscribeParallel ( p -> p . map ( v -> v ) ) ; TestHelper . checkDoubleOnSubscribeParallel ( p -> p . map ( v -> v ) . filter ( v -> true ) ) ; 
Flowable < Integer > f = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Subscriber < @ NonNull ? super @ NonNull Integer > s ) @ SuppressWarnings ( "unchecked" ) ConditionalSubscriber < Integer > subscriber = ( ConditionalSubscriber < Integer > ) s ; subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . tryOnNext ( 1 ) ; subscriber . tryOnNext ( 2 ) ; ; ParallelFlowable . fromArray ( f ) . map ( v -> throw new TestException ( ) ; ) . filter ( v -> true ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
calls ++ ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . filter ( Functions . alwaysTrue ( ) , e ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . filter ( Functions . alwaysFalse ( ) , e ) . sequential ( ) . test ( ) . assertResult ( ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . filter ( Functions . alwaysFalse ( ) , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . < Integer > error ( new TestException ( ) ) . parallel ( 1 ) . filter ( Functions . alwaysTrue ( ) , e ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . filter ( Functions . alwaysTrue ( ) , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . < Integer > error ( new TestException ( ) ) . parallel ( 1 ) . filter ( Functions . alwaysTrue ( ) , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , ParallelFailureHandling . ERROR ) . sequential ( ) . test ( ) . assertFailure ( ArithmeticException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , ParallelFailureHandling . STOP ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) int count ; @ Override public boolean test ( Integer v ) throws Exception if ( count ++ == 1 ) return true ; return 1 / v > 0 ; , ParallelFailureHandling . RETRY ) . sequential ( ) . test ( ) . assertResult ( 0 , 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception return n < 5 ? ParallelFailureHandling . RETRY : ParallelFailureHandling . SKIP ; ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , ParallelFailureHandling . SKIP ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , ArithmeticException . class , TestException . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . just ( 1 ) . parallel ( 1 ) . filter ( Functions . alwaysTrue ( ) , ParallelFailureHandling . ERROR ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . filter ( Functions . alwaysTrue ( ) , ParallelFailureHandling . ERROR ) . sequential ( ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( ArithmeticException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , ParallelFailureHandling . STOP ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) int count ; @ Override public boolean test ( Integer v ) throws Exception if ( count ++ == 1 ) return true ; return 1 / v > 0 ; , ParallelFailureHandling . RETRY ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 0 , 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception return n < 5 ? ParallelFailureHandling . RETRY : ParallelFailureHandling . SKIP ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , ParallelFailureHandling . SKIP ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 0 , 2 ) . parallel ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return 1 / v > 0 ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , ArithmeticException . class , TestException . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . just ( 1 ) . parallel ( 1 ) . filter ( Functions . alwaysTrue ( ) , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . filter ( Functions . alwaysTrue ( ) , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> ParallelFlowable . fromArray ( f ) . filter ( v -> true , ParallelFailureHandling . SKIP ) . sequential ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> ParallelFlowable . fromArray ( f ) . filter ( v -> true , ParallelFailureHandling . SKIP ) . filter ( v -> true , ParallelFailureHandling . SKIP ) . sequential ( ) ) ; 
Flowable . just ( 1 ) . parallel ( ) . filter ( v -> false , ParallelFailureHandling . SKIP ) . filter ( v -> true , ParallelFailureHandling . SKIP ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . parallel ( ) . filter ( v -> true , ParallelFailureHandling . SKIP ) . filter ( v -> false , ParallelFailureHandling . SKIP ) . sequential ( ) . test ( ) . assertResult ( ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . runOn ( ImmediateThinScheduler . INSTANCE ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 1000 ) . parallel ( 2 ) . runOn ( Schedulers . computation ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . sequential ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
new ParallelFlowable < Integer > ( ) @ Override public int parallelism ( ) return 1 ; @ Override public void subscribe ( Subscriber < ? super Integer > [ ] subscribers ) subscribers [ 0 ] . onSubscribe ( new BooleanSubscription ( ) ) ; subscribers [ 0 ] . onNext ( 1 ) ; subscribers [ 0 ] . onNext ( 2 ) ; subscribers [ 0 ] . onNext ( 3 ) ; . runOn ( ImmediateThinScheduler . INSTANCE , 1 ) . sequential ( 1 ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; 
Flowable . error ( new TestException ( ) ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . sequential ( 1 ) . test ( 0 ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( 0L ) ; Flowable . error ( new TestException ( ) ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( new Subscriber [ ] ts ) ; ts . assertFailure ( TestException . class ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( 0L ) ; Flowable . empty ( ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( new Subscriber [ ] ts ) ; ts . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . parallel ( 1 ) . runOn ( Schedulers . computation ( ) ) . sequential ( ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; pp . parallel ( 1 ) . runOn ( Schedulers . computation ( ) ) . subscribe ( new Subscriber [ ] ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . parallel ( 1 ) . runOn ( Schedulers . computation ( ) ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; pp . parallel ( 1 ) . runOn ( Schedulers . computation ( ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( new Subscriber [ ] ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 5 ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . subscribe ( new Subscriber [ ] ts ) ; ts . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 5 ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( new Subscriber [ ] ts ) ; ts . assertResult ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeParallel ( pf -> pf . runOn ( ImmediateThinScheduler . INSTANCE ) ) ; 
TestHelper . checkDoubleOnSubscribeParallel ( pf -> pf . runOn ( ImmediateThinScheduler . INSTANCE ) . filter ( v -> true ) ) ; 
TestHelper . assertBadRequestReported ( ParallelFlowable . fromArray ( PublishProcessor . create ( ) ) . runOn ( ImmediateThinScheduler . INSTANCE ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; Flowable . range ( 1 , 5 ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . subscribe ( new Subscriber [ ] ts ) ; ts . requestMore ( 5 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; Flowable . range ( 1 , 5 ) . parallel ( 1 ) . runOn ( ImmediateThinScheduler . INSTANCE ) . filter ( v -> true ) . subscribe ( new Subscriber [ ] ts ) ; ts . requestMore ( 5 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
calls ++ ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . map ( Functions . identity ( ) , e ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . < Integer > error ( new TestException ( ) ) . parallel ( 1 ) . map ( Functions . identity ( ) , e ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . just ( 1 ) . parallel ( 1 ) . map ( Functions . identity ( ) , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
for ( ParallelFailureHandling e : ParallelFailureHandling . values ( ) ) Flowable . < Integer > error ( new TestException ( ) ) . parallel ( 1 ) . map ( Functions . identity ( ) , e ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , ParallelFailureHandling . ERROR ) . sequential ( ) . test ( ) . assertFailure ( ArithmeticException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , ParallelFailureHandling . STOP ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) int count ; @ Override public Integer apply ( Integer v ) throws Exception if ( count ++ == 1 ) return - 1 ; return 1 / v ; , ParallelFailureHandling . RETRY ) . sequential ( ) . test ( ) . assertResult ( - 1 , 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception return n < 5 ? ParallelFailureHandling . RETRY : ParallelFailureHandling . SKIP ; ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , ParallelFailureHandling . SKIP ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , ArithmeticException . class , TestException . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . just ( 1 ) . parallel ( 1 ) . map ( Functions . identity ( ) , ParallelFailureHandling . ERROR ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . map ( Functions . identity ( ) , ParallelFailureHandling . ERROR ) . sequential ( ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( ArithmeticException . class ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , ParallelFailureHandling . STOP ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) int count ; @ Override public Integer apply ( Integer v ) throws Exception if ( count ++ == 1 ) return - 1 ; return 1 / v ; , ParallelFailureHandling . RETRY ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( - 1 , 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception return n < 5 ? ParallelFailureHandling . RETRY : ParallelFailureHandling . SKIP ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , ParallelFailureHandling . SKIP ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 0 , 2 ) . parallel ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return 1 / v ; , new BiFunction < Long , Throwable , ParallelFailureHandling > ( ) @ Override public ParallelFailureHandling apply ( Long n , Throwable e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , ArithmeticException . class , TestException . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . just ( 1 ) . parallel ( 1 ) . map ( Functions . identity ( ) , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . map ( Functions . identity ( ) , ParallelFailureHandling . ERROR ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkEnum ( ParallelFailureHandling . class ) ; 
TestHelper . checkInvalidParallelSubscribers ( Flowable . range ( 1 , 10 ) . parallel ( ) . map ( v -> v , ParallelFailureHandling . SKIP ) ) ; 
TestHelper . checkDoubleOnSubscribeParallel ( p -> p . map ( v -> v , ParallelFailureHandling . ERROR ) ) ; TestHelper . checkDoubleOnSubscribeParallel ( p -> p . map ( v -> v , ParallelFailureHandling . ERROR ) . filter ( v -> true ) ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; . parallel ( 1 , 1 ) . sequential ( 1 ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; 
s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; 
Flowable . just ( 1 ) . filter ( Functions . alwaysFalse ( ) ) . parallel ( ) . sequential ( ) . test ( ) . assertResult ( ) ; 
return new StripBoundary < > ( upstream ) ; 
return qs . poll ( ) ; 
Flowable . just ( 1 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( new StripBoundary < > ( null ) ) . parallel ( ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; up . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( new StripBoundary < > ( null ) ) . parallel ( ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( up . hasSubscribers ( ) ) ; 
final Set < String > between = new HashSet < > ( ) ; final ConcurrentHashMap < String , String > processing = new ConcurrentHashMap < > ( ) ; TestSubscriberEx < Object > ts = Flowable . range ( 1 , 10 ) . observeOn ( Schedulers . single ( ) , false , 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception between . add ( Thread . currentThread ( ) . getName ( ) ) ; ) . parallel ( 2 , 1 ) . runOn ( Schedulers . computation ( ) , 1 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception processing . putIfAbsent ( Thread . currentThread ( ) . getName ( ) , "" ) ; return v ; ) . sequential ( ) . to ( TestHelper . < Object > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertComplete ( ) . assertNoErrors ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertEquals ( between . toString ( ) , 1 , between . size ( ) ) ; assertTrue ( between . toString ( ) , between . iterator ( ) . next ( ) . contains ( "RxSingleScheduler" ) ) ; Map < String , String > map = processing ; for ( String e : map . keySet ( ) ) assertTrue ( map . toString ( ) , e . contains ( "RxComputationThreadPool" ) ) ; 
TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) . parallel ( ) ) ; 
Flowable . just ( 1 , 2 ) . filter ( v -> v == 1 ) . compose ( TestHelper . flowableStripBoundary ( ) ) . parallel ( 1 ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onComplete ( ) ; up . filter ( v -> v == 1 ) . compose ( TestHelper . flowableStripBoundary ( ) ) . parallel ( 1 ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . parallel ( ) . sequential ( ) ) ; 
FlowableSubscriber < Integer > fs = new FlowableSubscriber < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( @ NonNull Subscription s ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestHelper . race ( ( ) -> s . request ( Long . MAX_VALUE ) , ( ) -> s . request ( Long . MAX_VALUE ) ) ; ; PublishProcessor . create ( ) . parallel ( 1 ) . subscribe ( new FlowableSubscriber [ ] fs ) ; 
FlowableSubscriber < Integer > fs = new FlowableSubscriber < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) @ Override public void onSubscribe ( @ NonNull Subscription s ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestHelper . race ( ( ) -> s . request ( 1 ) , ( ) -> s . request ( 1 ) ) ; ; PublishProcessor . create ( ) . parallel ( 1 ) . subscribe ( new FlowableSubscriber [ ] fs ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . reduce ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiFunction < List < Integer > , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; return a ; ) ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . reduce ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception throw new TestException ( ) ; , new BiFunction < List < Integer > , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; return a ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . reduce ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiFunction < List < Integer > , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( List < Integer > a , Integer b ) throws Exception if ( b == 3 ) throw new TestException ( ) ; a . add ( b ) ; return a ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = pp . parallel ( ) . reduce ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiFunction < List < Integer > , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; return a ; ) . sequential ( ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . parallel ( ) . reduce ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiFunction < List < Integer > , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; return a ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . reduce ( new Supplier < List < Object > > ( ) @ Override public List < Object > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiFunction < List < Object > , Object , List < Object > > ( ) @ Override public List < Object > apply ( List < Object > a , Object b ) throws Exception a . add ( b ) ; return a ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeParallel ( pf -> pf . reduce ( ArrayList :: new , ( a , b ) -> a ) ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
Flowable . range ( 1 , 10 ) . parallel ( ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 3 == 0 ; ) . sequential ( ) . test ( ) . assertResult ( 6 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . filter ( Functions . alwaysTrue ( ) ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . error ( new TestException ( ) ) . parallel ( ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . parallel ( ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> ParallelFlowable . fromArray ( f ) . filter ( v -> true ) . sequential ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> ParallelFlowable . fromArray ( f ) . filter ( v -> true ) . filter ( v -> true ) . sequential ( ) ) ; 
Flowable . just ( 1 ) . parallel ( ) . filter ( v -> false ) . filter ( v -> true ) . sequential ( ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . parallel ( ) . filter ( v -> true ) . filter ( v -> false ) . sequential ( ) . test ( ) . assertResult ( ) ; 
return 4 ; 
Flowable < Integer > source = Flowable . range ( 1 , 1000000 ) . hide ( ) ; for ( int i = 1 ; i < 33 ; i ++ ) Flowable < Integer > result = ParallelFlowable . from ( source , i ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . sequential ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; ts . assertSubscribed ( ) . assertValueCount ( 1000000 ) . assertComplete ( ) . assertNoErrors ( ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 1000000 ) ; for ( int i = 1 ; i < 33 ; i ++ ) Flowable < Integer > result = ParallelFlowable . from ( source , i ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . sequential ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; ts . assertSubscribed ( ) . assertValueCount ( 1000000 ) . assertComplete ( ) . assertNoErrors ( ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 1000000 ) . hide ( ) ; int ncpu = Math . max ( 8 , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; for ( int i = 1 ; i < ncpu + 1 ; i ++ ) ExecutorService exec = Executors . newFixedThreadPool ( i ) ; Scheduler scheduler = Schedulers . from ( exec ) ; try Flowable < Integer > result = ParallelFlowable . from ( source , i ) . runOn ( scheduler ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . sequential ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertSubscribed ( ) . assertValueCount ( 1000000 ) . assertComplete ( ) . assertNoErrors ( ) ; finally exec . shutdown ( ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 1000000 ) ; int ncpu = Math . max ( 8 , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; for ( int i = 1 ; i < ncpu + 1 ; i ++ ) ExecutorService exec = Executors . newFixedThreadPool ( i ) ; Scheduler scheduler = Schedulers . from ( exec ) ; try Flowable < Integer > result = ParallelFlowable . from ( source , i ) . runOn ( scheduler ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . sequential ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; ts . awaitDone ( 10 , TimeUnit . SECONDS ) ; ts . assertSubscribed ( ) . assertValueCount ( 1000000 ) . assertComplete ( ) . assertNoErrors ( ) ; finally exec . shutdown ( ) ; 
for ( int i = 1 ; i <= Runtime . getRuntime ( ) . availableProcessors ( ) * 2 ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 10 ) . parallel ( i ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . subscribe ( ts ) ; ts . assertResult ( 55 ) ; 
int m = 100000 ; for ( int n = 1 ; n <= m ; n *= 10 ) for ( int i = 1 ; i <= Runtime . getRuntime ( ) . availableProcessors ( ) ; i ++ ) ExecutorService exec = Executors . newFixedThreadPool ( i ) ; Scheduler scheduler = Schedulers . from ( exec ) ; try TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , n ) . map ( new Function < Integer , Long > ( ) @ Override public Long apply ( Integer v ) throws Exception return ( long ) v ; ) . parallel ( i ) . runOn ( scheduler ) . reduce ( new BiFunction < Long , Long , Long > ( ) @ Override public Long apply ( Long a , Long b ) throws Exception return a + b ; ) . subscribe ( ts ) ; ts . awaitDone ( 500 , TimeUnit . SECONDS ) ; long e = ( ( long ) n ) * ( 1 + n ) / 2 ; ts . assertResult ( e ) ; finally exec . shutdown ( ) ; 
TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; Flowable . fromArray ( 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ) . parallel ( ) . toSortedList ( Functions . naturalComparator ( ) ) . subscribe ( ts ) ; ts . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; Flowable . fromArray ( 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ) . parallel ( ) . sorted ( Functions . naturalComparator ( ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 ) ; ts . request ( 5 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ; ts . request ( 3 ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Supplier < List < Integer > > as = new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 10 ) . parallel ( ) . collect ( as , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . sequential ( ) . flatMapIterable ( new Function < List < Integer > , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( List < Integer > v ) throws Exception return v ; ) . subscribe ( ts ) ; ts . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ParallelFlowable . fromArray ( Flowable . range ( 1 , 5 ) , Flowable . range ( 6 , 5 ) ) . sequential ( ) . subscribe ( ts ) ; ts . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 5 ) . parallel ( ) . concatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . range ( v * 10 + 1 , 3 ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 11 , 12 , 13 , 21 , 22 , 23 , 31 , 32 , 33 , 41 , 42 , 43 , 51 , 52 , 53 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 5 ) . parallel ( ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . range ( v * 10 + 1 , 3 ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 11 , 12 , 13 , 21 , 22 , 23 , 31 , 32 , 33 , 41 , 42 , 43 , 51 , 52 , 53 ) ; 
ExecutorService exec = Executors . newFixedThreadPool ( 3 ) ; Scheduler s = Schedulers . from ( exec ) ; try Supplier < List < Integer > > as = new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100000 ) . parallel ( 3 ) . runOn ( s ) . collect ( as , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception System . out . println ( v . size ( ) ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 3 ) . assertNoErrors ( ) . assertComplete ( ) ; List < List < Integer > > list = ts . values ( ) ; Assert . assertEquals ( 100000 , list . get ( 0 ) . size ( ) + list . get ( 1 ) . size ( ) + list . get ( 2 ) . size ( ) ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newFixedThreadPool ( 3 ) ; Scheduler s = Schedulers . from ( exec ) ; try Supplier < List < Integer > > as = new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100000 ) . hide ( ) . parallel ( 3 ) . runOn ( s ) . collect ( as , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception System . out . println ( v . size ( ) ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 3 ) . assertNoErrors ( ) . assertComplete ( ) ; List < List < Integer > > list = ts . values ( ) ; Assert . assertEquals ( 100000 , list . get ( 0 ) . size ( ) + list . get ( 1 ) . size ( ) + list . get ( 2 ) . size ( ) ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newFixedThreadPool ( 3 ) ; Scheduler s = Schedulers . from ( exec ) ; try Supplier < List < Integer > > as = new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100000 ) . hide ( ) . observeOn ( s ) . parallel ( 3 ) . runOn ( s ) . collect ( as , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception System . out . println ( v . size ( ) ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 3 ) . assertNoErrors ( ) . assertComplete ( ) ; List < List < Integer > > list = ts . values ( ) ; Assert . assertEquals ( 100000 , list . get ( 0 ) . size ( ) + list . get ( 1 ) . size ( ) + list . get ( 2 ) . size ( ) ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newFixedThreadPool ( 3 ) ; Scheduler s = Schedulers . from ( exec ) ; try Supplier < List < Integer > > as = new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100000 ) . hide ( ) . observeOn ( s ) . parallel ( 3 ) . runOn ( s ) . collect ( as , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception System . out . println ( v . size ( ) ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 3 ) . assertNoErrors ( ) . assertComplete ( ) ; List < List < Integer > > list = ts . values ( ) ; Assert . assertEquals ( 100000 , list . get ( 0 ) . size ( ) + list . get ( 1 ) . size ( ) + list . get ( 2 ) . size ( ) ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newFixedThreadPool ( 3 ) ; Scheduler s = Schedulers . from ( exec ) ; try Supplier < List < Integer > > as = new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100000 ) . observeOn ( s ) . parallel ( 3 ) . runOn ( s ) . collect ( as , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception System . out . println ( v . size ( ) ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 3 ) . assertNoErrors ( ) . assertComplete ( ) ; List < List < Integer > > list = ts . values ( ) ; Assert . assertEquals ( 100000 , list . get ( 0 ) . size ( ) + list . get ( 1 ) . size ( ) + list . get ( 2 ) . size ( ) ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newFixedThreadPool ( 4 ) ; Scheduler s = Schedulers . from ( exec ) ; try Supplier < List < Integer > > as = new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100000 ) . take ( 1000 ) . observeOn ( s ) . parallel ( 3 ) . runOn ( s ) . collect ( as , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception System . out . println ( v . size ( ) ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 3 ) . assertNoErrors ( ) . assertComplete ( ) ; List < List < Integer > > list = ts . values ( ) ; Assert . assertEquals ( 1000 , list . get ( 0 ) . size ( ) + list . get ( 1 ) . size ( ) + list . get ( 2 ) . size ( ) ) ; finally exec . shutdown ( ) ; 
ExecutorService exec = Executors . newFixedThreadPool ( 3 ) ; Scheduler s = Schedulers . from ( exec ) ; try Supplier < List < Integer > > as = new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) up . onNext ( i ) ; up . take ( 1000 ) . observeOn ( s ) . parallel ( 3 ) . runOn ( s ) . collect ( as , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception System . out . println ( v . size ( ) ) ; ) . sequential ( ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 3 ) . assertNoErrors ( ) . assertComplete ( ) ; List < List < Integer > > list = ts . values ( ) ; Assert . assertEquals ( 1000 , list . get ( 0 ) . size ( ) + list . get ( 1 ) . size ( ) + list . get ( 2 ) . size ( ) ) ; finally exec . shutdown ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( 0 ) ; Flowable . range ( 1 , 3 ) . parallel ( 3 ) . sequential ( ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; 
for ( int parallelism = 1 ; parallelism <= 8 ; parallelism ++ ) for ( int prefetch = 1 ; prefetch <= 1024 ; prefetch *= 2 ) Flowable . range ( 1 , 1024 * 1024 ) . parallel ( parallelism , prefetch ) . map ( Functions . < Integer > identity ( ) ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( 1024 * 1024 ) . assertNoErrors ( ) . assertComplete ( ) ; 
for ( int parallelism = 1 ; parallelism <= 8 ; parallelism *= 2 ) for ( int prefetch = 1 ; prefetch <= 1024 ; prefetch *= 2 ) System . out . println ( "parallelismAndPrefetchAsync >> " + parallelism + ", " + prefetch ) ; Flowable . range ( 1 , 1024 * 1024 ) . parallel ( parallelism , prefetch ) . runOn ( Schedulers . computation ( ) ) . map ( Functions . < Integer > identity ( ) ) . sequential ( prefetch ) . to ( TestHelper . < Integer > testConsumer ( ) ) . withTag ( "parallelism = " + parallelism + ", prefetch = " + prefetch ) . awaitDone ( 30 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1024 * 1024 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 10 ) . parallel ( 2 ) . subscribe ( new Subscriber [ ] ts ) ; ts . assertFailure ( IllegalArgumentException . class ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; TestSubscriber < Integer > ts3 = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 10 ) . parallel ( 2 ) . subscribe ( new Subscriber [ ] ts1 , ts2 , ts3 ) ; ts1 . assertFailure ( IllegalArgumentException . class ) ; ts2 . assertFailure ( IllegalArgumentException . class ) ; ts3 . assertFailure ( IllegalArgumentException . class ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 20 ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ) ; 
final boolean [ ] cancelled = false ; Flowable . range ( 1 , 20 ) . concatWith ( Flowable . < Integer > never ( ) ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception cancelled [ 0 ] = true ; ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception if ( v == 10 ) throw new TestException ( ) ; return v % 2 == 0 ; ) . sequential ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertError ( TestException . class ) . assertNotComplete ( ) ; Thread . sleep ( 100 ) ; assertTrue ( cancelled [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( v == 3 ) throw new TestException ( ) ; else count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertError ( TestException . class ) . assertNotComplete ( ) ; assertTrue ( "" + count [ 0 ] , count [ 0 ] < 5 ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( v == 3 ) throw new TestException ( ) ; else count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertError ( TestException . class ) . assertNotComplete ( ) ; assertTrue ( "" + count [ 0 ] , count [ 0 ] < 5 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . error ( new TestException ( ) ) . parallel ( ) . runOn ( Schedulers . computation ( ) ) . sequential ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; Thread . sleep ( 300 ) ; for ( Throwable ex : errors ) ex . printStackTrace ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception if ( v == 3 ) throw new TestException ( ) ; return v ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception if ( e instanceof TestException ) count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertError ( TestException . class ) . assertNotComplete ( ) ; assertEquals ( 1 , count [ 0 ] ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 5 ) . parallel ( 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception if ( v == 3 ) throw new TestException ( ) ; return v ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception if ( e instanceof TestException ) throw new IOException ( ) ; ) . sequential ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertError ( CompositeException . class ) . assertNotComplete ( ) ; List < Throwable > errors = TestHelper . errorList ( ts ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , IOException . class ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 2 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . doAfterTerminated ( new Action ( ) @ Override public void run ( ) throws Exception count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 2 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 2 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long s ) throws Exception count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 2 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception count [ 0 ] ++ ; ) . sequential ( ) . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 2 , count [ 0 ] ) ; 
ParallelFlowable . fromArray ( new Publisher [ 0 ] ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . to ( new ParallelFlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( ParallelFlowable < Integer > pf ) return pf . sequential ( ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . to ( new ParallelFlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( ParallelFlowable < Integer > pf ) throw new TestException ( ) ; ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . compose ( new ParallelTransformer < Integer , Integer > ( ) @ Override public ParallelFlowable < Integer > apply ( ParallelFlowable < Integer > pf ) return pf . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) ; ) . sequential ( ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 6 ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception if ( v == 3 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( v ) ; , true ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception if ( e instanceof TestException ) count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertValues ( 1 , 2 , 4 , 5 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; assertEquals ( 1 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception if ( v == 3 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( v ) ; , true , 1 ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception if ( e instanceof TestException ) count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertValues ( 1 , 2 , 4 , 5 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; assertEquals ( 1 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception if ( v == 3 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( v ) ; , true ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception if ( e instanceof TestException ) count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertValues ( 1 , 2 , 4 , 5 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; assertEquals ( 1 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception if ( v == 3 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( v ) ; , 1 , true ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception if ( e instanceof TestException ) count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertValues ( 1 , 2 , 4 , 5 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; assertEquals ( 1 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Flowable . range ( 1 , 5 ) . parallel ( 2 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception if ( v == 3 ) return Flowable . error ( new TestException ( ) ) ; return Flowable . just ( v ) ; , false ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception if ( e instanceof TestException ) count [ 0 ] ++ ; ) . sequential ( ) . test ( ) . assertValues ( 1 , 2 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; assertEquals ( 1 , count [ 0 ] ) ; 
int n = source . parallelism ( ) ; @ SuppressWarnings ( "unchecked" ) TestSubscriber < Object > [ ] consumers = new TestSubscriber [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) consumers [ i ] = new TestSubscriber < > ( ) ; source . subscribe ( consumers ) ; for ( int i = 0 ; i <= n ; i ++ ) consumers [ i ] . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( IllegalArgumentException . class ) ; 
TestHelper . checkEnum ( ListAddBiConsumer . class ) ; 
MergerBiFunction < Integer > f = new MergerBiFunction < > ( Functions . < Integer > naturalComparator ( ) ) ; assertEquals ( 0 , f . apply ( Collections . < Integer > emptyList ( ) , Collections . < Integer > emptyList ( ) ) . size ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 ) , f . apply ( Collections . < Integer > emptyList ( ) , Arrays . asList ( 1 , 2 ) ) ) ; for ( int i = 0 ; i < 4 ; i ++ ) int k = 0 ; List < Integer > list1 = new ArrayList < > ( ) ; for ( int j = 0 ; j < i ; j ++ ) list1 . add ( k ++ ) ; List < Integer > list2 = new ArrayList < > ( ) ; for ( int j = i ; j < 4 ; j ++ ) list2 . add ( k ++ ) ; assertEquals ( Arrays . asList ( 0 , 1 , 2 , 3 ) , f . apply ( list1 , list2 ) ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) ) ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . flatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) ) ) ; 
ParallelFlowableTest . checkSubscriberCount ( ParallelFlowable . fromArray ( new Publisher [ ] Flowable . just ( 1 ) ) ) ; 
new ParallelFlowable < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > [ ] subscribers ) subscribers [ 0 ] . onSubscribe ( new BooleanSubscription ( ) ) ; subscribers [ 0 ] . onNext ( 1 ) ; subscribers [ 0 ] . onNext ( 2 ) ; subscribers [ 0 ] . onNext ( 3 ) ; @ Override public int parallelism ( ) return 1 ; . sequential ( 1 ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; 
@ SuppressWarnings ( "unchecked" ) final Subscriber < ? super Integer > [ ] subs = new Subscriber [ 1 ] ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; subs [ 0 ] . onNext ( 2 ) ; subs [ 0 ] . onNext ( 3 ) ; ; new ParallelFlowable < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > [ ] subscribers ) subs [ 0 ] = subscribers [ 0 ] ; subscribers [ 0 ] . onSubscribe ( new BooleanSubscription ( ) ) ; subscribers [ 0 ] . onNext ( 1 ) ; @ Override public int parallelism ( ) return 1 ; . sequential ( 1 ) . subscribe ( ts ) ; ts . assertFailure ( MissingBackpressureException . class , 1 ) ; 
Flowable . empty ( ) . parallel ( ) . sequential ( ) . test ( 0 ) . assertResult ( ) ; 
new ParallelFlowable < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > [ ] subscribers ) subscribers [ 0 ] . onSubscribe ( new BooleanSubscription ( ) ) ; subscribers [ 0 ] . onNext ( 1 ) ; subscribers [ 0 ] . onNext ( 2 ) ; @ Override public int parallelism ( ) return 1 ; . sequentialDelayError ( 1 ) . test ( 0 ) . requestMore ( 1 ) . assertFailure ( MissingBackpressureException . class , 1 ) ; 
@ SuppressWarnings ( "unchecked" ) final Subscriber < ? super Integer > [ ] subs = new Subscriber [ 1 ] ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) subs [ 0 ] . onNext ( 2 ) ; subs [ 0 ] . onNext ( 3 ) ; ; new ParallelFlowable < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > [ ] subscribers ) subs [ 0 ] = subscribers [ 0 ] ; subscribers [ 0 ] . onSubscribe ( new BooleanSubscription ( ) ) ; subscribers [ 0 ] . onNext ( 1 ) ; @ Override public int parallelism ( ) return 1 ; . sequentialDelayError ( 1 ) . subscribe ( ts ) ; ts . request ( 1 ) ; ts . assertFailure ( MissingBackpressureException . class , 1 , 2 ) ; 
Flowable . empty ( ) . parallel ( ) . sequentialDelayError ( ) . test ( 0 ) . assertResult ( ) ; 
TestSubscriberEx < Integer > flow = Flowable . range ( 1 , 2 ) . parallel ( 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . sequentialDelayError ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > error = TestHelper . errorList ( flow ) ; TestHelper . assertError ( error , 0 , TestException . class ) ; TestHelper . assertError ( error , 1 , TestException . class ) ; 
Flowable . just ( 1 ) . parallel ( 1 ) . sequentialDelayError ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 2 ) . parallel ( 1 ) . sequentialDelayError ( 1 ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 3 ) . parallel ( 1 ) . sequentialDelayError ( 1 ) . take ( 2 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . range ( 1 , 3 ) . parallel ( 1 ) . sequentialDelayError ( 1 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 3 ) . parallel ( 1 ) . sequentialDelayError ( 1 ) . test ( 0 ) ; ts . cancel ( ) ; ts . assertEmpty ( ) ; 
TestSubscriber < Integer > ts = Flowable . < Integer > empty ( ) . parallel ( 1 ) . sequentialDelayError ( 1 ) . test ( 0 ) ; ts . assertResult ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 3 ) . parallel ( 1 ) . sequential ( ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 3 ) . parallel ( 1 ) . sequentialDelayError ( ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
Flowable . range ( 1 , 3 ) . parallel ( 1 ) . sequentialDelayError ( ) . test ( 0 ) . requestMore ( 1 ) . assertValues ( 1 ) . requestMore ( 1 ) . assertValues ( 1 , 2 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 ) ; 
Flowable . range ( 1 , 4 ) . parallel ( 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception if ( v == 1 ) throw new TestException ( ) ; return v ; ) . sequentialDelayError ( ) . test ( ) . assertFailure ( TestException . class , 2 , 3 , 4 ) ; 
Flowable . range ( 1 , 4 ) . hide ( ) . parallel ( 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception if ( v == 1 ) throw new TestException ( ) ; return v ; ) . sequentialDelayError ( ) . test ( ) . assertFailure ( TestException . class , 2 , 3 , 4 ) ; 
Flowable . range ( 1 , 10 ) . parallel ( 1 ) . sequential ( ) . takeUntil ( v -> true ) . test ( 0L ) . requestMore ( 100 ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 10 ) . parallel ( 1 ) . sequentialDelayError ( ) . takeUntil ( v -> true ) . test ( 0L ) . requestMore ( 100 ) . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . parallel ( 1 ) . sequential ( ) . test ( 0L ) ; pp . onNext ( 1 ) ; ts . requestMore ( 10 ) . assertValuesOnly ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . parallel ( 1 ) . sequentialDelayError ( ) . test ( 0L ) ; pp . onNext ( 1 ) ; ts . requestMore ( 10 ) . assertValuesOnly ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onNext ( 2 ) ; ; ParallelFlowable . fromArray ( pp ) . sequential ( ) . subscribeWith ( ts ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 , 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onNext ( 2 ) ; ; ParallelFlowable . fromArray ( pp ) . sequentialDelayError ( ) . subscribeWith ( ts ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 , 2 ) ; 
TestHelper . assertBadRequestReported ( ParallelFlowable . fromArray ( PublishProcessor . create ( ) ) . sequential ( ) ) ; 
TestHelper . withErrorTracking ( errors -> for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) AtomicReference < Subscriber < ? super Integer > > ref1 = new AtomicReference < > ( ) ; AtomicReference < Subscriber < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Flowable < Integer > f1 = new Flowable < Integer > ( ) @ Override public void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; ref1 . set ( s ) ; ; Flowable < Integer > f2 = new Flowable < Integer > ( ) @ Override public void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; ref2 . set ( s ) ; ; ParallelFlowable . fromArray ( f1 , f2 ) . sequential ( 1 ) . test ( 0 ) ; TestHelper . race ( ( ) -> ref1 . get ( ) . onNext ( 1 ) ; ref1 . get ( ) . onNext ( 2 ) ; , ( ) -> ref2 . get ( ) . onNext ( 3 ) ; ref2 . get ( ) . onNext ( 4 ) ; ) ; errors . clear ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) AtomicReference < Subscriber < ? super Integer > > ref1 = new AtomicReference < > ( ) ; AtomicReference < Subscriber < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Flowable < Integer > f1 = new Flowable < Integer > ( ) @ Override public void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; ref1 . set ( s ) ; ; Flowable < Integer > f2 = new Flowable < Integer > ( ) @ Override public void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; ref2 . set ( s ) ; ; ParallelFlowable . fromArray ( f1 , f2 ) . sequentialDelayError ( 1 ) . test ( 0 ) ; TestHelper . race ( ( ) -> ref1 . get ( ) . onNext ( 1 ) ; ref1 . get ( ) . onNext ( 2 ) ; , ( ) -> ref2 . get ( ) . onNext ( 3 ) ; ref2 . get ( ) . onNext ( 4 ) ; ) ; errors . clear ( ) ; ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception throw new TestException ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception if ( b == 3 ) throw new TestException ( ) ; a . add ( b ) ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = pp . parallel ( ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . sequential ( ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . parallel ( ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . collect ( new Supplier < List < Object > > ( ) @ Override public List < Object > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Object > , Object > ( ) @ Override public void accept ( List < Object > a , Object b ) throws Exception a . add ( b ) ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeParallel ( pf -> pf . collect ( ArrayList :: new , ArrayList :: add ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . parallel ( ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . < Integer > error ( new TestException ( ) ) . parallel ( ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ParallelFlowable . fromArray ( Flowable . < Integer > error ( new IOException ( ) ) , Flowable . < Integer > error ( new TestException ( ) ) ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . < Integer > empty ( ) . parallel ( ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertResult ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . reduce ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return "" + a + b ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 4 ) . parallel ( 2 ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception if ( b == 3 ) throw new TestException ( ) ; return a + b ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 4 ) . parallel ( 2 ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception if ( a == 1 + 3 ) throw new TestException ( ) ; return a + b ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeParallelToFlowable ( pf -> pf . reduce ( ( a , b ) -> a ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . parallel ( ) . sorted ( Functions . < Integer > naturalComparator ( ) ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . < Integer > error ( new TestException ( ) ) . parallel ( ) . sorted ( Functions . < Integer > naturalComparator ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . < Integer > error ( new TestException ( ) ) . parallel ( ) . sorted ( Functions . < Integer > naturalComparator ( ) ) . test ( 0 ) . assertFailure ( TestException . class ) ; assertTrue ( errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ParallelFlowable . fromArray ( Flowable . < Integer > error ( new IOException ( ) ) , Flowable . < Integer > error ( new TestException ( ) ) ) . sorted ( Functions . < Integer > naturalComparator ( ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . fromArray ( 4 , 3 , 2 , 1 ) . parallel ( 2 ) . sorted ( new Comparator < Integer > ( ) @ Override public int compare ( Integer o1 , Integer o2 ) if ( o1 == 4 && o2 == 3 ) throw new TestException ( ) ; return o1 . compareTo ( o2 ) ; ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Flowable . < Integer > empty ( ) . parallel ( ) . sorted ( Functions . < Integer > naturalComparator ( ) ) . test ( ) . assertResult ( ) ; 
Integer [ ] values = new Integer [ 100 * 1000 ] ; for ( int i = 0 ; i < values . length ; i ++ ) values [ i ] = values . length - i ; TestSubscriber < Integer > ts = Flowable . fromArray ( values ) . parallel ( 2 ) . runOn ( Schedulers . computation ( ) ) . sorted ( Functions . naturalComparator ( ) ) . observeOn ( Schedulers . single ( ) ) . test ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( values . length ) . assertNoErrors ( ) . assertComplete ( ) ; List < Integer > list = ts . values ( ) ; for ( int i = 0 ; i < values . length ; i ++ ) assertEquals ( i + 1 , list . get ( i ) . intValue ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ReplayProcessor < Integer > pp = ReplayProcessor . create ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; final TestSubscriber < Integer > ts = pp . parallel ( 2 ) . sorted ( Functions . naturalComparator ( ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ReplayProcessor < Integer > pp = ReplayProcessor . create ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; final TestSubscriber < Integer > ts = pp . parallel ( 2 ) . sorted ( Functions . naturalComparator ( ) ) . test ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestHelper . assertBadRequestReported ( PublishProcessor . < Integer > create ( ) . parallel ( ) . sorted ( Functions . naturalComparator ( ) ) ) ; 
TestHelper . withErrorTracking ( errors -> PublishProcessor < List < Integer > > pp1 = PublishProcessor . create ( ) ; PublishProcessor < List < Integer > > pp2 = PublishProcessor . create ( ) ; new ParallelSortedJoin < > ( ParallelFlowable . fromArray ( pp1 , pp2 ) , ( a , b ) -> pp1 . onError ( new IOException ( ) ) ; throw new TestException ( ) ; ) . test ( ) ; pp1 . onNext ( Arrays . asList ( 1 ) ) ; pp2 . onNext ( Arrays . asList ( 2 ) ) ; pp1 . onComplete ( ) ; pp2 . onComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
ParallelFlowableTest . checkSubscriberCount ( Flowable . range ( 1 , 5 ) . parallel ( ) . doOnNext ( Functions . emptyConsumer ( ) ) ) ; 
Flowable . range ( 1 , 5 ) . parallel ( ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new ParallelInvalid ( ) . doOnNext ( Functions . emptyConsumer ( ) ) . sequential ( ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . range ( 1 , 5 ) . parallel ( ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . < Integer > never ( ) . parallel ( ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . test ( ) . cancel ( ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . just ( 1 ) . parallel ( ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . parallel ( ) . doAfterTerminated ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . test ( ) . assertResult ( 1 ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . < Integer > error ( new IOException ( ) ) . parallel ( ) . doAfterTerminated ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . sequential ( ) . test ( ) . assertFailure ( IOException . class ) ; assertFalse ( errors . isEmpty ( ) ) ; for ( Throwable ex : errors ) Throwable exc = ex . getCause ( ) ; assertTrue ( ex . toString ( ) , exc instanceof TestException || exc instanceof IOException ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> ParallelFlowable . fromArray ( f ) . doOnComplete ( ( ) -> ) . sequential ( ) ) ; 
Runnable run = mock ( Runnable . class ) ; Disposable d = Disposable . fromRunnable ( run ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "RunnableDisposable(disposed=false, " ) ) ; d . dispose ( ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "RunnableDisposable(disposed=true, " ) ) ; d . dispose ( ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "RunnableDisposable(disposed=true, " ) ) ; verify ( run , times ( 1 ) ) . run ( ) ; 
Disposable empty = Disposable . empty ( ) ; assertFalse ( empty . isDisposed ( ) ) ; empty . dispose ( ) ; assertTrue ( empty . isDisposed ( ) ) ; 
Disposable disposed = Disposable . disposed ( ) ; assertTrue ( disposed . isDisposed ( ) ) ; 
Action action = mock ( Action . class ) ; Disposable d = Disposable . fromAction ( action ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "ActionDisposable(disposed=false, " ) ) ; d . dispose ( ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "ActionDisposable(disposed=true, " ) ) ; d . dispose ( ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "ActionDisposable(disposed=true, " ) ) ; verify ( action , times ( 1 ) ) . run ( ) ; 
try Disposable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new IllegalArgumentException ( ) ; ) . dispose ( ) ; fail ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) try Disposable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new InternalError ( ) ; ) . dispose ( ) ; fail ( "Should have thrown!" ) ; catch ( InternalError ex ) try Disposable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . dispose ( ) ; fail ( "Should have thrown!" ) ; catch ( RuntimeException ex ) if ( ! ( ex . getCause ( ) instanceof IOException ) ) fail ( ex . toString ( ) + ": Should have cause of IOException" ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Disposable d = Disposable . empty ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) d . dispose ( ) ; ; TestHelper . race ( r , r ) ; 
Disposable . fromSubscription ( null ) ; 
Subscription s = mock ( Subscription . class ) ; Disposable . fromSubscription ( s ) . dispose ( ) ; verify ( s ) . cancel ( ) ; verify ( s , never ( ) ) . request ( anyInt ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try AtomicReference < Disposable > target = new AtomicReference < > ( ) ; Disposable d = Disposable . empty ( ) ; DisposableHelper . setOnce ( target , d ) ; Disposable d1 = Disposable . empty ( ) ; DisposableHelper . setOnce ( target , d1 ) ; assertTrue ( d1 . isDisposed ( ) ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; AutoCloseable ac = ( ) -> counter . getAndIncrement ( ) ; Disposable d = Disposable . fromAutoCloseable ( ac ) ; assertFalse ( d . isDisposed ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "AutoCloseableDisposable(disposed=false, " ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , counter . get ( ) ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "AutoCloseableDisposable(disposed=true, " ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , counter . get ( ) ) ; assertTrue ( d . toString ( ) , d . toString ( ) . contains ( "AutoCloseableDisposable(disposed=true, " ) ) ; 
TestHelper . withErrorTracking ( errors -> AutoCloseable ac = ( ) -> throw new TestException ( ) ; ; Disposable d = Disposable . fromAutoCloseable ( ac ) ; assertFalse ( d . isDisposed ( ) ) ; assertTrue ( errors . isEmpty ( ) ) ; try d . dispose ( ) ; fail ( "Should have thrown!" ) ; catch ( TestException expected ) assertTrue ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertTrue ( errors . isEmpty ( ) ) ; ) ; 
AtomicInteger counter = new AtomicInteger ( ) ; Disposable d = Disposable . fromAction ( ( ) -> counter . getAndIncrement ( ) ) ; AutoCloseable ac = Disposable . toAutoCloseable ( d ) ; assertFalse ( d . isDisposed ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; ac . close ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , counter . get ( ) ) ; ac . close ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; ) ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; ) ) ; cd . dispose ( ) ; assertEquals ( 2 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final CompositeDisposable cd = new CompositeDisposable ( ) ; final int count = 10 ; final CountDownLatch start = new CountDownLatch ( 1 ) ; for ( int i = 0 ; i < count ; i ++ ) cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; ) ) ; final List < Thread > threads = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; i ++ ) final Thread t = new Thread ( ) @ Override public void run ( ) try start . await ( ) ; cd . dispose ( ) ; catch ( final InterruptedException e ) fail ( e . getMessage ( ) ) ; ; t . start ( ) ; threads . add ( t ) ; start . countDown ( ) ; for ( final Thread t : threads ) t . join ( ) ; assertEquals ( count , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new RuntimeException ( "failed on first one" ) ; ) ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; ) ) ; try cd . dispose ( ) ; fail ( "Expecting an exception" ) ; catch ( RuntimeException e ) assertEquals ( e . getMessage ( ) , "failed on first one" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new RuntimeException ( "failed on first one" ) ; ) ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new RuntimeException ( "failed on second one too" ) ; ) ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; ) ) ; try cd . dispose ( ) ; fail ( "Expecting an exception" ) ; catch ( CompositeException e ) assertEquals ( e . getExceptions ( ) . size ( ) , 2 ) ; assertEquals ( 1 , counter . get ( ) ) ; 
Disposable d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( d1 ) ; cd . add ( d2 ) ; cd . remove ( d1 ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertFalse ( d2 . isDisposed ( ) ) ; 
Disposable d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( d1 ) ; cd . add ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertFalse ( d2 . isDisposed ( ) ) ; cd . clear ( ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; assertFalse ( cd . isDisposed ( ) ) ; Disposable d3 = Disposable . empty ( ) ; cd . add ( d3 ) ; cd . dispose ( ) ; assertTrue ( d3 . isDisposed ( ) ) ; assertTrue ( cd . isDisposed ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; ) ) ; cd . dispose ( ) ; cd . dispose ( ) ; cd . dispose ( ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final CompositeDisposable cd = new CompositeDisposable ( ) ; final int count = 10 ; final CountDownLatch start = new CountDownLatch ( 1 ) ; cd . add ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; ) ) ; final List < Thread > threads = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; i ++ ) final Thread t = new Thread ( ) @ Override public void run ( ) try start . await ( ) ; cd . dispose ( ) ; catch ( final InterruptedException e ) fail ( e . getMessage ( ) ) ; ; t . start ( ) ; threads . add ( t ) ; start . countDown ( ) ; for ( final Thread t : threads ) t . join ( ) ; assertEquals ( 1 , counter . get ( ) ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; CompositeDisposable cd1 = new CompositeDisposable ( ) ; CompositeDisposable cd2 = new CompositeDisposable ( ) ; cd . add ( cd1 ) ; cd . remove ( cd1 ) ; cd . add ( cd2 ) ; cd . remove ( cd1 ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( null ) ; 
Disposable d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; CompositeDisposable cd = new CompositeDisposable ( d1 , d2 ) ; assertEquals ( 2 , cd . size ( ) ) ; cd . clear ( ) ; assertEquals ( 0 , cd . size ( ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; Disposable d3 = Disposable . empty ( ) ; Disposable d4 = Disposable . empty ( ) ; cd = new CompositeDisposable ( d3 , d4 ) ; cd . dispose ( ) ; assertTrue ( d3 . isDisposed ( ) ) ; assertTrue ( d4 . isDisposed ( ) ) ; assertEquals ( 0 , cd . size ( ) ) ; 
Disposable d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; CompositeDisposable cd = new CompositeDisposable ( Arrays . asList ( d1 , d2 ) ) ; assertEquals ( 2 , cd . size ( ) ) ; cd . clear ( ) ; assertEquals ( 0 , cd . size ( ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; Disposable d3 = Disposable . empty ( ) ; Disposable d4 = Disposable . empty ( ) ; cd = new CompositeDisposable ( Arrays . asList ( d3 , d4 ) ) ; assertEquals ( 2 , cd . size ( ) ) ; cd . dispose ( ) ; assertTrue ( d3 . isDisposed ( ) ) ; assertTrue ( d4 . isDisposed ( ) ) ; assertEquals ( 0 , cd . size ( ) ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; Disposable d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; Disposable d3 = Disposable . empty ( ) ; cd . addAll ( d1 , d2 ) ; cd . addAll ( d3 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertFalse ( d2 . isDisposed ( ) ) ; assertFalse ( d3 . isDisposed ( ) ) ; cd . clear ( ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; d1 = Disposable . empty ( ) ; d2 = Disposable . empty ( ) ; cd = new CompositeDisposable ( ) ; cd . addAll ( d1 , d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertFalse ( d2 . isDisposed ( ) ) ; cd . dispose ( ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; assertEquals ( 0 , cd . size ( ) ) ; cd . clear ( ) ; assertEquals ( 0 , cd . size ( ) ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; cd . dispose ( ) ; Disposable d1 = Disposable . empty ( ) ; assertFalse ( cd . add ( d1 ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; d1 = Disposable . empty ( ) ; Disposable d2 = Disposable . empty ( ) ; assertFalse ( cd . addAll ( d1 , d2 ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; Disposable d1 = Disposable . empty ( ) ; assertFalse ( cd . delete ( d1 ) ) ; Disposable d2 = Disposable . empty ( ) ; cd . add ( d2 ) ; assertFalse ( cd . delete ( d1 ) ) ; cd . dispose ( ) ; assertFalse ( cd . delete ( d1 ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . add ( Disposable . empty ( ) ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . addAll ( Disposable . empty ( ) ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . remove ( d1 ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . delete ( d1 ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . clear ( ) ; ; TestHelper . race ( run , run ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . add ( Disposable . empty ( ) ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . addAll ( Disposable . empty ( ) ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . remove ( d1 ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . delete ( d1 ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . clear ( ) ; ; TestHelper . race ( run , run2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final CompositeDisposable cd = new CompositeDisposable ( ) ; final Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) cd . dispose ( ) ; ; Runnable run2 = new Runnable ( ) @ Override public void run ( ) cd . size ( ) ; ; TestHelper . race ( run , run2 ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( Disposable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new IllegalArgumentException ( ) ; ) ) ; Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; try cd . dispose ( ) ; fail ( "Failed to throw" ) ; catch ( IllegalArgumentException ex ) assertTrue ( d1 . isDisposed ( ) ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( Disposable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new AssertionError ( ) ; ) ) ; Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; try cd . dispose ( ) ; fail ( "Failed to throw" ) ; catch ( AssertionError ex ) assertTrue ( d1 . isDisposed ( ) ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( Disposable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) ) ; Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; try cd . dispose ( ) ; fail ( "Failed to throw" ) ; catch ( RuntimeException ex ) if ( ! ( ex . getCause ( ) instanceof IOException ) ) fail ( ex . toString ( ) + " should have thrown RuntimeException(IOException)" ) ; assertTrue ( d1 . isDisposed ( ) ) ; 
throw ( E ) new IOException ( ) ; 
CompositeDisposable cd = new CompositeDisposable ( ) ; cd . add ( new Disposable ( ) @ Override public void dispose ( ) CompositeDisposableTest . < RuntimeException > throwSneaky ( ) ; @ Override public boolean isDisposed ( ) return false ; ) ; Disposable d1 = Disposable . empty ( ) ; cd . add ( d1 ) ; try cd . dispose ( ) ; fail ( "Failed to throw" ) ; catch ( RuntimeException ex ) if ( ! ( ex . getCause ( ) instanceof IOException ) ) fail ( ex . toString ( ) + " should have thrown RuntimeException(IOException)" ) ; assertTrue ( d1 . isDisposed ( ) ) ; 
FutureTask < Object > ft = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; Disposable d = Disposable . fromFuture ( ft ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertTrue ( ft . isCancelled ( ) ) ; 
FutureTask < Object > ft = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; Disposable d = Disposable . fromFuture ( ft , true ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertTrue ( ft . isCancelled ( ) ) ; 
FutureTask < Object > ft = new FutureTask < > ( Functions . EMPTY_RUNNABLE , null ) ; FutureDisposable d = new FutureDisposable ( ft , false ) ; assertFalse ( d . isDisposed ( ) ) ; assertFalse ( d . isDisposed ( ) ) ; ft . run ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
serialDisposable = new SerialDisposable ( ) ; 
serialDisposable . dispose ( ) ; 
final Disposable underlying = mock ( Disposable . class ) ; serialDisposable . set ( underlying ) ; assertSame ( underlying , serialDisposable . get ( ) ) ; final Disposable another = mock ( Disposable . class ) ; serialDisposable . set ( another ) ; assertSame ( another , serialDisposable . get ( ) ) ; 
final Disposable underlying = mock ( Disposable . class ) ; serialDisposable . set ( underlying ) ; serialDisposable . replace ( Disposable . empty ( ) ) ; serialDisposable . dispose ( ) ; verify ( underlying , never ( ) ) . dispose ( ) ; 
Disposable underlying = mock ( Disposable . class ) ; serialDisposable . set ( underlying ) ; serialDisposable . dispose ( ) ; verify ( underlying ) . dispose ( ) ; serialDisposable . dispose ( ) ; verifyNoMoreInteractions ( underlying ) ; 
Disposable underlying = mock ( Disposable . class ) ; serialDisposable . set ( underlying ) ; verifyNoInteractions ( underlying ) ; serialDisposable . set ( underlying ) ; verify ( underlying ) . dispose ( ) ; 
Disposable underlying = mock ( Disposable . class ) ; serialDisposable . set ( underlying ) ; underlying . dispose ( ) ; verify ( underlying ) . dispose ( ) ; 
Disposable first = mock ( Disposable . class ) ; serialDisposable . set ( first ) ; Disposable second = mock ( Disposable . class ) ; serialDisposable . set ( second ) ; verify ( first ) . dispose ( ) ; 
Disposable first = mock ( Disposable . class ) ; serialDisposable . set ( first ) ; Disposable second = mock ( Disposable . class ) ; serialDisposable . set ( second ) ; serialDisposable . dispose ( ) ; verify ( second ) . dispose ( ) ; 
serialDisposable . dispose ( ) ; Disposable underlying = mock ( Disposable . class ) ; serialDisposable . set ( underlying ) ; verify ( underlying ) . dispose ( ) ; 
final Disposable firstSet = mock ( Disposable . class ) ; serialDisposable . set ( firstSet ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; final int count = 10 ; final CountDownLatch end = new CountDownLatch ( count ) ; final List < Thread > threads = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; i ++ ) final Thread t = new Thread ( ) @ Override public void run ( ) try start . await ( ) ; serialDisposable . dispose ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; finally end . countDown ( ) ; ; t . start ( ) ; threads . add ( t ) ; final Disposable underlying = mock ( Disposable . class ) ; start . countDown ( ) ; serialDisposable . set ( underlying ) ; end . await ( ) ; verify ( firstSet ) . dispose ( ) ; verify ( underlying ) . dispose ( ) ; for ( final Thread t : threads ) t . join ( ) ; 
final int count = 10 ; final List < Disposable > subscriptions = new ArrayList < > ( ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; final CountDownLatch end = new CountDownLatch ( count ) ; final List < Thread > threads = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; i ++ ) final Disposable subscription = mock ( Disposable . class ) ; subscriptions . add ( subscription ) ; final Thread t = new Thread ( ) @ Override public void run ( ) try start . await ( ) ; serialDisposable . set ( subscription ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; finally end . countDown ( ) ; ; t . start ( ) ; threads . add ( t ) ; start . countDown ( ) ; end . await ( ) ; serialDisposable . dispose ( ) ; for ( final Disposable subscription : subscriptions ) verify ( subscription ) . dispose ( ) ; for ( final Thread t : threads ) t . join ( ) ; 
Disposable empty = Disposable . empty ( ) ; SerialDisposable d = new SerialDisposable ( empty ) ; assertFalse ( d . isDisposed ( ) ) ; assertSame ( empty , d . get ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; assertNotSame ( empty , d . get ( ) ) ; assertNotSame ( DisposableHelper . DISPOSED , d . get ( ) ) ; 
serialDisposable = new SequentialDisposable ( ) ; 
serialDisposable . dispose ( ) ; 
final Disposable underlying = mock ( Disposable . class ) ; serialDisposable . update ( underlying ) ; assertSame ( underlying , serialDisposable . get ( ) ) ; final Disposable another = mock ( Disposable . class ) ; serialDisposable . update ( another ) ; assertSame ( another , serialDisposable . get ( ) ) ; 
final Disposable underlying = mock ( Disposable . class ) ; serialDisposable . update ( underlying ) ; serialDisposable . replace ( Disposable . empty ( ) ) ; serialDisposable . dispose ( ) ; verify ( underlying , never ( ) ) . dispose ( ) ; 
Disposable underlying = mock ( Disposable . class ) ; serialDisposable . update ( underlying ) ; serialDisposable . dispose ( ) ; verify ( underlying ) . dispose ( ) ; serialDisposable . dispose ( ) ; verifyNoMoreInteractions ( underlying ) ; 
Disposable underlying = mock ( Disposable . class ) ; serialDisposable . update ( underlying ) ; verifyNoInteractions ( underlying ) ; serialDisposable . update ( underlying ) ; verify ( underlying ) . dispose ( ) ; 
Disposable underlying = mock ( Disposable . class ) ; serialDisposable . update ( underlying ) ; underlying . dispose ( ) ; verify ( underlying ) . dispose ( ) ; 
Disposable first = mock ( Disposable . class ) ; serialDisposable . update ( first ) ; Disposable second = mock ( Disposable . class ) ; serialDisposable . update ( second ) ; verify ( first ) . dispose ( ) ; 
Disposable first = mock ( Disposable . class ) ; serialDisposable . update ( first ) ; Disposable second = mock ( Disposable . class ) ; serialDisposable . update ( second ) ; serialDisposable . dispose ( ) ; verify ( second ) . dispose ( ) ; 
serialDisposable . dispose ( ) ; Disposable underlying = mock ( Disposable . class ) ; serialDisposable . update ( underlying ) ; verify ( underlying ) . dispose ( ) ; 
final Disposable firstSet = mock ( Disposable . class ) ; serialDisposable . update ( firstSet ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; final int count = 10 ; final CountDownLatch end = new CountDownLatch ( count ) ; final List < Thread > threads = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; i ++ ) final Thread t = new Thread ( ) @ Override public void run ( ) try start . await ( ) ; serialDisposable . dispose ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; finally end . countDown ( ) ; ; t . start ( ) ; threads . add ( t ) ; final Disposable underlying = mock ( Disposable . class ) ; start . countDown ( ) ; serialDisposable . update ( underlying ) ; end . await ( ) ; verify ( firstSet ) . dispose ( ) ; verify ( underlying ) . dispose ( ) ; for ( final Thread t : threads ) t . join ( ) ; 
final int count = 10 ; final List < Disposable > subscriptions = new ArrayList < > ( ) ; final CountDownLatch start = new CountDownLatch ( 1 ) ; final CountDownLatch end = new CountDownLatch ( count ) ; final List < Thread > threads = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; i ++ ) final Disposable subscription = mock ( Disposable . class ) ; subscriptions . add ( subscription ) ; final Thread t = new Thread ( ) @ Override public void run ( ) try start . await ( ) ; serialDisposable . update ( subscription ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; finally end . countDown ( ) ; ; t . start ( ) ; threads . add ( t ) ; start . countDown ( ) ; end . await ( ) ; serialDisposable . dispose ( ) ; for ( final Disposable subscription : subscriptions ) verify ( subscription ) . dispose ( ) ; for ( final Thread t : threads ) t . join ( ) ; 
Flowable < List < Integer > > f = Flowable . just ( 1 , 2 , 3 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer v ) list . add ( v ) ; ) . toFlowable ( ) ; List < Integer > list = f . blockingLast ( ) ; assertEquals ( 3 , list . size ( ) ) ; assertEquals ( 1 , list . get ( 0 ) . intValue ( ) ) ; assertEquals ( 2 , list . get ( 1 ) . intValue ( ) ) ; assertEquals ( 3 , list . get ( 2 ) . intValue ( ) ) ; List < Integer > list2 = f . blockingLast ( ) ; assertEquals ( 3 , list2 . size ( ) ) ; assertEquals ( 1 , list2 . get ( 0 ) . intValue ( ) ) ; assertEquals ( 2 , list2 . get ( 1 ) . intValue ( ) ) ; assertEquals ( 3 , list2 . get ( 2 ) . intValue ( ) ) ; 
String value = Flowable . just ( 1 , 2 , 3 ) . collect ( new Supplier < StringBuilder > ( ) @ Override public StringBuilder get ( ) return new StringBuilder ( ) ; , new BiConsumer < StringBuilder , Integer > ( ) @ Override public void accept ( StringBuilder sb , Integer v ) if ( sb . length ( ) > 0 ) sb . append ( "-" ) ; sb . append ( v ) ; ) . toFlowable ( ) . blockingLast ( ) . toString ( ) ; assertEquals ( "1-2-3" , value ) ; 
final RuntimeException e = new RuntimeException ( ) ; Flowable . just ( 1 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception throw e ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer t ) list . add ( t ) ; ) . test ( ) . assertNoValues ( ) . assertError ( e ) . assertNotComplete ( ) ; 
try final List < Throwable > list = new CopyOnWriteArrayList < > ( ) ; RxJavaPlugins . setErrorHandler ( addToList ( list ) ) ; final RuntimeException e1 = new RuntimeException ( ) ; final RuntimeException e2 = new RuntimeException ( ) ; Burst . items ( 1 ) . error ( e2 ) . collect ( supplierListCreator ( ) , biConsumerThrows ( e1 ) ) . toFlowable ( ) . test ( ) . assertError ( e1 ) . assertNotComplete ( ) ; assertEquals ( 1 , list . size ( ) ) ; assertEquals ( e2 , list . get ( 0 ) . getCause ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; Burst . item ( 1 ) . create ( ) . collect ( supplierListCreator ( ) , biConsumerThrows ( e ) ) . toFlowable ( ) . test ( ) . assertError ( e ) . assertNotComplete ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; final AtomicBoolean added = new AtomicBoolean ( ) ; BiConsumer < Object , Integer > throwOnFirstOnly = new BiConsumer < Object , Integer > ( ) boolean once = true ; @ Override public void accept ( Object o , Integer t ) if ( once ) once = false ; throw e ; else added . set ( true ) ; ; Burst . items ( 1 , 2 ) . create ( ) . collect ( supplierListCreator ( ) , throwOnFirstOnly ) . toFlowable ( ) . test ( ) . assertError ( e ) . assertNoValues ( ) . assertNotComplete ( ) ; assertFalse ( added . get ( ) ) ; 
Flowable . just ( 1 , 1 , 1 , 1 , 2 ) . collectInto ( new HashSet < > ( ) , new BiConsumer < HashSet < Integer > , Integer > ( ) @ Override public void accept ( HashSet < Integer > s , Integer v ) throws Exception s . add ( v ) ; ) . toFlowable ( ) . test ( ) . assertResult ( new HashSet < > ( Arrays . asList ( 1 , 2 ) ) ) ; 
Single < List < Integer > > o = Flowable . just ( 1 , 2 , 3 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer v ) list . add ( v ) ; ) ; List < Integer > list = o . blockingGet ( ) ; assertEquals ( 3 , list . size ( ) ) ; assertEquals ( 1 , list . get ( 0 ) . intValue ( ) ) ; assertEquals ( 2 , list . get ( 1 ) . intValue ( ) ) ; assertEquals ( 3 , list . get ( 2 ) . intValue ( ) ) ; List < Integer > list2 = o . blockingGet ( ) ; assertEquals ( 3 , list2 . size ( ) ) ; assertEquals ( 1 , list2 . get ( 0 ) . intValue ( ) ) ; assertEquals ( 2 , list2 . get ( 1 ) . intValue ( ) ) ; assertEquals ( 3 , list2 . get ( 2 ) . intValue ( ) ) ; 
String value = Flowable . just ( 1 , 2 , 3 ) . collect ( new Supplier < StringBuilder > ( ) @ Override public StringBuilder get ( ) return new StringBuilder ( ) ; , new BiConsumer < StringBuilder , Integer > ( ) @ Override public void accept ( StringBuilder sb , Integer v ) if ( sb . length ( ) > 0 ) sb . append ( "-" ) ; sb . append ( v ) ; ) . blockingGet ( ) . toString ( ) ; assertEquals ( "1-2-3" , value ) ; 
final RuntimeException e = new RuntimeException ( ) ; Flowable . just ( 1 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception throw e ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer t ) list . add ( t ) ; ) . test ( ) . assertNoValues ( ) . assertError ( e ) . assertNotComplete ( ) ; 
try final List < Throwable > list = new CopyOnWriteArrayList < > ( ) ; RxJavaPlugins . setErrorHandler ( addToList ( list ) ) ; final RuntimeException e1 = new RuntimeException ( ) ; final RuntimeException e2 = new RuntimeException ( ) ; Burst . items ( 1 ) . error ( e2 ) . collect ( supplierListCreator ( ) , biConsumerThrows ( e1 ) ) . test ( ) . assertError ( e1 ) . assertNotComplete ( ) ; assertEquals ( 1 , list . size ( ) ) ; assertEquals ( e2 , list . get ( 0 ) . getCause ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; Burst . item ( 1 ) . create ( ) . collect ( supplierListCreator ( ) , biConsumerThrows ( e ) ) . test ( ) . assertError ( e ) . assertNotComplete ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; final AtomicBoolean added = new AtomicBoolean ( ) ; BiConsumer < Object , Integer > throwOnFirstOnly = new BiConsumer < Object , Integer > ( ) boolean once = true ; @ Override public void accept ( Object o , Integer t ) if ( once ) once = false ; throw e ; else added . set ( true ) ; ; Burst . items ( 1 , 2 ) . create ( ) . collect ( supplierListCreator ( ) , throwOnFirstOnly ) . test ( ) . assertError ( e ) . assertNoValues ( ) . assertNotComplete ( ) ; assertFalse ( added . get ( ) ) ; 
Flowable . just ( 1 , 1 , 1 , 1 , 2 ) . collectInto ( new HashSet < > ( ) , new BiConsumer < HashSet < Integer > , Integer > ( ) @ Override public void accept ( HashSet < Integer > s , Integer v ) throws Exception s . add ( v ) ; ) . test ( ) . assertResult ( new HashSet < > ( Arrays . asList ( 1 , 2 ) ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 , 2 ) . collect ( Functions . justSupplier ( new ArrayList < > ( ) ) , new BiConsumer < ArrayList < Integer > , Integer > ( ) @ Override public void accept ( ArrayList < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 , 2 ) . collect ( Functions . justSupplier ( new ArrayList < > ( ) ) , new BiConsumer < ArrayList < Integer > , Integer > ( ) @ Override public void accept ( ArrayList < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . toFlowable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Integer > , Flowable < ArrayList < Integer > > > ( ) @ Override public Flowable < ArrayList < Integer > > apply ( Flowable < Integer > f ) throws Exception return f . collect ( Functions . justSupplier ( new ArrayList < > ( ) ) , new BiConsumer < ArrayList < Integer > , Integer > ( ) @ Override public void accept ( ArrayList < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Integer > , Single < ArrayList < Integer > > > ( ) @ Override public Single < ArrayList < Integer > > apply ( Flowable < Integer > f ) throws Exception return f . collect ( Functions . justSupplier ( new ArrayList < > ( ) ) , new BiConsumer < ArrayList < Integer > , Integer > ( ) @ Override public void accept ( ArrayList < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) ; ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Throwable > caughtError = new AtomicReference < > ( ) ; Flowable < Long > f = Flowable . interval ( 50 , TimeUnit . MILLISECONDS ) ; Subscriber < Long > subscriber = new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) System . out . println ( "error: " + e ) ; caughtError . set ( e ) ; latch . countDown ( ) ; @ Override public void onNext ( Long args ) throw new RuntimeException ( "forced failure" ) ; ; f . safeSubscribe ( subscriber ) ; latch . await ( 2000 , TimeUnit . MILLISECONDS ) ; assertNotNull ( caughtError . get ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Throwable > caughtError = new AtomicReference < > ( ) ; Flowable < Long > f = Flowable . interval ( 50 , TimeUnit . MILLISECONDS ) ; Subscriber < Long > subscriber = new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) System . out . println ( "error: " + e ) ; caughtError . set ( e ) ; latch . countDown ( ) ; @ Override public void onNext ( Long args ) throw new RuntimeException ( "forced failure" ) ; ; f . observeOn ( Schedulers . newThread ( ) ) . safeSubscribe ( subscriber ) ; latch . await ( 2000 , TimeUnit . MILLISECONDS ) ; assertNotNull ( caughtError . get ( ) ) ; 
return new CylonDetectorObservable < > ( onSubscribe ) ; 
onSubscribe . subscribe ( subscriber ) ; 
return x ( new RobotConversionFunc < > ( operator ) ) ; 
try return operator . apply ( onSubscribe ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
try return transformer . apply ( this ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
return new CylonDetectorObservable < > ( new FlowableFilter < > ( Flowable . fromPublisher ( onSubscribe ) , predicate ) ) ; 
return new CylonDetectorObservable < > ( new FlowableMap < > ( Flowable . fromPublisher ( onSubscribe ) , func ) ) ; 
return boop ( new Function < T , String > ( ) @ Override public String apply ( T t ) Object cylon = ( ( Jail ) t ) . cylon ; throwOutTheAirlock ( cylon ) ; if ( t instanceof Jail ) String name = cylon . toString ( ) ; return "Cylon '" + name + "' has been destroyed" ; else return "Cylon 'anonymous' has been destroyed" ; ) ; 
$EMPTY$
return CylonDetectorObservable . create ( new Publisher < R > ( ) @ Override public void subscribe ( Subscriber < ? super R > subscriber ) try Subscriber < ? super T > st = operator . apply ( subscriber ) ; try onSubscribe . subscribe ( st ) ; catch ( Throwable e ) st . onError ( e ) ; catch ( Throwable e ) subscriber . onError ( e ) ; ) ; 
return CylonDetectorObservable . create ( onSubscribe ) ; 
return Flowable . fromPublisher ( onSubscribe ) ; 
final TestObserver < String > to = new TestObserver < > ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) System . out . println ( "Complete" ) ; @ Override public void onError ( Throwable e ) System . out . println ( "error: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; @ Override public void onNext ( String t ) System . out . println ( t ) ; ) ; List < Object > crewOfBattlestarGalactica = Arrays . asList ( new Object [ ] "William Adama" , "Laura Roslin" , "Lee Adama" , new Cylon ( ) ) ; Flowable . fromIterable ( crewOfBattlestarGalactica ) . doOnNext ( new Consumer < Object > ( ) @ Override public void accept ( Object pv ) System . out . println ( pv ) ; ) . to ( new ConvertToCylonDetector < > ( ) ) . beep ( new Predicate < Object > ( ) @ Override public boolean test ( Object t ) return t instanceof Cylon ; ) . boop ( new Function < Object , Object > ( ) @ Override public Object apply ( Object cylon ) return new Jail ( cylon ) ; ) . DESTROY ( ) . x ( new ConvertToObservable < > ( ) ) . reduce ( "Cylon Detector finished. Report:\n" , new BiFunction < String , String , String > ( ) @ Override public String apply ( String a , String n ) return a + n + "\n" ; ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
return new Jail ( cylon ) ; 
final AtomicReference < Throwable > thrown = new AtomicReference < > ( null ) ; final AtomicBoolean isFinished = new AtomicBoolean ( false ) ; ConcurrentLinkedQueue < ? extends Integer > queue = Flowable . range ( 0 , 5 ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( final Integer i ) return Flowable . range ( 0 , 5 ) . observeOn ( Schedulers . io ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer k ) try Thread . sleep ( System . currentTimeMillis ( ) % 100 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return i + k ; ) ; ) . to ( new FlowableConverter < Integer , ConcurrentLinkedQueue < Integer > > ( ) @ Override public ConcurrentLinkedQueue < Integer > apply ( Flowable < Integer > onSubscribe ) final ConcurrentLinkedQueue < Integer > q = new ConcurrentLinkedQueue < > ( ) ; onSubscribe . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) isFinished . set ( true ) ; @ Override public void onError ( Throwable e ) thrown . set ( e ) ; @ Override public void onNext ( Integer t ) q . add ( t ) ; ) ; return q ; ) ; int x = 0 ; while ( ! isFinished . get ( ) ) Integer i = queue . poll ( ) ; if ( i != null ) x ++ ; System . out . println ( x + " item: " + i ) ; Assert . assertNull ( thrown . get ( ) ) ; 
final ConcurrentLinkedQueue < Integer > q = new ConcurrentLinkedQueue < > ( ) ; onSubscribe . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) isFinished . set ( true ) ; @ Override public void onError ( Throwable e ) thrown . set ( e ) ; @ Override public void onNext ( Integer t ) q . add ( t ) ; ) ; return q ; 
Flowable < HorrorMovie > horrors = Flowable . just ( new HorrorMovie ( ) ) ; Flowable < Flowable < HorrorMovie > > metaHorrors = Flowable . just ( horrors ) ; Flowable . < Media > merge ( metaHorrors ) ; 
Flowable < Media > f1 = Flowable . < Media > just ( new HorrorMovie ( ) , new Movie ( ) ) ; Flowable < Media > f2 = Flowable . just ( new Media ( ) , new HorrorMovie ( ) ) ; Flowable < Flowable < Media > > os = Flowable . just ( f1 , f2 ) ; List < Media > values = Flowable . merge ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( 4 , values . size ( ) ) ; 
Flowable < Media > f1 = Flowable . just ( new HorrorMovie ( ) , new Movie ( ) , new Media ( ) ) ; Flowable < Media > f2 = Flowable . just ( new Media ( ) , new HorrorMovie ( ) ) ; Flowable < Flowable < Media > > os = Flowable . just ( f1 , f2 ) ; List < Media > values = Flowable . merge ( os ) . toList ( ) . blockingGet ( ) ; assertEquals ( 5 , values . size ( ) ) ; 
Flowable < Movie > f1 = Flowable . just ( new HorrorMovie ( ) , new Movie ( ) ) ; Flowable < Media > f2 = Flowable . just ( new Media ( ) , new HorrorMovie ( ) ) ; List < Media > values = Flowable . merge ( f1 , f2 ) . toList ( ) . blockingGet ( ) ; assertTrue ( values . get ( 0 ) instanceof HorrorMovie ) ; assertTrue ( values . get ( 1 ) instanceof Movie ) ; assertNotNull ( values . get ( 2 ) ) ; assertTrue ( values . get ( 3 ) instanceof HorrorMovie ) ; 
Flowable < Movie > f1 = Flowable . defer ( new Supplier < Publisher < Movie > > ( ) @ Override public Publisher < Movie > get ( ) return Flowable . just ( new HorrorMovie ( ) , new Movie ( ) ) ; ) ; Flowable < Media > f2 = Flowable . just ( new Media ( ) , new HorrorMovie ( ) ) ; List < Media > values = Flowable . merge ( f1 , f2 ) . toList ( ) . blockingGet ( ) ; assertTrue ( values . get ( 0 ) instanceof HorrorMovie ) ; assertTrue ( values . get ( 1 ) instanceof Movie ) ; assertNotNull ( values . get ( 2 ) ) ; assertTrue ( values . get ( 3 ) instanceof HorrorMovie ) ; 
final ArrayList < List < Integer > > lists = new ArrayList < > ( ) ; Flowable . concat ( Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . window ( 3 ) . map ( new Function < Flowable < Integer > , Flowable < List < Integer > > > ( ) @ Override public Flowable < List < Integer > > apply ( Flowable < Integer > xs ) return xs . toList ( ) . toFlowable ( ) ; ) ) . blockingForEach ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > xs ) lists . add ( xs ) ; ) ; assertArrayEquals ( lists . get ( 0 ) . toArray ( new Integer [ 3 ] ) , new Integer [ ] 1 , 2 , 3 ) ; assertArrayEquals ( lists . get ( 1 ) . toArray ( new Integer [ 3 ] ) , new Integer [ ] 4 , 5 , 6 ) ; assertEquals ( 2 , lists . size ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Integer > > ts = pp . window ( 5 , TimeUnit . SECONDS , scheduler , 2 ) . flatMapSingle ( new Function < Flowable < Integer > , SingleSource < List < Integer > > > ( ) @ Override public SingleSource < List < Integer > > apply ( Flowable < Integer > v ) throws Throwable return v . toList ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; ts . assertValueCount ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; pp . onNext ( 3 ) ; scheduler . advanceTimeBy ( 6 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 2 ) ; pp . onNext ( 4 ) ; pp . onNext ( 5 ) ; ts . assertValueCount ( 3 ) ; pp . onNext ( 4 ) ; scheduler . advanceTimeBy ( 6 , TimeUnit . SECONDS ) ; ts . assertValueCount ( 4 ) . assertNoErrors ( ) . assertNotComplete ( ) ; ts . cancel ( ) ; 
List < String > values = Flowable . just ( "one" , "two" ) . startWithArray ( "zero" ) . toList ( ) . blockingGet ( ) ; assertEquals ( "zero" , values . get ( 0 ) ) ; assertEquals ( "two" , values . get ( 2 ) ) ; 
List < String > li = new ArrayList < > ( ) ; li . add ( "alpha" ) ; li . add ( "beta" ) ; List < String > values = Flowable . just ( "one" , "two" ) . startWithIterable ( li ) . toList ( ) . blockingGet ( ) ; assertEquals ( "alpha" , values . get ( 0 ) ) ; assertEquals ( "beta" , values . get ( 1 ) ) ; assertEquals ( "one" , values . get ( 2 ) ) ; assertEquals ( "two" , values . get ( 3 ) ) ; 
List < String > li = new ArrayList < > ( ) ; li . add ( "alpha" ) ; li . add ( "beta" ) ; List < String > values = Flowable . just ( "one" , "two" ) . startWith ( Flowable . fromIterable ( li ) ) . toList ( ) . blockingGet ( ) ; assertEquals ( "alpha" , values . get ( 0 ) ) ; assertEquals ( "beta" , values . get ( 1 ) ) ; assertEquals ( "one" , values . get ( 2 ) ) ; assertEquals ( "two" , values . get ( 3 ) ) ; 
Flowable . just ( 1 ) . startWithArray ( ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 10 ) . to ( TestHelper . < Integer > testSubscriber ( Long . MAX_VALUE , QueueFuseable . ANY , false ) ) . assertFusionMode ( QueueFuseable . SYNC ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . fromArray ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . to ( TestHelper . < Integer > testSubscriber ( Long . MAX_VALUE , QueueFuseable . ANY , false ) ) . assertFusionMode ( QueueFuseable . SYNC ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) . to ( TestHelper . < Integer > testSubscriber ( Long . MAX_VALUE , QueueFuseable . ANY , false ) ) . assertFusionMode ( QueueFuseable . SYNC ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 10 ) . hide ( ) . to ( TestHelper . < Integer > testSubscriber ( Long . MAX_VALUE , QueueFuseable . ANY , false ) ) . assertNotFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . fromArray ( new Integer [ ] 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . hide ( ) . to ( TestHelper . < Integer > testSubscriber ( Long . MAX_VALUE , QueueFuseable . ANY , false ) ) . assertNotFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) . hide ( ) . to ( TestHelper . < Integer > testSubscriber ( Long . MAX_VALUE , QueueFuseable . ANY , false ) ) . assertNotFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . assertNoErrors ( ) . assertComplete ( ) ; 
w = TestHelper . mockSubscriber ( ) ; wo = TestHelper . mockSingleObserver ( ) ; wm = TestHelper . mockMaybeObserver ( ) ; 
String [ ] items = new String [ ] "one" , "two" , "three" ; assertEquals ( ( Long ) 3L , Flowable . fromArray ( items ) . count ( ) . blockingGet ( ) ) ; assertEquals ( "two" , Flowable . fromArray ( items ) . skip ( 1 ) . take ( 1 ) . blockingSingle ( ) ) ; assertEquals ( "three" , Flowable . fromArray ( items ) . takeLast ( 1 ) . blockingSingle ( ) ) ; 
ArrayList < String > items = new ArrayList < > ( ) ; items . add ( "one" ) ; items . add ( "two" ) ; items . add ( "three" ) ; assertEquals ( ( Long ) 3L , Flowable . fromIterable ( items ) . count ( ) . blockingGet ( ) ) ; assertEquals ( "two" , Flowable . fromIterable ( items ) . skip ( 1 ) . take ( 1 ) . blockingSingle ( ) ) ; assertEquals ( "three" , Flowable . fromIterable ( items ) . takeLast ( 1 ) . blockingSingle ( ) ) ; 
Flowable < String > items = Flowable . just ( "one" , "two" , "three" ) ; assertEquals ( ( Long ) 3L , items . count ( ) . blockingGet ( ) ) ; assertEquals ( "two" , items . skip ( 1 ) . take ( 1 ) . blockingSingle ( ) ) ; assertEquals ( "three" , items . takeLast ( 1 ) . blockingSingle ( ) ) ; 
Flowable < String > items = Flowable . just ( "one" ) ; assertEquals ( ( Long ) 1L , items . count ( ) . blockingGet ( ) ) ; assertEquals ( "one" , items . takeLast ( 1 ) . blockingSingle ( ) ) ; 
Flowable < String > flowable = Flowable . just ( "one" , "two" , "three" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > flowable = Flowable . just ( "a" , "b" , "c" , "d" ) ; flowable . count ( ) . toFlowable ( ) . subscribe ( w ) ; verify ( w ) . onNext ( 4L ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > flowable = Flowable . empty ( ) ; flowable . count ( ) . toFlowable ( ) . subscribe ( w ) ; verify ( w ) . onNext ( 0L ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > f = Flowable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new RuntimeException ( ) ; ) ; f . count ( ) . toFlowable ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onComplete ( ) ; verify ( w , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; 
Flowable < String > flowable = Flowable . just ( "a" , "b" , "c" , "d" ) ; flowable . count ( ) . subscribe ( wo ) ; verify ( wo ) . onSuccess ( 4L ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > flowable = Flowable . empty ( ) ; flowable . count ( ) . subscribe ( wo ) ; verify ( wo ) . onSuccess ( 0L ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > f = Flowable . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new RuntimeException ( ) ; ) ; f . count ( ) . subscribe ( wo ) ; verify ( wo , never ( ) ) . onSuccess ( anyInt ( ) ) ; verify ( wo , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 3 , 5 , 4 , 6 , 3 ) ; flowable . filter ( IS_EVEN ) . take ( 1 ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( 4 ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 3 , 5 , 7 , 9 , 7 , 5 , 3 , 1 ) ; flowable . filter ( IS_EVEN ) . take ( 1 ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 ) ; flowable . take ( 1 ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( 1 ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > flowable = Flowable . empty ( ) ; flowable . take ( 1 ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > flowable = Flowable . empty ( ) ; flowable . firstElement ( ) . toFlowable ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 3 , 5 , 7 , 9 , 7 , 5 , 3 , 1 ) ; flowable . filter ( IS_EVEN ) . firstElement ( ) . toFlowable ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onComplete ( ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > flowable = Flowable . empty ( ) ; flowable . firstElement ( ) . subscribe ( wm ) ; verify ( wm , never ( ) ) . onSuccess ( anyInt ( ) ) ; verify ( wm ) . onComplete ( ) ; verify ( wm , never ( ) ) . onError ( isA ( NoSuchElementException . class ) ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 3 , 5 , 7 , 9 , 7 , 5 , 3 , 1 ) ; flowable . filter ( IS_EVEN ) . firstElement ( ) . subscribe ( wm ) ; verify ( wm , never ( ) ) . onSuccess ( anyInt ( ) ) ; verify ( wm , times ( 1 ) ) . onComplete ( ) ; verify ( wm , never ( ) ) . onError ( isA ( NoSuchElementException . class ) ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 , 4 ) ; flowable . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . toFlowable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( w ) . onNext ( 10 ) ; 
Flowable < Integer > flowable = Flowable . range ( 1 , 0 ) ; flowable . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . toFlowable ( ) . test ( ) . assertResult ( ) ; 
Flowable < Integer > flowable = Flowable . range ( 1 , 0 ) ; int value = flowable . reduce ( 1 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . blockingGet ( ) ; assertEquals ( 1 , value ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 , 4 ) ; flowable . reduce ( 50 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyInt ( ) ) ; verify ( wo ) . onSuccess ( 60 ) ; 
Flowable < Integer > obs = Flowable . just ( 1 ) ; Flowable < Integer > chained = obs . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; chained . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 0 ) ) . onError ( any ( Throwable . class ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Flowable . just ( "1" , "2" , "three" , "4" ) . subscribeOn ( Schedulers . newThread ( ) ) . safeSubscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) error . set ( e ) ; System . out . println ( "error" ) ; e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String v ) int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; ) ; latch . await ( ) ; assertEquals ( 2 , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) fail ( "It should be a NumberFormatException" ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Flowable . just ( "1" , "2" , "three" , "4" ) . safeSubscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; @ Override public void onError ( Throwable e ) error . set ( e ) ; System . out . println ( "error" ) ; e . printStackTrace ( ) ; @ Override public void onNext ( String v ) int num = Integer . parseInt ( v ) ; System . out . println ( num ) ; count . incrementAndGet ( ) ; ) ; assertEquals ( 2 , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) fail ( "It should be a NumberFormatException" ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Flowable . just ( "1" , "2" ) . concatWith ( Flowable . < String > error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) return new NumberFormatException ( ) ; ) ) . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) System . out . println ( "completed" ) ; @ Override public void onError ( Throwable e ) error . set ( e ) ; System . out . println ( "error" ) ; e . printStackTrace ( ) ; @ Override public void onNext ( String v ) System . out . println ( v ) ; count . incrementAndGet ( ) ; ) ; assertEquals ( 2 , count . get ( ) ) ; assertNotNull ( error . get ( ) ) ; if ( ! ( error . get ( ) instanceof NumberFormatException ) ) fail ( "It should be a NumberFormatException" ) ; 
