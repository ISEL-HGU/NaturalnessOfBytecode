final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ; ps . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
TestObserver < Integer > to = Observable . just ( 1 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; Observable . empty ( ) . switchMapMaybe ( Functions . justFunction ( ms ) ) . test ( ) . assertResult ( ) ; assertFalse ( ms . hasObservers ( ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( 1 ) . switchMapMaybe ( Functions . justFunction ( ms ) ) . test ( ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onSuccess ( 2 ) ; to . assertResult ( 2 ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . switchMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . switchMapMaybeDelayError ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUtilityClass ( ScalarXMapZHelper . class ) ; 
Flowable . range ( 1 , 5 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v % 2 == 0 ) return Maybe . just ( v ) ; return Maybe . empty ( ) ; ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 1024 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v % 2 == 0 ) return Maybe . just ( v ) ; return Maybe . empty ( ) ; ) . test ( 0L ) ; ts . requestMore ( 1 ) . assertResult ( 1024 ) ; 
Flowable . error ( new TestException ( ) ) . switchMapMaybe ( Functions . justFunction ( Maybe . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . switchMapMaybe ( Functions . justFunction ( Maybe . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . switchMapMaybe ( Functions . justFunction ( Maybe . never ( ) ) ) ; ) ; 
Flowable . range ( 1 , 5 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms1 = MaybeSubject . create ( ) ; final MaybeSubject < Integer > ms2 = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms1 ; return ms2 ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( ms1 . hasObservers ( ) ) ; pp . onNext ( 2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms1 = MaybeSubject . create ( ) ; final MaybeSubject < Integer > ms2 = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms1 ; return ms2 ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( ms1 . hasObservers ( ) ) ; pp . onNext ( 2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; ts . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . assertEmpty ( ) ; ms . onComplete ( ) ; ts . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
Flowable . just ( 1 ) . switchMapMaybe ( new Function < Integer , MaybeSource < ? extends Object > > ( ) @ Override public MaybeSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception ts . cancel ( ) ; return Maybe . just ( 1 ) ; ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) ts . cancel ( ) ; return Maybe . just ( 1 ) ; ) . subscribe ( ts ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( "outer" ) ) ; . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( "inner" ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "outer" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < MaybeObserver < ? super Integer > > moRef = new AtomicReference < > ( ) ; TestSubscriberEx < Integer > ts = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( "outer" ) ) ; . switchMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; moRef . set ( observer ) ; ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "outer" ) ; moRef . get ( ) . onError ( new TestException ( "inner" ) ) ; moRef . get ( ) . onComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestSubscriberEx < Integer > ts = pp . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Maybe . never ( ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . errors ( ) . size ( ) != 0 ) assertTrue ( errors . isEmpty ( ) ) ; ts . assertFailure ( TestException . class ) ; else if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Maybe . never ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . switchMapMaybeDelayError ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Maybe . empty ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onSuccess ( 3 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; requestMore ( 1 ) ; ; Flowable . range ( 1 , 5 ) . switchMapMaybe ( Functions . justFunction ( Maybe . just ( 1 ) ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . switchMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . switchMapMaybeDelayError ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; ) ; ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ms . flatMapObservable ( Functions . justFunction ( ps ) ) . test ( ) ; assertTrue ( ms . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ms . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ms . flatMapObservable ( Functions . justFunction ( ps ) ) . test ( ) ; assertTrue ( ms . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; ms . onSuccess ( 1 ) ; assertFalse ( ms . hasObservers ( ) ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ms . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; 
Maybe . just ( 1 ) . flatMapObservable ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Maybe . never ( ) . flatMapObservable ( Functions . justFunction ( Observable . never ( ) ) ) ) ; 
Flowable . range ( 1 , 5 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 1024 ) . concatMapSingle ( Single :: just , 32 ) . test ( ) . assertValueCount ( 1024 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 1024 ) . hide ( ) . concatMapSingle ( Single :: just , 32 ) . test ( ) . assertValueCount ( 1024 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 1024 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; , 32 ) . test ( 0 ) ; for ( int i = 1 ; i <= 1024 ; i ++ ) ts . assertValueCount ( i - 1 ) . assertNoErrors ( ) . assertNotComplete ( ) . requestMore ( 1 ) . assertValueCount ( i ) . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . error ( new TestException ( ) ) . concatMapSingle ( Functions . justFunction ( Single . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . concatMapSingle ( Functions . justFunction ( Single . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . concatMapSingleDelayError ( Functions . justFunction ( ms ) , false ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; assertTrue ( ms . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . concatMapSingleDelayError ( Functions . justFunction ( Single . just ( ( Object ) 1 ) ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; s . onError ( new TestException ( ) ) ; . concatMapSingle ( Functions . justFunction ( Single . never ( ) ) , 1 ) . test ( ) . assertFailure ( MissingBackpressureException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 5 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Flowable . range ( 1 , 5 ) . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . test ( 3 ) . assertValues ( 1 , 2 , 3 ) . assertNoErrors ( ) . assertNotComplete ( ) . cancel ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < SingleObserver < ? super Integer > > obs = new AtomicReference < > ( ) ; TestSubscriberEx < Integer > ts = pp . concatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; obs . set ( observer ) ; ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; pp . onNext ( 1 ) ; pp . onError ( new TestException ( "outer" ) ) ; obs . get ( ) . onError ( new TestException ( "inner" ) ) ; ts . assertFailureAndMessage ( TestException . class , "outer" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriberEx < Object > ts = Flowable . range ( 1 , 5 ) . concatMapSingleDelayError ( new Function < Integer , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Integer v ) throws Exception return Single . error ( new TestException ( ) ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; CompositeException ce = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; assertEquals ( 5 , ce . getExceptions ( ) . size ( ) ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Object > ts = pp . concatMapSingle ( new Function < Integer , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; ts . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; ConcatMapSingleSubscriber < Integer , Integer > operator = new ConcatMapSingleSubscriber < > ( ts , Functions . justFunction ( Single . < Integer > never ( ) ) , 16 , ErrorMode . IMMEDIATE ) ; operator . onSubscribe ( new BooleanSubscription ( ) ) ; operator . queue . offer ( 1 ) ; operator . getAndIncrement ( ) ; ts . cancel ( ) ; assertFalse ( operator . queue . isEmpty ( ) ) ; operator . addAndGet ( - 2 ) ; operator . cancel ( ) ; assertTrue ( operator . queue . isEmpty ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final SingleSubject < Integer > ss = SingleSubject . create ( ) ; final TestSubscriber < Integer > ts = Flowable . just ( 1 ) . hide ( ) . concatMapSingle ( Functions . justFunction ( ss ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ss . onSuccess ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertNoErrors ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapSingleDelayError ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; , false , 2 ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapSingleDelayError ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; , true , 2 ) ; ) ; 
Flowable . range ( 1 , 5 ) . hide ( ) . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; up . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . < Integer > rejectFlowableFusion ( ) . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertEmpty ( ) ; 
Flowable . range ( 1 , 5 ) . map ( v -> if ( v == 3 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . concatMapSingle ( v -> Single . just ( v ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = cs . andThen ( ps ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( cs . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = cs . andThen ( ps ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; cs . onComplete ( ) ; assertFalse ( cs . hasObservers ( ) ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( cs . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = cs . andThen ( ps ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; cs . onError ( new TestException ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = cs . andThen ( ps ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; cs . onComplete ( ) ; assertFalse ( cs . hasObservers ( ) ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Completable . never ( ) . andThen ( Observable . never ( ) ) ) ; 
Observable . range ( 1 , 5 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 1024 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; , 32 ) . test ( ) . assertValueCount ( 1024 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . range ( 1 , 10 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 10 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v % 2 == 0 ) return Maybe . just ( v ) ; return Maybe . empty ( ) ; ) . test ( ) . assertResult ( 2 , 4 , 6 , 8 , 10 ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 1024 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v % 2 == 0 ) return Maybe . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; return Maybe . < Integer > empty ( ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 512 ) . assertNoErrors ( ) . assertComplete ( ) ; for ( int i = 0 ; i < 512 ; i ++ ) to . assertValueAt ( i , ( i + 1 ) * 2 ) ; 
Observable . error ( new TestException ( ) ) . concatMapMaybe ( Functions . justFunction ( Maybe . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . concatMapMaybe ( Functions . justFunction ( Maybe . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . concatMapMaybeDelayError ( Functions . justFunction ( ms ) , false ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; assertTrue ( ms . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . concatMapMaybeDelayError ( Functions . justFunction ( ms ) , false ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; assertTrue ( ms . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; to . assertEmpty ( ) ; ms . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . concatMapMaybeDelayError ( Functions . justFunction ( Maybe . empty ( ) ) ) ; ) ; 
Observable . range ( 1 , 5 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Observable . range ( 1 , 5 ) . concatWith ( Observable . < Integer > never ( ) ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . test ( ) . assertValues ( 1 , 2 , 3 , 4 , 5 ) . assertNoErrors ( ) . assertNotComplete ( ) . dispose ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "outer" ) ) ; . concatMapMaybe ( Functions . justFunction ( Maybe . error ( new TestException ( "inner" ) ) ) , 1 ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "outer" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < MaybeObserver < ? super Integer > > obs = new AtomicReference < > ( ) ; TestObserverEx < Integer > to = ps . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; obs . set ( observer ) ; ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ps . onNext ( 1 ) ; ps . onError ( new TestException ( "outer" ) ) ; obs . get ( ) . onError ( new TestException ( "inner" ) ) ; to . assertFailureAndMessage ( TestException . class , "outer" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserverEx < Object > to = Observable . range ( 1 , 5 ) . concatMapMaybeDelayError ( new Function < Integer , MaybeSource < ? extends Object > > ( ) @ Override public MaybeSource < ? extends Object > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( ) ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; CompositeException ce = ( CompositeException ) to . errors ( ) . get ( 0 ) ; assertEquals ( 5 , ce . getExceptions ( ) . size ( ) ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Object > to = ps . concatMapMaybe ( new Function < Integer , MaybeSource < ? extends Object > > ( ) @ Override public MaybeSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
TestObserver < Object > to = Observable . just ( 1 ) . concatMapMaybe ( new Function < Integer , MaybeSource < ? extends Object > > ( ) @ Override public MaybeSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . hide ( ) . concatMapMaybe ( Functions . justFunction ( Maybe . never ( ) ) ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; Observable . empty ( ) . concatMapMaybe ( Functions . justFunction ( ms ) ) . test ( ) . assertResult ( ) ; assertFalse ( ms . hasObservers ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; ConcatMapMaybeMainObserver < Integer , Integer > operator = new ConcatMapMaybeMainObserver < > ( to , Functions . justFunction ( Maybe . < Integer > never ( ) ) , 16 , ErrorMode . IMMEDIATE ) ; operator . onSubscribe ( Disposable . empty ( ) ) ; operator . queue . offer ( 1 ) ; operator . getAndIncrement ( ) ; to . dispose ( ) ; assertFalse ( operator . queue . isEmpty ( ) ) ; operator . addAndGet ( - 2 ) ; operator . dispose ( ) ; assertTrue ( operator . queue . isEmpty ( ) ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = Observable . fromArray ( ms , Maybe . just ( 2 ) , Maybe . just ( 3 ) , Maybe . just ( 4 ) ) . concatMapMaybe ( Functions . < Maybe < Integer > > identity ( ) , 2 ) . test ( ) ; to . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; to . assertResult ( 1 , 2 , 3 , 4 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; final TestObserver < Integer > to = Observable . just ( 1 ) . hide ( ) . concatMapMaybe ( Functions . justFunction ( ms ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ms . onSuccess ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertNoErrors ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapMaybeDelayError ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; , false , 2 ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapMaybeDelayError ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; , true , 2 ) ; ) ; 
Observable . range ( 1 , 5 ) . hide ( ) . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . < Integer > rejectObservableFusion ( ) . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertEmpty ( ) ; 
Observable . range ( 1 , 5 ) . map ( v -> if ( v == 3 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . observableStripBoundary ( ) ) . concatMapMaybe ( v -> Maybe . just ( v ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Flowable . range ( 1 , 10 ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . test ( ) . assertResult ( ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; pp . onNext ( 1 ) ; assertTrue ( cs . hasObservers ( ) ) ; to . assertEmpty ( ) ; cs . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
final CompletableSubject [ ] css = CompletableSubject . create ( ) , CompletableSubject . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = pp . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return css [ v ] ; ) . test ( ) ; to . assertEmpty ( ) ; pp . onNext ( 0 ) ; assertTrue ( css [ 0 ] . hasObservers ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( css [ 0 ] . hasObservers ( ) ) ; assertTrue ( css [ 1 ] . hasObservers ( ) ) ; pp . onComplete ( ) ; to . assertEmpty ( ) ; assertTrue ( css [ 1 ] . hasObservers ( ) ) ; css [ 1 ] . onComplete ( ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestHelper . checkDisposed ( pp . switchMapCompletable ( Functions . justFunction ( cs ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToCompletable ( new Function < Flowable < Object > , Completable > ( ) @ Override public Completable apply ( Flowable < Object > f ) throws Exception return f . switchMapCompletable ( Functions . justFunction ( Completable . never ( ) ) ) ; ) ; 
Flowable . range ( 1 , 5 ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer f ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Flowable . range ( 1 , 5 ) . switchMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer f ) throws Exception to . dispose ( ) ; return Completable . complete ( ) ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex0 = new TestException ( ) ; final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . switchMapCompletable ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onError ( ex0 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( "main" ) ) ; . switchMapCompletable ( Functions . justFunction ( Completable . error ( new TestException ( "inner" ) ) ) ) . to ( TestHelper . testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "main" ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . switchMapCompletableDelayError ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; cs . onError ( new TestException ( ) ) ; to . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . switchMapCompletableDelayError ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; to . assertEmpty ( ) ; cs . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = pp . switchMapCompletableDelayError ( Functions . justFunction ( cs ) ) . test ( ) ; pp . onNext ( 1 ) ; pp . onError ( new TestException ( ) ) ; to . assertEmpty ( ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return upstream . switchMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return upstream . switchMapCompletableDelayError ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; ) ; ) ; 
Flowable . range ( 1 , 5 ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . error ( new TestException ( ) ) . switchMapSingle ( Functions . justFunction ( Single . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . switchMapSingle ( Functions . justFunction ( Single . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . switchMapSingle ( Functions . justFunction ( Single . never ( ) ) ) ; ) ; 
Flowable . range ( 1 , 5 ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms1 = SingleSubject . create ( ) ; final SingleSubject < Integer > ms2 = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms1 ; return ms2 ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( ms1 . hasObservers ( ) ) ; pp . onNext ( 2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms1 = SingleSubject . create ( ) ; final SingleSubject < Integer > ms2 = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms1 ; return ms2 ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( ms1 . hasObservers ( ) ) ; pp . onNext ( 2 ) ; assertFalse ( ms1 . hasObservers ( ) ) ; assertTrue ( ms2 . hasObservers ( ) ) ; ms2 . onError ( new TestException ( ) ) ; ts . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . assertEmpty ( ) ; ms . onSuccess ( 1 ) ; ts . assertFailure ( TestException . class , 1 ) ; 
Flowable . just ( 1 ) . switchMapSingle ( new Function < Integer , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception ts . cancel ( ) ; return Single . just ( 1 ) ; ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) ts . cancel ( ) ; return Single . just ( 1 ) ; ) . subscribe ( ts ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertFalse ( ms . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( "outer" ) ) ; . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . error ( new TestException ( "inner" ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "outer" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < SingleObserver < ? super Integer > > moRef = new AtomicReference < > ( ) ; TestSubscriberEx < Integer > ts = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( "outer" ) ) ; . switchMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; moRef . set ( observer ) ; ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "outer" ) ; moRef . get ( ) . onError ( new TestException ( "inner" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return ms ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; final TestSubscriberEx < Integer > ts = pp . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Single . never ( ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . errors ( ) . size ( ) != 0 ) assertTrue ( errors . isEmpty ( ) ) ; ts . assertFailure ( TestException . class ) ; else if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Single . never ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertError ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return e instanceof TestException || e instanceof CompositeException ; ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > ms = SingleSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ms ; return Single . never ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ms . onSuccess ( 3 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; requestMore ( 1 ) ; ; Flowable . range ( 1 , 5 ) . switchMapSingle ( Functions . justFunction ( Single . just ( 1 ) ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Flowable . just ( 1 ) . switchMapSingle ( Functions . justFunction ( Single . just ( 1 ) ) ) . test ( 0 ) . assertEmpty ( ) . requestMore ( 1 ) . assertResult ( 1 ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . switchMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . switchMapSingleDelayError ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; ) ; ) ; 
Single . using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception throw new TestException ( ) ; , Functions . justFunction ( Single . just ( 1 ) ) , Functions . emptyConsumer ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( Single . just ( 1 ) ) , Functions . emptyConsumer ( ) ) . test ( ) . assertResult ( 1 ) ; 
Single . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( Single . just ( 1 ) ) , Functions . emptyConsumer ( ) , false ) . test ( ) . assertResult ( 1 ) ; 
Single . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( Single . error ( new TestException ( ) ) ) , Functions . emptyConsumer ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( Single . error ( new TestException ( ) ) ) , Functions . emptyConsumer ( ) , false ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = Single . using ( Functions . justSupplier ( Disposable . empty ( ) ) , mapperThrows , disposerThrows ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "Mapper" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "Disposer" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . using ( Functions . justSupplier ( Disposable . empty ( ) ) , mapperThrows , disposerThrows , false ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Mapper" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Disposer" ) ; finally RxJavaPlugins . reset ( ) ; 
Disposable d = Disposable . empty ( ) ; Single . using ( Functions . justSupplier ( d ) , mapperThrows , disposer ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( d . isDisposed ( ) ) ; 
Disposable d = Disposable . empty ( ) ; Single . using ( Functions . justSupplier ( d ) , mapperThrows , disposer , false ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( d . isDisposed ( ) ) ; 
Disposable d = Disposable . empty ( ) ; Single . using ( Functions . justSupplier ( d ) , mapper , disposer , false ) . test ( true ) ; assertTrue ( d . isDisposed ( ) ) ; 
Single . using ( Functions . justSupplier ( Disposable . empty ( ) ) , mapper , disposerThrows ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . using ( Functions . justSupplier ( Disposable . empty ( ) ) , mapper , disposerThrows , false ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Disposer" ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserverEx < Integer > to = Single . using ( Functions . justSupplier ( Disposable . empty ( ) ) , new Function < Disposable , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Disposable v ) throws Exception return Single . < Integer > error ( new TestException ( "Mapper-run" ) ) ; , disposerThrows ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "Mapper-run" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "Disposer" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . using ( Functions . justSupplier ( Disposable . empty ( ) ) , new Function < Disposable , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Disposable v ) throws Exception return Single . < Integer > error ( new TestException ( "Mapper-run" ) ) ; , disposerThrows , false ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Disposer" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Disposable d = Disposable . empty ( ) ; final TestObserver < Integer > to = Single . using ( Functions . justSupplier ( d ) , new Function < Disposable , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Disposable v ) throws Exception return pp . single ( - 99 ) ; , disposer ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( d . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . using ( Functions . justSupplier ( 1 ) , new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onSuccess ( 1 ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; , Functions . emptyConsumer ( ) ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Disposable d = Disposable . empty ( ) ; final TestObserver < Integer > to = Single . using ( Functions . justSupplier ( d ) , new Function < Disposable , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Disposable v ) throws Exception return pp . single ( - 99 ) ; , disposer ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( d . isDisposed ( ) ) ; 
final StringBuilder sb = new StringBuilder ( ) ; TestObserver < Integer > to = Single . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer t ) throws Throwable return Single . < Integer > never ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Dispose" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , true ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; assertEquals ( "ResourceDispose" , sb . toString ( ) ) ; 
final StringBuilder sb = new StringBuilder ( ) ; TestObserver < Integer > to = Single . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer t ) throws Throwable return Single . < Integer > never ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Dispose" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , false ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; assertEquals ( "DisposeResource" , sb . toString ( ) ) ; 
Single . concat ( Flowable . just ( Single . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Single . concat ( Flowable . fromCallable ( new Callable < Single < Integer > > ( ) @ Override public Single < Integer > call ( ) throws Exception return Single . just ( 1 ) ; ) ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Collections . < Integer > emptyList ( ) ; ) . test ( ) . assertResult ( ) ; 
Single . < Integer > error ( new TestException ( ) ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 ) ; ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 ) ; ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 1 , 100 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 1 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 100 , 1 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 2 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
TestHelper . checkDoubleOnSubscribeSingleToObservable ( new Function < Single < Object > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Single < Object > o ) throws Exception return o . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Collections . singleton ( 1 ) ; ) ; ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Collections . singleton ( 1 ) ; ) ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . take ( 500 * 1000 ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . observeOn ( Schedulers . single ( ) ) . take ( 500 * 1000 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . flattenAsObservable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Arrays . asList ( 1 , 2 , 3 ) ; ) . subscribe ( new Observer < Integer > ( ) QueueDisposable < Integer > qd ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSubscribe ( Disposable d ) qd = ( QueueDisposable < Integer > ) d ; assertEquals ( QueueFuseable . ASYNC , qd . requestFusion ( QueueFuseable . ANY ) ) ; @ Override public void onNext ( Integer value ) assertFalse ( qd . isEmpty ( ) ) ; qd . clear ( ) ; assertTrue ( qd . isEmpty ( ) ) ; qd . dispose ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Single . just ( 1 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Maybe . just ( 2 ) ; return Maybe . just ( 1 ) ; ) . test ( ) . assertResult ( 2 ) ; 
Single . just ( 1 ) . concatMapMaybe ( new Function < Integer , MaybeSource < String > > ( ) @ Override public MaybeSource < String > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Maybe . just ( "2" ) ; return Maybe . just ( "1" ) ; ) . test ( ) . assertResult ( "2" ) ; 
Single . just ( 1 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( final Integer integer ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( NullPointerException . class ) . assertErrorMessage ( "The mapper returned a null MaybeSource" ) ; 
Single . just ( 1 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( final Integer integer ) throws Exception throw new RuntimeException ( "something went terribly wrong!" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "something went terribly wrong!" ) ; 
RuntimeException exception = new RuntimeException ( "test" ) ; Single . error ( exception ) . concatMapMaybe ( new Function < Object , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( final Object integer ) throws Exception return Maybe . just ( new Object ( ) ) ; ) . test ( ) . assertError ( exception ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 1 ) ; ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToMaybe ( new Function < Single < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Single < Integer > v ) throws Exception return v . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 1 ) ; ) ; ) ; 
Single . just ( 1 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . concatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Single . concatArrayEagerDelayError ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . fromPublisher ( Flowable . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Single . fromPublisher ( Flowable . range ( 1 , 3 ) ) . test ( ) . assertFailure ( IndexOutOfBoundsException . class ) ; 
Single . fromPublisher ( Flowable . empty ( ) ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
Single . fromPublisher ( Flowable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Integer > to = Single . fromPublisher ( pp ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestHelper . checkDisposed ( Single . fromPublisher ( Flowable . never ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . fromPublisher ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; BooleanSubscription s2 = new BooleanSubscription ( ) ; s . onSubscribe ( s2 ) ; assertTrue ( s2 . isCancelled ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onNext ( 2 ) ; s . onError ( new TestException ( ) ) ; s . onComplete ( ) ; ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "Subscription already set!" ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Single . just ( 1 ) . doAfterTerminate ( afterTerminate ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertAfterTerminateCalledOnce ( ) ; 
Single . < Integer > error ( new TestException ( ) ) . doAfterTerminate ( afterTerminate ) . subscribeWith ( to ) . assertFailure ( TestException . class ) ; assertAfterTerminateCalledOnce ( ) ; 
Single . just ( 1 ) . doAfterTerminate ( afterTerminate ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertAfterTerminateCalledOnce ( ) ; 
Single . < Integer > error ( new TestException ( ) ) . doAfterTerminate ( afterTerminate ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertFailure ( TestException . class ) ; assertAfterTerminateCalledOnce ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . just ( 1 ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . singleOrError ( ) . doAfterTerminate ( afterTerminate ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Integer > , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Single < Integer > m ) throws Exception return m . doAfterTerminate ( afterTerminate ) ; ) ; 
assertEquals ( 1 , call [ 0 ] ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > m ) throws Exception return m . onTerminateDetach ( ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . singleOrError ( ) . onTerminateDetach ( ) ) ; 
Single . error ( new TestException ( ) ) . onTerminateDetach ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . onTerminateDetach ( ) . test ( ) . assertResult ( 1 ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Object > to = new Single < Object > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Object > observer ) observer . onSubscribe ( wr . get ( ) ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; to . dispose ( ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertEmpty ( ) ; assertNull ( wr . get ( ) ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Integer > to = new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( wr . get ( ) ) ; observer . onError ( new TestException ( ) ) ; observer . onError ( new IOException ( ) ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertFailure ( TestException . class ) ; assertNull ( wr . get ( ) ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Integer > to = new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( wr . get ( ) ) ; observer . onSuccess ( 1 ) ; observer . onSuccess ( 2 ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertResult ( 1 ) ; assertNull ( wr . get ( ) ) ; 
Single < Integer > s = Single . defer ( new Supplier < Single < Integer > > ( ) int counter ; @ Override public Single < Integer > get ( ) throws Exception return Single . just ( ++ counter ) ; ) ; for ( int i = 1 ; i < 33 ; i ++ ) s . test ( ) . assertResult ( i ) ; 
Single . concatDelayError ( Arrays . asList ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . concatDelayError ( Flowable . fromArray ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . concatDelayError ( Flowable . fromArray ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < Integer > observer = Single . just ( 1 ) . delay ( 5 , TimeUnit . SECONDS , scheduler ) . test ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; observer . assertNoValues ( ) ; scheduler . advanceTimeTo ( 5 , TimeUnit . SECONDS ) ; observer . assertValue ( 1 ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < ? > observer = Single . error ( new TestException ( ) ) . delay ( 5 , TimeUnit . SECONDS , scheduler ) . test ( ) ; scheduler . triggerActions ( ) ; observer . assertError ( TestException . class ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < Integer > observer = Single . just ( 1 ) . delay ( 5 , TimeUnit . SECONDS , scheduler , true ) . test ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; observer . assertNoValues ( ) ; scheduler . advanceTimeTo ( 5 , TimeUnit . SECONDS ) ; observer . assertValue ( 1 ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < ? > observer = Single . error ( new TestException ( ) ) . delay ( 5 , TimeUnit . SECONDS , scheduler , true ) . test ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; observer . assertNoErrors ( ) ; scheduler . advanceTimeTo ( 5 , TimeUnit . SECONDS ) ; observer . assertError ( TestException . class ) ; 
Single . just ( 1 ) . delaySubscription ( Completable . complete ( ) . delay ( 100 , TimeUnit . MILLISECONDS ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . delaySubscription ( Observable . timer ( 100 , TimeUnit . MILLISECONDS ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . delaySubscription ( Flowable . timer ( 100 , TimeUnit . MILLISECONDS ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . delaySubscription ( Single . timer ( 100 , TimeUnit . MILLISECONDS ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , Schedulers . io ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Thread > thread = new AtomicReference < > ( ) ; Single . < String > error ( new Exception ( ) ) . delay ( 0 , TimeUnit . MILLISECONDS , Schedulers . newThread ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throws Exception thread . set ( Thread . currentThread ( ) ) ; latch . countDown ( ) ; ) . onErrorResumeWith ( Single . just ( "" ) ) . subscribe ( ) ; latch . await ( ) ; assertNotEquals ( Thread . currentThread ( ) , thread . get ( ) ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . delaySubscription ( Flowable . just ( 1 ) ) ) ; 
Single . just ( 1 ) . delaySubscription ( Flowable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . just ( 1 ) . delaySubscription ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . delaySubscription ( Observable . just ( 1 ) ) ) ; 
Single . just ( 1 ) . delaySubscription ( Observable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . just ( 1 ) . delaySubscription ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Single . just ( 1 ) . delaySubscription ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . delaySubscription ( Single . just ( 2 ) ) ) ; 
TestHelper . checkDisposed ( Completable . complete ( ) . andThen ( Single . just ( 1 ) ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletableToSingle ( new Function < Completable , Single < Object > > ( ) @ Override public Single < Object > apply ( Completable c ) throws Exception return c . andThen ( Single . just ( ( Object ) 1 ) ) ; ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , Single < Object > > ( ) @ Override public Single < Object > apply ( Single < Object > s ) throws Exception return Single . just ( ( Object ) 1 ) . delaySubscription ( s ) ; ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToSingle ( f -> SingleSubject . create ( ) . delaySubscription ( f ) ) ; 
TestHelper . checkDoubleOnSubscribeObservableToSingle ( o -> SingleSubject . create ( ) . delaySubscription ( o ) ) ; 
Single . switchOnNext ( Flowable . range ( 1 , 5 ) . map ( v -> if ( v % 2 == 0 ) return Single . just ( v ) ; return Single . just ( 10 + v ) ; ) ) . test ( ) . assertResult ( 11 , 2 , 13 , 4 , 15 ) ; 
Single . switchOnNextDelayError ( Flowable . range ( 1 , 5 ) . map ( v -> if ( v % 2 == 0 ) return Single . just ( v ) ; return Single . just ( 10 + v ) ; ) ) . test ( ) . assertResult ( 11 , 2 , 13 , 4 , 15 ) ; 
PublishProcessor < Single < Integer > > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Single . switchOnNext ( pp ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; SingleSubject < Integer > ss1 = SingleSubject . create ( ) ; SingleSubject < Integer > ss2 = SingleSubject . create ( ) ; pp . onNext ( ss1 ) ; assertTrue ( ss1 . hasObservers ( ) ) ; pp . onNext ( ss2 ) ; assertFalse ( ss1 . hasObservers ( ) ) ; assertTrue ( ss2 . hasObservers ( ) ) ; pp . onComplete ( ) ; assertTrue ( ss2 . hasObservers ( ) ) ; ss2 . onSuccess ( 1 ) ; ts . assertResult ( 1 ) ; 
PublishProcessor < Single < Integer > > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Single . switchOnNextDelayError ( pp ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; SingleSubject < Integer > ss1 = SingleSubject . create ( ) ; SingleSubject < Integer > ss2 = SingleSubject . create ( ) ; pp . onNext ( ss1 ) ; assertTrue ( ss1 . hasObservers ( ) ) ; pp . onNext ( ss2 ) ; assertFalse ( ss1 . hasObservers ( ) ) ; assertTrue ( ss2 . hasObservers ( ) ) ; assertTrue ( ss2 . hasObservers ( ) ) ; ss2 . onError ( new TestException ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Single < Integer > cached = pp . single ( - 99 ) . cache ( ) ; TestObserver < Integer > to = cached . test ( true ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; to . assertEmpty ( ) ; cached . test ( ) . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Single < Integer > cached = pp . single ( - 99 ) . cache ( ) ; final TestObserver < Integer > to1 = cached . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cached . test ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Single < Integer > cached = pp . single ( - 99 ) . cache ( ) ; SingleObserver < Integer > doubleDisposer = new SingleObserver < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) d . dispose ( ) ; d . dispose ( ) ; @ Override public void onSuccess ( Integer value ) @ Override public void onError ( Throwable e ) ; cached . subscribe ( doubleDisposer ) ; cached . test ( ) ; cached . subscribe ( doubleDisposer ) ; 
Single . mergeArray ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Single . mergeArray ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 3 ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Single . mergeArrayDelayError ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Single . mergeArrayDelayError ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 3 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 3 ) ; 
Single . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Maybe . just ( 2 ) ; return Maybe . just ( 1 ) ; ) . test ( ) . assertResult ( 2 ) ; 
Single . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < String > > ( ) @ Override public MaybeSource < String > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Maybe . just ( "2" ) ; return Maybe . just ( "1" ) ; ) . test ( ) . assertResult ( "2" ) ; 
Single . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( final Integer integer ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( NullPointerException . class ) . assertErrorMessage ( "The mapper returned a null MaybeSource" ) ; 
Single . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( final Integer integer ) throws Exception throw new RuntimeException ( "something went terribly wrong!" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "something went terribly wrong!" ) ; 
RuntimeException exception = new RuntimeException ( "test" ) ; Single . error ( exception ) . flatMapMaybe ( new Function < Object , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( final Object integer ) throws Exception return Maybe . just ( new Object ( ) ) ; ) . test ( ) . assertError ( exception ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 1 ) ; ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToMaybe ( new Function < Single < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Single < Integer > v ) throws Exception return v . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 1 ) ; ) ; ) ; 
Single . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Single . just ( 1 ) . timeInterval ( ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . error ( new TestException ( ) ) . timeInterval ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . timeInterval ( TimeUnit . SECONDS ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . timeInterval ( Schedulers . single ( ) ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . timeInterval ( TimeUnit . SECONDS , Schedulers . single ( ) ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( m -> m . timeInterval ( ) ) ; 
TestHelper . checkDisposed ( SingleSubject . create ( ) . timeInterval ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Timed < Integer > > to = ss . timeInterval ( scheduler ) . test ( ) ; scheduler . advanceTimeBy ( 1000 , TimeUnit . MILLISECONDS ) ; ss . onSuccess ( 1 ) ; to . assertResult ( new Timed < > ( 1 , 1000L , TimeUnit . MILLISECONDS ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final String [ ] name = null ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; pp . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception name [ 0 ] = Thread . currentThread ( ) . getName ( ) ; cdl . countDown ( ) ; ) . single ( - 99 ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( true ) ; assertTrue ( cdl . await ( 5 , TimeUnit . SECONDS ) ) ; int times = 10 ; while ( times -- > 0 && pp . hasSubscribers ( ) ) Thread . sleep ( 100 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertNotEquals ( Thread . currentThread ( ) . getName ( ) , name [ 0 ] ) ; 
Single . just ( 1 ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertResult ( 1 ) ; 
Single . < Integer > error ( new TestException ( ) ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . unsubscribeOn ( Schedulers . single ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > v ) throws Exception return v . unsubscribeOn ( Schedulers . single ( ) ) ; ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Disposable [ ] ds = null ; pp . single ( - 99 ) . unsubscribeOn ( Schedulers . computation ( ) ) . subscribe ( new SingleObserver < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) ds [ 0 ] = d ; @ Override public void onSuccess ( Integer value ) @ Override public void onError ( Throwable e ) ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) ds [ 0 ] . dispose ( ) ; ; TestHelper . race ( r , r ) ; 
calls ++ ; 
Single . just ( 1 ) . doFinally ( this ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls ) ; 
Single . error ( new TestException ( ) ) . doFinally ( this ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , Single < Object > > ( ) @ Override public Single < Object > apply ( Single < Object > f ) throws Exception return f . doFinally ( SingleDoFinallyTest . this ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . just ( 1 ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( 1 ) . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . doFinally ( this ) ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; Single . just ( 1 ) . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) . assertResult ( 1 ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; Single . error ( new TestException ( ) ) . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) . assertFailure ( TestException . class ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; doThrow ( new TestException ( "First" ) ) . when ( onSubscribe ) . accept ( any ( ) ) ; Disposable bs = Disposable . empty ( ) ; new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( bs ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onSuccess ( 1 ) ; . doOnLifecycle ( onSubscribe , onDispose ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( bs . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; doThrow ( new TestException ( "First" ) ) . when ( onDispose ) . run ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = ss . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) ; assertTrue ( ss . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ss . hasObservers ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "First" ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose ) . run ( ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = ss . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) ; assertTrue ( ss . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ss . hasObservers ( ) ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose ) . run ( ) ; 
TestHelper . checkDisposed ( SingleSubject . create ( ) . doOnLifecycle ( d -> , ( ) -> ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( m -> m . doOnLifecycle ( d -> , ( ) -> ) ) ; 
Single . concatEager ( Arrays . asList ( Single . just ( 1 ) , Single . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . concatEager ( Arrays . asList ( Single . just ( 1 ) , Single . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . concatEager ( Arrays . asList ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Single . concatEager ( Arrays . asList ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Single . concatEager ( Flowable . fromArray ( Single . just ( 1 ) , Single . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . concatEager ( Flowable . fromArray ( Single . just ( 1 ) , Single . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . concatEager ( Flowable . fromArray ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Single . concatEagerDelayError ( Arrays . asList ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . concatEagerDelayError ( Arrays . asList ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . concatEagerDelayError ( Flowable . fromArray ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . concatEagerDelayError ( Flowable . fromArray ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) , Single . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) ) ; 
final boolean [ ] b = false ; Single . just ( 1 ) . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Exception return Completable . complete ( ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception b [ 0 ] = true ; ) ; ) . test ( ) . assertResult ( ) ; assertTrue ( b [ 0 ] ) ; 
final boolean [ ] b = false ; Single . < Integer > error ( new TestException ( ) ) . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Exception return Completable . complete ( ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception b [ 0 ] = true ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( b [ 0 ] ) ; 
final boolean [ ] b = false ; Single . just ( 1 ) . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( b [ 0 ] ) ; 
final boolean [ ] b = false ; Single . just ( 1 ) . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertFalse ( b [ 0 ] ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Integer > to = Single . just ( 1 ) . subscribeOn ( scheduler ) . test ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertResult ( 1 ) ; assertTrue ( list . toString ( ) , list . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . subscribeOn ( new TestScheduler ( ) ) ) ; 
Single . error ( new TestException ( ) ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
final Disposable d = Disposable . empty ( ) ; Single . < Integer > create ( new SingleOnSubscribe < Integer > ( ) @ Override public void subscribe ( SingleEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onSuccess ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( 1 ) ; assertTrue ( d . isDisposed ( ) ) ; 
final Disposable d1 = Disposable . empty ( ) ; final Disposable d2 = Disposable . empty ( ) ; Single . < Integer > create ( new SingleOnSubscribe < Integer > ( ) @ Override public void subscribe ( SingleEmitter < Integer > e ) throws Exception e . setDisposable ( d1 ) ; e . setCancellable ( new Cancellable ( ) @ Override public void cancel ( ) throws Exception d2 . dispose ( ) ; ) ; e . onSuccess ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( 1 ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; 
final Disposable d = Disposable . empty ( ) ; Single . < Integer > create ( new SingleOnSubscribe < Integer > ( ) @ Override public void subscribe ( SingleEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onError ( new TestException ( ) ) ; e . onSuccess ( 2 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( d . isDisposed ( ) ) ; 
Single . unsafeCreate ( Single . just ( 1 ) ) ; 
Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > s ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > s ) throws Exception s . onSuccess ( 1 ) ; ) ) ; 
Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > s ) throws Exception s . onSuccess ( null ) ; s . onSuccess ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > s ) throws Exception s . onError ( null ) ; s . onError ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > s ) throws Exception try s . onSuccess ( 1 ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) ) . subscribe ( new SingleObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) throw new TestException ( ) ; @ Override public void onError ( Throwable e ) ) ; 
Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > s ) throws Exception Disposable d = Disposable . empty ( ) ; s . setDisposable ( d ) ; try s . onSuccess ( 1 ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; ) . subscribe ( new SingleObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) throw new TestException ( ) ; @ Override public void onError ( Throwable e ) ) ; 
Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > s ) throws Exception try s . onError ( new IOException ( ) ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) ) . subscribe ( new SingleObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; ) ; 
Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > s ) throws Exception Disposable d = Disposable . empty ( ) ; s . setDisposable ( d ) ; try s . onError ( new IOException ( ) ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; ) . subscribe ( new SingleObserver < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onSuccess ( Object value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Boolean [ ] response = null ; Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > e ) throws Exception e . onSuccess ( 1 ) ; response [ 0 ] = e . tryOnError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( 1 ) ; assertFalse ( response [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Single . create ( new SingleOnSubscribe < Object > ( ) @ Override public void subscribe ( SingleEmitter < Object > emitter ) throws Exception assertTrue ( emitter . toString ( ) . contains ( SingleCreate . Emitter . class . getSimpleName ( ) ) ) ; ) . test ( ) . assertEmpty ( ) ; 
Single . just ( 1 ) . materialize ( ) . test ( ) . assertResult ( Notification . createOnNext ( 1 ) ) ; 
TestException ex = new TestException ( ) ; Maybe . error ( ex ) . materialize ( ) . test ( ) . assertResult ( Notification . createOnError ( ex ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Notification < Object > > > ( ) @ Override public SingleSource < Notification < Object > > apply ( Single < Object > v ) throws Exception return v . materialize ( ) ; ) ; 
TestHelper . checkDisposed ( SingleSubject . create ( ) . materialize ( ) ) ; 
Single . just ( Notification . createOnNext ( 1 ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( Notification . < Integer > createOnComplete ( ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) . test ( ) . assertResult ( ) ; 
Single . < Notification < Integer > > error ( new TestException ( ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( Notification . < Integer > createOnError ( new TestException ( ) ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeSingleToMaybe ( new Function < Single < Object > , MaybeSource < Object > > ( ) @ SuppressWarnings ( "unchecked" , "rawtypes" ) @ Override public MaybeSource < Object > apply ( Single < Object > v ) throws Exception return v . dematerialize ( ( Function ) Functions . identity ( ) ) ; ) ; 
TestHelper . checkDisposed ( SingleSubject . < Notification < Integer > > create ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ) ; 
Single . just ( Notification . createOnNext ( 1 ) ) . dematerialize ( new Function < Notification < Integer > , Notification < Integer > > ( ) @ Override public Notification < Integer > apply ( Notification < Integer > v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( Notification . createOnNext ( 1 ) ) . dematerialize ( Functions . justFunction ( ( Notification < Integer > ) null ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Single . just ( Notification . createOnNext ( 1 ) ) . dematerialize ( new Function < Notification < Integer > , Notification < String > > ( ) @ Override public Notification < String > apply ( Notification < Integer > v ) throws Exception return Notification . createOnNext ( "Value-" + 1 ) ; ) . test ( ) . assertResult ( "Value-1" ) ; 
Single . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception return 5 ; ) . test ( ) . assertResult ( 5 ) ; 
Single . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
Single . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The supplier returned a null value" ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Supplier < Integer > supplier = new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception return atomicInteger . incrementAndGet ( ) ; ; Single . fromSupplier ( supplier ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Single . fromSupplier ( supplier ) . test ( ) . assertResult ( 2 ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
Supplier < Object > func = mock ( Supplier . class ) ; when ( func . get ( ) ) . thenReturn ( new Object ( ) ) ; Single < Object > fromSupplierSingle = Single . fromSupplier ( func ) ; verifyNoInteractions ( func ) ; fromSupplierSingle . subscribe ( ) ; verify ( func ) . get ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Integer > to = Single . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; return 1 ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Supplier < String > func = mock ( Supplier . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . get ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Single < String > fromSupplierObservable = Single . fromSupplier ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; TestObserver < String > outer = new TestObserver < > ( observer ) ; fromSupplierObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . dispose ( ) ; funcLatch . countDown ( ) ; verify ( func ) . get ( ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verifyNoMoreInteractions ( observer ) ; 
final Exception checkedException = new Exception ( "test exception" ) ; Single < Object > fromSupplierObservable = Single . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw checkedException ; ) ; SingleObserver < Object > observer = TestHelper . mockSingleObserver ( ) ; fromSupplierObservable . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verify ( observer ) . onError ( checkedException ) ; verifyNoMoreInteractions ( observer ) ; 
final int [ ] count = 0 ; Single . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception count [ 0 ] ++ ; return 1 ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , count [ 0 ] ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Single . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception to . dispose ( ) ; return 1 ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
Single . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; ) . toObservable ( ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Single . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception return 1 ; ) . toObservable ( ) . singleOrError ( ) . test ( ) . assertResult ( 1 ) ; 
Single . error ( new TestException ( ) ) . hide ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . hide ( ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > s ) throws Exception return s . hide ( ) ; ) ; 
final int [ ] count = 0 ; Single . never ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception count [ 0 ] ++ ; ) . test ( true ) ; assertEquals ( 1 , count [ 0 ] ) ; 
final Object [ ] event = null ; Single . error ( new TestException ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception event [ 0 ] = e ; ) . test ( ) ; assertTrue ( event [ 0 ] . toString ( ) , event [ 0 ] instanceof TestException ) ; 
final int [ ] count = 0 ; Single . never ( ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception count [ 0 ] ++ ; ) . test ( ) ; assertEquals ( 1 , count [ 0 ] ) ; 
final Object [ ] event = null ; Single . just ( 1 ) . doOnSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception event [ 0 ] = e ; ) . test ( ) ; assertEquals ( 1 , event [ 0 ] ) ; 
final int [ ] count = 0 ; Single . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception count [ 0 ] ++ ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , count [ 0 ] ) ; 
final int [ ] count = 0 ; Single . error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception count [ 0 ] ++ ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , count [ 0 ] ) ; 
Single . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . error ( new TestException ( "Outer" ) ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Inner" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Outer" ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] call = 0 ; Single . just ( 1 ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) throws Exception call [ 0 ] ++ ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , call [ 0 ] ) ; 
TestObserverEx < Object > to = Single . error ( new TestException ( "Outer" ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
Single . just ( 1 ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = Single . < Integer > error ( new TestException ( "Main" ) ) . doOnEvent ( new BiConsumer < Integer , Throwable > ( ) @ Override public void accept ( Integer v , Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Main" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
final int [ ] calls = 0 ; TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception calls [ 0 ] ++ ; ) ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Single . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception calls [ 0 ] ++ ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Single . error ( new TestException ( ) ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception calls [ 0 ] ++ ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > s ) throws Exception return s . doOnDispose ( Functions . EMPTY_ACTION ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . singleOrError ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] call = 0 ; Single . error ( new TestException ( ) ) . doOnSuccess ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception call [ 0 ] ++ ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
Single . just ( 1 ) . doOnSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable bs = Disposable . empty ( ) ; new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( bs ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onSuccess ( 1 ) ; . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( "First" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( bs . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Single . just ( 1 ) . startWith ( Completable . complete ( ) ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . startWith ( Completable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . startWith ( Single . just ( 0 ) ) . test ( ) . assertResult ( 0 , 1 ) ; 
Single . just ( 1 ) . startWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . startWith ( Maybe . just ( 0 ) ) . test ( ) . assertResult ( 0 , 1 ) ; 
Single . just ( 1 ) . startWith ( Maybe . empty ( ) ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . startWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . startWith ( Observable . just ( - 1 , 0 ) ) . test ( ) . assertResult ( - 1 , 0 , 1 ) ; 
Single . just ( 1 ) . startWith ( Observable . empty ( ) ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . startWith ( Observable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . startWith ( Flowable . just ( - 1 , 0 ) ) . test ( ) . assertResult ( - 1 , 0 , 1 ) ; 
Single . just ( 1 ) . startWith ( Observable . empty ( ) ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . startWith ( Flowable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
final PublishSubject < String > subject = PublishSubject . create ( ) ; final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < String > observer = subject . single ( "" ) . timeout ( 100 , TimeUnit . MILLISECONDS , scheduler ) . test ( ) ; assertTrue ( subject . hasObservers ( ) ) ; observer . dispose ( ) ; assertFalse ( subject . hasObservers ( ) ) ; 
Single . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , Single . error ( new TestException ( ) ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Single . error ( new TestException ( ) ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
TestScheduler sch = new TestScheduler ( ) ; SingleSubject < Integer > subj = SingleSubject . create ( ) ; subj . timeout ( 1 , TimeUnit . SECONDS , sch , Single . just ( 1 ) ) . test ( true ) . assertEmpty ( ) ; assertFalse ( subj . hasObservers ( ) ) ; 
TestHelper . checkDisposed ( SingleSubject . create ( ) . timeout ( 1 , TimeUnit . DAYS ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; SingleSubject < Integer > subj = SingleSubject . create ( ) ; SingleSubject < Integer > fallback = SingleSubject . create ( ) ; TestObserver < Integer > to = subj . timeout ( 1 , TimeUnit . SECONDS , sch , fallback ) . test ( ) ; assertFalse ( fallback . hasObservers ( ) ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertFalse ( subj . hasObservers ( ) ) ; assertTrue ( fallback . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( fallback . hasObservers ( ) ) ; 
final int [ ] calls = 0 ; Single . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception calls [ 0 ] ++ ; ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final SingleSubject < Integer > subj = SingleSubject . create ( ) ; SingleSubject < Integer > fallback = SingleSubject . create ( ) ; final TestScheduler sch = new TestScheduler ( ) ; TestObserver < Integer > to = subj . timeout ( 1 , TimeUnit . MILLISECONDS , sch , fallback ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) subj . onSuccess ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sch . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ! fallback . hasObservers ( ) ) to . assertResult ( 1 ) ; else to . assertEmpty ( ) ; 
final TestException ex = new TestException ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final SingleSubject < Integer > subj = SingleSubject . create ( ) ; SingleSubject < Integer > fallback = SingleSubject . create ( ) ; final TestScheduler sch = new TestScheduler ( ) ; TestObserver < Integer > to = subj . timeout ( 1 , TimeUnit . MILLISECONDS , sch , fallback ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) subj . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sch . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ! fallback . hasObservers ( ) ) to . assertFailure ( TestException . class ) ; else to . assertEmpty ( ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Single . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS ) . to ( TestHelper . < Object > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( 1 , TimeUnit . MILLISECONDS ) ) ; 
Single . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , Single . just ( 1 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Disposable d = Disposable . empty ( ) ; new Single < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull SingleObserver < ? super @ NonNull Integer > observer ) try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; observer . onSubscribe ( d ) ; . timeout ( 1 , TimeUnit . MILLISECONDS , Single . just ( 1 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; assertTrue ( d . isDisposed ( ) ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . single ( - 99 ) . ambWith ( pp2 . single ( - 99 ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . single ( - 99 ) . ambWith ( pp2 . single ( - 99 ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; List < Single < Integer > > singles = Arrays . asList ( pp1 . single ( - 99 ) , pp2 . single ( - 99 ) ) ; TestObserver < Integer > to = Single . amb ( singles ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; List < Single < Integer > > singles = Arrays . asList ( pp1 . single ( - 99 ) , pp2 . single ( - 99 ) ) ; TestObserver < Integer > to = Single . amb ( singles ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; to . assertResult ( 2 ) ; 
Single . ambArray ( ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
assertSame ( Single . never ( ) , Single . ambArray ( Single . never ( ) ) ) ; 
Single . ambArray ( Single . error ( new TestException ( ) ) , Single . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Subject < Integer > ps = ReplaySubject . create ( ) ; ps . onNext ( 1 ) ; final Single < Integer > source = Single . ambArray ( ps . singleOrError ( ) , Single . < Integer > never ( ) , Single . < Integer > never ( ) , null ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertError ( errors , 0 , NullPointerException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Subject < Integer > ps1 = PublishSubject . create ( ) ; final Subject < Integer > ps2 = PublishSubject . create ( ) ; Single . ambArray ( ps1 . singleOrError ( ) , ps2 . singleOrError ( ) ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Subject < Integer > ps1 = PublishSubject . create ( ) ; final Subject < Integer > ps2 = PublishSubject . create ( ) ; Single . ambArray ( ps1 . singleOrError ( ) , ps2 . singleOrError ( ) ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onNext ( 1 ) ; ps1 . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Single < ? > [ ] sources = new Single [ 32 ] ; Arrays . fill ( sources , Single . never ( ) ) ; sources [ 31 ] = Single . just ( 31 ) ; Single . amb ( Arrays . asList ( sources ) ) . test ( ) . assertResult ( 31 ) ; 
Single < Integer > error = Single . error ( new RuntimeException ( ) ) ; Single . just ( 1 ) . ambWith ( error ) . test ( ) . assertValue ( 1 ) ; 
Single < Integer > error = Single . error ( new RuntimeException ( ) ) ; Single . amb ( Arrays . asList ( Single . just ( 1 ) , error ) ) . test ( ) . assertValue ( 1 ) ; 
Single < Integer > error = Single . error ( new RuntimeException ( ) ) ; Single . ambArray ( Single . just ( 1 ) , error ) . test ( ) . assertValue ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Single . ambArray ( Single . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Single . never ( ) ) . subscribe ( new BiConsumer < Object , Throwable > ( ) @ Override public void accept ( Object v , Throwable e ) throws Exception assertNotNull ( v ) ; assertNull ( e ) ; interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Single . ambArray ( Single . error ( ex ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Single . never ( ) ) . subscribe ( new BiConsumer < Object , Throwable > ( ) @ Override public void accept ( Object v , Throwable e ) throws Exception assertNull ( v ) ; assertNotNull ( e ) ; interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
SingleSource < Integer > source = new SingleSource < Integer > ( ) @ Override public void subscribe ( SingleObserver < ? super Integer > observer ) Single . just ( 1 ) . subscribe ( observer ) ; ; Single . amb ( Arrays . asList ( source , source ) ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . lift ( new SingleOperator < Integer , Integer > ( ) @ Override public SingleObserver < Integer > apply ( final SingleObserver < ? super Integer > observer ) throws Exception return new SingleObserver < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) observer . onSubscribe ( d ) ; @ Override public void onSuccess ( Integer value ) observer . onSuccess ( value + 1 ) ; @ Override public void onError ( Throwable e ) observer . onError ( e ) ; ; ) . test ( ) . assertResult ( 2 ) ; 
TestHelper . checkDisposed ( Single . timer ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try for ( Scheduler s : new Scheduler [ ] Schedulers . single ( ) , Schedulers . computation ( ) , Schedulers . newThread ( ) , Schedulers . io ( ) , Schedulers . from ( exec , true ) ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; TestObserver < Long > to = Single . timer ( 1 , TimeUnit . MILLISECONDS , s ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long v ) throws Exception try Thread . sleep ( 3000 ) ; catch ( InterruptedException ex ) interrupted . set ( true ) ; return v ; ) . test ( ) ; Thread . sleep ( 500 ) ; to . dispose ( ) ; Thread . sleep ( 500 ) ; assertTrue ( s . getClass ( ) . getSimpleName ( ) , interrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . toObservable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToObservable ( new Function < Single < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Single < Object > s ) throws Exception return s . toObservable ( ) ; ) ; 
Single . just ( 1 ) . doAfterSuccess ( afterSuccess ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Single . < Integer > error ( new TestException ( ) ) . doAfterSuccess ( afterSuccess ) . subscribeWith ( to ) . assertFailure ( TestException . class ) ; assertTrue ( values . isEmpty ( ) ) ; 
Single . just ( 1 ) . doAfterSuccess ( afterSuccess ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Single . < Integer > error ( new TestException ( ) ) . doAfterSuccess ( afterSuccess ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertFailure ( TestException . class ) ; assertTrue ( values . isEmpty ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . just ( 1 ) . doAfterSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . singleOrError ( ) . doAfterSuccess ( afterSuccess ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Integer > , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Single < Integer > m ) throws Exception return m . doAfterSuccess ( afterSuccess ) ; ) ; 
Single . fromMaybe ( Maybe . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Single . fromMaybe ( Maybe . empty ( ) . hide ( ) ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
Single . fromMaybe ( Maybe . empty ( ) . hide ( ) , 1 ) . test ( ) . assertResult ( 1 ) ; 
Single . fromMaybe ( Maybe . error ( new TestException ( ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = Single . fromMaybe ( ms ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ms . hasObservers ( ) ) ; 
Single . never ( ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
Single . timer ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 0L ) ; 
assertSame ( Single . never ( ) , Single . wrap ( Single . never ( ) ) ) ; Single . wrap ( new SingleSource < Object > ( ) @ Override public void subscribe ( SingleObserver < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; ) . test ( ) . assertResult ( 1 ) ; 
Single < Number > source = Single . just ( 1d ) . cast ( Number . class ) ; source . test ( ) . assertResult ( ( Number ) 1d ) ; 
Single . just ( 1 ) . contains ( 1 ) . test ( ) . assertResult ( true ) ; Single . just ( 2 ) . contains ( 1 ) . test ( ) . assertResult ( false ) ; 
Single . just ( 1 ) . compose ( new SingleTransformer < Integer , Object > ( ) @ Override public SingleSource < Object > apply ( Single < Integer > f ) return f . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return v + 1 ; ) ; ) . test ( ) . assertResult ( 2 ) ; 
assertNotSame ( Single . never ( ) , Single . never ( ) . hide ( ) ) ; 
Single . < Integer > error ( new TestException ( ) ) . onErrorResumeWith ( Single . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Single . < Integer > error ( new TestException ( ) ) . onErrorReturnItem ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . repeat ( ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Single . just ( 1 ) . repeat ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
final AtomicBoolean flag = new AtomicBoolean ( ) ; Single . just ( 1 ) . doOnSuccess ( new Consumer < Integer > ( ) int c ; @ Override public void accept ( Integer v ) throws Exception if ( ++ c == 5 ) flag . set ( true ) ; ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return flag . get ( ) ; ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Single . fromCallable ( new Callable < Object > ( ) int c ; @ Override public Object call ( ) throws Exception if ( ++ c != 5 ) throw new TestException ( ) ; return 1 ; ) . retry ( ) . test ( ) . assertResult ( 1 ) ; 
Single . fromCallable ( new Callable < Object > ( ) int c ; @ Override public Object call ( ) throws Exception if ( ++ c != 5 ) throw new TestException ( ) ; return 1 ; ) . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer i , Throwable e ) throws Exception return true ; ) . test ( ) . assertResult ( 1 ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Single . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception if ( calls . incrementAndGet ( ) != 6 ) throw new TestException ( ) ; return 1 ; ) . retry ( 5 ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 6 , calls . get ( ) ) ; 
Single . fromCallable ( new Callable < Object > ( ) int c ; @ Override public Object call ( ) throws Exception if ( ++ c != 5 ) throw new TestException ( ) ; return 1 ; ) . retry ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return true ; ) . test ( ) . assertResult ( 1 ) ; 
Single . never ( ) . timeout ( 100 , TimeUnit . MILLISECONDS , Schedulers . io ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
Single . never ( ) . timeout ( 100 , TimeUnit . MILLISECONDS , Schedulers . io ( ) , Single . just ( 1 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . ignoreElement ( ) . test ( ) . assertResult ( ) ; Single . error ( new TestException ( ) ) . ignoreElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . toObservable ( ) . test ( ) . assertResult ( 1 ) ; Single . error ( new TestException ( ) ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . sequenceEqual ( Single . just ( 1 ) , Single . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( true ) ; Single . sequenceEqual ( Single . just ( 1 ) , Single . just ( 2 ) ) . test ( ) . assertResult ( false ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . observeOn ( Schedulers . single ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > s ) throws Exception return s . observeOn ( Schedulers . single ( ) ) ; ) ; 
Single . error ( new TestException ( ) ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . timestamp ( ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . error ( new TestException ( ) ) . timestamp ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . timestamp ( TimeUnit . SECONDS ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . timestamp ( Schedulers . single ( ) ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . timestamp ( TimeUnit . SECONDS , Schedulers . single ( ) ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( m -> m . timestamp ( ) ) ; 
TestHelper . checkDisposed ( SingleSubject . create ( ) . timestamp ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Timed < Integer > > to = ss . timestamp ( scheduler ) . test ( ) ; scheduler . advanceTimeBy ( 1000 , TimeUnit . MILLISECONDS ) ; ss . onSuccess ( 1 ) ; to . assertResult ( new Timed < > ( 1 , 1000L , TimeUnit . MILLISECONDS ) ) ; 
Single . just ( 1 ) . ofType ( Integer . class ) . test ( ) . assertResult ( 1 ) ; 
TestObserver < Number > to = Single . just ( 1 ) . ofType ( Number . class ) . test ( ) ; to . assertResult ( ( Number ) 1 ) ; 
TestObserver < String > to = Single . just ( 1 ) . ofType ( String . class ) . test ( ) ; to . assertResult ( ) ; 
TestObserver < Number > to = Single . < Integer > error ( new TestException ( ) ) . ofType ( Number . class ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < String > to = Single . < Integer > error ( new TestException ( ) ) . ofType ( String . class ) . test ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposedSingleToMaybe ( new Function < Single < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Single < Object > m ) throws Exception return m . ofType ( Object . class ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . singleElement ( ) . ofType ( Object . class ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToMaybe ( new Function < Single < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Single < Object > f ) throws Exception return f . ofType ( Object . class ) ; ) ; 
Single . just ( 1 ) . onErrorReturnItem ( 2 ) . test ( ) . assertResult ( 1 ) ; 
TestObserverEx < Integer > to = Single . < Integer > error ( new TestException ( "Outer" ) ) . onErrorReturn ( new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
Single . error ( new TestException ( "Main" ) ) . onErrorResumeWith ( Single . error ( new TestException ( "Resume" ) ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Resume" ) ; 
TestHelper . checkDisposed ( Single . error ( new TestException ( "Main" ) ) . onErrorResumeWith ( Single . just ( 1 ) ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > s ) throws Exception return s . onErrorResumeWith ( Single . just ( 1 ) ) ; ) ; 
Single . just ( 1 ) . onErrorResumeWith ( Single . just ( 2 ) ) . test ( ) . assertResult ( 1 ) ; 
Single . just ( 1 ) . concatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( 2 ) ; return Single . just ( 1 ) ; ) . test ( ) . assertResult ( 2 ) ; 
Single . just ( 1 ) . concatMap ( new Function < Integer , SingleSource < String > > ( ) @ Override public SingleSource < String > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( "2" ) ; return Single . just ( "1" ) ; ) . test ( ) . assertResult ( "2" ) ; 
Single . just ( 1 ) . concatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( NullPointerException . class ) . assertErrorMessage ( "The single returned by the mapper is null" ) ; 
Single . just ( 1 ) . concatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception throw new RuntimeException ( "something went terribly wrong!" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "something went terribly wrong!" ) ; 
RuntimeException exception = new RuntimeException ( "test" ) ; Single . error ( exception ) . concatMap ( new Function < Object , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( final Object integer ) throws Exception return Single . just ( new Object ( ) ) ; ) . test ( ) . assertError ( exception ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . concatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( 2 ) ; ) ) ; 
Single . just ( 1 ) . concatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > s ) throws Exception return s . concatMap ( new Function < Object , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Object v ) throws Exception return Single . just ( v ) ; ) ; ) ; 
Single . just ( 1 ) . onErrorComplete ( ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . withErrorTracking ( errors -> Single . error ( new TestException ( ) ) . onErrorComplete ( ) . test ( ) . assertResult ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Single . error ( new TestException ( ) ) . onErrorComplete ( error -> error instanceof TestException ) . test ( ) . assertResult ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Single . error ( new IOException ( ) ) . onErrorComplete ( error -> error instanceof TestException ) . test ( ) . assertFailure ( IOException . class ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> TestObserverEx < Object > to = Single . error ( new IOException ( ) ) . onErrorComplete ( error -> throw new TestException ( ) ; ) . subscribeWith ( new TestObserverEx < > ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( to , 0 , IOException . class ) ; TestHelper . assertError ( to , 1 , TestException . class ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = ss . onErrorComplete ( ) . test ( ) ; assertTrue ( "No subscribers?!" , ss . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Still subscribers?!" , ss . hasObservers ( ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToMaybe ( f -> f . onErrorComplete ( ) ) ; 
TestHelper . checkDisposed ( SingleSubject . create ( ) . onErrorComplete ( ) ) ; 
Single . just ( 1 ) . contains ( 2 , new BiPredicate < Object , Object > ( ) @ Override public boolean test ( Object a , Object b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . error ( new TestException ( ) ) . contains ( 2 ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) SingleObserver < Integer > consumer = mock ( SingleObserver . class ) ; Single . just ( 1 ) . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onSuccess ( 1 ) ; order . verifyNoMoreInteractions ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) SingleObserver < Integer > consumer = mock ( SingleObserver . class ) ; Single . < Integer > error ( new TestException ( ) ) . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onError ( any ( TestException . class ) ) ; order . verifyNoMoreInteractions ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) SingleObserver < Integer > consumer = mock ( SingleObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onSubscribe ( any ( ) ) ; Disposable d = Disposable . empty ( ) ; new Single < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull SingleObserver < ? super Integer > observer ) observer . onSubscribe ( d ) ; observer . onSuccess ( 1 ) ; observer . onError ( new IOException ( ) ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verifyNoMoreInteractions ( ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , IOException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) SingleObserver < Integer > consumer = mock ( SingleObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onSuccess ( any ( ) ) ; new Single < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onSuccess ( 1 ) ; order . verifyNoMoreInteractions ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) SingleObserver < Integer > consumer = mock ( SingleObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onError ( any ( ) ) ; new Single < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new IOException ( ) ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onError ( any ( IOException . class ) ) ; order . verifyNoMoreInteractions ( ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; CompositeException compositeException = ( CompositeException ) errors . get ( 0 ) ; TestHelper . assertError ( compositeException . getExceptions ( ) , 0 , IOException . class ) ; TestHelper . assertError ( compositeException . getExceptions ( ) , 1 , TestException . class ) ; ) ; 
Single . concatArrayDelayError ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception return 5 ; ) . test ( ) . assertResult ( 5 ) ; 
Single . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
Single . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The callable returned a null value" ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Callable < Integer > callable = new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception return atomicInteger . incrementAndGet ( ) ; ; Single . fromCallable ( callable ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Single . fromCallable ( callable ) . test ( ) . assertResult ( 2 ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
Callable < Object > func = mock ( Callable . class ) ; when ( func . call ( ) ) . thenReturn ( new Object ( ) ) ; Single < Object > fromCallableSingle = Single . fromCallable ( func ) ; verifyNoInteractions ( func ) ; fromCallableSingle . subscribe ( ) ; verify ( func ) . call ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Integer > to = Single . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; return 1 ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Callable < String > func = mock ( Callable . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . call ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Single < String > fromCallableObservable = Single . fromCallable ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; TestObserver < String > outer = new TestObserver < > ( observer ) ; fromCallableObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . dispose ( ) ; funcLatch . countDown ( ) ; verify ( func ) . call ( ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verifyNoMoreInteractions ( observer ) ; 
final Exception checkedException = new Exception ( "test exception" ) ; Single < Object > fromCallableObservable = Single . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw checkedException ; ) ; SingleObserver < Object > observer = TestHelper . mockSingleObserver ( ) ; fromCallableObservable . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verify ( observer ) . onError ( checkedException ) ; verifyNoMoreInteractions ( observer ) ; 
final int [ ] count = 0 ; Single . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception count [ 0 ] ++ ; return 1 ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , count [ 0 ] ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Single . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception to . dispose ( ) ; return 1 ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
Single . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return 1 ; ) . toObservable ( ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Single . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception return 1 ; ) . toObservable ( ) . singleOrError ( ) . test ( ) . assertResult ( 1 ) ; 
Single . error ( new Supplier < Throwable > ( ) @ Override public Throwable get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + "" + b ; ) . test ( ) . assertResult ( "12" ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception return a + "" + b + c ; ) . test ( ) . assertResult ( "123" ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) , new Function4 < Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d ) throws Exception return a + "" + b + c + d ; ) . test ( ) . assertResult ( "1234" ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) , Single . just ( 5 ) , new Function5 < Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e ) throws Exception return a + "" + b + c + d + e ; ) . test ( ) . assertResult ( "12345" ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) , Single . just ( 5 ) , Single . just ( 6 ) , new Function6 < Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f ) throws Exception return a + "" + b + c + d + e + f ; ) . test ( ) . assertResult ( "123456" ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) , Single . just ( 5 ) , Single . just ( 6 ) , Single . just ( 7 ) , new Function7 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g ) throws Exception return a + "" + b + c + d + e + f + g ; ) . test ( ) . assertResult ( "1234567" ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) , Single . just ( 5 ) , Single . just ( 6 ) , Single . just ( 7 ) , Single . just ( 8 ) , new Function8 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g , Integer h ) throws Exception return a + "" + b + c + d + e + f + g + h ; ) . test ( ) . assertResult ( "12345678" ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) , Single . just ( 5 ) , Single . just ( 6 ) , Single . just ( 7 ) , Single . just ( 8 ) , Single . just ( 9 ) , new Function9 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g , Integer h , Integer i ) throws Exception return a + "" + b + c + d + e + f + g + h + i ; ) . test ( ) . assertResult ( "123456789" ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Single < Integer > source = Single . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; Single . zip ( source , source , new BiFunction < Integer , Integer , Object > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertResult ( 2 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Single < Integer > source = Single . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; Single . zip ( Arrays . asList ( source , source ) , new Function < Object [ ] , Object > ( ) @ Override public Integer apply ( Object [ ] o ) throws Exception return ( Integer ) o [ 0 ] + ( Integer ) o [ 1 ] ; ) . test ( ) . assertResult ( 2 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final boolean [ ] b = false ; Single . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Exception return Completable . complete ( ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception b [ 0 ] = true ; ) ; ) . test ( ) . assertResult ( ) ; assertTrue ( b [ 0 ] ) ; 
final boolean [ ] b = false ; Single . < Integer > error ( new TestException ( ) ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Exception return Completable . complete ( ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception b [ 0 ] = true ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( b [ 0 ] ) ; 
final boolean [ ] b = false ; Single . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( b [ 0 ] ) ; 
final boolean [ ] b = false ; Single . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertFalse ( b [ 0 ] ) ; 
Single . just ( 1 ) . flatMapObservable ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 5 ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Single . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . range ( v , 5 ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
final TestException ex = new TestException ( ) ; Single . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception throw ex ; ) . test ( ) . assertNoValues ( ) . assertError ( ex ) ; 
final TestException ex = new TestException ( ) ; Single . < Integer > error ( ex ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( 1 ) ; ) . test ( ) . assertNoValues ( ) . assertError ( ex ) ; 
final AtomicBoolean disposed = new AtomicBoolean ( ) ; TestSubscriberEx < Integer > ts = Single . < Integer > never ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception disposed . set ( true ) ; ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . range ( v , 5 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertNotTerminated ( ) ; assertFalse ( disposed . get ( ) ) ; ts . cancel ( ) ; assertTrue ( disposed . get ( ) ) ; ts . assertNotTerminated ( ) ; 
final AtomicBoolean disposed = new AtomicBoolean ( ) ; TestSubscriberEx < Integer > ts = Single . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . < Integer > never ( ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception disposed . set ( true ) ; ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertNotTerminated ( ) ; assertFalse ( disposed . get ( ) ) ; ts . cancel ( ) ; assertTrue ( disposed . get ( ) ) ; ts . assertNotTerminated ( ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( 2 ) ; return Single . just ( 1 ) ; ) . test ( ) . assertResult ( 2 ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < String > > ( ) @ Override public SingleSource < String > apply ( final Integer integer ) throws Exception if ( integer == 1 ) return Single . just ( "2" ) ; return Single . just ( "1" ) ; ) . test ( ) . assertResult ( "2" ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( NullPointerException . class ) . assertErrorMessage ( "The single returned by the mapper is null" ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception throw new RuntimeException ( "something went terribly wrong!" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "something went terribly wrong!" ) ; 
RuntimeException exception = new RuntimeException ( "test" ) ; Single . error ( exception ) . flatMap ( new Function < Object , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( final Object integer ) throws Exception return Single . just ( new Object ( ) ) ; ) . test ( ) . assertError ( exception ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( 2 ) ; ) ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > s ) throws Exception return s . flatMap ( new Function < Object , SingleSource < ? extends Object > > ( ) @ Override public SingleSource < ? extends Object > apply ( Object v ) throws Exception return Single . just ( v ) ; ) ; ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . singleOrError ( ) . toFlowable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeSingleToFlowable ( new Function < Single < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Single < Object > s ) throws Exception return s . toFlowable ( ) ; ) ; 
Single . just ( 1 ) . blockingSubscribe ( ) ; 
Single . just ( 1 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( ) ; 
TestHelper . withErrorTracking ( errors -> Single . error ( new TestException ( ) ) . blockingSubscribe ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Single . error ( new TestException ( ) ) . delay ( 100 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Single . just ( 1 ) . blockingSubscribe ( success ) ; verify ( success ) . accept ( 1 ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Single . just ( 1 ) . delay ( 50 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( success ) ; verify ( success ) . accept ( 1 ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; doThrow ( new TestException ( ) ) . when ( success ) . accept ( any ( ) ) ; Single . just ( 1 ) . blockingSubscribe ( success ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success ) . accept ( 1 ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Single . < Integer > error ( new TestException ( ) ) . blockingSubscribe ( success ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; Single . < Integer > error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( success ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Single . just ( 1 ) . blockingSubscribe ( success , consumer ) ; verify ( success ) . accept ( 1 ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Single . just ( 1 ) . delay ( 50 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( success , consumer ) ; verify ( success ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; doThrow ( new TestException ( ) ) . when ( success ) . accept ( any ( ) ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Single . just ( 1 ) . blockingSubscribe ( success , consumer ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success ) . accept ( any ( ) ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Single . < Integer > error ( new TestException ( ) ) . blockingSubscribe ( success , consumer ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Single . < Integer > error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( success , consumer ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . accept ( any ( ) ) ; Single . < Integer > error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( success , consumer ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Action onDispose = mock ( Action . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < Integer > success = mock ( Consumer . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Thread . currentThread ( ) . interrupt ( ) ; Single . < Integer > never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( success , consumer ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( onDispose ) . run ( ) ; verify ( success , never ( ) ) . accept ( any ( ) ) ; verify ( consumer ) . accept ( any ( InterruptedException . class ) ) ; ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Single . just ( 1 ) . blockingSubscribe ( to ) ; to . assertResult ( 1 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Single . just ( 1 ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( to ) ; to . assertResult ( 1 ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Single . error ( new TestException ( ) ) . blockingSubscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Single . error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
Action onDispose = mock ( Action . class ) ; TestObserver < Object > to = new TestObserver < > ( ) ; to . dispose ( ) ; Single . never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( to ) ; to . assertEmpty ( ) ; verify ( onDispose ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> Action onDispose = mock ( Action . class ) ; TestObserver < Object > to = new TestObserver < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; Single . never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( to ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( onDispose ) . run ( ) ; to . assertFailure ( InterruptedException . class ) ; ) ; 
Single . just ( 1 ) . concatWith ( Single . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . concat ( Single . just ( 1 ) , Single . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . concat ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Single . concat ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
for ( int i = 1 ; i < 100 ; i ++ ) Single < Integer > [ ] array = new Single [ i ] ; Arrays . fill ( array , Single . just ( 1 ) ) ; Single . concatArray ( array ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( i ) . assertNoErrors ( ) . assertComplete ( ) ; 
PublishProcessor < String > pp1 = PublishProcessor . create ( ) ; PublishProcessor < String > pp2 = PublishProcessor . create ( ) ; TestSubscriber < String > ts = Single . concatArrayEager ( pp1 . single ( "1" ) , pp2 . single ( "2" ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; ts . assertEmpty ( ) ; pp1 . onComplete ( ) ; ts . assertResult ( "1" , "2" ) ; ts . assertComplete ( ) ; 
PublishProcessor < String > pp1 = PublishProcessor . create ( ) ; PublishProcessor < String > pp2 = PublishProcessor . create ( ) ; TestSubscriber < String > ts = Single . concatEager ( Arrays . asList ( pp1 . single ( "2" ) , pp2 . single ( "1" ) ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; ts . assertEmpty ( ) ; pp1 . onComplete ( ) ; ts . assertResult ( "2" , "1" ) ; ts . assertComplete ( ) ; 
PublishProcessor < String > pp1 = PublishProcessor . create ( ) ; PublishProcessor < String > pp2 = PublishProcessor . create ( ) ; TestSubscriber < String > ts = Single . concatEager ( Flowable . just ( pp1 . single ( "1" ) , pp2 . single ( "2" ) ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; ts . assertEmpty ( ) ; pp1 . onComplete ( ) ; ts . assertResult ( "1" , "2" ) ; ts . assertComplete ( ) ; 
for ( int i = 1 ; i < 100 ; i ++ ) Single < Integer > [ ] array = new Single [ i ] ; Arrays . fill ( array , Single . just ( 1 ) ) ; Single . concat ( Observable . fromArray ( array ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( i ) . assertNoErrors ( ) . assertComplete ( ) ; 
final int [ ] calls = 0 ; Single < Integer > source = Single . create ( new SingleOnSubscribe < Integer > ( ) @ Override public void subscribe ( SingleEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onSuccess ( 1 ) ; ) ; Single . concatArray ( source , source ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Single < Integer > source = Single . create ( new SingleOnSubscribe < Integer > ( ) @ Override public void subscribe ( SingleEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onSuccess ( 1 ) ; ) ; Single . concat ( Arrays . asList ( source , source ) ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp ) . test ( ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . single ( - 99 ) ) . test ( ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . ignoreElements ( ) ) . test ( ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp ) . test ( ) ; source . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . single ( - 99 ) ) . test ( ) ; source . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . ignoreElements ( ) ) . test ( ) ; source . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp ) . test ( ) ; pp . onNext ( 1 ) ; to . assertFailure ( CancellationException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . single ( - 99 ) ) . test ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; to . assertFailure ( CancellationException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . ignoreElements ( ) ) . test ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; to . assertFailure ( CancellationException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp ) . test ( ) ; pp . onComplete ( ) ; to . assertFailure ( CancellationException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . ignoreElements ( ) ) . test ( ) ; pp . onComplete ( ) ; to . assertFailure ( CancellationException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp ) . test ( ) ; pp . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . single ( - 99 ) ) . test ( ) ; pp . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestObserver < Integer > to = source . single ( - 99 ) . takeUntil ( pp . ignoreElements ( ) ) . test ( ) ; pp . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Single . never ( ) . takeUntil ( Flowable . never ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Integer > to = pp1 . singleOrError ( ) . takeUntil ( pp2 ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . just ( 1 ) . takeUntil ( Flowable . just ( 1 ) . take ( 1 ) ) . test ( ) . assertFailure ( CancellationException . class ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Single . never ( ) . takeUntil ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; ) . test ( ) . assertFailure ( CancellationException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; SingleSubject < Integer > other = SingleSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onSuccess ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( 1 ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; SingleSubject < Integer > other = SingleSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; SingleSubject < Integer > other = SingleSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onSuccess ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( CancellationException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; SingleSubject < Integer > other = SingleSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; SingleSubject < Integer > other = SingleSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertEmpty ( ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; main . onSuccess ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertResult ( 1 ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; other . onNext ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertFailure ( CancellationException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; other . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertFailure ( CancellationException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; other . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasSubscribers ( ) ) ; to . assertEmpty ( ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onSuccess ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( 1 ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( CancellationException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > main = SingleSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertEmpty ( ) ; 
Single . merge ( Single . just ( Single . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Single . merge ( Single . just ( 1 ) , Single . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . merge ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Single . merge ( Single . just ( 1 ) , Single . just ( 2 ) , Single . just ( 3 ) , Single . just ( 4 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single < Integer > source1 = Single . error ( new TestException ( "First" ) ) ; Single < Integer > source2 = Single . error ( new TestException ( "Second" ) ) ; Single . merge ( source1 , source2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Single . mergeDelayError ( Arrays . asList ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . mergeDelayError ( Flowable . just ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . mergeDelayError ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Single . mergeDelayError ( Single . < Integer > error ( new TestException ( ) ) , Single . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Single . mergeDelayError ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Single . mergeDelayError ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , Single . just ( 2 ) , Single . just ( 3 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) ) ; 
Single . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( final Integer integer ) throws Exception if ( integer == 1 ) return 2 ; return 1 ; ) . test ( ) . assertResult ( 2 ) ; 
Single . just ( 1 ) . map ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception return null ; ) . to ( TestHelper . < SingleSource < Integer > > testConsumer ( ) ) . assertNoValues ( ) . assertError ( NullPointerException . class ) . assertErrorMessage ( "The mapper function returned a null value." ) ; 
Single . just ( 1 ) . map ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final Integer integer ) throws Exception throw new RuntimeException ( "something went terribly wrong!" ) ; ) . to ( TestHelper . < SingleSource < Integer > > testConsumer ( ) ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "something went terribly wrong!" ) ; 
RuntimeException exception = new RuntimeException ( "test" ) ; Single . error ( exception ) . map ( new Function < Object , Object > ( ) @ Override public Object apply ( final Object integer ) throws Exception return new Object ( ) ; ) . test ( ) . assertError ( exception ) ; 
TestHelper . checkUtilityClass ( SingleInternalHelper . class ) ; 
assertEquals ( 1 , SingleInternalHelper . NoSuchElementSupplier . values ( ) . length ) ; assertNotNull ( SingleInternalHelper . NoSuchElementSupplier . valueOf ( "INSTANCE" ) ) ; 
assertEquals ( 1 , SingleInternalHelper . ToFlowable . values ( ) . length ) ; assertNotNull ( SingleInternalHelper . ToFlowable . valueOf ( "INSTANCE" ) ) ; 
Iterable < ? extends Flowable < Integer > > it = SingleInternalHelper . iterableToFlowable ( Collections . singletonList ( Single . just ( 1 ) ) ) ; Iterator < ? extends Flowable < Integer > > iter = it . iterator ( ) ; if ( iter . hasNext ( ) ) iter . next ( ) . test ( ) . assertResult ( 1 ) ; if ( iter . hasNext ( ) ) fail ( "Iterator reports an additional element" ) ; else fail ( "Iterator was empty" ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Collections . < Integer > emptyList ( ) ; ) . test ( ) . assertResult ( ) ; 
Single . < Integer > error ( new TestException ( ) ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . test ( 0 ) ; ts . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 ) ; ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 ) ; ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 1 , 100 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 1 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 100 , 1 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new CrashingIterable ( 100 , 2 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . take ( 500 * 1000 ) . observeOn ( Schedulers . single ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception Integer [ ] array = new Integer [ 1000 * 1000 ] ; Arrays . fill ( array , 1 ) ; return Arrays . asList ( array ) ; ) . observeOn ( Schedulers . single ( ) ) . take ( 500 * 1000 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Arrays . asList ( 1 , 2 , 3 ) ; ) . subscribe ( new FlowableSubscriber < Integer > ( ) QueueSubscription < Integer > qs ; @ SuppressWarnings ( "unchecked" ) @ Override public void onSubscribe ( Subscription s ) qs = ( QueueSubscription < Integer > ) s ; assertEquals ( QueueFuseable . ASYNC , qs . requestFusion ( QueueFuseable . ANY ) ) ; @ Override public void onNext ( Integer value ) assertFalse ( qs . isEmpty ( ) ) ; qs . clear ( ) ; assertTrue ( qs . isEmpty ( ) ) ; qs . cancel ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return new CrashingIterable ( 100 , 2 , 100 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return new CrashingIterable ( 100 , 100 , 1 ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return new CrashingIterable ( 100 , 2 , 100 ) ; ) . to ( TestHelper . < Integer > testSubscriber ( 2L ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
Single . just ( 1 ) . flattenAsFlowable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return new CrashingIterable ( 100 , 100 , 1 ) ; ) . to ( TestHelper . < Integer > testSubscriber ( 2L ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . singleElement ( ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( 1 , 2 , 3 ) ; ) . test ( 5L ) . assertEmpty ( ) ; 
final Integer [ ] a = new Integer [ 1000 ] ; Arrays . fill ( a , 1 ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . onNext ( 1 ) ; final TestSubscriber < Integer > ts = ps . singleElement ( ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( a ) ; ) . test ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; for ( int i = 0 ; i < 500 ; i ++ ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 500 ; i ++ ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . onNext ( 1 ) ; final TestSubscriber < Integer > ts = ps . singleElement ( ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( 1 , 2 , 3 ) ; ) . test ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final Integer [ ] a = new Integer [ 1000 ] ; Arrays . fill ( a , 1 ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ == 2 ) ts . cancel ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; ) . subscribe ( ts ) ; ts . request ( 3 ) ; ts . assertValues ( 1 , 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final Integer [ ] a = new Integer [ 1000 ] ; Arrays . fill ( a , 1 ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ == 2 ) ts . cancel ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; ) . subscribe ( ts ) ; ts . request ( Long . MAX_VALUE ) ; ts . assertValues ( 1 , 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final Integer [ ] a = new Integer [ 1000 ] ; Arrays . fill ( a , 1 ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestSubscriber < Integer > ts = ps . singleOrError ( ) . flattenAsFlowable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( a ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 1000 ; i ++ ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestHelper . checkDoubleOnSubscribeSingleToFlowable ( s -> s . flattenAsFlowable ( v -> Collections . emptyList ( ) ) ) ; 
TestHelper . assertBadRequestReported ( SingleSubject . create ( ) . flattenAsFlowable ( v -> Collections . emptyList ( ) ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( @ NonNull Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Single . just ( 1 ) . flattenAsFlowable ( v -> Arrays . asList ( 1 , 2 ) ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
List < Object > list = Arrays . asList ( 1 ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestSubscriber < Object > ts = ss . flattenAsFlowable ( v -> list ) . test ( 0L ) ; TestHelper . race ( ( ) -> ss . onSuccess ( 1 ) , ( ) -> ts . request ( 1 ) ) ; ts . assertResult ( 1 ) ; 
Single . sequenceEqual ( Single . just ( 1 ) , Single . just ( 1 ) ) . test ( ) . assertResult ( true ) ; 
Single . sequenceEqual ( Single . just ( 1 ) , Single . just ( 2 ) ) . test ( ) . assertResult ( false ) ; 
Single . sequenceEqual ( Single . just ( 1 ) , Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . sequenceEqual ( Single . error ( new TestException ( ) ) , Single . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Single . sequenceEqual ( Single . error ( new TestException ( "One" ) ) , Single . error ( new TestException ( "Two" ) ) ) . to ( TestHelper . < Boolean > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "One" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Two" ) ; finally RxJavaPlugins . reset ( ) ; 
Single . zip ( Single . error ( new TestException ( ) ) , Single . just ( 1 ) , addString ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . zip ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) , addString ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Object > to = Single . zip ( pp . single ( 0 ) , pp . single ( 0 ) , addString ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . zip ( Single . just ( 1 ) , Single . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; TestObserver < Object > to = Single . zip ( pp0 . single ( 0 ) , pp1 . single ( 0 ) , pp0 . single ( 0 ) , addString3 ) . test ( ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp0 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final TestObserver < Object > to = Single . zip ( pp0 . single ( 0 ) , pp1 . single ( 0 ) , addString ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp0 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Single . zipArray ( new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; , Single . just ( 1 ) , null ) . blockingGet ( ) ; 
Single . zipArray ( new Function < Object [ ] , Object [ ] > ( ) @ Override public Object [ ] apply ( Object [ ] a ) throws Exception return a ; , new SingleSource [ 0 ] ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
Single . zipArray ( new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return ( Integer ) a [ 0 ] + 1 ; , Single . just ( 1 ) ) . test ( ) . assertResult ( 2 ) ; 
Single . zipArray ( Functions . justFunction ( null ) , Single . just ( 1 ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The zipper returned a null value" ) ; 
Single . zipArray ( Functions . justFunction ( null ) , Single . just ( 1 ) , Single . just ( 2 ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The zipper returned a null value" ) ; 
TestHelper . checkDisposed ( Single . zipArray ( Functions . justFunction ( 1 ) , SingleSubject . create ( ) , SingleSubject . create ( ) ) ) ; 
Single . zipArray ( a -> Arrays . asList ( a ) , Single . just ( 1 ) , Single . just ( 2 ) ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 ) ) ; 
AtomicReference < SingleObserver < ? super Integer > > emitter = new AtomicReference < > ( ) ; TestObserver < List < Object > > to = Single . zipArray ( Arrays :: asList , ( SingleSource < Integer > ) o -> emitter . set ( o ) , Single . < Integer > never ( ) ) . test ( ) ; emitter . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; to . dispose ( ) ; emitter . get ( ) . onSuccess ( 1 ) ; to . assertEmpty ( ) ; 
Single . zip ( Arrays . asList ( Single . error ( new TestException ( ) ) , Single . just ( 1 ) ) , addString ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . zip ( Arrays . asList ( Single . just ( 1 ) , Single . < Integer > error ( new TestException ( ) ) ) , addString ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Object > to = Single . zip ( Arrays . asList ( pp . single ( 0 ) , pp . single ( 0 ) ) , addString ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Single . zip ( Arrays . asList ( Single . just ( 1 ) , Single . just ( 2 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . zip ( Arrays . asList ( Single . just ( 1 ) , Single . just ( 2 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; TestObserver < Object > to = Single . zip ( Arrays . asList ( pp0 . single ( 0 ) , pp1 . single ( 0 ) , pp0 . single ( 0 ) ) , addString ) . test ( ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( pp0 . hasSubscribers ( ) ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final TestObserver < Object > to = Single . zip ( Arrays . asList ( pp0 . single ( 0 ) , pp1 . single ( 0 ) ) , addString ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp0 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Single . zip ( new CrashingMappedIterable < > ( 1 , 100 , 100 , new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) , addString ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Single . zip ( new CrashingMappedIterable < > ( 100 , 20 , 100 , new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) , addString ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
Single . zip ( new CrashingMappedIterable < > ( 100 , 100 , 5 , new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) , addString ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "next()" ) ; 
Single . zip ( Arrays . asList ( null , Single . just ( 1 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingGet ( ) ; 
Single . zip ( Arrays . asList ( Single . just ( 1 ) , null ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] v ) return 1 ; ) . blockingGet ( ) ; 
Single . zip ( Collections . < SingleSource < Integer > > emptyList ( ) , new Function < Object [ ] , Object [ ] > ( ) @ Override public Object [ ] apply ( Object [ ] a ) throws Exception return a ; ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
Single . zip ( Collections . singleton ( Single . just ( 1 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return ( Integer ) a [ 0 ] + 1 ; ) . test ( ) . assertResult ( 2 ) ; 
Single . zip ( Arrays . asList ( Single . just ( 1 ) ) , Functions . justFunction ( null ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The zipper returned a null value" ) ; 
SingleSource < Integer > source = new SingleSource < Integer > ( ) @ Override public void subscribe ( SingleObserver < ? super Integer > observer ) Single . just ( 1 ) . subscribe ( observer ) ; ; Single . zip ( Arrays . asList ( source , source ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] t ) throws Throwable return 2 ; ) . test ( ) . assertResult ( 2 ) ; 
final AtomicBoolean atomicBoolean = new AtomicBoolean ( ) ; Single . just ( 1 ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) throws Exception atomicBoolean . set ( true ) ; ) . test ( ) . assertResult ( 1 ) ; assertTrue ( atomicBoolean . get ( ) ) ; 
final AtomicBoolean atomicBoolean = new AtomicBoolean ( ) ; Single . error ( new TestException ( ) ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) atomicBoolean . set ( true ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( atomicBoolean . get ( ) ) ; 
Single . just ( 1 ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Object > to = Single . error ( new TestException ( "Outer" ) ) . doOnTerminate ( new Action ( ) @ Override public void run ( ) throw new TestException ( "Inner" ) ; ) . to ( TestHelper . testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
return new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer a , Integer b ) throws Exception return a + ":" + b ; ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( 2 ) ; , stringCombine ( ) ) . test ( ) . assertResult ( "1:2" ) ; 
final int [ ] call = 0 ; Single . < Integer > error ( new TestException ( ) ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception call [ 0 ] ++ ; return Single . just ( 1 ) ; , stringCombine ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
final int [ ] call = 0 ; Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception call [ 0 ] ++ ; return Single . < Integer > error ( new TestException ( ) ) ; , stringCombine ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , call [ 0 ] ) ; 
TestHelper . checkDisposed ( SingleSubject . create ( ) . flatMap ( new Function < Object , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Object v ) throws Exception return Single . just ( 1 ) ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) throws Exception return b ; ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Single < Object > v ) throws Exception return v . flatMap ( new Function < Object , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Object v ) throws Exception return Single . just ( 1 ) ; , new BiFunction < Object , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b ) throws Exception return b ; ) ; ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; , stringCombine ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return null ; , stringCombine ( ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( 2 ) ; , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( 2 ) ; , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Single . just ( 1 ) . flatMap ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception to . dispose ( ) ; return Single . just ( 2 ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception throw new IllegalStateException ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; 
Single . fromFuture ( Flowable . just ( 1 ) . toFuture ( ) ) . subscribeOn ( Schedulers . io ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Single . fromFuture ( Flowable . never ( ) . toFuture ( ) , 1 , TimeUnit . SECONDS ) . subscribeOn ( Schedulers . io ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
Single . fromPublisher ( Flowable . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Single . just ( 1 ) . flatMap ( Functions . justFunction ( Single . just ( 1 ) ) , Functions . justFunction ( Single . just ( 1 ) ) ) ) ; 
TestHelper . checkDoubleOnSubscribeSingle ( new Function < Single < Integer > , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Single < Integer > m ) throws Exception return m . flatMap ( Functions . justFunction ( Single . just ( 1 ) ) , Functions . justFunction ( Single . just ( 1 ) ) ) ; ) ; 
Single . just ( 1 ) . flatMap ( Functions . justFunction ( ( Single < Integer > ) null ) , Functions . justFunction ( Single . just ( 1 ) ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestObserverEx < Integer > to = Single . < Integer > error ( new TestException ( ) ) . flatMap ( Functions . justFunction ( Single . just ( 1 ) ) , Functions . justFunction ( ( Single < Integer > ) null ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class ) ; TestHelper . assertError ( ce , 1 , NullPointerException . class ) ; 
Single . just ( 1 ) . flatMap ( Functions . justFunction ( Single . < Integer > error ( new TestException ( ) ) ) , Functions . justFunction ( ( Single < Integer > ) null ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Single . just ( 1 ) . flatMap ( v -> Single . just ( 2 ) , e -> Single . just ( 3 ) ) . test ( ) . assertResult ( 2 ) ; 
TestHelper . withErrorTracking ( errors -> Single . error ( new TestException ( ) ) . flatMap ( v -> Single . just ( 2 ) , e -> Single . just ( 3 ) ) . test ( ) . assertResult ( 3 ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Single . error ( new TestException ( ) ) . flatMap ( v -> Single . just ( 2 ) , e -> Single . < Integer > error ( new IOException ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Callable < Object > callable = new Callable < Object > ( ) @ Override public Object call ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ; Completable . fromCallable ( callable ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Completable . fromCallable ( callable ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Completable completable = Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; completable . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
Callable < String > func = mock ( Callable . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . call ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Completable fromCallableObservable = Completable . fromCallable ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; TestObserver < String > outer = new TestObserver < > ( observer ) ; fromCallableObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . dispose ( ) ; funcLatch . countDown ( ) ; verify ( func ) . call ( ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verifyNoMoreInteractions ( observer ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception calls . incrementAndGet ( ) ; throw new TestException ( ) ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 1 , calls . get ( ) ) ; 
calls ++ ; 
Completable . complete ( ) . doFinally ( this ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls ) ; 
Completable . error ( new TestException ( ) ) . doFinally ( this ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( new Function < Completable , Completable > ( ) @ Override public Completable apply ( Completable f ) throws Exception return f . doFinally ( CompletableDoFinallyTest . this ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable . complete ( ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( ) . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . ignoreElements ( ) . doFinally ( this ) ) ; 
Completable . complete ( ) . andThen ( Maybe . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Completable . complete ( ) . andThen ( Maybe . error ( new RuntimeException ( "test" ) ) ) . to ( TestHelper . testConsumer ( ) ) . assertNotComplete ( ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "test" ) ; 
Completable . complete ( ) . andThen ( Maybe . empty ( ) ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertComplete ( ) ; 
Completable . error ( new RuntimeException ( "bla" ) ) . andThen ( Maybe . empty ( ) ) . to ( TestHelper . testConsumer ( ) ) . assertNotComplete ( ) . assertNoValues ( ) . assertError ( RuntimeException . class ) . assertErrorMessage ( "bla" ) ; 
Completable . fromPublisher ( Flowable . just ( 1 ) ) . test ( ) . assertResult ( ) ; 
Completable . fromPublisher ( Flowable . empty ( ) ) . test ( ) . assertResult ( ) ; 
Completable . fromPublisher ( Flowable . error ( new UnsupportedOperationException ( ) ) ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
TestHelper . checkDisposed ( Completable . fromPublisher ( Flowable . just ( 1 ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToCompletable ( new Function < Flowable < Object > , Completable > ( ) @ Override public Completable apply ( Flowable < Object > f ) throws Exception return Completable . fromPublisher ( f ) ; ) ; 
Completable . never ( ) . hide ( ) . test ( ) . assertNotComplete ( ) . assertNoErrors ( ) ; 
Completable . complete ( ) . hide ( ) . test ( ) . assertResult ( ) ; 
Completable . error ( new TestException ( ) ) . hide ( ) . test ( ) . assertFailure ( TestException . class ) ; 
assertFalse ( CompletableSubject . create ( ) . hide ( ) instanceof CompletableSubject ) ; 
TestHelper . checkDisposedCompletable ( new Function < Completable , CompletableSource > ( ) @ Override public CompletableSource apply ( Completable m ) throws Exception return m . hide ( ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestHelper . checkDisposed ( pp . ignoreElements ( ) . hide ( ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( new Function < Completable , Completable > ( ) @ Override public Completable apply ( Completable f ) throws Exception return f . hide ( ) ; ) ; 
TestHelper . checkDoubleOnSubscribeCompletableToObservable ( new Function < Completable , Observable < ? > > ( ) @ Override public Observable < ? > apply ( Completable c ) throws Exception return c . toObservable ( ) ; ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( new Function < Completable , CompletableSource > ( ) @ Override public CompletableSource apply ( Completable m ) throws Exception return m . onTerminateDetach ( ) ; ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . ignoreElements ( ) . onTerminateDetach ( ) ) ; 
Completable . error ( new TestException ( ) ) . onTerminateDetach ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . complete ( ) . onTerminateDetach ( ) . test ( ) . assertResult ( ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Void > to = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( wr . get ( ) ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; to . dispose ( ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertEmpty ( ) ; assertNull ( wr . get ( ) ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Void > to = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( wr . get ( ) ) ; observer . onComplete ( ) ; observer . onComplete ( ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertResult ( ) ; assertNull ( wr . get ( ) ) ; 
Disposable d = Disposable . empty ( ) ; final WeakReference < Disposable > wr = new WeakReference < > ( d ) ; TestObserver < Void > to = new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( wr . get ( ) ) ; observer . onError ( new TestException ( ) ) ; observer . onError ( new IOException ( ) ) ; ; . onTerminateDetach ( ) . test ( ) ; d = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; to . assertFailure ( TestException . class ) ; assertNull ( wr . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ; Completable . fromRunnable ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Completable . fromRunnable ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Completable completable = Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; completable . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) calls . incrementAndGet ( ) ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) calls . incrementAndGet ( ) ; throw new TestException ( ) ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , calls . get ( ) ) ; 
Runnable run = mock ( Runnable . class ) ; Completable . fromRunnable ( run ) . test ( true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; Completable . fromRunnable ( ( ) -> to . dispose ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; 
TestHelper . withErrorTracking ( errors -> TestObserver < Void > to = new TestObserver < > ( ) ; Completable . fromRunnable ( ( ) -> to . dispose ( ) ; throw new TestException ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Action run = new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ; Completable . fromAction ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Completable . fromAction ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Completable completable = Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; completable . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception calls . incrementAndGet ( ) ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , calls . get ( ) ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception calls . incrementAndGet ( ) ; throw new TestException ( ) ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , calls . get ( ) ) ; 
Action run = mock ( Action . class ) ; Completable . fromAction ( run ) . test ( true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; Completable . fromAction ( ( ) -> to . dispose ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; 
TestHelper . withErrorTracking ( errors -> TestObserver < Void > to = new TestObserver < > ( ) ; Completable . fromAction ( ( ) -> to . dispose ( ) ; throw new TestException ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Thread . currentThread ( ) . interrupt ( ) ; try PublishProcessor . create ( ) . ignoreElements ( ) . blockingAwait ( ) ; fail ( "Should have thrown RuntimeException" ) ; catch ( RuntimeException ex ) if ( ! ( ex . getCause ( ) instanceof InterruptedException ) ) fail ( "Wrong cause: " + ex . getCause ( ) ) ; 
Thread . currentThread ( ) . interrupt ( ) ; try PublishProcessor . create ( ) . ignoreElements ( ) . blockingAwait ( 1 , TimeUnit . SECONDS ) ; fail ( "Should have thrown RuntimeException" ) ; catch ( RuntimeException ex ) if ( ! ( ex . getCause ( ) instanceof InterruptedException ) ) fail ( "Wrong cause: " + ex . getCause ( ) ) ; 
assertFalse ( PublishProcessor . create ( ) . ignoreElements ( ) . blockingAwait ( 100 , TimeUnit . MILLISECONDS ) ) ; 
Completable . complete ( ) . startWith ( Single . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Completable . fromRunnable ( run ) . startWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Completable . complete ( ) . startWith ( Maybe . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Completable . complete ( ) . startWith ( Maybe . empty ( ) ) . test ( ) . assertResult ( ) ; 
Runnable run = mock ( Runnable . class ) ; Completable . fromRunnable ( run ) . startWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Completable . error ( new TestException ( ) ) . onErrorResumeNext ( Functions . justFunction ( Completable . error ( new TestException ( "second" ) ) ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "second" ) ; 
TestHelper . checkDisposedCompletable ( new Function < Completable , CompletableSource > ( ) @ Override public CompletableSource apply ( Completable c ) throws Exception return c . onErrorResumeNext ( Functions . justFunction ( Completable . complete ( ) ) ) ; ) ; 
TestHelper . checkDisposedCompletable ( new Function < Completable , CompletableSource > ( ) @ Override public CompletableSource apply ( Completable c ) throws Exception return Completable . error ( new TestException ( ) ) . onErrorResumeNext ( Functions . justFunction ( c ) ) ; ) ; 
TestHelper . checkDisposed ( Completable . error ( new TestException ( ) ) . onErrorResumeNext ( Functions . justFunction ( Completable . never ( ) ) ) ) ; 
Action action = mock ( Action . class ) ; Completable . complete ( ) . onErrorResumeWith ( Completable . fromAction ( action ) ) . test ( ) . assertResult ( ) ; verify ( action , never ( ) ) . run ( ) ; 
Action action = mock ( Action . class ) ; Completable . error ( new TestException ( ) ) . onErrorResumeWith ( Completable . fromAction ( action ) ) . test ( ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
Action action1 = mock ( Action . class ) ; Action action2 = mock ( Action . class ) ; Completable . concatArrayDelayError ( Completable . fromAction ( action1 ) , Completable . error ( new TestException ( ) ) , Completable . fromAction ( action2 ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( action1 ) . run ( ) ; verify ( action2 ) . run ( ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Void > to = Completable . complete ( ) . subscribeOn ( scheduler ) . test ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertResult ( ) ; assertTrue ( list . toString ( ) , list . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . ignoreElements ( ) . subscribeOn ( new TestScheduler ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( new Function < Completable , CompletableSource > ( ) @ Override public CompletableSource apply ( Completable c ) throws Exception return c . subscribeOn ( Schedulers . single ( ) ) ; ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Void > to = Completable . merge ( Arrays . asList ( ps1 . ignoreElements ( ) , ps2 . ignoreElements ( ) ) ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . merge ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) return new Iterator < Completable > ( ) @ Override public boolean hasNext ( ) to . dispose ( ) ; return true ; @ Override public Completable next ( ) return Completable . complete ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . merge ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) return new Iterator < Completable > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Completable next ( ) to . dispose ( ) ; return Completable . complete ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
TestHelper . checkDisposed ( new MergeCompletableObserver ( new TestObserver < Void > ( ) , new CompositeDisposable ( ) , new AtomicInteger ( ) ) ) ; 
final int [ ] counter = 0 ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter [ 0 ] ++ ; ) . repeatWhen ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception final int [ ] j = 3 ; return f . takeWhile ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) throws Exception return j [ 0 ] -- != 0 ; ) ; ) . subscribe ( ) ; assertEquals ( 4 , counter [ 0 ] ) ; 
Completable . complete ( ) . delay ( 100 , TimeUnit . MILLISECONDS , Schedulers . trampoline ( ) ) . test ( ) . assertResult ( ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Thread > thread = new AtomicReference < > ( ) ; Completable . error ( new Exception ( ) ) . delay ( 0 , TimeUnit . MILLISECONDS , Schedulers . newThread ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throws Exception thread . set ( Thread . currentThread ( ) ) ; latch . countDown ( ) ; ) . onErrorComplete ( ) . subscribe ( ) ; latch . await ( ) ; assertNotEquals ( Thread . currentThread ( ) , thread . get ( ) ) ; 
TestHelper . checkDisposed ( Completable . never ( ) . delay ( 1 , TimeUnit . MINUTES ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( new Function < Completable , CompletableSource > ( ) @ Override public CompletableSource apply ( Completable c ) throws Exception return c . delay ( 1 , TimeUnit . MINUTES ) ; ) ; 
Completable . complete ( ) . delay ( 1 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Void > to = Completable . error ( new TestException ( ) ) . delay ( 100 , TimeUnit . MILLISECONDS , scheduler , false ) . test ( ) ; to . assertEmpty ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; to . assertFailure ( TestException . class ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertFailure ( TestException . class ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Void > to = Completable . error ( new TestException ( ) ) . delay ( 100 , TimeUnit . MILLISECONDS , scheduler , true ) . test ( ) ; to . assertEmpty ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; to . assertEmpty ( ) ; scheduler . advanceTimeBy ( 99 , TimeUnit . MILLISECONDS ) ; to . assertFailure ( TestException . class ) ; 
Completable . unsafeCreate ( Completable . complete ( ) ) ; 
assertSame ( Completable . complete ( ) , Completable . wrap ( Completable . complete ( ) ) ) ; 
Completable . wrap ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; ) . test ( ) . assertResult ( ) ; 
Completable . unsafeCreate ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) throw new NullPointerException ( ) ; ) . test ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable . unsafeCreate ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) throw new IllegalArgumentException ( ) ; ) . test ( ) ; fail ( "Should have thrown!" ) ; catch ( NullPointerException ex ) if ( ! ( ex . getCause ( ) instanceof IllegalArgumentException ) ) fail ( ex . toString ( ) + ": should have thrown NPA(IAE)" ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Completable . complete ( ) . observeOn ( Schedulers . single ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( new Function < Completable , CompletableSource > ( ) @ Override public CompletableSource apply ( Completable c ) throws Exception return c . observeOn ( Schedulers . single ( ) ) ; ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . ignoreElements ( ) . unsubscribeOn ( scheduler ) . test ( ) . dispose ( ) ; assertTrue ( ps . hasObservers ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertFalse ( ps . hasObservers ( ) ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . ignoreElements ( ) . unsubscribeOn ( new TestScheduler ( ) ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Void > to = ps . ignoreElements ( ) . unsubscribeOn ( scheduler ) . test ( ) ; to . dispose ( ) ; ps . onComplete ( ) ; to . assertEmpty ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Void > to = ps . ignoreElements ( ) . unsubscribeOn ( scheduler ) . test ( ) ; to . dispose ( ) ; ps . onError ( new TestException ( ) ) ; to . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final int [ ] call = 0 ; Completable . complete ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . unsubscribeOn ( scheduler ) . test ( ) . assertResult ( ) ; scheduler . triggerActions ( ) ; assertEquals ( 0 , call [ 0 ] ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final int [ ] call = 0 ; Completable . error ( new TestException ( ) ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . unsubscribeOn ( scheduler ) . test ( ) . assertFailure ( TestException . class ) ; scheduler . triggerActions ( ) ; assertEquals ( 0 , call [ 0 ] ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( c -> c . unsubscribeOn ( Schedulers . computation ( ) ) ) ; 
Completable . never ( ) . timeout ( 100 , TimeUnit . MILLISECONDS , Schedulers . io ( ) ) . to ( TestHelper . < Void > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( 100 , TimeUnit . MILLISECONDS ) ) ; 
final int [ ] call = 0 ; Completable other = Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) ; Completable . never ( ) . timeout ( 100 , TimeUnit . MILLISECONDS , Schedulers . io ( ) , other ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; assertEquals ( 1 , call [ 0 ] ) ; 
final PublishSubject < String > subject = PublishSubject . create ( ) ; final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < Void > observer = subject . ignoreElements ( ) . timeout ( 100 , TimeUnit . MILLISECONDS , scheduler ) . test ( ) ; assertTrue ( subject . hasObservers ( ) ) ; observer . dispose ( ) ; assertFalse ( subject . hasObservers ( ) ) ; 
Completable . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , Completable . error ( new TestException ( ) ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Completable . complete ( ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
Completable . error ( new TestException ( ) ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final TestScheduler scheduler = new TestScheduler ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserverEx < Void > to = ps . ignoreElements ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , scheduler , Completable . complete ( ) ) . to ( TestHelper . < Void > testConsumer ( ) ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertTerminated ( ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; AtomicBoolean once = new AtomicBoolean ( ) ; TimeOutObserver a = new TimeOutObserver ( cd , once , to ) ; a . onComplete ( ) ; a . onComplete ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try a . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception e . setDisposable ( d ) ; e . onComplete ( ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; ) . test ( ) . assertResult ( ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d1 = Disposable . empty ( ) ; final Disposable d2 = Disposable . empty ( ) ; Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception e . setDisposable ( d1 ) ; e . setCancellable ( new Cancellable ( ) @ Override public void cancel ( ) throws Exception d2 . dispose ( ) ; ) ; e . onComplete ( ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; ) . test ( ) . assertResult ( ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception e . setDisposable ( d ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; e . onError ( new TestException ( "second" ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception e . onError ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestHelper . checkDisposed ( Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception e . onComplete ( ) ; ) ) ; 
Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onError ( new IOException ( ) ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) ) ; 
Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onComplete ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; 
Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception try e . onError ( new IOException ( ) ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) ) ; 
Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception try e . onComplete ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( e . isDisposed ( ) ) ; ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Boolean [ ] response = null ; Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter e ) throws Exception e . onComplete ( ) ; response [ 0 ] = e . tryOnError ( new TestException ( ) ) ; ) . test ( ) . assertResult ( ) ; assertFalse ( response [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Completable . create ( new CompletableOnSubscribe ( ) @ Override public void subscribe ( CompletableEmitter emitter ) throws Exception assertTrue ( emitter . toString ( ) . contains ( CompletableCreate . Emitter . class . getSimpleName ( ) ) ) ; ) . test ( ) . assertEmpty ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable . concat ( Flowable . fromPublisher ( new Publisher < Completable > ( ) @ Override public void subscribe ( Subscriber < ? super Completable > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( Completable . never ( ) ) ; s . onNext ( Completable . never ( ) ) ; s . onNext ( Completable . never ( ) ) ; s . onNext ( Completable . never ( ) ) ; s . onComplete ( ) ; ) , 1 ) . test ( ) . assertFailure ( MissingBackpressureException . class ) ; TestHelper . assertError ( errors , 0 , MissingBackpressureException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try Completable . concat ( Flowable . just ( Completable . complete ( ) ) , - 99 ) ; fail ( "Should have thrown IllegalArgumentExceptio" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "prefetch > 0 required but it was -99" , ex . getMessage ( ) ) ; 
TestHelper . checkDisposed ( Completable . concat ( Flowable . just ( Completable . complete ( ) ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . concat ( pp1 . map ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return pp2 . ignoreElements ( ) ; ) ) . test ( ) ; pp1 . onNext ( 1 ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Completable . concat ( Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception throw new TestException ( ) ; ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . concat ( Flowable . just ( Completable . complete ( ) ) . hide ( ) , Integer . MAX_VALUE ) . test ( ) . assertResult ( ) ; 
Completable . concat ( Flowable . just ( Completable . complete ( ) ) , Integer . MAX_VALUE ) . test ( ) . assertResult ( ) ; 
UnicastProcessor < Completable > up = UnicastProcessor . create ( ) ; up . onNext ( Completable . complete ( ) ) ; up . onComplete ( ) ; Completable . concat ( up , Integer . MAX_VALUE ) . test ( ) . assertResult ( ) ; 
Completable . concatArray ( Completable . complete ( ) , Completable . complete ( ) ) . test ( true ) . assertEmpty ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . concatArray ( new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; to . dispose ( ) ; observer . onComplete ( ) ; , Completable . complete ( ) ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
Completable . concat ( Arrays . asList ( Completable . complete ( ) , Completable . complete ( ) ) ) . test ( true ) . assertEmpty ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . concat ( Arrays . asList ( new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; to . dispose ( ) ; observer . onComplete ( ) ; , Completable . complete ( ) ) ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
Completable [ ] a = new Completable [ 1024 ] ; Arrays . fill ( a , Completable . complete ( ) ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Completable c = Completable . concatArray ( a ) ; final TestObserver < Void > to = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) c . subscribe ( to ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Completable [ ] a = new Completable [ 1024 ] ; Arrays . fill ( a , Completable . complete ( ) ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Completable c = Completable . concat ( Arrays . asList ( a ) ) ; final TestObserver < Void > to = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) c . subscribe ( to ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int k = 0 ; k < 100 ; k ++ ) final int count = 10 ; final CountDownLatch latch = new CountDownLatch ( count ) ; final boolean [ ] interrupted = false ; for ( int i = 0 ; i < count ; i ++ ) Completable c0 = Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception try Thread . sleep ( 30 ) ; catch ( InterruptedException e ) System . out . println ( "Interrupted! " + Thread . currentThread ( ) ) ; interrupted [ 0 ] = true ; ) ; Completable . concat ( Arrays . asList ( Completable . complete ( ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( Schedulers . io ( ) ) , c0 ) ) . subscribe ( new Action ( ) @ Override public void run ( ) throws Exception latch . countDown ( ) ; ) ; latch . await ( ) ; assertFalse ( "The second Completable was interrupted!" , interrupted [ 0 ] ) ; 
TestHelper . < Completable > checkDoubleOnSubscribeFlowableToCompletable ( f -> Completable . concat ( f ) ) ; 
assertNull ( Completable . complete ( ) . subscribeOn ( Schedulers . computation ( ) ) . toFuture ( ) . get ( ) ) ; 
try Completable . error ( new TestException ( ) ) . subscribeOn ( Schedulers . computation ( ) ) . toFuture ( ) . get ( ) ; fail ( "Should have thrown!" ) ; catch ( ExecutionException ex ) assertTrue ( "" + ex . getCause ( ) , ex . getCause ( ) instanceof TestException ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; Future < Void > f = cs . toFuture ( ) ; assertTrue ( cs . hasObservers ( ) ) ; f . cancel ( true ) ; assertFalse ( cs . hasObservers ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; Future < Void > f = cs . toFuture ( ) ; assertTrue ( cs . hasObservers ( ) ) ; f . cancel ( false ) ; assertFalse ( cs . hasObservers ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable . complete ( ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( CompletableSubject . create ( ) . doOnComplete ( Functions . EMPTY_ACTION ) ) ; 
TestException ex = new TestException ( ) ; Completable . error ( ex ) . materialize ( ) . test ( ) . assertResult ( Notification . createOnError ( ex ) ) ; 
Completable . complete ( ) . materialize ( ) . test ( ) . assertResult ( Notification . createOnComplete ( ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletableToSingle ( new Function < Completable , SingleSource < Notification < Object > > > ( ) @ Override public SingleSource < Notification < Object > > apply ( Completable v ) throws Exception return v . materialize ( ) ; ) ; 
TestHelper . checkDisposed ( CompletableSubject . create ( ) . materialize ( ) ) ; 
List < Completable > ms = new ArrayList < > ( ) ; for ( int i = 0 ; i < 32 ; i ++ ) ms . add ( Completable . never ( ) ) ; ms . add ( Completable . complete ( ) ) ; Completable . amb ( ms ) . test ( ) . assertResult ( ) ; 
Completable . amb ( Arrays . asList ( Completable . complete ( ) , Completable . complete ( ) ) ) . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . amb ( Arrays . asList ( pp1 . ignoreElements ( ) , pp2 . ignoreElements ( ) ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final TestObserver < Void > to = Completable . amb ( Arrays . asList ( pp0 . ignoreElements ( ) , pp1 . ignoreElements ( ) ) ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp0 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Subject < Integer > ps = ReplaySubject . create ( ) ; ps . onNext ( 1 ) ; final Completable source = Completable . ambArray ( ps . ignoreElements ( ) , Completable . never ( ) , Completable . never ( ) , null ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . test ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertError ( errors , 0 , NullPointerException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Completable error = Completable . error ( new RuntimeException ( ) ) ; Completable . complete ( ) . ambWith ( error ) . test ( ) . assertComplete ( ) ; 
Completable error = Completable . error ( new RuntimeException ( ) ) ; Completable . amb ( Arrays . asList ( Completable . complete ( ) , error ) ) . test ( ) . assertComplete ( ) ; 
Completable error = Completable . error ( new RuntimeException ( ) ) ; Completable . ambArray ( Completable . complete ( ) , error ) . test ( ) . assertComplete ( ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; CompositeDisposable cd = new CompositeDisposable ( ) ; AtomicBoolean once = new AtomicBoolean ( ) ; Amb a = new Amb ( once , cd , to ) ; a . onSubscribe ( Disposable . empty ( ) ) ; a . onComplete ( ) ; a . onComplete ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try a . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
CompletableSubject main = CompletableSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Void > to = main . ambWith ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( ) ; 
CompletableSubject main = CompletableSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Void > to = main . ambWith ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
CompletableSubject main = CompletableSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Void > to = main . ambWith ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( ) ; 
CompletableSubject main = CompletableSubject . create ( ) ; CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Void > to = main . ambWith ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable . ambArray ( Completable . error ( ex ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Completable . never ( ) ) . subscribe ( Functions . EMPTY_ACTION , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Completable . ambArray ( Completable . complete ( ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Completable . never ( ) ) . subscribe ( new Action ( ) @ Override public void run ( ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
CompletableSource source = new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) Completable . complete ( ) . subscribe ( observer ) ; ; Completable . amb ( Arrays . asList ( source , source ) ) . test ( ) . assertResult ( ) ; 
Completable . fromSingle ( Single . just ( 1 ) ) . test ( ) . assertResult ( ) ; 
Completable . fromSingle ( Single . error ( new UnsupportedOperationException ( ) ) ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
TestHelper . checkDoubleOnSubscribeCompletableToFlowable ( new Function < Completable , Publisher < ? > > ( ) @ Override public Publisher < ? > apply ( Completable c ) throws Exception return c . toFlowable ( ) ; ) ; 
Completable . fromMaybe ( Maybe . just ( 1 ) ) . test ( ) . assertResult ( ) ; 
Completable . fromMaybe ( Maybe . < Integer > empty ( ) ) . test ( ) . assertResult ( ) ; 
Completable . fromMaybe ( Maybe . error ( new UnsupportedOperationException ( ) ) ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
Completable . complete ( ) . andThen ( Completable . complete ( ) ) . test ( ) . assertComplete ( ) ; 
Completable . complete ( ) . andThen ( Completable . error ( new TestException ( "test" ) ) ) . to ( TestHelper . testConsumer ( ) ) . assertNotComplete ( ) . assertNoValues ( ) . assertError ( TestException . class ) . assertErrorMessage ( "test" ) ; 
Completable . complete ( ) . andThen ( Completable . never ( ) ) . test ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
Completable . error ( new TestException ( "bla" ) ) . andThen ( Completable . complete ( ) ) . to ( TestHelper . testConsumer ( ) ) . assertNotComplete ( ) . assertNoValues ( ) . assertError ( TestException . class ) . assertErrorMessage ( "bla" ) ; 
Completable . error ( new TestException ( "bla" ) ) . andThen ( Completable . never ( ) ) . to ( TestHelper . testConsumer ( ) ) . assertNotComplete ( ) . assertNoValues ( ) . assertError ( TestException . class ) . assertErrorMessage ( "bla" ) ; 
Completable . error ( new TestException ( "error1" ) ) . andThen ( Completable . error ( new TestException ( "error2" ) ) ) . to ( TestHelper . testConsumer ( ) ) . assertNotComplete ( ) . assertNoValues ( ) . assertError ( TestException . class ) . assertErrorMessage ( "error1" ) ; 
final AtomicInteger completableRunCount = new AtomicInteger ( ) ; Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) completableRunCount . incrementAndGet ( ) ; ) . andThen ( Completable . complete ( ) ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , completableRunCount . get ( ) ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ) . andThen ( Completable . complete ( ) ) . subscribe ( to ) ; to . assertNotComplete ( ) . assertNoErrors ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . complete ( ) . andThen ( Completable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ) ) . subscribe ( to ) ; to . assertNotComplete ( ) . assertNoErrors ( ) ; 
TestHelper . checkDisposed ( Completable . complete ( ) . andThen ( Completable . complete ( ) ) ) ; 
for ( int k = 0 ; k < 100 ; k ++ ) final int count = 10 ; final CountDownLatch latch = new CountDownLatch ( count ) ; final boolean [ ] interrupted = false ; for ( int i = 0 ; i < count ; i ++ ) Completable . complete ( ) . subscribeOn ( Schedulers . io ( ) ) . observeOn ( Schedulers . io ( ) ) . andThen ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception try Thread . sleep ( 30 ) ; catch ( InterruptedException e ) System . out . println ( "Interrupted! " + Thread . currentThread ( ) ) ; interrupted [ 0 ] = true ; ) ) . subscribe ( new Action ( ) @ Override public void run ( ) throws Exception latch . countDown ( ) ; ) ; latch . await ( ) ; assertFalse ( "The second Completable was interrupted!" , interrupted [ 0 ] ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( c -> c . andThen ( c ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter . incrementAndGet ( ) ; ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter . incrementAndGet ( ) ; throw new TestException ( ) ; ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , counter . get ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; Completable result = Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter . incrementAndGet ( ) ; ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; TestObserver < Void > to = result . test ( ) ; to . assertEmpty ( ) ; scheduler . advanceTimeBy ( 90 , TimeUnit . MILLISECONDS ) ; to . dispose ( ) ; scheduler . advanceTimeBy ( 15 , TimeUnit . MILLISECONDS ) ; to . assertEmpty ( ) ; assertEquals ( 0 , counter . get ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; Completable result = Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter . incrementAndGet ( ) ; ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; TestObserver < Void > to = result . test ( ) ; scheduler . advanceTimeBy ( 90 , TimeUnit . MILLISECONDS ) ; to . assertEmpty ( ) ; scheduler . advanceTimeBy ( 15 , TimeUnit . MILLISECONDS ) ; to . assertResult ( ) ; assertEquals ( 1 , counter . get ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; Completable result = Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter . incrementAndGet ( ) ; throw new TestException ( ) ; ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; TestObserver < Void > to = result . test ( ) ; scheduler . advanceTimeBy ( 90 , TimeUnit . MILLISECONDS ) ; to . assertEmpty ( ) ; scheduler . advanceTimeBy ( 15 , TimeUnit . MILLISECONDS ) ; to . assertFailure ( TestException . class ) ; assertEquals ( 1 , counter . get ( ) ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Void > to = cs . delaySubscription ( 1 , TimeUnit . SECONDS , scheduler ) . test ( ) ; assertFalse ( cs . hasObservers ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; assertTrue ( cs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( cs . hasObservers ( ) ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw new TestException ( ) ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . complete ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . error ( new TestException ( ) ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . complete ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) . assertResult ( ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . error ( new TestException ( ) ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . complete ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) . test ( ) . assertResult ( ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception throw new TestException ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception throw new TestException ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Void > to = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception throw new TestException ( "Main" ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , true ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > list = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( list , 0 , TestException . class , "Main" ) ; TestHelper . assertError ( list , 1 , TestException . class , "Disposer" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception throw new TestException ( "Main" ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , false ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Main" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Disposer" ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] call = 0 ; TestObserverEx < Void > to = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . never ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception call [ 0 ] ++ ; , false ) . to ( TestHelper . < Void > testConsumer ( ) ) ; to . dispose ( ) ; assertEquals ( 1 , call [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Void > to = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . never ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( ) ; , false ) . test ( ) ; to . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . never ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . complete ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . complete ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , true ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Void > to = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . error ( new TestException ( "Main" ) ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( "Disposer" ) ; , true ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > list = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( list , 0 , TestException . class , "Main" ) ; TestHelper . assertError ( list , 1 , TestException . class , "Disposer" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return Completable . wrap ( new CompletableSource ( ) @ Override public void subscribe ( CompletableObserver observer ) Disposable d1 = Disposable . empty ( ) ; observer . onSubscribe ( d1 ) ; Disposable d2 = Disposable . empty ( ) ; observer . onSubscribe ( d2 ) ; assertFalse ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , false ) . test ( ) ; TestHelper . assertError ( errors , 0 , IllegalStateException . class , "Disposable already set!" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserverEx < Void > to = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return ps . ignoreElements ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . to ( TestHelper . < Void > testConsumer ( ) ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
RxJavaPlugins . setErrorHandler ( Functions . emptyConsumer ( ) ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Void > to = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return ps . ignoreElements ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Void > to = Completable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , CompletableSource > ( ) @ Override public CompletableSource apply ( Object v ) throws Exception return ps . ignoreElements ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception , true ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final StringBuilder sb = new StringBuilder ( ) ; TestObserver < Void > to = Completable . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Throwable return Completable . never ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Dispose" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , true ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; assertEquals ( "ResourceDispose" , sb . toString ( ) ) ; 
final StringBuilder sb = new StringBuilder ( ) ; TestObserver < Void > to = Completable . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer t ) throws Throwable return Completable . never ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Dispose" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , false ) . test ( ) ; to . assertEmpty ( ) ; to . dispose ( ) ; assertEquals ( "DisposeResource" , sb . toString ( ) ) ; 
Completable . fromObservable ( Observable . just ( 1 ) ) . test ( ) . assertResult ( ) ; 
Completable . fromObservable ( Observable . empty ( ) ) . test ( ) . assertResult ( ) ; 
Completable . fromObservable ( Observable . error ( new UnsupportedOperationException ( ) ) ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
TestHelper . withErrorTracking ( errors -> CompletableObserver consumer = mock ( CompletableObserver . class ) ; Completable . error ( new TestException ( ) ) . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onError ( any ( TestException . class ) ) ; order . verifyNoMoreInteractions ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> CompletableObserver consumer = mock ( CompletableObserver . class ) ; Completable . complete ( ) . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onComplete ( ) ; order . verifyNoMoreInteractions ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> CompletableObserver consumer = mock ( CompletableObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onSubscribe ( any ( ) ) ; Disposable d = Disposable . empty ( ) ; new Completable ( ) @ Override protected void subscribeActual ( @ NonNull CompletableObserver observer ) observer . onSubscribe ( d ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verifyNoMoreInteractions ( ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , IOException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> CompletableObserver consumer = mock ( CompletableObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onError ( any ( ) ) ; new Completable ( ) @ Override protected void subscribeActual ( @ NonNull CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new IOException ( ) ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onError ( any ( IOException . class ) ) ; order . verifyNoMoreInteractions ( ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; CompositeException compositeException = ( CompositeException ) errors . get ( 0 ) ; TestHelper . assertError ( compositeException . getExceptions ( ) , 0 , IOException . class ) ; TestHelper . assertError ( compositeException . getExceptions ( ) , 1 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> CompletableObserver consumer = mock ( CompletableObserver . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . onComplete ( ) ; new Completable ( ) @ Override protected void subscribeActual ( @ NonNull CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; . safeSubscribe ( consumer ) ; InOrder order = inOrder ( consumer ) ; order . verify ( consumer ) . onSubscribe ( any ( Disposable . class ) ) ; order . verify ( consumer ) . onComplete ( ) ; order . verifyNoMoreInteractions ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Completable . sequenceEqual ( Completable . complete ( ) , Completable . complete ( ) ) . test ( ) . assertResult ( true ) ; 
Completable . sequenceEqual ( Completable . error ( new TestException ( ) ) , Completable . complete ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Completable . sequenceEqual ( Completable . complete ( ) , Completable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
count ++ ; 
count ++ ; 
Completable c = Completable . complete ( ) . doOnSubscribe ( this ) . cache ( ) ; assertEquals ( 0 , count ) ; c . test ( ) . assertResult ( ) ; assertEquals ( 1 , count ) ; c . test ( ) . assertResult ( ) ; assertEquals ( 1 , count ) ; c . test ( ) . assertResult ( ) ; assertEquals ( 1 , count ) ; 
Completable c = Completable . error ( new TestException ( ) ) . doOnSubscribe ( this ) . cache ( ) ; assertEquals ( 0 , count ) ; c . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , count ) ; c . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , count ) ; c . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , count ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Void > to1 = new TestObserver < > ( ) ; final TestObserver < Void > to2 = new TestObserver < Void > ( ) @ Override public void onComplete ( ) super . onComplete ( ) ; to1 . dispose ( ) ; ; Completable c = ps . ignoreElements ( ) . cache ( ) ; c . subscribe ( to2 ) ; c . subscribe ( to1 ) ; ps . onComplete ( ) ; to1 . assertEmpty ( ) ; to2 . assertResult ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Void > to1 = new TestObserver < > ( ) ; final TestObserver < Void > to2 = new TestObserver < Void > ( ) @ Override public void onError ( Throwable ex ) super . onError ( ex ) ; to1 . dispose ( ) ; ; Completable c = ps . ignoreElements ( ) . cache ( ) ; c . subscribe ( to2 ) ; c . subscribe ( to1 ) ; ps . onError ( new TestException ( ) ) ; to1 . assertEmpty ( ) ; to2 . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Completable c = ps . ignoreElements ( ) . cache ( ) ; assertFalse ( ps . hasObservers ( ) ) ; TestObserver < Void > to1 = c . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to1 . dispose ( ) ; assertTrue ( ps . hasObservers ( ) ) ; TestObserver < Void > to2 = c . test ( ) ; TestObserver < Void > to3 = c . test ( ) ; to3 . dispose ( ) ; TestObserver < Void > to4 = c . test ( true ) ; to3 . dispose ( ) ; ps . onComplete ( ) ; to1 . assertEmpty ( ) ; to2 . assertResult ( ) ; to3 . assertEmpty ( ) ; to4 . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Completable c = ps . ignoreElements ( ) . cache ( ) ; final TestObserver < Void > to1 = new TestObserver < > ( ) ; final TestObserver < Void > to2 = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) c . subscribe ( to1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) c . subscribe ( to2 ) ; ; TestHelper . race ( r1 , r2 ) ; ps . onComplete ( ) ; to1 . assertResult ( ) ; to2 . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Completable c = ps . ignoreElements ( ) . cache ( ) ; final TestObserver < Void > to1 = c . test ( ) ; final TestObserver < Void > to2 = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) c . subscribe ( to2 ) ; ; TestHelper . race ( r1 , r2 ) ; ps . onComplete ( ) ; to1 . assertEmpty ( ) ; to2 . assertResult ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Void > to = new TestObserver < > ( ) ; ps . ignoreElements ( ) . cache ( ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) to . onSubscribe ( EmptyDisposable . INSTANCE ) ; d . dispose ( ) ; d . dispose ( ) ; @ Override public void onComplete ( ) to . onComplete ( ) ; @ Override public void onError ( Throwable e ) to . onError ( e ) ; ) ; ps . onComplete ( ) ; to . assertEmpty ( ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Completable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Supplier < Object > supplier = new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ; Completable . fromSupplier ( supplier ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Completable . fromSupplier ( supplier ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Completable completable = Completable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception atomicInteger . incrementAndGet ( ) ; return null ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; completable . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Completable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
Supplier < String > func = mock ( Supplier . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . get ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Completable fromSupplierObservable = Completable . fromSupplier ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; TestObserver < String > outer = new TestObserver < > ( observer ) ; fromSupplierObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . dispose ( ) ; funcLatch . countDown ( ) ; verify ( func ) . get ( ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verifyNoMoreInteractions ( observer ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Completable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception calls . incrementAndGet ( ) ; throw new TestException ( ) ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 1 , calls . get ( ) ) ; 
Action action1 = mock ( Action . class ) ; Action action2 = mock ( Action . class ) ; Completable . concatDelayError ( Arrays . asList ( Completable . fromAction ( action1 ) , Completable . error ( new TestException ( ) ) , Completable . fromAction ( action2 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( action1 ) . run ( ) ; verify ( action2 ) . run ( ) ; 
Action action1 = mock ( Action . class ) ; Action action2 = mock ( Action . class ) ; Completable . concatDelayError ( Flowable . fromArray ( Completable . fromAction ( action1 ) , Completable . error ( new TestException ( ) ) , Completable . fromAction ( action2 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( action1 ) . run ( ) ; verify ( action2 ) . run ( ) ; 
Action action1 = mock ( Action . class ) ; Action action2 = mock ( Action . class ) ; Completable . concatDelayError ( Flowable . fromArray ( Completable . fromAction ( action1 ) , Completable . error ( new TestException ( ) ) , Completable . fromAction ( action2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class ) ; verify ( action1 ) . run ( ) ; verify ( action2 ) . run ( ) ; 
Completable . complete ( ) . onErrorComplete ( ) . test ( ) . assertResult ( ) ; 
final int [ ] call = 0 ; Completable . complete ( ) . onErrorResumeNext ( new Function < Throwable , CompletableSource > ( ) @ Override public CompletableSource apply ( Throwable e ) throws Exception call [ 0 ] ++ ; return Completable . complete ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , call [ 0 ] ) ; 
Completable . error ( new TestException ( ) ) . onErrorReturnItem ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Completable . error ( new TestException ( ) ) . onErrorReturn ( Functions . justFunction ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . assertCompositeExceptions ( Completable . error ( new TestException ( ) ) . onErrorReturn ( new Function < Throwable , Object > ( ) @ Override public Object apply ( Throwable v ) throws Exception throw new IOException ( ) ; ) . to ( TestHelper . testConsumer ( ) ) , TestException . class , IOException . class ) ; 
Completable . complete ( ) . onErrorReturnItem ( 2 ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( CompletableSubject . create ( ) . onErrorReturnItem ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletableToMaybe ( new Function < Completable , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Completable v ) throws Exception return v . onErrorReturnItem ( 1 ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable . complete ( ) . lift ( new CompletableOperator ( ) @ Override public CompletableObserver apply ( CompletableObserver o ) throws Exception throw new TestException ( ) ; ) . test ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
try Completable . merge ( Flowable . just ( Completable . complete ( ) ) , - 99 ) ; fail ( "Should have thrown IllegalArgumentExceptio" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "maxConcurrency > 0 required but it was -99" , ex . getMessage ( ) ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . mergeArray ( new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; to . dispose ( ) ; , Completable . complete ( ) ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . mergeArrayDelayError ( new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; to . dispose ( ) ; , Completable . complete ( ) ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CompletableObserver [ ] co = null ; Completable . mergeArrayDelayError ( Completable . complete ( ) , new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; co [ 0 ] = observer ; ) . test ( ) . assertResult ( ) ; co [ 0 ] . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . mergeArray ( Completable . complete ( ) , pp . ignoreElements ( ) ) . test ( ) ; pp . onComplete ( ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . mergeArrayDelayError ( Completable . complete ( ) , pp . ignoreElements ( ) ) . test ( ) ; pp . onComplete ( ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . mergeArrayDelayError ( Completable . complete ( ) , pp . ignoreElements ( ) ) . test ( ) ; pp . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Completable . merge ( Flowable . just ( Completable . complete ( ) ) ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . merge ( Flowable . just ( pp . ignoreElements ( ) ) ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . dispose ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; to . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . merge ( Flowable . just ( pp . ignoreElements ( ) ) ) . test ( ) ; pp . onComplete ( ) ; to . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . merge ( Flowable . just ( pp . ignoreElements ( ) ) ) . test ( ) ; pp . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . mergeDelayError ( Flowable . just ( pp . ignoreElements ( ) ) ) . test ( ) ; pp . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserverEx < Void > to = Completable . merge ( pp1 . map ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return pp2 . ignoreElements ( ) ; ) ) . to ( TestHelper . < Void > testConsumer ( ) ) ; pp1 . onNext ( 1 ) ; final Throwable ex1 = new TestException ( ) ; final Throwable ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; Throwable ex = to . errors ( ) . get ( 0 ) ; if ( ex instanceof CompositeException ) to . assertSubscribed ( ) . assertNoValues ( ) . assertNotComplete ( ) ; errors = TestHelper . compositeList ( ex ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , TestException . class ) ; else to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserverEx < Void > to = Completable . mergeDelayError ( pp1 . map ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Exception return pp2 . ignoreElements ( ) ; ) ) . to ( TestHelper . < Void > testConsumer ( ) ) ; pp1 . onNext ( 1 ) ; final Throwable ex1 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; final Throwable ex2 = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , TestException . class ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . merge ( Flowable . just ( pp1 . ignoreElements ( ) , pp2 . ignoreElements ( ) ) , 1 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; to . assertResult ( ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . mergeDelayError ( Flowable . just ( pp1 . ignoreElements ( ) , pp2 . ignoreElements ( ) ) , 1 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; to . assertResult ( ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . mergeDelayError ( Flowable . just ( pp1 . ignoreElements ( ) , pp2 . ignoreElements ( ) ) , 1 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
final PublishProcessor < PublishProcessor < Integer > > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . mergeDelayError ( pp0 . map ( new Function < PublishProcessor < Integer > , Completable > ( ) @ Override public Completable apply ( PublishProcessor < Integer > v ) throws Exception return v . ignoreElements ( ) ; ) , 1 ) . test ( ) ; pp0 . onNext ( pp1 ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; pp1 . onComplete ( ) ; pp0 . onNext ( pp2 ) ; pp0 . onError ( new TestException ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; pp2 . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Completable . mergeDelayError ( new Flowable < Completable > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Completable > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( Completable . complete ( ) ) ; s . onError ( new TestException ( "First" ) ) ; s . onError ( new TestException ( "Second" ) ) ; ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CompletableObserver [ ] o = null ; Completable . mergeDelayError ( Flowable . just ( new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; o [ 0 ] = observer ; ) ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; o [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . mergeDelayError ( Flowable . just ( new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; to . dispose ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ) ) . subscribe ( to ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . mergeArray ( pp1 . ignoreElements ( ) , pp2 . ignoreElements ( ) ) . test ( ) ; pp1 . onNext ( 1 ) ; final Throwable ex1 = new TestException ( ) ; final Throwable ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Completable . mergeDelayError ( Arrays . asList ( Completable . complete ( ) ) ) . test ( true ) . assertEmpty ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . mergeDelayError ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) return new Iterator < Completable > ( ) @ Override public boolean hasNext ( ) to . dispose ( ) ; return true ; @ Override public Completable next ( ) return Completable . complete ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
final TestObserver < Void > to = new TestObserver < > ( ) ; Completable . mergeDelayError ( new Iterable < Completable > ( ) @ Override public Iterator < Completable > iterator ( ) return new Iterator < Completable > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Completable next ( ) to . dispose ( ) ; return Completable . complete ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return Completable . mergeArray ( upstream . ignoreElements ( ) , Completable . complete ( ) . hide ( ) ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return Completable . merge ( Arrays . asList ( upstream . ignoreElements ( ) , Completable . complete ( ) . hide ( ) ) ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return Completable . mergeArrayDelayError ( upstream . ignoreElements ( ) , Completable . complete ( ) . hide ( ) ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return Completable . mergeDelayError ( Arrays . asList ( upstream . ignoreElements ( ) , Completable . complete ( ) . hide ( ) ) ) ; ) ; 
CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = Completable . mergeDelayError ( Arrays . asList ( cs , cs , cs ) ) . test ( ) ; to . assertEmpty ( ) ; cs . onComplete ( ) ; to . assertResult ( ) ; 
TestHelper . checkDisposed ( new CompletableMergeArrayDelayError . TryTerminateAndReportDisposable ( new AtomicThrowable ( ) ) ) ; 
TestHelper . checkDisposed ( new CompletableMergeArray . InnerCompletableObserver ( new TestObserver < Void > ( ) , new AtomicBoolean ( ) , new CompositeDisposable ( ) , 1 ) ) ; 
TestHelper . < Completable > checkDoubleOnSubscribeFlowableToCompletable ( f -> Completable . merge ( f ) ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; Completable . complete ( ) . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) . assertResult ( ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; Completable . error ( new TestException ( ) ) . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) . assertFailure ( TestException . class ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; doThrow ( new TestException ( "First" ) ) . when ( onSubscribe ) . accept ( any ( ) ) ; Disposable bs = Disposable . empty ( ) ; new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( bs ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; . doOnLifecycle ( onSubscribe , onDispose ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( bs . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose , never ( ) ) . run ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> @ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; doThrow ( new TestException ( "First" ) ) . when ( onDispose ) . run ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = cs . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( cs . hasObservers ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "First" ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose ) . run ( ) ; ) ; 
@ SuppressWarnings ( "unchecked" ) Consumer < ? super Disposable > onSubscribe = mock ( Consumer . class ) ; Action onDispose = mock ( Action . class ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Void > to = cs . doOnLifecycle ( onSubscribe , onDispose ) . test ( ) ; assertTrue ( cs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( cs . hasObservers ( ) ) ; verify ( onSubscribe ) . accept ( any ( ) ) ; verify ( onDispose ) . run ( ) ; 
TestHelper . checkDisposed ( CompletableSubject . create ( ) . doOnLifecycle ( d -> , ( ) -> ) ) ; 
TestHelper . checkDoubleOnSubscribeCompletable ( m -> m . doOnLifecycle ( d -> , ( ) -> ) ) ; 
Completable . complete ( ) . blockingSubscribe ( ) ; 
Completable . complete ( ) . delay ( 100 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( ) ; 
TestHelper . withErrorTracking ( errors -> Completable . error ( new TestException ( ) ) . blockingSubscribe ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Completable . error ( new TestException ( ) ) . delay ( 100 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Action action = mock ( Action . class ) ; Completable . complete ( ) . blockingSubscribe ( action ) ; verify ( action ) . run ( ) ; 
Action action = mock ( Action . class ) ; Completable . complete ( ) . delay ( 50 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( action ) ; verify ( action ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> Action action = mock ( Action . class ) ; doThrow ( new TestException ( ) ) . when ( action ) . run ( ) ; Completable . complete ( ) . blockingSubscribe ( action ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( action ) . run ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Action action = mock ( Action . class ) ; Completable . error ( new TestException ( ) ) . blockingSubscribe ( action ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( action , never ( ) ) . run ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Action action = mock ( Action . class ) ; Completable . error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( action ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( action , never ( ) ) . run ( ) ; ) ; 
Action action = mock ( Action . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Completable . complete ( ) . blockingSubscribe ( action , consumer ) ; verify ( action ) . run ( ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; 
Action action = mock ( Action . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Completable . complete ( ) . delay ( 50 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( action , consumer ) ; verify ( action ) . run ( ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; 
TestHelper . withErrorTracking ( errors -> Action action = mock ( Action . class ) ; doThrow ( new TestException ( ) ) . when ( action ) . run ( ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Completable . complete ( ) . blockingSubscribe ( action , consumer ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( action ) . run ( ) ; verify ( consumer , never ( ) ) . accept ( any ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Action action = mock ( Action . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Completable . error ( new TestException ( ) ) . blockingSubscribe ( action , consumer ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( action , never ( ) ) . run ( ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Action action = mock ( Action . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Completable . error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( action , consumer ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( action , never ( ) ) . run ( ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Action action = mock ( Action . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; doThrow ( new TestException ( ) ) . when ( consumer ) . accept ( any ( ) ) ; Completable . error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( action , consumer ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; verify ( action , never ( ) ) . run ( ) ; verify ( consumer ) . accept ( any ( TestException . class ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Action onDispose = mock ( Action . class ) ; Action action = mock ( Action . class ) ; @ SuppressWarnings ( "unchecked" ) Consumer < ? super Throwable > consumer = mock ( Consumer . class ) ; Thread . currentThread ( ) . interrupt ( ) ; Completable . never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( action , consumer ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( onDispose ) . run ( ) ; verify ( action , never ( ) ) . run ( ) ; verify ( consumer ) . accept ( any ( InterruptedException . class ) ) ; ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; Completable . complete ( ) . blockingSubscribe ( to ) ; to . assertResult ( ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; Completable . complete ( ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( to ) ; to . assertResult ( ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; Completable . error ( new TestException ( ) ) . blockingSubscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; Completable . error ( new TestException ( ) ) . delay ( 50 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . blockingSubscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
Action onDispose = mock ( Action . class ) ; TestObserver < Void > to = new TestObserver < > ( ) ; to . dispose ( ) ; Completable . never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( to ) ; to . assertEmpty ( ) ; verify ( onDispose ) . run ( ) ; 
TestHelper . withErrorTracking ( errors -> Action onDispose = mock ( Action . class ) ; TestObserver < Void > to = new TestObserver < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; Completable . never ( ) . doOnDispose ( onDispose ) . blockingSubscribe ( to ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; verify ( onDispose ) . run ( ) ; to . assertFailure ( InterruptedException . class ) ; ) ; 
Completable . complete ( ) . doOnEvent ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Void > to = Completable . error ( new TestException ( "Outer" ) ) . doOnEvent ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
final AtomicBoolean atomicBoolean = new AtomicBoolean ( ) ; assertFalse ( atomicBoolean . get ( ) ) ; Completable . complete ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception atomicBoolean . set ( true ) ; ) . test ( ) . assertResult ( ) . dispose ( ) ; assertTrue ( atomicBoolean . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable bs = Disposable . empty ( ) ; new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( bs ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( "First" ) ; ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( bs . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Completable . timer ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try for ( Scheduler s : new Scheduler [ ] Schedulers . single ( ) , Schedulers . computation ( ) , Schedulers . newThread ( ) , Schedulers . io ( ) , Schedulers . from ( exec , true ) ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; TestObserver < Void > to = Completable . timer ( 1 , TimeUnit . MILLISECONDS , s ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception try Thread . sleep ( 3000 ) ; catch ( InterruptedException ex ) interrupted . set ( true ) ; ) . test ( ) ; Thread . sleep ( 500 ) ; to . dispose ( ) ; Thread . sleep ( 500 ) ; assertTrue ( s . getClass ( ) . getSimpleName ( ) , interrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
CompletableSubject cs1 = CompletableSubject . create ( ) ; CompletableSubject cs2 = CompletableSubject . create ( ) ; TestObserver < Void > to = cs1 . takeUntil ( cs2 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( cs1 . hasObservers ( ) ) ; assertTrue ( cs2 . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( cs1 . hasObservers ( ) ) ; assertFalse ( cs2 . hasObservers ( ) ) ; 
CompletableSubject cs1 = CompletableSubject . create ( ) ; CompletableSubject cs2 = CompletableSubject . create ( ) ; TestObserver < Void > to = cs1 . takeUntil ( cs2 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( cs1 . hasObservers ( ) ) ; assertTrue ( cs2 . hasObservers ( ) ) ; cs1 . onComplete ( ) ; assertFalse ( cs1 . hasObservers ( ) ) ; assertFalse ( cs2 . hasObservers ( ) ) ; to . assertResult ( ) ; 
CompletableSubject cs1 = CompletableSubject . create ( ) ; CompletableSubject cs2 = CompletableSubject . create ( ) ; TestObserver < Void > to = cs1 . takeUntil ( cs2 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( cs1 . hasObservers ( ) ) ; assertTrue ( cs2 . hasObservers ( ) ) ; cs2 . onComplete ( ) ; assertFalse ( cs1 . hasObservers ( ) ) ; assertFalse ( cs2 . hasObservers ( ) ) ; to . assertResult ( ) ; 
CompletableSubject cs1 = CompletableSubject . create ( ) ; CompletableSubject cs2 = CompletableSubject . create ( ) ; TestObserver < Void > to = cs1 . takeUntil ( cs2 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( cs1 . hasObservers ( ) ) ; assertTrue ( cs2 . hasObservers ( ) ) ; cs1 . onError ( new TestException ( ) ) ; assertFalse ( cs1 . hasObservers ( ) ) ; assertFalse ( cs2 . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
CompletableSubject cs1 = CompletableSubject . create ( ) ; CompletableSubject cs2 = CompletableSubject . create ( ) ; TestObserver < Void > to = cs1 . takeUntil ( cs2 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( cs1 . hasObservers ( ) ) ; assertTrue ( cs2 . hasObservers ( ) ) ; cs2 . onError ( new TestException ( ) ) ; assertFalse ( cs1 . hasObservers ( ) ) ; assertFalse ( cs2 . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
CompletableSubject cs1 = CompletableSubject . create ( ) ; CompletableSubject cs2 = CompletableSubject . create ( ) ; TestHelper . checkDisposed ( cs1 . takeUntil ( cs2 ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( ) ) ; . takeUntil ( Completable . complete ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; . takeUntil ( Completable . complete ( ) ) . test ( ) . assertResult ( ) ; assertTrue ( errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < CompletableObserver > ref = new AtomicReference < > ( ) ; Completable . complete ( ) . takeUntil ( new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ref . set ( observer ) ; ) . test ( ) . assertResult ( ) ; ref . get ( ) . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < CompletableObserver > ref = new AtomicReference < > ( ) ; Completable . complete ( ) . takeUntil ( new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ref . set ( observer ) ; ) . test ( ) . assertResult ( ) ; ref . get ( ) . onComplete ( ) ; assertTrue ( errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . ignoreElements ( ) . test ( true ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . ignoreElements ( ) . test ( false ) ; assertTrue ( ps . hasObservers ( ) ) ; 
Runnable run = mock ( Runnable . class ) ; Completable . switchOnNext ( Flowable . range ( 1 , 10 ) . map ( v -> if ( v % 2 == 0 ) return Completable . fromRunnable ( run ) ; return Completable . complete ( ) ; ) ) . test ( ) . assertResult ( ) ; verify ( run , times ( 5 ) ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Completable . switchOnNextDelayError ( Flowable . range ( 1 , 10 ) . map ( v -> if ( v % 2 == 0 ) return Completable . fromRunnable ( run ) ; return Completable . complete ( ) ; ) ) . test ( ) . assertResult ( ) ; verify ( run , times ( 5 ) ) . run ( ) ; 
PublishProcessor < Completable > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . switchOnNext ( pp ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . assertEmpty ( ) ; CompletableSubject cs1 = CompletableSubject . create ( ) ; CompletableSubject cs2 = CompletableSubject . create ( ) ; pp . onNext ( cs1 ) ; assertTrue ( cs1 . hasObservers ( ) ) ; pp . onNext ( cs2 ) ; assertFalse ( cs1 . hasObservers ( ) ) ; assertTrue ( cs2 . hasObservers ( ) ) ; pp . onComplete ( ) ; assertTrue ( cs2 . hasObservers ( ) ) ; cs2 . onComplete ( ) ; to . assertResult ( ) ; 
PublishProcessor < Completable > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = Completable . switchOnNextDelayError ( pp ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . assertEmpty ( ) ; CompletableSubject cs1 = CompletableSubject . create ( ) ; CompletableSubject cs2 = CompletableSubject . create ( ) ; pp . onNext ( cs1 ) ; assertTrue ( cs1 . hasObservers ( ) ) ; pp . onNext ( cs2 ) ; assertFalse ( cs1 . hasObservers ( ) ) ; assertTrue ( cs2 . hasObservers ( ) ) ; assertTrue ( cs2 . hasObservers ( ) ) ; cs2 . onError ( new TestException ( ) ) ; assertTrue ( pp . hasSubscribers ( ) ) ; to . assertEmpty ( ) ; pp . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkUtilityClass ( ObservableScalarXMap . class ) ; 
EmptyDisposable . error ( new TestException ( ) , observer ) ; 
throw new TestException ( ) ; 
EmptyDisposable . complete ( observer ) ; 
return null ; 
ScalarDisposable < Integer > sd = new ScalarDisposable < > ( observer , 1 ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; 
return 1 ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; assertTrue ( ObservableScalarXMap . tryScalarXMapSubscribe ( new CallablePublisher ( ) , to , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer f ) throws Exception return Observable . just ( 1 ) ; ) ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; assertTrue ( ObservableScalarXMap . tryScalarXMapSubscribe ( new EmptyCallablePublisher ( ) , to , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer f ) throws Exception return Observable . just ( 1 ) ; ) ) ; to . assertResult ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; assertTrue ( ObservableScalarXMap . tryScalarXMapSubscribe ( new OneCallablePublisher ( ) , to , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer f ) throws Exception throw new TestException ( ) ; ) ) ; to . assertFailure ( TestException . class ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; assertTrue ( ObservableScalarXMap . tryScalarXMapSubscribe ( new OneCallablePublisher ( ) , to , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer f ) throws Exception return Observable . just ( 1 ) ; ) ) ; to . assertResult ( 1 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; assertTrue ( ObservableScalarXMap . tryScalarXMapSubscribe ( new OneCallablePublisher ( ) , to , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer f ) throws Exception return Observable . empty ( ) ; ) ) ; to . assertResult ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; assertTrue ( ObservableScalarXMap . tryScalarXMapSubscribe ( new OneCallablePublisher ( ) , to , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer f ) throws Exception return new CallablePublisher ( ) ; ) ) ; to . assertFailure ( TestException . class ) ; 
ObservableScalarXMap . scalarXMap ( 1 , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
ObservableScalarXMap . scalarXMap ( 1 , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return new CallablePublisher ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; ScalarDisposable < Integer > sd = new ScalarDisposable < > ( to , 1 ) ; to . onSubscribe ( sd ) ; assertFalse ( sd . isDisposed ( ) ) ; assertTrue ( sd . isEmpty ( ) ) ; sd . run ( ) ; assertTrue ( sd . isDisposed ( ) ) ; assertTrue ( sd . isEmpty ( ) ) ; to . assertResult ( 1 ) ; try sd . offer ( 1 ) ; fail ( "Should have thrown" ) ; catch ( UnsupportedOperationException ex ) try sd . offer ( 1 , 2 ) ; fail ( "Should have thrown" ) ; catch ( UnsupportedOperationException ex ) 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; final ScalarDisposable < Integer > sd = new ScalarDisposable < > ( to , 1 ) ; to . onSubscribe ( sd ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) sd . run ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sd . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; final ScalarDisposable < Integer > sd = new ScalarDisposable < > ( to , 1 ) ; to . onSubscribe ( sd ) ; assertEquals ( QueueFuseable . NONE , sd . requestFusion ( QueueFuseable . ASYNC ) ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) ; Observable < String > m = o . scan ( "" , new BiFunction < String , Integer , String > ( ) @ Override public String apply ( String s , Integer n ) return s + n . toString ( ) ; ) ; m . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onNext ( "" ) ; verify ( observer , times ( 1 ) ) . onNext ( "1" ) ; verify ( observer , times ( 1 ) ) . onNext ( "12" ) ; verify ( observer , times ( 1 ) ) . onNext ( "123" ) ; verify ( observer , times ( 4 ) ) . onNext ( anyString ( ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observer < Integer > observer = TestHelper . mockObserver ( ) ; Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) ; Observable < Integer > m = o . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) ; m . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onNext ( 0 ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( 3 ) ; verify ( observer , times ( 1 ) ) . onNext ( 6 ) ; verify ( observer , times ( 3 ) ) . onNext ( anyInt ( ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observer < Integer > observer = TestHelper . mockObserver ( ) ; Observable < Integer > o = Observable . just ( 1 ) ; Observable < Integer > m = o . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) ; m . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onNext ( 0 ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 100 ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 > 0 ; ) . subscribe ( to ) ; assertEquals ( 100 , to . values ( ) . size ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable . range ( 1 , 100 ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) fail ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; @ Override public void onNext ( Integer t ) count . incrementAndGet ( ) ; ) ; assertEquals ( 101 , count . get ( ) ) ; 
Observable < List < Integer > > o = Observable . range ( 1 , 10 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer t2 ) list . add ( t2 ) ; ) . toObservable ( ) . takeLast ( 1 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) , o . blockingSingle ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) , o . blockingSingle ( ) ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . take ( 1 ) ; TestObserverEx < Integer > observer = new TestObserverEx < > ( ) ; o . subscribe ( observer ) ; observer . assertValue ( 0 ) ; observer . assertTerminated ( ) ; observer . assertNoErrors ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; to . assertValue ( 0 ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . scan ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ) ; TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . scan ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . scan ( 0 , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ; ) ; 
Observable . error ( new TestException ( ) ) . scan ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Object > , Object > ( ) @ Override public Object apply ( Observable < Object > o ) throws Exception return o . scan ( 0 , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ; , false , 1 , 1 , 0 , 0 ) ; 
final RuntimeException err = new RuntimeException ( ) ; final RuntimeException err2 = new RuntimeException ( ) ; final List < Throwable > list = new CopyOnWriteArrayList < > ( ) ; final Consumer < Throwable > errorConsumer = new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throws Exception list . add ( t ) ; ; try RxJavaPlugins . setErrorHandler ( errorConsumer ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > o ) Disposable d = Disposable . empty ( ) ; o . onSubscribe ( d ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; o . onError ( err2 ) ; ) . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throws Exception throw err ; ) . test ( ) . assertError ( err ) . assertValue ( 1 ) ; finally RxJavaPlugins . reset ( ) ; 
final RuntimeException err = new RuntimeException ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > o ) Disposable d = Disposable . empty ( ) ; o . onSubscribe ( d ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; o . onComplete ( ) ; ) . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throws Exception throw err ; ) . test ( ) . assertError ( err ) . assertValue ( 1 ) ; 
final RuntimeException err = new RuntimeException ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > o ) Disposable d = Disposable . empty ( ) ; o . onSubscribe ( d ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; o . onNext ( 3 ) ; ) . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throws Exception count . incrementAndGet ( ) ; throw err ; ) . test ( ) . assertError ( err ) . assertValue ( 1 ) ; assertEquals ( 1 , count . get ( ) ) ; 
Supplier < Observable < String > > factory = mock ( Supplier . class ) ; Observable < String > firstObservable = Observable . just ( "one" , "two" ) ; Observable < String > secondObservable = Observable . just ( "three" , "four" ) ; when ( factory . get ( ) ) . thenReturn ( firstObservable , secondObservable ) ; Observable < String > deferred = Observable . defer ( factory ) ; verifyNoInteractions ( factory ) ; Observer < String > firstObserver = TestHelper . mockObserver ( ) ; deferred . subscribe ( firstObserver ) ; verify ( factory , times ( 1 ) ) . get ( ) ; verify ( firstObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( firstObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( firstObserver , times ( 0 ) ) . onNext ( "three" ) ; verify ( firstObserver , times ( 0 ) ) . onNext ( "four" ) ; verify ( firstObserver , times ( 1 ) ) . onComplete ( ) ; Observer < String > secondObserver = TestHelper . mockObserver ( ) ; deferred . subscribe ( secondObserver ) ; verify ( factory , times ( 2 ) ) . get ( ) ; verify ( secondObserver , times ( 0 ) ) . onNext ( "one" ) ; verify ( secondObserver , times ( 0 ) ) . onNext ( "two" ) ; verify ( secondObserver , times ( 1 ) ) . onNext ( "three" ) ; verify ( secondObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( secondObserver , times ( 1 ) ) . onComplete ( ) ; 
Supplier < Observable < String > > factory = mock ( Supplier . class ) ; when ( factory . get ( ) ) . thenThrow ( new TestException ( ) ) ; Observable < String > result = Observable . defer ( factory ) ; Observer < String > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observable . fromMaybe ( Maybe . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . fromMaybe ( Maybe . empty ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
Observable . fromMaybe ( Maybe . error ( new TestException ( ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = Observable . fromMaybe ( ms ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ms . hasObservers ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Observable . fromMaybe ( Maybe . just ( 1 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . SYNC ) ; Observable . fromMaybe ( Maybe . just ( 1 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 ) ; 
assertEquals ( 2 , Observable . fromArray ( 1 , 2 ) . elementAt ( 1 ) . toObservable ( ) . blockingSingle ( ) . intValue ( ) ) ; 
assertEquals ( - 99 , Observable . fromArray ( 1 , 2 ) . elementAt ( 2 ) . toObservable ( ) . blockingSingle ( - 99 ) . intValue ( ) ) ; 
assertEquals ( 2 , Observable . fromArray ( 1 , 2 ) . elementAt ( 1 , 0 ) . toObservable ( ) . blockingSingle ( ) . intValue ( ) ) ; 
assertEquals ( 0 , Observable . fromArray ( 1 , 2 ) . elementAt ( 2 , 0 ) . toObservable ( ) . blockingSingle ( ) . intValue ( ) ) ; 
assertEquals ( 2 , Observable . fromArray ( 1 , 2 ) . elementAt ( 1 ) . blockingGet ( ) . intValue ( ) ) ; 
Observable . fromArray ( 1 , 2 ) . elementAt ( - 1 ) ; 
assertNull ( Observable . fromArray ( 1 , 2 ) . elementAt ( 2 ) . blockingGet ( ) ) ; 
assertEquals ( 2 , Observable . fromArray ( 1 , 2 ) . elementAt ( 1 , 0 ) . blockingGet ( ) . intValue ( ) ) ; 
assertEquals ( 0 , Observable . fromArray ( 1 , 2 ) . elementAt ( 2 , 0 ) . blockingGet ( ) . intValue ( ) ) ; 
Observable . fromArray ( 1 , 2 ) . elementAt ( - 1 , 0 ) ; 
Observable . empty ( ) . elementAtOrError ( - 1 ) ; 
Observable . empty ( ) . elementAtOrError ( 0 ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Observable . just ( 1 ) . elementAtOrError ( 0 ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Observable . just ( 1 , 2 , 3 ) . elementAtOrError ( 1 ) . test ( ) . assertNoErrors ( ) . assertValue ( 2 ) ; 
Observable . just ( 1 , 2 , 3 ) . elementAtOrError ( 3 ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Observable . error ( new RuntimeException ( "error" ) ) . elementAtOrError ( 0 ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
Observable . empty ( ) . elementAt ( 0 ) . test ( ) . assertResult ( ) ; 
Observable . empty ( ) . elementAt ( 0 , 5 ) . test ( ) . assertResult ( 5 ) ; 
Observable . empty ( ) . elementAt ( 1 ) . test ( ) . assertResult ( ) ; 
Observable . empty ( ) . elementAt ( 1 , 10 ) . test ( ) . assertResult ( 10 ) ; 
Observable . empty ( ) . elementAtOrError ( 1 ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . elementAt ( 0 ) . toObservable ( ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . elementAt ( 0 ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . elementAt ( 0 , 1 ) . toObservable ( ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . elementAt ( 0 , 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . elementAt ( 0 ) . toObservable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservableToMaybe ( new Function < Observable < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Observable < Object > o ) throws Exception return o . elementAt ( 0 ) ; ) ; TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Observable < Object > o ) throws Exception return o . elementAt ( 0 , 1 ) ; ) ; 
Observable . empty ( ) . elementAt ( 1 , 10 ) . toObservable ( ) . test ( ) . assertResult ( 10 ) ; 
Observable . error ( new TestException ( ) ) . elementAt ( 1 , 10 ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . elementAt ( 0 ) . toObservable ( ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . elementAt ( 0 ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . elementAt ( 0 , 1 ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
scheduler = new TestScheduler ( ) ; observer = TestHelper . mockObserver ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( observer , 100 , "one" ) ; publishNext ( observer , 400 , "two" ) ; publishNext ( observer , 900 , "three" ) ; publishCompleted ( observer , 1000 ) ; ) ; Observable < String > sampled = source . debounce ( 400 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; scheduler . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 800 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; scheduler . advanceTimeTo ( 1000 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( observer , 100 , "a" ) ; publishNext ( observer , 200 , "b" ) ; publishNext ( observer , 300 , "c" ) ; publishNext ( observer , 400 , "d" ) ; publishNext ( observer , 500 , "e" ) ; publishNext ( observer , 600 , "f" ) ; publishNext ( observer , 700 , "g" ) ; publishNext ( observer , 800 , "h" ) ; publishCompleted ( observer , 900 ) ; ) ; Observable < String > sampled = source . debounce ( 200 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; scheduler . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 0 ) ) . onNext ( anyString ( ) ) ; scheduler . advanceTimeTo ( 1000 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; Exception error = new TestException ( ) ; publishNext ( observer , 100 , "one" ) ; publishNext ( observer , 600 , "two" ) ; publishError ( observer , 700 , error ) ; ) ; Observable < String > sampled = source . debounce ( 400 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; scheduler . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 500 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer ) . onNext ( "one" ) ; scheduler . advanceTimeTo ( 701 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > debouncer = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > debounceSel = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return debouncer ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . debounce ( debounceSel ) . subscribe ( o ) ; source . onNext ( 1 ) ; debouncer . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; debouncer . onNext ( 2 ) ; source . onNext ( 5 ) ; source . onComplete ( ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 4 ) ; inOrder . verify ( o ) . onNext ( 5 ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > debounceSel = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . debounce ( debounceSel ) . subscribe ( o ) ; source . onNext ( 1 ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > debounceSel = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return Observable . error ( new TestException ( ) ) ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . debounce ( debounceSel ) . subscribe ( o ) ; source . onNext ( 1 ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . debounce ( 100 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( o ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > debouncer = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > debounceSel = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return debouncer ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . debounce ( debounceSel ) . subscribe ( o ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; debouncer . onComplete ( ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; TestObserverEx < Integer > observer = new TestObserverEx < > ( ) ; Observable . merge ( Observable . just ( 1 ) , Observable . just ( 2 ) . delay ( 10 , TimeUnit . MILLISECONDS , scheduler ) ) . debounce ( 20 , TimeUnit . MILLISECONDS , scheduler ) . take ( 1 ) . subscribe ( observer ) ; scheduler . advanceTimeBy ( 30 , TimeUnit . MILLISECONDS ) ; observer . assertValue ( 2 ) ; observer . assertTerminated ( ) ; observer . assertNoErrors ( ) ; 
Observable . just ( 1 ) . debounce ( 1 , TimeUnit . SECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . debounce ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . debounce ( Functions . justFunction ( Observable . never ( ) ) ) ) ; Disposable d = new ObservableDebounceTimed . DebounceEmitter < > ( 1 , 1 , null ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . debounce ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > o ) throws Exception return o . debounce ( new Function < Integer , ObservableSource < Long > > ( ) @ Override public ObservableSource < Long > apply ( Integer v ) throws Exception return Observable . timer ( 1 , TimeUnit . SECONDS ) ; ) ; , false , 1 , 1 , 1 ) ; TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( final Observable < Integer > o ) throws Exception return Observable . just ( 1 ) . debounce ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return o ; ) ; , false , 1 , 1 , 1 ) ; 
Observable . just ( 1 ) . debounce ( Functions . justFunction ( Observable . empty ( ) ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > o ) throws Exception return o . debounce ( Functions . justFunction ( Observable . never ( ) ) ) ; ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; BehaviorSubject . createDefault ( 1 ) . debounce ( new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer o ) throws Exception to . dispose ( ) ; return Observable . never ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; to . dispose ( ) ; observer . onComplete ( ) ; . debounce ( Functions . justFunction ( Observable . never ( ) ) ) . subscribeWith ( to ) . assertEmpty ( ) ; 
final AtomicReference < Observer < ? super Integer > > ref = new AtomicReference < > ( ) ; TestObserver < Integer > to = Observable . range ( 1 , 2 ) . debounce ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer o ) throws Exception if ( o != 1 ) return Observable . never ( ) ; return new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ref . set ( observer ) ; ; ) . test ( ) ; ref . get ( ) . onNext ( 1 ) ; to . assertResult ( 2 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . debounce ( 1 , TimeUnit . SECONDS ) ; ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; to . dispose ( ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; . debounce ( 1 , TimeUnit . SECONDS ) . subscribe ( to ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; DebounceTimedObserver < Integer > sub = new DebounceTimedObserver < > ( to , 1 , TimeUnit . SECONDS , new TestScheduler ( ) . createWorker ( ) ) ; sub . onSubscribe ( Disposable . empty ( ) ) ; DebounceEmitter < Integer > de = new DebounceEmitter < > ( 1 , 50 , sub ) ; de . run ( ) ; de . run ( ) ; to . assertEmpty ( ) ; 
Observable . error ( new TestException ( ) ) . debounce ( 1 , TimeUnit . SECONDS ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . empty ( ) . debounce ( new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object o ) return Observable . just ( new Object ( ) ) ; ) . subscribe ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . debounce ( 1 , TimeUnit . SECONDS ) ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 , 3 ) ; Observable < Integer > take = w . takeWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer input ) return input < 3 ; ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; take . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , never ( ) ) . onNext ( 3 ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Subject < Integer > s = PublishSubject . create ( ) ; Observable < Integer > take = s . takeWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer input ) return input < 3 ; ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; take . subscribe ( observer ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; s . onNext ( 4 ) ; s . onNext ( 5 ) ; s . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , never ( ) ) . onNext ( 3 ) ; verify ( observer , never ( ) ) . onNext ( 4 ) ; verify ( observer , never ( ) ) . onNext ( 5 ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . just ( "one" , "two" , "three" ) ; Observable < String > take = w . takeWhile ( new Predicate < String > ( ) int index ; @ Override public boolean test ( String input ) return index ++ < 2 ; ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; take . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onError ( new Throwable ( "test failed" ) ) ; ) ; source . takeWhile ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return false ; ) . blockingLast ( "" ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onError ( new Throwable ( "test failed" ) ) ; 
TestObservable source = new TestObservable ( mock ( Disposable . class ) , "one" ) ; final RuntimeException testException = new RuntimeException ( "test exception" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > take = Observable . unsafeCreate ( source ) . takeWhile ( new Predicate < String > ( ) @ Override public boolean test ( String s ) throw testException ; ) ; take . subscribe ( observer ) ; try source . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , times ( 1 ) ) . onError ( testException ) ; 
Disposable upstream = mock ( Disposable . class ) ; TestObservable w = new TestObservable ( upstream , "one" , "two" , "three" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > take = Observable . unsafeCreate ( w ) . takeWhile ( new Predicate < String > ( ) int index ; @ Override public boolean test ( String s ) return index ++ < 1 ; ) ; take . subscribe ( observer ) ; try w . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; System . out . println ( "TestObservable thread finished" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onNext ( "three" ) ; verify ( upstream , times ( 1 ) ) . dispose ( ) ; 
Observable < Integer > source = Observable . range ( 1 , 1000 ) . takeWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertValue ( 1 ) ; 
TestObserverEx < String > to = new TestObserverEx < > ( ) ; Observable . just ( "abc" ) . takeWhile ( new Predicate < String > ( ) @ Override public boolean test ( String t1 ) throw new TestException ( ) ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . takeWhile ( Functions . alwaysTrue ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . takeWhile ( Functions . alwaysTrue ( ) ) ; ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onComplete ( ) ; . takeWhile ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; 
o = new Object ( ) ; WeakReference < Object > wr = new WeakReference < > ( o ) ; TestObserver < Object > to = new TestObserver < > ( ) ; Observable . just ( o ) . count ( ) . toObservable ( ) . onTerminateDetach ( ) . subscribe ( to ) ; to . assertValue ( 1L ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; o = null ; System . gc ( ) ; Thread . sleep ( 200 ) ; Assert . assertNull ( "Object retained!" , wr . get ( ) ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . error ( new TestException ( ) ) . onTerminateDetach ( ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . empty ( ) . onTerminateDetach ( ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . range ( 1 , 1000 ) . onTerminateDetach ( ) . subscribe ( to ) ; to . assertValueCount ( 1000 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
o = new Object ( ) ; WeakReference < Object > wr = new WeakReference < > ( o ) ; TestObserver < Long > to = Observable . just ( o ) . count ( ) . toObservable ( ) . onTerminateDetach ( ) . test ( ) ; o = null ; to . dispose ( ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; Assert . assertNull ( "Object retained!" , wr . get ( ) ) ; 
TestHelper . checkDisposed ( Observable . never ( ) . onTerminateDetach ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . onTerminateDetach ( ) ; ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
Observable < String > observable1 = createObservable ( new String [ ] "1" , "11" , "111" , "1111" , 2000 , null ) ; Observable < String > observable2 = createObservable ( new String [ ] "2" , "22" , "222" , "2222" , 1000 , null ) ; Observable < String > observable3 = createObservable ( new String [ ] "3" , "33" , "333" , "3333" , 3000 , null ) ; Observable < String > o = Observable . ambArray ( observable1 , observable2 , observable3 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( 100000 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "22" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "222" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "2222" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
IOException expectedException = new IOException ( "fake exception" ) ; Observable < String > observable1 = createObservable ( new String [ ] , 2000 , new IOException ( "fake exception" ) ) ; Observable < String > observable2 = createObservable ( new String [ ] "2" , "22" , "222" , "2222" , 1000 , expectedException ) ; Observable < String > observable3 = createObservable ( new String [ ] , 3000 , new IOException ( "fake exception" ) ) ; Observable < String > o = Observable . ambArray ( observable1 , observable2 , observable3 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( 100000 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "22" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "222" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "2222" ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( expectedException ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < String > observable1 = createObservable ( new String [ ] "1" , 2000 , null ) ; Observable < String > observable2 = createObservable ( new String [ ] , 1000 , null ) ; Observable < String > observable3 = createObservable ( new String [ ] "3" , 3000 , null ) ; Observable < String > o = Observable . ambArray ( observable1 , observable2 , observable3 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; scheduler . advanceTimeBy ( 100000 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final AtomicLong count = new AtomicLong ( ) ; Consumer < Disposable > incrementer = new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) count . incrementAndGet ( ) ; ; Observable < Integer > o1 = Observable . just ( 1 ) . doOnSubscribe ( incrementer ) . delay ( 100 , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; Observable < Integer > o2 = Observable . just ( 1 ) . doOnSubscribe ( incrementer ) . delay ( 100 , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . computation ( ) ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . ambArray ( o1 , o2 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 2 , count . get ( ) ) ; 
int result = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) ) . ambWith ( Observable . just ( 2 ) ) . blockingSingle ( ) ; assertEquals ( 1 , result ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; PublishSubject < Integer > source3 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . ambArray ( source1 , source2 , source3 ) . subscribe ( to ) ; assertTrue ( "Source 1 doesn't have subscribers!" , source1 . hasObservers ( ) ) ; assertTrue ( "Source 2 doesn't have subscribers!" , source2 . hasObservers ( ) ) ; assertTrue ( "Source 3 doesn't have subscribers!" , source3 . hasObservers ( ) ) ; source1 . onNext ( 1 ) ; assertTrue ( "Source 1 doesn't have subscribers!" , source1 . hasObservers ( ) ) ; assertFalse ( "Source 2 still has subscribers!" , source2 . hasObservers ( ) ) ; assertFalse ( "Source 2 still has subscribers!" , source3 . hasObservers ( ) ) ; 
assertSame ( Observable . empty ( ) , Observable . ambArray ( ) ) ; 
assertSame ( Observable . never ( ) , Observable . ambArray ( Observable . never ( ) ) ) ; 
Observable < ? > [ ] a = new Observable [ 32 ] ; Arrays . fill ( a , Observable . never ( ) ) ; a [ 31 ] = Observable . just ( 1 ) ; Observable . amb ( Arrays . asList ( a ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . amb ( Collections . < Observable < Integer > > emptyList ( ) ) . test ( ) . assertResult ( ) ; 
Observable . amb ( Collections . singletonList ( Observable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Observable . ambArray ( Observable . never ( ) , Observable . never ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserverEx < Integer > to = Observable . ambArray ( ps1 , ps2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertSubscribed ( ) . assertNoErrors ( ) . assertNotComplete ( ) . assertValueCount ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . ambArray ( ps1 , ps2 ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . ambArray ( ps1 , ps2 ) . test ( ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex ) ; ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestHelper . race ( r1 , r2 ) ; finally RxJavaPlugins . reset ( ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; 
Observable < Integer > error = Observable . error ( new RuntimeException ( ) ) ; Observable . just ( 1 ) . ambWith ( error ) . test ( ) . assertValue ( 1 ) . assertComplete ( ) ; 
Observable < Integer > error = Observable . error ( new RuntimeException ( ) ) ; Observable . amb ( Arrays . asList ( Observable . just ( 1 ) , error ) ) . test ( ) . assertValue ( 1 ) . assertComplete ( ) ; 
Observable < Integer > error = Observable . error ( new RuntimeException ( ) ) ; Observable . ambArray ( Observable . just ( 1 ) , error ) . test ( ) . assertValue ( 1 ) . assertComplete ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable . ambArray ( Observable . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Observable . never ( ) ) . subscribe ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable . ambArray ( Observable . error ( ex ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Observable . never ( ) ) . subscribe ( Functions . emptyConsumer ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable . ambArray ( Observable . empty ( ) . subscribeOn ( Schedulers . single ( ) ) . observeOn ( Schedulers . computation ( ) ) , Observable . never ( ) ) . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) throws Exception interrupted . set ( Thread . currentThread ( ) . isInterrupted ( ) ) ; cdl . countDown ( ) ; ) ; assertTrue ( cdl . await ( 500 , TimeUnit . SECONDS ) ) ; assertFalse ( "Interrupted!" , interrupted . get ( ) ) ; 
ObservableSource < Integer > source = new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) Observable . just ( 1 ) . subscribe ( observer ) ; ; Observable . amb ( Arrays . asList ( source , source ) ) . test ( ) . assertResult ( 1 ) ; 
stringObserver = TestHelper . mockObserver ( ) ; for ( Thread t : Thread . getAllStackTraces ( ) . keySet ( ) ) if ( t . getName ( ) . startsWith ( "RxNewThread" ) ) count ++ ; 
try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; for ( Thread t : Thread . getAllStackTraces ( ) . keySet ( ) ) if ( t . getName ( ) . startsWith ( "RxNewThread" ) ) -- count ; if ( count != 0 ) throw new IllegalStateException ( "NewThread leak!" ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; Observable < Observable < String > > observableOfObservables = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( o1 ) ; observer . onNext ( o2 ) ; observer . onComplete ( ) ; ) ; Observable < String > m = Observable . merge ( observableOfObservables ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( o1 ) ; observer . onNext ( o2 ) ; observer . onComplete ( ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; Observable < String > m = Observable . merge ( o1 , o2 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; List < Observable < String > > listOfObservables = new ArrayList < > ( ) ; listOfObservables . add ( o1 ) ; listOfObservables . add ( o2 ) ; Observable < String > m = Observable . merge ( listOfObservables ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; 
final AtomicBoolean unsubscribed = new AtomicBoolean ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Observable < Observable < Long > > source = Observable . unsafeCreate ( new ObservableSource < Observable < Long > > ( ) @ Override public void subscribe ( final Observer < ? super Observable < Long > > observer ) final Disposable upstream = Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) System . out . println ( "*** unsubscribed" ) ; unsubscribed . set ( true ) ; ) ; observer . onSubscribe ( upstream ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) while ( ! unsubscribed . get ( ) ) observer . onNext ( Observable . just ( 1L , 2L ) ) ; System . out . println ( "Done looping after unsubscribe: " + unsubscribed . get ( ) ) ; observer . onComplete ( ) ; latch . countDown ( ) ; ) . start ( ) ; ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( source ) . take ( 6 ) . blockingForEach ( new Consumer < Long > ( ) @ Override public void accept ( Long v ) System . out . println ( "Value: " + v ) ; int c = count . incrementAndGet ( ) ; if ( c > 6 ) fail ( "Should be only 6" ) ; ) ; latch . await ( 1000 , TimeUnit . MILLISECONDS ) ; System . out . println ( "unsubscribed: " + unsubscribed . get ( ) ) ; assertTrue ( unsubscribed . get ( ) ) ; 
final Disposable upstream = Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) System . out . println ( "*** unsubscribed" ) ; unsubscribed . set ( true ) ; ) ; observer . onSubscribe ( upstream ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) while ( ! unsubscribed . get ( ) ) observer . onNext ( Observable . just ( 1L , 2L ) ) ; System . out . println ( "Done looping after unsubscribe: " + unsubscribed . get ( ) ) ; observer . onComplete ( ) ; latch . countDown ( ) ; ) . start ( ) ; 
final TestASynchronousObservable o1 = new TestASynchronousObservable ( ) ; final TestASynchronousObservable o2 = new TestASynchronousObservable ( ) ; Observable < String > m = Observable . merge ( Observable . unsafeCreate ( o1 ) , Observable . unsafeCreate ( o2 ) ) ; TestObserver < String > to = new TestObserver < > ( stringObserver ) ; m . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) System . out . println ( "testSynchronizationOfMultipleSequencesLoop > " + i ) ; synchronizationOfMultipleSequences ( ) ; 
final TestASynchronousObservable o1 = new TestASynchronousObservable ( ) ; final TestASynchronousObservable o2 = new TestASynchronousObservable ( ) ; final CountDownLatch endLatch = new CountDownLatch ( 1 ) ; final AtomicInteger concurrentCounter = new AtomicInteger ( ) ; final AtomicInteger totalCounter = new AtomicInteger ( ) ; Observable < String > m = Observable . merge ( Observable . unsafeCreate ( o1 ) , Observable . unsafeCreate ( o2 ) ) ; m . subscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new RuntimeException ( "failed" , e ) ; @ Override public void onNext ( String v ) totalCounter . incrementAndGet ( ) ; concurrentCounter . incrementAndGet ( ) ; try if ( Thread . currentThread ( ) . getName ( ) . equals ( "TestASynchronousObservable" ) ) endLatch . await ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; throw new RuntimeException ( "failed" , e ) ; finally concurrentCounter . decrementAndGet ( ) ; ) ; o1 . onNextBeingSent . await ( ) ; o2 . onNextBeingSent . await ( ) ; int timeout = 20 ; while ( timeout -- > 0 && concurrentCounter . get ( ) != 1 ) Thread . sleep ( 100 ) ; try assertEquals ( 1 , concurrentCounter . get ( ) ) ; finally endLatch . countDown ( ) ; try o1 . t . join ( ) ; o2 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertEquals ( 2 , totalCounter . get ( ) ) ; assertEquals ( 0 , concurrentCounter . get ( ) ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestErrorObservable ( "four" , null , "six" ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestErrorObservable ( "one" , "two" , "three" ) ) ; Observable < String > m = Observable . merge ( o1 , o2 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "one" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "two" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "three" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "five" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "six" ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestErrorObservable ( "one" , "two" , "three" ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestErrorObservable ( "four" , null , "six" ) ) ; final Observable < String > o3 = Observable . unsafeCreate ( new TestErrorObservable ( "seven" , "eight" , null ) ) ; final Observable < String > o4 = Observable . unsafeCreate ( new TestErrorObservable ( "nine" ) ) ; Observable < String > m = Observable . merge ( o1 , o2 , o3 , o4 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "five" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "six" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "seven" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "eight" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "nine" ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "hello" ) ; observer . onComplete ( ) ; 
TestScheduler scheduler1 = new TestScheduler ( ) ; AtomicBoolean os1 = new AtomicBoolean ( false ) ; Observable < Long > o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler1 , os1 ) ; TestScheduler scheduler2 = new TestScheduler ( ) ; AtomicBoolean os2 = new AtomicBoolean ( false ) ; Observable < Long > o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler2 , os2 ) ; TestObserverEx < Long > to = new TestObserverEx < > ( ) ; Observable . merge ( o1 , o2 ) . subscribe ( to ) ; to . assertNoValues ( ) ; scheduler1 . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; scheduler2 . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; to . assertValues ( 0L , 1L , 2L , 0L , 1L ) ; assertFalse ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; scheduler1 . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; to . assertValues ( 0L , 1L , 2L , 0L , 1L , 3L , 4L ) ; assertTrue ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; scheduler2 . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; to . assertValues ( 0L , 1L , 2L , 0L , 1L , 3L , 4L , 2L , 3L , 4L ) ; assertTrue ( os1 . get ( ) ) ; assertTrue ( os2 . get ( ) ) ; to . assertTerminated ( ) ; 
for ( int i = 0 ; i < 10 ; i ++ ) TestScheduler scheduler1 = new TestScheduler ( ) ; AtomicBoolean os1 = new AtomicBoolean ( false ) ; Observable < Long > o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler1 , os1 ) ; TestScheduler scheduler2 = new TestScheduler ( ) ; AtomicBoolean os2 = new AtomicBoolean ( false ) ; Observable < Long > o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook ( scheduler2 , os2 ) ; TestObserver < Long > to = new TestObserver < > ( ) ; Observable . merge ( o1 , o2 ) . subscribe ( to ) ; to . assertNoValues ( ) ; scheduler1 . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; scheduler2 . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; to . assertValues ( 0L , 1L , 2L , 0L , 1L ) ; assertFalse ( os1 . get ( ) ) ; assertFalse ( os2 . get ( ) ) ; to . dispose ( ) ; assertTrue ( os1 . get ( ) ) ; assertTrue ( os2 . get ( ) ) ; to . assertValues ( 0L , 1L , 2L , 0L , 1L ) ; 
return Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( final Observer < ? super Long > child ) Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 5 ) . subscribe ( new Observer < Long > ( ) @ Override public void onSubscribe ( final Disposable d ) child . onSubscribe ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; d . dispose ( ) ; ) ) ; @ Override public void onNext ( Long t ) child . onNext ( t ) ; @ Override public void onError ( Throwable t ) unsubscribed . set ( true ) ; child . onError ( t ) ; @ Override public void onComplete ( ) unsubscribed . set ( true ) ; child . onComplete ( ) ; ) ; ) ; 
Observable < Integer > o = Observable . range ( 1 , 10000 ) . subscribeOn ( Schedulers . newThread ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) Observable < Integer > merge = Observable . merge ( o , o , o ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; merge . subscribe ( to ) ; to . awaitDone ( 3 , TimeUnit . SECONDS ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; List < Integer > onNextEvents = to . values ( ) ; assertEquals ( 30000 , onNextEvents . size ( ) ) ; 
Observable < Integer > o = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( final Observer < ? super Integer > observer ) Worker inner = Schedulers . newThread ( ) . createWorker ( ) ; final CompositeDisposable as = new CompositeDisposable ( ) ; as . add ( Disposable . empty ( ) ) ; as . add ( inner ) ; observer . onSubscribe ( as ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) try for ( int i = 0 ; i < 100 ; i ++ ) observer . onNext ( 1 ) ; try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; catch ( Exception e ) observer . onError ( e ) ; as . dispose ( ) ; observer . onComplete ( ) ; ) ; ) ; for ( int i = 0 ; i < 10 ; i ++ ) Observable < Integer > merge = Observable . merge ( o , o , o ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; merge . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertComplete ( ) ; List < Integer > onNextEvents = to . values ( ) ; assertEquals ( 300 , onNextEvents . size ( ) ) ; 
Observable < Integer > o = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( final Observer < ? super Integer > observer ) Worker inner = Schedulers . newThread ( ) . createWorker ( ) ; final CompositeDisposable as = new CompositeDisposable ( ) ; as . add ( Disposable . empty ( ) ) ; as . add ( inner ) ; observer . onSubscribe ( as ) ; inner . schedule ( new Runnable ( ) @ Override public void run ( ) try for ( int i = 0 ; i < 10000 ; i ++ ) observer . onNext ( i ) ; catch ( Exception e ) observer . onError ( e ) ; as . dispose ( ) ; observer . onComplete ( ) ; observer . onComplete ( ) ; observer . onComplete ( ) ; ) ; ) ; for ( int i = 0 ; i < 10 ; i ++ ) Observable < Integer > merge = Observable . merge ( o , o , o ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; merge . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; List < Integer > onNextEvents = to . values ( ) ; assertEquals ( 30000 , onNextEvents . size ( ) ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Integer > o1 = createInfiniteObservable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; final AtomicInteger generated2 = new AtomicInteger ( ) ; Observable < Integer > o2 = createInfiniteObservable ( generated2 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestObserverEx < Integer > testObserver = new TestObserverEx < Integer > ( ) @ Override public void onNext ( Integer t ) System . err . println ( "TestObserver received => " + t + "  on thread " + Thread . currentThread ( ) ) ; super . onNext ( t ) ; ; Observable . merge ( o1 . take ( Flowable . bufferSize ( ) * 2 ) , o2 . take ( Flowable . bufferSize ( ) * 2 ) ) . subscribe ( testObserver ) ; testObserver . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( testObserver . errors ( ) . size ( ) > 0 ) testObserver . errors ( ) . get ( 0 ) . printStackTrace ( ) ; testObserver . assertNoErrors ( ) ; System . err . println ( testObserver . values ( ) ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , testObserver . values ( ) . size ( ) ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) ) ; System . out . println ( "Generated 2: " + generated2 . get ( ) ) ; assertTrue ( generated1 . get ( ) >= Flowable . bufferSize ( ) * 2 && generated1 . get ( ) <= Flowable . bufferSize ( ) * 4 ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) System . err . flush ( ) ; System . out . println ( "---" ) ; System . out . flush ( ) ; backpressureUpstream2 ( ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Integer > o1 = createInfiniteObservable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestObserverEx < Integer > testObserver = new TestObserverEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ; Observable . merge ( o1 . take ( Flowable . bufferSize ( ) * 2 ) , Observable . just ( - 99 ) ) . subscribe ( testObserver ) ; testObserver . awaitDone ( 5 , TimeUnit . SECONDS ) ; List < Integer > onNextEvents = testObserver . values ( ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) + " / received: " + onNextEvents . size ( ) ) ; System . out . println ( onNextEvents ) ; if ( testObserver . errors ( ) . size ( ) > 0 ) testObserver . errors ( ) . get ( 0 ) . printStackTrace ( ) ; testObserver . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 + 1 , onNextEvents . size ( ) ) ; assertTrue ( generated1 . get ( ) >= Flowable . bufferSize ( ) * 2 && generated1 . get ( ) <= Flowable . bufferSize ( ) * 3 ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Integer > o1 = createInfiniteObservable ( generated1 ) . subscribeOn ( Schedulers . computation ( ) ) ; final AtomicInteger generated2 = new AtomicInteger ( ) ; Observable < Integer > o2 = createInfiniteObservable ( generated2 ) . subscribeOn ( Schedulers . computation ( ) ) ; TestObserverEx < Integer > to = new TestObserverEx < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t < 100 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; super . onNext ( t ) ; ; Observable . merge ( o1 . take ( Flowable . bufferSize ( ) * 2 ) , o2 . take ( Flowable . bufferSize ( ) * 2 ) ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( to . errors ( ) . size ( ) > 0 ) to . errors ( ) . get ( 0 ) . printStackTrace ( ) ; to . assertNoErrors ( ) ; System . err . println ( to . values ( ) ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , to . values ( ) . size ( ) ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) ) ; System . out . println ( "Generated 2: " + generated2 . get ( ) ) ; assertTrue ( generated1 . get ( ) >= Flowable . bufferSize ( ) * 2 && generated1 . get ( ) <= Flowable . bufferSize ( ) * 4 ) ; 
final AtomicInteger generated1 = new AtomicInteger ( ) ; Observable < Observable < Integer > > o1 = createInfiniteObservable ( generated1 ) . map ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return Observable . just ( 1 , 2 , 3 ) ; ) ; TestObserverEx < Integer > to = new TestObserverEx < Integer > ( ) int i ; @ Override public void onNext ( Integer t ) if ( i ++ < 400 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; super . onNext ( t ) ; ; Observable . merge ( o1 ) . observeOn ( Schedulers . computation ( ) ) . take ( Flowable . bufferSize ( ) * 2 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( to . errors ( ) . size ( ) > 0 ) to . errors ( ) . get ( 0 ) . printStackTrace ( ) ; to . assertNoErrors ( ) ; System . out . println ( "Generated 1: " + generated1 . get ( ) ) ; System . err . println ( to . values ( ) ) ; System . out . println ( "done1 testBackpressureBothUpstreamAndDownstreamWithRegularObservables " ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , to . values ( ) . size ( ) ) ; System . out . println ( "done2 testBackpressureBothUpstreamAndDownstreamWithRegularObservables " ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNAsyncStreamsOfN ( 1 , 1 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 1 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNAsyncStreamsOfN ( 1 , 1000 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 1000 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNAsyncStreamsOfN ( 10 , 1000 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 10000 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNAsyncStreamsOfN ( 1000 , 1000 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 1000000 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNAsyncStreamsOfN ( 2000 , 100 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 200000 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNAsyncStreamsOfN ( 100 , 1 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 100 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNSyncStreamsOfN ( 1 , 1 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 1 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNSyncStreamsOfN ( 1 , 1000000 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 1000000 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNSyncStreamsOfN ( 1000 , 1000 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 1000000 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNSyncStreamsOfN ( 10000 , 10 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 100000 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; mergeNSyncStreamsOfN ( 1000000 , 1 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 1000000 , to . values ( ) . size ( ) ) ; 
Observable < Integer > o = Observable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) @ Override public Integer next ( ) return generated . getAndIncrement ( ) ; @ Override public boolean hasNext ( ) return true ; ; ) ; return o ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable < Observable < Integer > > os = Observable . range ( 1 , 10000 ) . map ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( final Integer i ) return Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; if ( i < 500 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; observer . onNext ( i ) ; observer . onComplete ( ) ; ) . subscribeOn ( Schedulers . computation ( ) ) . cache ( ) ; ) ; Observable . merge ( os ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 10000 , to . values ( ) . size ( ) ) ; 
List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) list . add ( i ) ; Observable < Integer > source = Observable . fromIterable ( list ) ; source . flatMap ( func ) . subscribe ( to ) ; if ( to . values ( ) . size ( ) != 1000 ) System . out . println ( to . values ( ) ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; to . assertValueSequence ( list ) ; 
runMerge ( toScalar , new TestObserverEx < > ( ) ) ; 
runMerge ( toHiddenScalar , new TestObserverEx < > ( ) ) ; 
for ( final int req : new int [ ] 16 , 32 , 64 , 128 , 256 ) TestObserverEx < Integer > to = new TestObserverEx < Integer > ( ) int remaining = req ; @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( -- remaining == 0 ) remaining = req ; ; runMerge ( toScalar , to ) ; 
for ( final int req : new int [ ] 16 , 32 , 64 , 128 , 256 ) TestObserverEx < Integer > to = new TestObserverEx < Integer > ( ) int remaining = req ; @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( -- remaining == 0 ) remaining = req ; ; runMerge ( toHiddenScalar , to ) ; 
Observable . mergeArray ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable < Integer > source1 = Observable . error ( new TestException ( "First" ) ) ; Observable < Integer > source2 = Observable . error ( new TestException ( "Second" ) ) ; Observable . merge ( source1 , source2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Callable < Object > func = mock ( Callable . class ) ; when ( func . call ( ) ) . thenReturn ( new Object ( ) ) ; Observable < Object > fromCallableObservable = Observable . fromCallable ( func ) ; verifyNoInteractions ( func ) ; fromCallableObservable . subscribe ( ) ; verify ( func ) . call ( ) ; 
Callable < String > func = mock ( Callable . class ) ; when ( func . call ( ) ) . thenReturn ( "test_value" ) ; Observable < String > fromCallableObservable = Observable . fromCallable ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; fromCallableObservable . subscribe ( observer ) ; verify ( observer ) . onNext ( "test_value" ) ; verify ( observer ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Callable < Object > func = mock ( Callable . class ) ; Throwable throwable = new IllegalStateException ( "Test exception" ) ; when ( func . call ( ) ) . thenThrow ( throwable ) ; Observable < Object > fromCallableObservable = Observable . fromCallable ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; fromCallableObservable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer ) . onError ( throwable ) ; 
Callable < String > func = mock ( Callable . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . call ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Observable < String > fromCallableObservable = Observable . fromCallable ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; TestObserver < String > outer = new TestObserver < > ( observer ) ; fromCallableObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . dispose ( ) ; funcLatch . countDown ( ) ; verify ( func ) . call ( ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verifyNoMoreInteractions ( observer ) ; 
final Exception checkedException = new Exception ( "test exception" ) ; Observable < Object > fromCallableObservable = Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw checkedException ; ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; fromCallableObservable . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verify ( observer ) . onError ( checkedException ) ; verifyNoMoreInteractions ( observer ) ; 
final int [ ] calls = 0 ; Observable . just ( 1 ) . flatMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return ++ calls [ 0 ] ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Observable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return ++ calls [ 0 ] ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
Observable . just ( 1 ) . flatMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return null ; ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return null ; ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
final int [ ] count = 0 ; Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception count [ 0 ] ++ ; return 1 ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , count [ 0 ] ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception to . dispose ( ) ; return 1 ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception to . dispose ( ) ; throw new TestException ( ) ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return 1 ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; ObserverResourceWrapper < Object > orw = new ObserverResourceWrapper < > ( to ) ; Disposable d = Disposable . empty ( ) ; orw . onSubscribe ( d ) ; assertFalse ( orw . isDisposed ( ) ) ; orw . dispose ( ) ; assertTrue ( orw . isDisposed ( ) ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; ObserverResourceWrapper < Object > orw = new ObserverResourceWrapper < > ( to ) ; TestHelper . doubleOnSubscribe ( orw ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; ObserverResourceWrapper < Object > orw = new ObserverResourceWrapper < > ( to ) ; Disposable d = Disposable . empty ( ) ; Disposable d1 = Disposable . empty ( ) ; orw . setResource ( d1 ) ; orw . onSubscribe ( d ) ; orw . onError ( new TestException ( ) ) ; assertTrue ( d1 . isDisposed ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Object > other = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Observable . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( to ) ; to . assertNotComplete ( ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onNext ( 1 ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
PublishSubject < Object > other = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Observable . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( to ) ; to . assertNotComplete ( ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onNext ( 1 ) ; other . onNext ( 2 ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
PublishSubject < Object > other = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Observable . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( to ) ; to . assertNotComplete ( ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onComplete ( ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
PublishSubject < Object > other = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Observable . < Integer > error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( to ) ; to . assertNotComplete ( ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onComplete ( ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( TestException . class ) ; 
PublishSubject < Object > other = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Observable . < Integer > error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( to ) ; to . assertNotComplete ( ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onError ( new TestException ( ) ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( TestException . class ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > o ) throws Exception return Observable . just ( 1 ) . delaySubscription ( o ) ; , false , 1 , 1 , 1 ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try for ( Scheduler s : new Scheduler [ ] Schedulers . single ( ) , Schedulers . computation ( ) , Schedulers . newThread ( ) , Schedulers . io ( ) , Schedulers . from ( exec ) ) final TestObserver < Boolean > observer = TestObserver . create ( ) ; observer . withTag ( s . getClass ( ) . getSimpleName ( ) ) ; Observable . < Boolean > create ( new ObservableOnSubscribe < Boolean > ( ) @ Override public void subscribe ( ObservableEmitter < Boolean > emitter ) throws Exception emitter . onNext ( Thread . interrupted ( ) ) ; emitter . onComplete ( ) ; ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , s ) . subscribe ( observer ) ; observer . awaitDone ( 5 , TimeUnit . SECONDS ) ; observer . assertValue ( false ) ; finally exec . shutdown ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; ConnectableObservable < String > o = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; observer . onNext ( "one" ) ; observer . onComplete ( ) ; ) . start ( ) ; ) . publish ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; latch . countDown ( ) ; ) ; Disposable connection = o . connect ( ) ; try if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; finally connection . dispose ( ) ; 
ConnectableObservable < Integer > is = Observable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . publish ( ) ; Observable < Integer > fast = is . observeOn ( Schedulers . computation ( ) ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "^^^^^^^^^^^^^ completed FAST" ) ; ) ; Observable < Integer > slow = is . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer i ) if ( c == 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) c ++ ; return i ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "^^^^^^^^^^^^^ completed SLOW" ) ; ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . merge ( fast , slow ) . subscribe ( to ) ; is . connect ( ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , to . values ( ) . size ( ) ) ; 
final AtomicInteger emitted = new AtomicInteger ( ) ; Observable < Integer > xs = Observable . range ( 0 , Flowable . bufferSize ( ) * 2 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) emitted . incrementAndGet ( ) ; ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; xs . publish ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > xs ) return xs . takeUntil ( xs . skipWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i <= 3 ; ) ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertValues ( 0 , 1 , 2 , 3 ) ; assertEquals ( 5 , emitted . get ( ) ) ; System . out . println ( to . values ( ) ) ; 
Observable < Integer > xs = Observable . range ( 0 , Flowable . bufferSize ( ) * 2 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; ConnectableObservable < Integer > xsp = xs . publish ( ) ; xsp . takeUntil ( xsp . skipWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i <= 3 ; ) ) . subscribe ( to ) ; xsp . connect ( ) ; System . out . println ( to . values ( ) ) ; 
final AtomicInteger sourceEmission = new AtomicInteger ( ) ; final AtomicBoolean sourceUnsubscribed = new AtomicBoolean ( ) ; final Observable < Integer > source = Observable . range ( 1 , 100 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) sourceEmission . incrementAndGet ( ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) sourceUnsubscribed . set ( true ) ; ) . share ( ) ; ; final AtomicBoolean child1Unsubscribed = new AtomicBoolean ( ) ; final AtomicBoolean child2Unsubscribed = new AtomicBoolean ( ) ; final TestObserver < Integer > to2 = new TestObserver < > ( ) ; final TestObserver < Integer > to1 = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( values ( ) . size ( ) == 2 ) source . doOnDispose ( new Action ( ) @ Override public void run ( ) child2Unsubscribed . set ( true ) ; ) . take ( 5 ) . subscribe ( to2 ) ; super . onNext ( t ) ; ; source . doOnDispose ( new Action ( ) @ Override public void run ( ) child1Unsubscribed . set ( true ) ; ) . take ( 5 ) . subscribe ( to1 ) ; to1 . awaitDone ( 5 , TimeUnit . SECONDS ) ; to2 . awaitDone ( 5 , TimeUnit . SECONDS ) ; to1 . assertNoErrors ( ) ; to2 . assertNoErrors ( ) ; assertTrue ( sourceUnsubscribed . get ( ) ) ; assertTrue ( child1Unsubscribed . get ( ) ) ; assertTrue ( child2Unsubscribed . get ( ) ) ; to1 . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; to2 . assertValues ( 4 , 5 , 6 , 7 , 8 ) ; assertEquals ( 8 , sourceEmission . get ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; ConnectableObservable < Long > co = Observable . interval ( 10 , 10 , TimeUnit . MILLISECONDS , scheduler ) . take ( 3 ) . publish ( ) ; co . connect ( ) ; scheduler . advanceTimeBy ( 15 , TimeUnit . MILLISECONDS ) ; TestObserverEx < Long > to = new TestObserverEx < > ( ) ; co . subscribe ( to ) ; scheduler . advanceTimeBy ( 50 , TimeUnit . MILLISECONDS ) ; to . assertValues ( 1L , 2L ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; 
ConnectableObservable < Integer > source = Observable . just ( 1 ) . publish ( ) ; TestObserverEx < Integer > to1 = new TestObserverEx < > ( ) ; source . subscribe ( to1 ) ; Disposable connection = source . connect ( ) ; to1 . assertValue ( 1 ) ; to1 . assertNoErrors ( ) ; to1 . assertTerminated ( ) ; source . reset ( ) ; TestObserverEx < Integer > to2 = new TestObserverEx < > ( ) ; source . subscribe ( to2 ) ; Disposable connection2 = source . connect ( ) ; to2 . assertValue ( 1 ) ; to2 . assertNoErrors ( ) ; to2 . assertTerminated ( ) ; System . out . println ( connection ) ; System . out . println ( connection2 ) ; 
ObservablePublish < Integer > source = ( ObservablePublish < Integer > ) Observable . just ( 1 ) . publish ( ) ; TestObserverEx < Integer > to1 = new TestObserverEx < > ( ) ; source . subscribe ( to1 ) ; to1 . assertNoValues ( ) ; to1 . assertNoErrors ( ) ; to1 . assertNotComplete ( ) ; source . connect ( ) ; to1 . assertValue ( 1 ) ; to1 . assertNoErrors ( ) ; to1 . assertTerminated ( ) ; assertEquals ( 0 , source . current . get ( ) . get ( ) . length ) ; 
ConnectableObservable < Object > source = Observable . never ( ) . publish ( ) ; assertNotNull ( source . connect ( ) ) ; assertNotNull ( source . connect ( ) ) ; 
ConnectableObservable < Object > source = Observable . never ( ) . publish ( ) ; Disposable connection1 = source . connect ( ) ; Disposable connection2 = source . connect ( ) ; connection1 . dispose ( ) ; Disposable connection3 = source . connect ( ) ; connection2 . dispose ( ) ; assertTrue ( checkPublishDisposed ( connection1 ) ) ; assertTrue ( checkPublishDisposed ( connection2 ) ) ; assertFalse ( checkPublishDisposed ( connection3 ) ) ; 
return ( ( ObservablePublish . PublishConnection < Object > ) d ) . isDisposed ( ) ; 
final AtomicInteger calls = new AtomicInteger ( ) ; Observable < Integer > source = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > t ) t . onSubscribe ( Disposable . empty ( ) ) ; calls . getAndIncrement ( ) ; ) ; ConnectableObservable < Integer > conn = source . publish ( ) ; assertEquals ( 0 , calls . get ( ) ) ; conn . connect ( ) ; conn . connect ( ) ; assertEquals ( 1 , calls . get ( ) ) ; conn . connect ( ) . dispose ( ) ; conn . connect ( ) ; conn . connect ( ) ; assertEquals ( 2 , calls . get ( ) ) ; 
ConnectableObservable < Integer > co = Observable . range ( 0 , 1000 ) . publish ( ) ; Observable < Integer > obs = co . observeOn ( Schedulers . computation ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) for ( int j = 1 ; j < 6 ; j ++ ) List < TestObserverEx < Integer > > tos = new ArrayList < > ( ) ; for ( int k = 1 ; k < j ; k ++ ) TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; tos . add ( to ) ; obs . subscribe ( to ) ; Disposable connection = co . connect ( ) ; for ( TestObserverEx < Integer > to : tos ) to . awaitDone ( 2 , TimeUnit . SECONDS ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; assertEquals ( 1000 , to . values ( ) . size ( ) ) ; connection . dispose ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . < Integer > empty ( ) . publish ( ) ; co . connect ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . test ( ) ; ; TestHelper . race ( r1 , r1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . < Integer > empty ( ) . publish ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . connect ( ) ; ; TestHelper . race ( r1 , r1 ) ; 
Observable . just ( 1 ) . publish ( new Function < Observable < Integer > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Integer > v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable < Integer > o = Observable . never ( ) ; assertSame ( o , ( ( ( HasUpstreamObservableSource < ? > ) o . publish ( ) ) . source ( ) ) ) ; 
ConnectableObservable < Integer > co = Observable . < Integer > empty ( ) . publish ( ) ; try co . connect ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( ) ; ) ; catch ( TestException ex ) 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . < Integer > empty ( ) . publish ( ) ; final TestObserver < Integer > to = co . test ( ) ; final TestObserver < Integer > to2 = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
ConnectableObservable < Integer > co = Observable . < Integer > empty ( ) . publish ( ) ; co . test ( true ) . assertEmpty ( ) ; 
TestHelper . checkDisposed ( Observable . never ( ) . publish ( ) ) ; TestHelper . checkDisposed ( Observable . never ( ) . publish ( Functions . < Observable < Object > > identity ( ) ) ) ; 
ConnectableObservable < Integer > co = Observable . < Integer > empty ( ) . publish ( ) ; co . connect ( ) ; 
ConnectableObservable < Integer > co = Observable . range ( 1 , 2 ) . publish ( ) ; TestObserver < Integer > to = co . take ( 1 ) . test ( ) ; co . connect ( ) ; to . assertResult ( 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = ps . publish ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ps . onComplete ( ) ; ; co . subscribe ( to ) ; co . connect ( ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final ConnectableObservable < Integer > co = ps . publish ( ) ; final TestObserver < Integer > to = co . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . publish ( ) . autoConnect ( ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ConnectableObservable < Object > co = Observable . error ( new TestException ( ) ) . publish ( ) ; co . connect ( ) ; co . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final ConnectableObservable < Integer > co = ps . publish ( ) ; final Disposable d = co . connect ( ) ; final TestObserver < Integer > to = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) d . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to ) ; ; TestHelper . race ( r1 , r2 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . publish ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return Observable . range ( 1 , 2 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; assertFalse ( ps . hasObservers ( ) ) ; 
Observable . range ( 1 , 5 ) . publish ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return v . concatWith ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . error ( new TestException ( ) ) . publish ( Functions . < Observable < Object > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . publish ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return Observable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
final Observer < ? > [ ] sub = null ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) sub [ 0 ] = observer ; . publish ( ) . connect ( ) . dispose ( ) ; Disposable bs = Disposable . empty ( ) ; sub [ 0 ] . onSubscribe ( bs ) ; assertTrue ( bs . isDisposed ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( final Observable < Object > o ) throws Exception return Observable . < Integer > never ( ) . publish ( new Function < Observable < Integer > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Integer > v ) throws Exception return o ; ) ; ) ; 
ConnectableObservable < Integer > co = Observable . just ( 1 ) . concatWith ( Observable . < Integer > never ( ) ) . publish ( ) ; TestObserver < Integer > to1 = co . test ( ) ; TestObserver < Integer > to2 = co . test ( true ) ; co . connect ( ) ; to1 . assertValuesOnly ( 1 ) ; to2 . assertEmpty ( ) ; ( ( ObservablePublish < Integer > ) co ) . current . get ( ) . remove ( null ) ; 
try new ObservablePublish < > ( Observable . < Integer > empty ( ) ) . connect ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable t ) throws Exception throw new TestException ( ) ; ) ; fail ( "Should have thrown" ) ; catch ( TestException expected ) 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = new ObservablePublish < > ( Observable . < Integer > never ( ) ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) co . connect ( ) ; ; TestHelper . race ( r , r ) ; 
ConnectableObservable < Integer > co = Observable . just ( 1 ) . publish ( ) ; TestObserver < Integer > to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertResult ( 1 ) ; co . test ( ) . assertResult ( ) ; co . reset ( ) ; to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertResult ( 1 ) ; 
ConnectableObservable < Integer > co = Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . publish ( ) ; TestObserver < Integer > to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertFailure ( TestException . class , 1 ) ; co . test ( ) . assertFailure ( TestException . class ) ; co . reset ( ) ; to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertFailure ( TestException . class , 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = ps . publish ( ) ; assertFalse ( ps . hasObservers ( ) ) ; Disposable d = co . connect ( ) ; assertTrue ( ps . hasObservers ( ) ) ; d . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; TestObserver < Integer > to = co . test ( ) ; co . connect ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertValuesOnly ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = ps . publish ( ) ; TestObserver < Integer > to = co . test ( ) ; Disposable d = co . connect ( ) ; ps . onNext ( 1 ) ; d . dispose ( ) ; to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertEmpty ( ) ; ps . onNext ( 2 ) ; to . assertValuesOnly ( 2 ) ; 
final Disposable d = Disposable . empty ( ) ; Observable . < Integer > create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onComplete ( ) ; e . onError ( new TestException ( ) ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertTrue ( d . isDisposed ( ) ) ; 
final Disposable d1 = Disposable . empty ( ) ; final Disposable d2 = Disposable . empty ( ) ; Observable . < Integer > create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > e ) throws Exception e . setDisposable ( d1 ) ; e . setCancellable ( new Cancellable ( ) @ Override public void cancel ( ) throws Exception d2 . dispose ( ) ; ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onComplete ( ) ; e . onError ( new TestException ( ) ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; 
final Disposable d = Disposable . empty ( ) ; Observable . < Integer > create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; assertTrue ( d . isDisposed ( ) ) ; 
final Disposable d = Disposable . empty ( ) ; Observable . < Integer > create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; e . setDisposable ( d ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onComplete ( ) ; e . onError ( new TestException ( ) ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertTrue ( d . isDisposed ( ) ) ; 
final Disposable d = Disposable . empty ( ) ; Observable . < Integer > create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; e . setDisposable ( d ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; assertTrue ( d . isDisposed ( ) ) ; 
Observable . wrap ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onNext ( 3 ) ; observer . onNext ( 4 ) ; observer . onNext ( 5 ) ; observer . onComplete ( ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onNext ( 3 ) ; observer . onNext ( 4 ) ; observer . onNext ( 5 ) ; observer . onComplete ( ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . unsafeCreate ( Observable . just ( 1 ) ) ; 
final Throwable [ ] error = null ; Observable . create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > e ) throws Exception try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; 
final Throwable [ ] error = null ; Observable . create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception e . onNext ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception e . onError ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception e . serialize ( ) . onNext ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception e . serialize ( ) . onError ( null ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onError ( new IOException ( ) ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; ) . subscribe ( new Observer < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onComplete ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; ) . subscribe ( new Observer < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception ObservableEmitter < Object > f = e . serialize ( ) ; assertSame ( f , f . serialize ( ) ) ; assertFalse ( f . isDisposed ( ) ) ; final int [ ] calls = 0 ; f . setCancellable ( new Cancellable ( ) @ Override public void cancel ( ) throws Exception calls [ 0 ] ++ ; ) ; e . onComplete ( ) ; assertTrue ( f . isDisposed ( ) ) ; assertEquals ( 1 , calls [ 0 ] ) ; ) . test ( ) . assertResult ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception final ObservableEmitter < Object > f = e . serialize ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) f . onNext ( 1 ) ; ; TestHelper . race ( r1 , r1 ) ; ) . take ( TestHelper . RACE_DEFAULT_LOOPS ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( TestHelper . RACE_DEFAULT_LOOPS ) . assertComplete ( ) . assertNoErrors ( ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception final ObservableEmitter < Object > f = e . serialize ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 1000 ; i ++ ) f . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 100 ; i ++ ) f . onNext ( 1 ) ; f . onError ( new TestException ( ) ) ; ; TestHelper . race ( r1 , r2 ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertSubscribed ( ) . assertNotComplete ( ) . assertError ( TestException . class ) ; 
TestObserverEx < Object > to = Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception final ObservableEmitter < Object > f = e . serialize ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 1000 ; i ++ ) f . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 100 ; i ++ ) f . onNext ( 1 ) ; f . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertSubscribed ( ) . assertComplete ( ) . assertNoErrors ( ) ; int c = to . values ( ) . size ( ) ; assertTrue ( "" + c , c >= 100 ) ; 
Observable < Object > source = Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception final ObservableEmitter < Object > f = e . serialize ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) f . onError ( null ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) f . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) source . test ( ) . assertFailure ( Throwable . class ) ; finally RxJavaPlugins . reset ( ) ; assertFalse ( errors . isEmpty ( ) ) ; 
Observable < Object > source = Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception final ObservableEmitter < Object > f = e . serialize ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) f . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) f . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) source . test ( ) . assertResult ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Boolean [ ] response = null ; Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception e . onNext ( 1 ) ; response [ 0 ] = e . tryOnError ( new TestException ( ) ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; assertFalse ( response [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Boolean [ ] response = null ; Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception e = e . serialize ( ) ; e . onNext ( 1 ) ; response [ 0 ] = e . tryOnError ( new TestException ( ) ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; assertFalse ( response [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > emitter ) throws Exception assertTrue ( emitter . toString ( ) . contains ( ObservableCreate . CreateEmitter . class . getSimpleName ( ) ) ) ; assertTrue ( emitter . serialize ( ) . toString ( ) . contains ( ObservableCreate . CreateEmitter . class . getSimpleName ( ) ) ) ; ) . test ( ) . assertEmpty ( ) ; 
Observable . create ( emitter -> emitter . serialize ( ) . onComplete ( ) ) . test ( ) . assertResult ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . create ( emitter -> to . dispose ( ) ; emitter . serialize ( ) . onNext ( 1 ) ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . create ( emitter -> emitter = emitter . serialize ( ) ; emitter . onComplete ( ) ; emitter . onNext ( 1 ) ; ) . subscribe ( to ) ; to . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; AtomicReference < ObservableEmitter < Integer > > ref = new AtomicReference < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable . < Integer > create ( emitter -> emitter = emitter . serialize ( ) ; ref . set ( emitter ) ; emitter . onNext ( 1 ) ; ) . doOnNext ( v -> if ( v == 1 ) TestHelper . raceOther ( ( ) -> ref . get ( ) . onNext ( 2 ) ; , cdl ) ; ref . get ( ) . onNext ( 3 ) ; ) . subscribe ( to ) ; cdl . await ( ) ; to . assertValueCount ( 3 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; AtomicReference < ObservableEmitter < Integer > > ref = new AtomicReference < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observable . < Integer > create ( emitter -> emitter = emitter . serialize ( ) ; ref . set ( emitter ) ; emitter . onNext ( 1 ) ; ) . doOnNext ( v -> if ( v == 1 ) TestHelper . raceOther ( ( ) -> ref . get ( ) . onNext ( 2 ) ; ref . get ( ) . onComplete ( ) ; , cdl ) ; ref . get ( ) . onNext ( 3 ) ; ) . subscribe ( to ) ; cdl . await ( ) ; 
Observable . just ( 1 ) . doAfterNext ( afterNext ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Observable . just ( 1 ) . hide ( ) . doAfterNext ( afterNext ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Observable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . subscribeWith ( to ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 ) , values ) ; 
Observable . < Integer > error ( new TestException ( ) ) . doAfterNext ( afterNext ) . subscribeWith ( to ) . assertFailure ( TestException . class ) ; assertTrue ( values . isEmpty ( ) ) ; 
Observable . < Integer > empty ( ) . doAfterNext ( afterNext ) . subscribeWith ( to ) . assertResult ( ) ; assertTrue ( values . isEmpty ( ) ) ; 
TestObserverEx < Integer > to0 = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Observable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . subscribe ( to0 ) ; to0 . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
TestObserverEx < Integer > to0 = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; Observable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . subscribe ( to0 ) ; to0 . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
TestObserverEx < Integer > to0 = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . doAfterNext ( afterNext ) . subscribe ( to0 ) ; to0 . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
Observable . just ( 1 ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertResult ( 1 ) ; assertEquals ( Arrays . asList ( 1 , - 1 ) , values ) ; 
Observable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 ) , values ) ; 
Observable . < Integer > error ( new TestException ( ) ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertFailure ( TestException . class ) ; assertTrue ( values . isEmpty ( ) ) ; 
Observable . < Integer > empty ( ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( to ) . assertResult ( ) ; assertTrue ( values . isEmpty ( ) ) ; 
TestObserverEx < Integer > to0 = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Observable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to0 ) ; to0 . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
TestObserverEx < Integer > to0 = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; Observable . range ( 1 , 5 ) . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to0 ) ; to0 . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
TestObserverEx < Integer > to0 = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . doAfterNext ( afterNext ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to0 ) ; to0 . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( - 1 , - 2 , - 3 , - 4 , - 5 ) , values ) ; 
Observable . just ( 1 , 2 ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Observable . just ( 1 , 2 ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Observable . just ( 1 , 2 ) . hide ( ) . doAfterNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Observable . range ( 1 , 5 ) . mergeWith ( Single . just ( 100 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
Observable . range ( 1 , 512 ) . mergeWith ( Single . just ( 100 ) ) . test ( ) . assertValueCount ( 513 ) . assertComplete ( ) ; 
Observable . range ( 1 , 5 ) . mergeWith ( Single . just ( 100 ) ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
Observable . error ( new TestException ( ) ) . mergeWith ( Single . just ( 100 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . never ( ) . mergeWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < 10000 ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onSuccess ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( 1 , 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ) ; ps . onNext ( 1 ) ; cs . onSuccess ( 3 ) ; ps . onNext ( 4 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 , 4 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cs . onSuccess ( 2 ) ; ) ; ps . onNext ( 1 ) ; ps . onNext ( 3 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Observer < ? > > observerRef = new AtomicReference < > ( ) ; TestObserver < Integer > to = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observerRef . set ( observer ) ; . mergeWith ( Single . < Integer > error ( new IOException ( ) ) ) . test ( ) ; observerRef . get ( ) . onError ( new TestException ( ) ) ; to . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . error ( new IOException ( ) ) . mergeWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . mergeWith ( Single . just ( 1 ) ) ; ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onNext ( 1 ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; . mergeWith ( Single . < Integer > just ( 1 ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onNext ( 3 ) ; ) ; cs . onSuccess ( 0 ) ; ps . onNext ( 1 ) ; ps . onNext ( 4 ) ; ps . onComplete ( ) ; to . assertResult ( 0 , 1 , 2 , 3 , 4 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( ss ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( ss . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , ps . hasObservers ( ) ) ; assertFalse ( "other has observers" , ss . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( ss ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( ss . hasObservers ( ) ) ; ss . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , ps . hasObservers ( ) ) ; assertFalse ( "other has observers" , ss . hasObservers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . mergeWith ( Single . just ( 1 ) . hide ( ) ) ; ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . empty ( ) . takeUntil ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) return true ; ) . subscribe ( o ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o ) . onComplete ( ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . just ( 1 , 2 ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return false ; ) . subscribe ( o ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onNext ( 2 ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o ) . onComplete ( ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . just ( 1 , 2 ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . subscribe ( o ) ; verify ( o ) . onNext ( 1 ) ; verify ( o , never ( ) ) . onNext ( 2 ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o ) . onComplete ( ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . just ( 1 , 2 , 3 ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 == 2 ; ) . subscribe ( o ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onNext ( 2 ) ; verify ( o , never ( ) ) . onNext ( 3 ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o ) . onComplete ( ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Predicate < Integer > predicate = ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) throw new TestException ( "Forced failure" ) ; ) ; Observable . just ( 1 , 2 , 3 ) . takeUntil ( predicate ) . subscribe ( o ) ; verify ( o ) . onNext ( 1 ) ; verify ( o , never ( ) ) . onNext ( 2 ) ; verify ( o , never ( ) ) . onNext ( 3 ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . concatWith ( Observable . just ( 2 ) ) . takeUntil ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return false ; ) . subscribe ( o ) ; verify ( o ) . onNext ( 1 ) ; verify ( o , never ( ) ) . onNext ( 2 ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
TestObserverEx < String > to = new TestObserverEx < > ( ) ; final TestException e = new TestException ( "Forced failure" ) ; Predicate < String > predicate = ( new Predicate < String > ( ) @ Override public boolean test ( String t ) throw e ; ) ; Observable . just ( "abc" ) . takeUntil ( predicate ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNotComplete ( ) ; to . assertError ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . takeUntil ( Functions . alwaysFalse ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . takeUntil ( Functions . alwaysFalse ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . takeUntil ( Functions . alwaysFalse ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable < String > w = Observable . just ( "one" , "two" , "three" ) ; Observable < String > observable = w . filter ( new Predicate < String > ( ) @ Override public boolean test ( String t1 ) return t1 . equals ( "two" ) ; ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . filter ( Functions . alwaysTrue ( ) ) ; ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Observable . range ( 1 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 2 , 4 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( to ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 2 , 4 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ; Observable . range ( 1 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 2 , 4 ) ; 
Observable . range ( 1 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Observable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Action run = new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ; Observable . fromCompletable ( Completable . fromAction ( run ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Observable . fromCompletable ( Completable . fromAction ( run ) ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Observable < Object > source = Observable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; source . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Observable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Object > to = Observable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; ) ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Action run = mock ( Action . class ) ; Observable . fromCompletable ( Completable . fromAction ( run ) ) . test ( true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; Observable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . dispose ( ) ; ) ) . subscribeWith ( to ) . assertEmpty ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Action action = mock ( Action . class ) ; Observable . fromCompletable ( Completable . fromAction ( action ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . SYNC ) ; Action action = mock ( Action . class ) ; Observable . fromCompletable ( Completable . fromAction ( action ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
TestHelper . checkDisposed ( Observable . fromCompletable ( Completable . never ( ) ) ) ; 
Observable < ? > o = Observable . fromCompletable ( Completable . never ( ) ) ; assertTrue ( o instanceof HasUpstreamCompletableSource ) ; assertSame ( Completable . never ( ) , ( ( HasUpstreamCompletableSource ) o ) . source ( ) ) ; 
assertTrue ( Observable . empty ( ) . ignoreElements ( ) . toObservable ( ) . isEmpty ( ) . blockingGet ( ) ) ; 
assertTrue ( Observable . just ( 1 , 2 , 3 ) . ignoreElements ( ) . toObservable ( ) . isEmpty ( ) . blockingGet ( ) ) ; 
final int num = 10 ; final AtomicInteger upstreamCount = new AtomicInteger ( ) ; long count = Observable . range ( 1 , num ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . ignoreElements ( ) . toObservable ( ) . count ( ) . blockingGet ( ) ; assertEquals ( num , upstreamCount . get ( ) ) ; assertEquals ( 0 , count ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; Observable . range ( 1 , 10 ) . ignoreElements ( ) . toObservable ( ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; to . assertTerminated ( ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; TestException ex = new TestException ( "boo" ) ; Observable . error ( ex ) . ignoreElements ( ) . toObservable ( ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertTerminated ( ) ; to . assertError ( TestException . class ) ; to . assertErrorMessage ( "boo" ) ; 
final AtomicBoolean unsub = new AtomicBoolean ( ) ; Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > never ( ) ) . doOnDispose ( new Action ( ) @ Override public void run ( ) unsub . set ( true ) ; ) . ignoreElements ( ) . toObservable ( ) . subscribe ( ) . dispose ( ) ; assertTrue ( unsub . get ( ) ) ; 
Observable . empty ( ) . ignoreElements ( ) . blockingAwait ( ) ; 
Observable . just ( 1 , 2 , 3 ) . ignoreElements ( ) . blockingAwait ( ) ; 
final int num = 10 ; final AtomicInteger upstreamCount = new AtomicInteger ( ) ; Observable . range ( 1 , num ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . ignoreElements ( ) . blockingAwait ( ) ; assertEquals ( num , upstreamCount . get ( ) ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; Observable . range ( 1 , 10 ) . ignoreElements ( ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; to . assertTerminated ( ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; TestException ex = new TestException ( "boo" ) ; Observable . error ( ex ) . ignoreElements ( ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertTerminated ( ) ; to . assertError ( TestException . class ) ; to . assertErrorMessage ( "boo" ) ; 
final AtomicBoolean unsub = new AtomicBoolean ( ) ; Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > never ( ) ) . doOnDispose ( new Action ( ) @ Override public void run ( ) unsub . set ( true ) ; ) . ignoreElements ( ) . subscribe ( ) . dispose ( ) ; assertTrue ( unsub . get ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . ignoreElements ( ) . < Integer > toObservable ( ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; TestHelper . checkDisposed ( ps . ignoreElements ( ) . < Integer > toObservable ( ) ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . ignoreElements ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . ignoreElements ( ) . toObservable ( ) ) ; 
observer = TestHelper . mockObserver ( ) ; testScheduler = new TestScheduler ( ) ; subject = PublishSubject . create ( ) ; observable = subject . timeInterval ( testScheduler ) ; 
InOrder inOrder = inOrder ( observer ) ; observable . subscribe ( observer ) ; testScheduler . advanceTimeBy ( 1000 , TIME_UNIT ) ; subject . onNext ( 1 ) ; testScheduler . advanceTimeBy ( 2000 , TIME_UNIT ) ; subject . onNext ( 2 ) ; testScheduler . advanceTimeBy ( 3000 , TIME_UNIT ) ; subject . onNext ( 3 ) ; subject . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 1 , 1000 , TIME_UNIT ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 2 , 2000 , TIME_UNIT ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 3 , 3000 , TIME_UNIT ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler v ) throws Exception return scheduler ; ) ; try Observable . range ( 1 , 5 ) . timeInterval ( ) . map ( new Function < Timed < Integer > , Long > ( ) @ Override public Long apply ( Timed < Integer > v ) throws Exception return v . time ( ) ; ) . test ( ) . assertResult ( 0L , 0L , 0L , 0L , 0L ) ; finally RxJavaPlugins . reset ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler v ) throws Exception return scheduler ; ) ; try Observable . range ( 1 , 5 ) . timeInterval ( TimeUnit . SECONDS ) . map ( new Function < Timed < Integer > , Long > ( ) @ Override public Long apply ( Timed < Integer > v ) throws Exception return v . time ( ) ; ) . test ( ) . assertResult ( 0L , 0L , 0L , 0L , 0L ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . timeInterval ( ) ) ; 
Observable . error ( new TestException ( ) ) . timeInterval ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Timed < Object > > > ( ) @ Override public Observable < Timed < Object > > apply ( Observable < Object > f ) throws Exception return f . timeInterval ( ) ; ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skip ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 2 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( o ) . onNext ( 4 ) ; inOrder . verify ( o ) . onNext ( 5 ) ; inOrder . verify ( o ) . onNext ( 6 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skip ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skip ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skip ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; source . onError ( new TestException ( ) ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 2 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( o ) . onNext ( 4 ) ; inOrder . verify ( o ) . onNext ( 5 ) ; inOrder . verify ( o ) . onNext ( 6 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observable . just ( 1 ) . skip ( 1 , TimeUnit . MINUTES ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
int subCount = 3 ; final CountDownLatch upperLatch = new CountDownLatch ( subCount ) ; final CountDownLatch lowerLatch = new CountDownLatch ( subCount ) ; final CountDownLatch onNextLatch = new CountDownLatch ( subCount ) ; final AtomicInteger upperCount = new AtomicInteger ( ) ; final AtomicInteger lowerCount = new AtomicInteger ( ) ; Observable < Long > longs = Observable . interval ( 50 , TimeUnit . MILLISECONDS ) . doOnDispose ( new Action ( ) @ Override public void run ( ) upperLatch . countDown ( ) ; upperCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Long > ( ) @ Override public void accept ( Long aLong ) onNextLatch . countDown ( ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) lowerLatch . countDown ( ) ; lowerCount . incrementAndGet ( ) ; ) ; List < Disposable > subscriptions = new ArrayList < > ( ) ; List < TestObserver < Long > > subscribers = new ArrayList < > ( ) ; for ( int i = 0 ; i < subCount ; ++ i ) TestObserver < Long > observer = new TestObserver < > ( ) ; subscriptions . add ( observer ) ; longs . subscribe ( observer ) ; subscribers . add ( observer ) ; onNextLatch . await ( ) ; for ( int i = 0 ; i < subCount ; ++ i ) subscriptions . get ( i ) . dispose ( ) ; upperLatch . await ( ) ; lowerLatch . await ( ) ; assertEquals ( String . format ( "There should exactly %d un-subscription events for upper stream" , subCount ) , subCount , upperCount . get ( ) ) ; assertEquals ( String . format ( "There should exactly %d un-subscription events for lower stream" , subCount ) , subCount , lowerCount . get ( ) ) ; 
int subCount = 3 ; final CountDownLatch upperLatch = new CountDownLatch ( 1 ) ; final CountDownLatch lowerLatch = new CountDownLatch ( 1 ) ; final CountDownLatch onNextLatch = new CountDownLatch ( subCount ) ; final AtomicInteger upperCount = new AtomicInteger ( ) ; final AtomicInteger lowerCount = new AtomicInteger ( ) ; Observable < Long > longs = Observable . interval ( 50 , TimeUnit . MILLISECONDS ) . doOnDispose ( new Action ( ) @ Override public void run ( ) upperLatch . countDown ( ) ; upperCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Long > ( ) @ Override public void accept ( Long aLong ) onNextLatch . countDown ( ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) lowerLatch . countDown ( ) ; lowerCount . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) ; List < Disposable > subscriptions = new ArrayList < > ( ) ; List < TestObserver < Long > > subscribers = new ArrayList < > ( ) ; for ( int i = 0 ; i < subCount ; ++ i ) TestObserver < Long > observer = new TestObserver < > ( ) ; longs . subscribe ( observer ) ; subscriptions . add ( observer ) ; subscribers . add ( observer ) ; onNextLatch . await ( ) ; for ( int i = 0 ; i < subCount ; ++ i ) subscriptions . get ( i ) . dispose ( ) ; upperLatch . await ( ) ; lowerLatch . await ( ) ; assertEquals ( "There should exactly 1 un-subscription events for upper stream" , 1 , upperCount . get ( ) ) ; assertEquals ( "There should exactly 1 un-subscription events for lower stream" , 1 , lowerCount . get ( ) ) ; 
final AtomicInteger disposeCalled = new AtomicInteger ( ) ; final BehaviorSubject < Integer > s = BehaviorSubject . create ( ) ; s . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception disposeCalled . incrementAndGet ( ) ; s . onNext ( 2 ) ; ) . firstOrError ( ) . subscribe ( ) . dispose ( ) ; assertEquals ( 1 , disposeCalled . get ( ) ) ; 
return new Function < Integer , Observable < T > > ( ) @ Override public Observable < T > apply ( Integer t1 ) return observable ; ; 
return new Function < T , Observable < R > > ( ) @ Override public Observable < R > apply ( T t1 ) return observable ; ; 
MockitoAnnotations . openMocks ( this ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > m = Observable . merge ( source1 . groupJoin ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , add2 ) ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; source1 . onNext ( 2 ) ; source1 . onNext ( 4 ) ; source2 . onNext ( 16 ) ; source2 . onNext ( 32 ) ; source2 . onNext ( 64 ) ; source1 . onComplete ( ) ; source2 . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( 17 ) ; verify ( observer , times ( 1 ) ) . onNext ( 18 ) ; verify ( observer , times ( 1 ) ) . onNext ( 20 ) ; verify ( observer , times ( 1 ) ) . onNext ( 33 ) ; verify ( observer , times ( 1 ) ) . onNext ( 34 ) ; verify ( observer , times ( 1 ) ) . onNext ( 36 ) ; verify ( observer , times ( 1 ) ) . onNext ( 65 ) ; verify ( observer , times ( 1 ) ) . onNext ( 66 ) ; verify ( observer , times ( 1 ) ) . onNext ( 68 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Person > source1 = Observable . fromIterable ( Arrays . asList ( new Person ( 1 , "Joe" ) , new Person ( 2 , "Mike" ) , new Person ( 3 , "Charlie" ) ) ) ; Observable < PersonFruit > source2 = Observable . fromIterable ( Arrays . asList ( new PersonFruit ( 1 , "Strawberry" ) , new PersonFruit ( 1 , "Apple" ) , new PersonFruit ( 3 , "Peach" ) ) ) ; Observable < PPF > q = source1 . groupJoin ( source2 , just2 ( Observable . < Object > never ( ) ) , just2 ( Observable . < Object > never ( ) ) , new BiFunction < Person , Observable < PersonFruit > , PPF > ( ) @ Override public PPF apply ( Person t1 , Observable < PersonFruit > t2 ) return new PPF ( t1 , t2 ) ; ) ; q . subscribe ( new Observer < PPF > ( ) @ Override public void onNext ( final PPF ppf ) ppf . fruits . filter ( new Predicate < PersonFruit > ( ) @ Override public boolean test ( PersonFruit t1 ) return ppf . person . id == t1 . personId ; ) . subscribe ( new Consumer < PersonFruit > ( ) @ Override public void accept ( PersonFruit t1 ) observer . onNext ( Arrays . asList ( ppf . person . name , t1 . fruit ) ) ; ) ; @ Override public void onError ( Throwable e ) observer . onError ( e ) ; @ Override public void onComplete ( ) observer . onComplete ( ) ; @ Override public void onSubscribe ( Disposable d ) ) ; verify ( observer , times ( 1 ) ) . onNext ( Arrays . asList ( "Joe" , "Strawberry" ) ) ; verify ( observer , times ( 1 ) ) . onNext ( Arrays . asList ( "Joe" , "Apple" ) ) ; verify ( observer , times ( 1 ) ) . onNext ( Arrays . asList ( "Charlie" , "Peach" ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Observable < Integer > > m = source1 . groupJoin ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , add2 ) ; m . subscribe ( observer ) ; source2 . onNext ( 1 ) ; source1 . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Observable < Integer > > m = source1 . groupJoin ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , add2 ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; source2 . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( observer , times ( 1 ) ) . onNext ( any ( Observable . class ) ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > duration1 = Observable . < Integer > error ( new RuntimeException ( "Forced failure" ) ) ; Observable < Observable < Integer > > m = source1 . groupJoin ( source2 , just ( duration1 ) , just ( Observable . never ( ) ) , add2 ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > duration1 = Observable . < Integer > error ( new RuntimeException ( "Forced failure" ) ) ; Observable < Observable < Integer > > m = source1 . groupJoin ( source2 , just ( Observable . never ( ) ) , just ( duration1 ) , add2 ) ; m . subscribe ( observer ) ; source2 . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > fail = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) throw new RuntimeException ( "Forced failure" ) ; ; Observable < Observable < Integer > > m = source1 . groupJoin ( source2 , fail , just ( Observable . never ( ) ) , add2 ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > fail = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) throw new RuntimeException ( "Forced failure" ) ; ; Observable < Observable < Integer > > m = source1 . groupJoin ( source2 , just ( Observable . never ( ) ) , fail , add2 ) ; m . subscribe ( observer ) ; source2 . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; BiFunction < Integer , Observable < Integer > , Integer > fail = new BiFunction < Integer , Observable < Integer > , Integer > ( ) @ Override public Integer apply ( Integer t1 , Observable < Integer > t2 ) throw new RuntimeException ( "Forced failure" ) ; ; Observable < Integer > m = source1 . groupJoin ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , fail ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; source2 . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . groupJoin ( Observable . just ( 2 ) , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer left ) throws Exception return Observable . never ( ) ; , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer right ) throws Exception return Observable . never ( ) ; , new BiFunction < Integer , Observable < Integer > , Object > ( ) @ Override public Object apply ( Integer r , Observable < Integer > l ) throws Exception return l ; ) ) ; 
Observable . just ( 1 ) . groupJoin ( Observable . just ( 2 ) , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer left ) throws Exception return Observable . empty ( ) ; , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer right ) throws Exception return Observable . never ( ) ; , new BiFunction < Integer , Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer r , Observable < Integer > l ) throws Exception return l ; ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . assertResult ( ) ; 
Observable . just ( 1 ) . groupJoin ( Observable . just ( 2 ) , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer left ) throws Exception return Observable . error ( new TestException ( ) ) ; , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer right ) throws Exception return Observable . never ( ) ; , new BiFunction < Integer , Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer r , Observable < Integer > l ) throws Exception return l ; ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . groupJoin ( Observable . just ( 2 ) , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer left ) throws Exception return Observable . never ( ) ; , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer right ) throws Exception return Observable . empty ( ) ; , new BiFunction < Integer , Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer r , Observable < Integer > l ) throws Exception return l ; ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . assertResult ( 2 ) ; 
Observable . just ( 1 ) . groupJoin ( Observable . just ( 2 ) , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer left ) throws Exception return Observable . never ( ) ; , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer right ) throws Exception return Observable . error ( new TestException ( ) ) ; , new BiFunction < Integer , Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer r , Observable < Integer > l ) throws Exception return l ; ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Object > ps1 = PublishSubject . create ( ) ; final PublishSubject < Object > ps2 = PublishSubject . create ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Observable < Integer > > to = Observable . just ( 1 ) . groupJoin ( Observable . just ( 2 ) . concatWith ( Observable . < Integer > never ( ) ) , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer left ) throws Exception return ps1 ; , new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer right ) throws Exception return ps2 ; , new BiFunction < Integer , Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer r , Observable < Integer > l ) throws Exception return l ; ) . to ( TestHelper . < Observable < Integer > > testConsumer ( ) ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( Throwable . class ) . assertSubscribed ( ) . assertNotComplete ( ) . assertValueCount ( 1 ) ; Throwable exc = to . errors ( ) . get ( 0 ) ; if ( exc instanceof CompositeException ) List < Throwable > es = TestHelper . compositeList ( exc ) ; TestHelper . assertError ( es , 0 , TestException . class ) ; TestHelper . assertError ( es , 1 , TestException . class ) ; else to . assertError ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Object > ps1 = PublishSubject . create ( ) ; final PublishSubject < Object > ps2 = PublishSubject . create ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserverEx < Object > to = ps1 . groupJoin ( ps2 , new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object left ) throws Exception return Observable . never ( ) ; , new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object right ) throws Exception return Observable . never ( ) ; , new BiFunction < Object , Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Object r , Observable < Object > l ) throws Exception return l ; ) . flatMap ( Functions . < Observable < Object > > identity ( ) ) . to ( TestHelper . < Object > testConsumer ( ) ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertError ( Throwable . class ) . assertSubscribed ( ) . assertNotComplete ( ) . assertNoValues ( ) ; Throwable exc = to . errors ( ) . get ( 0 ) ; if ( exc instanceof CompositeException ) List < Throwable > es = TestHelper . compositeList ( exc ) ; TestHelper . assertError ( es , 0 , TestException . class ) ; TestHelper . assertError ( es , 1 , TestException . class ) ; else to . assertError ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishSubject < Object > ps1 = PublishSubject . create ( ) ; final PublishSubject < Object > ps2 = PublishSubject . create ( ) ; TestObserver < Object > to = ps1 . groupJoin ( ps2 , new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object left ) throws Exception return Observable . never ( ) ; , new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object right ) throws Exception return Observable . never ( ) ; , new BiFunction < Object , Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Object r , Observable < Object > l ) throws Exception return l ; ) . flatMap ( Functions . < Observable < Object > > identity ( ) ) . test ( ) ; ps2 . onNext ( 2 ) ; ps1 . onNext ( 1 ) ; ps1 . onComplete ( ) ; ps2 . onComplete ( ) ; to . assertResult ( 2 ) ; 
JoinSupport js = mock ( JoinSupport . class ) ; LeftRightObserver o = new LeftRightObserver ( js , false ) ; assertFalse ( o . isDisposed ( ) ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; o . dispose ( ) ; assertTrue ( o . isDisposed ( ) ) ; verify ( js ) . innerValue ( false , 1 ) ; verify ( js ) . innerValue ( false , 2 ) ; 
JoinSupport js = mock ( JoinSupport . class ) ; LeftRightEndObserver o = new LeftRightEndObserver ( js , false , 0 ) ; assertFalse ( o . isDisposed ( ) ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; assertTrue ( o . isDisposed ( ) ) ; verify ( js ) . innerClose ( false , o ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; ps1 . groupJoin ( ps2 , v -> Observable . never ( ) , v -> Observable . never ( ) , ( a , b ) -> a ) . doOnNext ( v -> to . dispose ( ) ; ) . subscribe ( to ) ; ps2 . onNext ( 1 ) ; ps1 . onNext ( 1 ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; ps1 . groupJoin ( ps2 , v -> Observable . never ( ) , v -> Observable . never ( ) , ( a , b ) -> a ) . doOnNext ( v -> if ( v == 1 ) ps2 . onNext ( 2 ) ; ps1 . onComplete ( ) ; ps2 . onComplete ( ) ; ) . subscribe ( to ) ; ps2 . onNext ( 1 ) ; ps1 . onNext ( 1 ) ; 
final List < List < T > > lists = new ArrayList < > ( ) ; Observable . concatEager ( observables . map ( new Function < Observable < T > , Observable < List < T > > > ( ) @ Override public Observable < List < T > > apply ( Observable < T > xs ) return xs . toList ( ) . toObservable ( ) ; ) ) . blockingForEach ( new Consumer < List < T > > ( ) @ Override public void accept ( List < T > xs ) lists . add ( xs ) ; ) ; return lists ; 
Observable < String > subject = Observable . just ( "one" , "two" , "three" , "four" , "five" ) ; Observable < Observable < String > > windowed = subject . window ( 3 ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( 2 , windows . size ( ) ) ; assertEquals ( list ( "one" , "two" , "three" ) , windows . get ( 0 ) ) ; assertEquals ( list ( "four" , "five" ) , windows . get ( 1 ) ) ; 
Observable < String > subject = Observable . just ( "one" , "two" , "three" , "four" , "five" ) ; Observable < Observable < String > > windowed = subject . window ( 3 , 3 ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( 2 , windows . size ( ) ) ; assertEquals ( list ( "one" , "two" , "three" ) , windows . get ( 0 ) ) ; assertEquals ( list ( "four" , "five" ) , windows . get ( 1 ) ) ; 
Observable < String > subject = Observable . fromArray ( new String [ ] "zero" , "one" , "two" , "three" , "four" , "five" ) ; Observable < Observable < String > > windowed = subject . window ( 3 , 1 ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( 6 , windows . size ( ) ) ; assertEquals ( list ( "zero" , "one" , "two" ) , windows . get ( 0 ) ) ; assertEquals ( list ( "one" , "two" , "three" ) , windows . get ( 1 ) ) ; assertEquals ( list ( "two" , "three" , "four" ) , windows . get ( 2 ) ) ; assertEquals ( list ( "three" , "four" , "five" ) , windows . get ( 3 ) ) ; assertEquals ( list ( "four" , "five" ) , windows . get ( 4 ) ) ; assertEquals ( list ( "five" ) , windows . get ( 5 ) ) ; 
Observable < String > subject = Observable . just ( "one" , "two" , "three" , "four" , "five" ) ; Observable < Observable < String > > windowed = subject . window ( 2 , 3 ) ; List < List < String > > windows = toLists ( windowed ) ; assertEquals ( 2 , windows . size ( ) ) ; assertEquals ( list ( "one" , "two" ) , windows . get ( 0 ) ) ; assertEquals ( list ( "four" , "five" ) , windows . get ( 1 ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( Observable . range ( 1 , 10000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . window ( 5 ) . take ( 2 ) ) . subscribe ( to ) ; to . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertEquals ( 10 , count . get ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( Observable . range ( 1 , 100000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) if ( count . incrementAndGet ( ) == 500000 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException ex ) ) . observeOn ( Schedulers . computation ( ) ) . window ( 5 ) . take ( 2 ) ) . subscribe ( to ) ; to . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertTrue ( count . get ( ) < 100000 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( Observable . range ( 1 , 10000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . window ( 5 , 4 ) . take ( 2 ) ) . subscribe ( to ) ; to . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 5 , 6 , 7 , 8 , 9 ) ; assertEquals ( 9 , count . get ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . merge ( Observable . range ( 1 , 100000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . observeOn ( Schedulers . computation ( ) ) . window ( 5 , 4 ) . take ( 2 ) , 128 ) . subscribe ( to ) ; to . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 5 , 6 , 7 , 8 , 9 ) ; 
return Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; while ( ! d . isDisposed ( ) ) for ( int i = 0 ; i < Math . random ( ) * 20 ; i ++ ) observer . onNext ( i ) ; try Thread . sleep ( ( long ) ( Math . random ( ) * 200 ) ) ; catch ( Exception e ) System . out . println ( "Hot done." ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; final int indicator = 999999999 ; hotStream ( ) . window ( 10 ) . take ( 2 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) return w . startWithItem ( indicator ) ; ) . subscribe ( to ) ; to . awaitDone ( 2 , TimeUnit . SECONDS ) ; to . assertComplete ( ) ; to . assertValueCount ( 22 ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . window ( 1 ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . window ( 2 , 1 ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . window ( 1 , 2 ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Observable < Object > > > ( ) @ Override public ObservableSource < Observable < Object > > apply ( Observable < Object > o ) throws Exception return o . window ( 1 ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Observable < Object > > > ( ) @ Override public ObservableSource < Observable < Object > > apply ( Observable < Object > o ) throws Exception return o . window ( 2 , 1 ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Observable < Object > > > ( ) @ Override public ObservableSource < Observable < Object > > apply ( Observable < Object > o ) throws Exception return o . window ( 1 , 2 ) ; ) ; 
Observable . error ( new TestException ( ) ) . window ( 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . window ( 1 , 2 ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . window ( 2 , 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
@ SuppressWarnings ( "rawtypes" ) final TestObserver [ ] to = null ; Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . window ( 2 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > w ) throws Exception to [ 0 ] = w . test ( ) ; ) . test ( ) . assertError ( TestException . class ) ; to [ 0 ] . assertFailure ( TestException . class , 1 ) ; 
@ SuppressWarnings ( "rawtypes" ) final TestObserver [ ] to = null ; Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . window ( 2 , 3 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > w ) throws Exception to [ 0 ] = w . test ( ) ; ) . test ( ) . assertError ( TestException . class ) ; to [ 0 ] . assertFailure ( TestException . class , 1 ) ; 
@ SuppressWarnings ( "rawtypes" ) final TestObserver [ ] to = null ; Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . window ( 3 , 2 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > w ) throws Exception to [ 0 ] = w . test ( ) ; ) . test ( ) . assertError ( TestException . class ) ; to [ 0 ] . assertFailure ( TestException . class , 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 10 ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < Observable < Integer > > inner = new AtomicReference < > ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 ) . take ( 1 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 5 , 10 ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < Observable < Integer > > inner = new AtomicReference < > ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , 10 ) . take ( 1 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 5 , 3 ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < Observable < Integer > > inner = new AtomicReference < > ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , 3 ) . take ( 1 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . dispose ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 , 15 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 , 15 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . dispose ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 , 5 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 , 5 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . dispose ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
Observable < List < Integer > > o = Observable . just ( 1 , 2 , 3 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer v ) list . add ( v ) ; ) . toObservable ( ) ; List < Integer > list = o . blockingLast ( ) ; assertEquals ( 3 , list . size ( ) ) ; assertEquals ( 1 , list . get ( 0 ) . intValue ( ) ) ; assertEquals ( 2 , list . get ( 1 ) . intValue ( ) ) ; assertEquals ( 3 , list . get ( 2 ) . intValue ( ) ) ; List < Integer > list2 = o . blockingLast ( ) ; assertEquals ( 3 , list2 . size ( ) ) ; assertEquals ( 1 , list2 . get ( 0 ) . intValue ( ) ) ; assertEquals ( 2 , list2 . get ( 1 ) . intValue ( ) ) ; assertEquals ( 3 , list2 . get ( 2 ) . intValue ( ) ) ; 
String value = Observable . just ( 1 , 2 , 3 ) . collect ( new Supplier < StringBuilder > ( ) @ Override public StringBuilder get ( ) return new StringBuilder ( ) ; , new BiConsumer < StringBuilder , Integer > ( ) @ Override public void accept ( StringBuilder sb , Integer v ) if ( sb . length ( ) > 0 ) sb . append ( "-" ) ; sb . append ( v ) ; ) . toObservable ( ) . blockingLast ( ) . toString ( ) ; assertEquals ( "1-2-3" , value ) ; 
try final List < Throwable > list = new CopyOnWriteArrayList < > ( ) ; RxJavaPlugins . setErrorHandler ( addToList ( list ) ) ; final RuntimeException e1 = new RuntimeException ( ) ; final RuntimeException e2 = new RuntimeException ( ) ; Burst . items ( 1 ) . error ( e2 ) . collect ( supplierListCreator ( ) , biConsumerThrows ( e1 ) ) . toObservable ( ) . test ( ) . assertError ( e1 ) . assertNotComplete ( ) ; assertEquals ( 1 , list . size ( ) ) ; assertEquals ( e2 , list . get ( 0 ) . getCause ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; Burst . item ( 1 ) . create ( ) . collect ( supplierListCreator ( ) , biConsumerThrows ( e ) ) . toObservable ( ) . test ( ) . assertError ( e ) . assertNotComplete ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; final AtomicBoolean added = new AtomicBoolean ( ) ; BiConsumer < Object , Integer > throwOnFirstOnly = new BiConsumer < Object , Integer > ( ) boolean once = true ; @ Override public void accept ( Object o , Integer t ) if ( once ) once = false ; throw e ; else added . set ( true ) ; ; Burst . items ( 1 , 2 ) . create ( ) . collect ( supplierListCreator ( ) , throwOnFirstOnly ) . test ( ) . assertError ( e ) . assertNoValues ( ) . assertNotComplete ( ) ; assertFalse ( added . get ( ) ) ; 
Observable . just ( 1 , 1 , 1 , 1 , 2 ) . collectInto ( new HashSet < > ( ) , new BiConsumer < HashSet < Integer > , Integer > ( ) @ Override public void accept ( HashSet < Integer > s , Integer v ) throws Exception s . add ( v ) ; ) . toObservable ( ) . test ( ) . assertResult ( new HashSet < > ( Arrays . asList ( 1 , 2 ) ) ) ; 
Single < List < Integer > > o = Observable . just ( 1 , 2 , 3 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer v ) list . add ( v ) ; ) ; List < Integer > list = o . blockingGet ( ) ; assertEquals ( 3 , list . size ( ) ) ; assertEquals ( 1 , list . get ( 0 ) . intValue ( ) ) ; assertEquals ( 2 , list . get ( 1 ) . intValue ( ) ) ; assertEquals ( 3 , list . get ( 2 ) . intValue ( ) ) ; List < Integer > list2 = o . blockingGet ( ) ; assertEquals ( 3 , list2 . size ( ) ) ; assertEquals ( 1 , list2 . get ( 0 ) . intValue ( ) ) ; assertEquals ( 2 , list2 . get ( 1 ) . intValue ( ) ) ; assertEquals ( 3 , list2 . get ( 2 ) . intValue ( ) ) ; 
String value = Observable . just ( 1 , 2 , 3 ) . collect ( new Supplier < StringBuilder > ( ) @ Override public StringBuilder get ( ) return new StringBuilder ( ) ; , new BiConsumer < StringBuilder , Integer > ( ) @ Override public void accept ( StringBuilder sb , Integer v ) if ( sb . length ( ) > 0 ) sb . append ( "-" ) ; sb . append ( v ) ; ) . blockingGet ( ) . toString ( ) ; assertEquals ( "1-2-3" , value ) ; 
try final List < Throwable > list = new CopyOnWriteArrayList < > ( ) ; RxJavaPlugins . setErrorHandler ( addToList ( list ) ) ; final RuntimeException e1 = new RuntimeException ( ) ; final RuntimeException e2 = new RuntimeException ( ) ; Burst . items ( 1 ) . error ( e2 ) . collect ( supplierListCreator ( ) , biConsumerThrows ( e1 ) ) . test ( ) . assertError ( e1 ) . assertNotComplete ( ) ; assertEquals ( 1 , list . size ( ) ) ; assertEquals ( e2 , list . get ( 0 ) . getCause ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; Burst . item ( 1 ) . create ( ) . collect ( supplierListCreator ( ) , biConsumerThrows ( e ) ) . test ( ) . assertError ( e ) . assertNotComplete ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; final AtomicBoolean added = new AtomicBoolean ( ) ; BiConsumer < Object , Integer > throwOnFirstOnly = new BiConsumer < Object , Integer > ( ) boolean once = true ; @ Override public void accept ( Object o , Integer t ) if ( once ) once = false ; throw e ; else added . set ( true ) ; ; Burst . items ( 1 , 2 ) . create ( ) . collect ( supplierListCreator ( ) , throwOnFirstOnly ) . test ( ) . assertError ( e ) . assertNoValues ( ) . assertNotComplete ( ) ; assertFalse ( added . get ( ) ) ; 
Observable . just ( 1 , 1 , 1 , 1 , 2 ) . collectInto ( new HashSet < > ( ) , new BiConsumer < HashSet < Integer > , Integer > ( ) @ Override public void accept ( HashSet < Integer > s , Integer v ) throws Exception s . add ( v ) ; ) . test ( ) . assertResult ( new HashSet < > ( Arrays . asList ( 1 , 2 ) ) ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 3 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 3 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . toObservable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Integer > , SingleSource < List < Integer > > > ( ) @ Override public SingleSource < List < Integer > > apply ( Observable < Integer > o ) throws Exception return o . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Integer > , ObservableSource < List < Integer > > > ( ) @ Override public ObservableSource < List < Integer > > apply ( Observable < Integer > o ) throws Exception return o . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . toObservable ( ) ; ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > o ) throws Exception return o . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) throws Exception return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > a , Integer b ) throws Exception a . add ( b ) ; ) . toObservable ( ) ; , false , 1 , 2 , Arrays . asList ( 1 ) ) ; 
Observable < ? > source = Observable . just ( 1 , 2 ) ; Observable < Integer > observable = source . cast ( Integer . class ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < ? > source = Observable . just ( 1 , 2 ) ; Observable < Boolean > observable = source . cast ( Boolean . class ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onError ( any ( ClassCastException . class ) ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . flatMap ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer item ) return Observable . just ( ( Object ) ( item + 1 ) ) ; , new Function < Throwable , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Throwable e ) return Observable . error ( e ) ; , new Supplier < Observable < Object > > ( ) @ Override public Observable < Object > get ( ) return Observable . never ( ) ; ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; to . assertValue ( 2 ) ; 
TestHelper . checkDisposed ( new Observable < Integer > ( ) @ SuppressWarnings ( "rawtypes" , "unchecked" ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) MapNotificationObserver mn = new MapNotificationObserver ( observer , Functions . justFunction ( Observable . just ( 1 ) ) , Functions . justFunction ( Observable . just ( 2 ) ) , Functions . justSupplier ( Observable . just ( 3 ) ) ) ; mn . onSubscribe ( Disposable . empty ( ) ) ; ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Object > o ) throws Exception return o . flatMap ( Functions . justFunction ( Observable . just ( 1 ) ) , Functions . justFunction ( Observable . just ( 2 ) ) , Functions . justSupplier ( Observable . just ( 3 ) ) ) ; ) ; 
TestObserverEx < Integer > to = Observable . < Integer > error ( new TestException ( "Outer" ) ) . flatMap ( Functions . justFunction ( Observable . just ( 1 ) ) , new Function < Throwable , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Throwable t ) throws Exception throw new TestException ( "Inner" ) ; , Functions . justSupplier ( Observable . just ( 3 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( to , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( to , 1 , TestException . class , "Inner" ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; final Observer < Object > o = TestHelper . mockObserver ( ) ; final List < Observer < Object > > values = new ArrayList < > ( ) ; Observer < Observable < Integer > > wo = new DefaultObserver < Observable < Integer > > ( ) @ Override public void onNext ( Observable < Integer > args ) final Observer < Object > mo = TestHelper . mockObserver ( ) ; values . add ( mo ) ; args . subscribe ( mo ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; ; source . window ( boundary ) . subscribe ( wo ) ; int n = 30 ; for ( int i = 0 ; i < n ; i ++ ) source . onNext ( i ) ; if ( i % 3 == 2 && i < n - 1 ) boundary . onNext ( i / 3 ) ; source . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; assertEquals ( n / 3 , values . size ( ) ) ; int j = 0 ; for ( Observer < Object > mo : values ) verify ( mo , never ( ) ) . onError ( any ( Throwable . class ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) verify ( mo ) . onNext ( j + i ) ; verify ( mo ) . onComplete ( ) ; j += 3 ; verify ( o ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; final Observer < Object > o = TestHelper . mockObserver ( ) ; final List < Observer < Object > > values = new ArrayList < > ( ) ; Observer < Observable < Integer > > wo = new DefaultObserver < Observable < Integer > > ( ) @ Override public void onNext ( Observable < Integer > args ) final Observer < Object > mo = TestHelper . mockObserver ( ) ; values . add ( mo ) ; args . subscribe ( mo ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; ; source . window ( boundary ) . subscribe ( wo ) ; int n = 30 ; for ( int i = 0 ; i < n ; i ++ ) source . onNext ( i ) ; if ( i % 3 == 2 && i < n - 1 ) boundary . onNext ( i / 3 ) ; boundary . onComplete ( ) ; assertEquals ( n / 3 , values . size ( ) ) ; int j = 0 ; for ( Observer < Object > mo : values ) for ( int i = 0 ; i < 3 ; i ++ ) verify ( mo ) . onNext ( j + i ) ; verify ( mo ) . onComplete ( ) ; verify ( mo , never ( ) ) . onError ( any ( Throwable . class ) ) ; j += 3 ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; final Observer < Object > o = TestHelper . mockObserver ( ) ; final List < Observer < Object > > values = new ArrayList < > ( ) ; Observer < Observable < Integer > > wo = new DefaultObserver < Observable < Integer > > ( ) @ Override public void onNext ( Observable < Integer > args ) final Observer < Object > mo = TestHelper . mockObserver ( ) ; values . add ( mo ) ; args . subscribe ( mo ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; ; source . window ( boundary ) . subscribe ( wo ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; boundary . onError ( new TestException ( ) ) ; assertEquals ( 1 , values . size ( ) ) ; Observer < Object > mo = values . get ( 0 ) ; verify ( mo ) . onNext ( 0 ) ; verify ( mo ) . onNext ( 1 ) ; verify ( mo ) . onNext ( 2 ) ; verify ( mo ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; final Observer < Object > o = TestHelper . mockObserver ( ) ; final List < Observer < Object > > values = new ArrayList < > ( ) ; Observer < Observable < Integer > > wo = new DefaultObserver < Observable < Integer > > ( ) @ Override public void onNext ( Observable < Integer > args ) final Observer < Object > mo = TestHelper . mockObserver ( ) ; values . add ( mo ) ; args . subscribe ( mo ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; ; source . window ( boundary ) . subscribe ( wo ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertEquals ( 1 , values . size ( ) ) ; Observer < Object > mo = values . get ( 0 ) ; verify ( mo ) . onNext ( 0 ) ; verify ( mo ) . onNext ( 1 ) ; verify ( mo ) . onNext ( 2 ) ; verify ( mo ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
TestHelper . checkDisposed ( Observable . never ( ) . window ( Observable . never ( ) ) ) ; 
TestObserverEx < Object > to = Observable . error ( new TestException ( ) ) . window ( Observable . never ( ) ) . flatMap ( Functions . < Observable < Object > > identity ( ) , true ) . to ( TestHelper . testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > o ) throws Exception return Observable . just ( 1 ) . window ( o ) . flatMap ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return v ; ) ; , false , 1 , 1 , ( Object [ ] ) null ) ; 
final Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( BehaviorSubject . createDefault ( 1 ) ) . flatMap ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return v ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Object > , Object > ( ) @ Override public Object apply ( Observable < Object > o ) throws Exception return o . window ( Observable . never ( ) ) . flatMap ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > v ) throws Exception return v ; ) ; , false , 1 , 1 , 1 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Observable < Object > > > ( ) @ Override public Observable < Observable < Object > > apply ( Observable < Object > f ) throws Exception return f . window ( Observable . never ( ) ) . takeLast ( 1 ) ; ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; TestObserver < Integer > to = source . window ( boundary ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > w ) throws Exception return w . take ( 1 ) ; ) . test ( ) ; source . onNext ( 1 ) ; assertFalse ( "source not disposed" , source . hasObservers ( ) ) ; assertFalse ( "boundary not disposed" , boundary . hasObservers ( ) ) ; to . assertResult ( 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Observer < ? super Object > > ref = new AtomicReference < > ( ) ; TestObserverEx < Observable < Object > > to = Observable . error ( new TestException ( "main" ) ) . window ( new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ref . set ( observer ) ; ) . doOnNext ( new Consumer < Observable < Object > > ( ) @ Override public void accept ( Observable < Object > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . to ( TestHelper . < Observable < Object > > testConsumer ( ) ) ; to . assertValueCount ( 1 ) . assertError ( TestException . class ) . assertErrorMessage ( "main" ) . assertNotComplete ( ) ; ref . get ( ) . onError ( new TestException ( "inner" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Observer < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Observer < ? super Object > > ref = new AtomicReference < > ( ) ; TestObserverEx < Observable < Object > > to = new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; refMain . set ( observer ) ; . window ( new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ref . set ( observer ) ; ) . to ( TestHelper . < Observable < Object > > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) refMain . get ( ) . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ref . get ( ) . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertValueCount ( 1 ) . assertTerminated ( ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicReference < Observer < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Observer < ? super Object > > ref = new AtomicReference < > ( ) ; TestObserver < Observable < Object > > to = new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; refMain . set ( observer ) ; . window ( new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ref . set ( observer ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) refMain . get ( ) . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ref . get ( ) . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertValueCount ( 2 ) . assertNotComplete ( ) . assertNoErrors ( ) ; 
final AtomicReference < Observer < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Observer < ? super Object > > ref = new AtomicReference < > ( ) ; TestObserverEx < Observable < Object > > to = new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; refMain . set ( observer ) ; . window ( new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ref . set ( observer ) ; ) . to ( TestHelper . < Observable < Object > > testConsumer ( ) ) ; to . assertValueCount ( 1 ) . assertNotTerminated ( ) . dispose ( ) ; ref . get ( ) . onNext ( 1 ) ; to . assertValueCount ( 1 ) . assertNotTerminated ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicReference < Observer < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Observer < ? super Object > > ref = new AtomicReference < > ( ) ; final TestObserver < Observable < Object > > to = new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; refMain . set ( observer ) ; . window ( new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) final AtomicInteger counter = new AtomicInteger ( ) ; observer . onSubscribe ( new Disposable ( ) @ Override public void dispose ( ) for ( int i = 0 ; i < 100 ; i ++ ) counter . incrementAndGet ( ) ; @ Override public boolean isDisposed ( ) return false ; ) ; ref . set ( observer ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) Observer < Object > o = ref . get ( ) ; o . onNext ( 1 ) ; o . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicReference < Observer < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Observer < ? super Object > > ref = new AtomicReference < > ( ) ; final TestObserver < Observable < Object > > to = new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; refMain . set ( observer ) ; . window ( new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) final AtomicInteger counter = new AtomicInteger ( ) ; observer . onSubscribe ( new Disposable ( ) @ Override public void dispose ( ) for ( int i = 0 ; i < 100 ; i ++ ) counter . incrementAndGet ( ) ; @ Override public boolean isDisposed ( ) return false ; ) ; ref . set ( observer ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) Observer < Object > o = ref . get ( ) ; o . onNext ( 1 ) ; o . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( Observable . < Integer > never ( ) ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < Observable < Integer > > inner = new AtomicReference < > ( ) ; TestObserver < Observable < Integer > > to = ps . window ( Observable . < Integer > never ( ) ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to . assertValueCount ( 1 ) ; ps . onNext ( 1 ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; to . assertValueCount ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = source . replay ( 3 ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; ConnectableObservable < Integer > co = source . replay ( 3 , 100 , TimeUnit . MILLISECONDS , scheduler ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = source . replay ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Observable < Integer > , Observable < Integer > > selector = new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > t1 ) return t1 . map ( dbl ) ; ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > co = source . replay ( selector ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 8 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Observable < Integer > , Observable < Integer > > selector = new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > t1 ) return t1 . map ( dbl ) ; ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > co = source . replay ( selector , 3 ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 8 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Observable < Integer > , Observable < Integer > > selector = new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > t1 ) return t1 . map ( dbl ) ; ; TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > co = source . replay ( selector , 100 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 6 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = source . replay ( 3 ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onComplete ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = source . replay ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onComplete ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onComplete ( ) ; 
final AtomicInteger effectCounter = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 , 2 , 3 , 4 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) effectCounter . incrementAndGet ( ) ; System . out . println ( "Sideeffect #" + v ) ; ) ; Observable < Integer > result = source . replay ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > o ) return o . take ( 2 ) ; ) ; for ( int i = 1 ; i < 3 ; i ++ ) effectCounter . set ( 0 ) ; System . out . printf ( "- %d -%n" , i ) ; result . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) System . out . println ( t1 ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) t1 . printStackTrace ( ) ; , new Action ( ) @ Override public void run ( ) System . out . println ( "Done" ) ; ) ; assertEquals ( 2 , effectCounter . get ( ) ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; Observer < Integer > spiedSubscriberBeforeConnect = TestHelper . mockObserver ( ) ; Observer < Integer > spiedSubscriberAfterConnect = TestHelper . mockObserver ( ) ; Observable < Integer > source = Observable . just ( 1 , 2 ) ; ConnectableObservable < Integer > replay = source . doOnNext ( sourceNext ) . doOnDispose ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . replay ( ) ; replay . subscribe ( spiedSubscriberBeforeConnect ) ; replay . subscribe ( spiedSubscriberBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( spiedSubscriberAfterConnect ) ; replay . subscribe ( spiedSubscriberAfterConnect ) ; verify ( spiedSubscriberBeforeConnect , times ( 2 ) ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( spiedSubscriberAfterConnect , times ( 2 ) ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 2 ) ; verify ( sourceCompleted , times ( 1 ) ) . run ( ) ; verifyObserverMock ( spiedSubscriberBeforeConnect , 2 , 4 ) ; verifyObserverMock ( spiedSubscriberAfterConnect , 2 , 4 ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( spiedSubscriberBeforeConnect ) ; verifyNoMoreInteractions ( spiedSubscriberAfterConnect ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; final TestScheduler mockScheduler = new TestScheduler ( ) ; Observer < Integer > mockObserverBeforeConnect = TestHelper . mockObserver ( ) ; Observer < Integer > mockObserverAfterConnect = TestHelper . mockObserver ( ) ; ConnectableObservable < Integer > replay = Observable . just ( 1 , 2 , 3 ) . doOnNext ( sourceNext ) . doOnDispose ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . subscribeOn ( mockScheduler ) . replay ( ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( mockObserverAfterConnect ) ; verify ( mockObserverBeforeConnect ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( mockObserverAfterConnect ) . onSubscribe ( ( Disposable ) any ( ) ) ; mockScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 2 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 3 ) ; verify ( sourceCompleted , times ( 1 ) ) . run ( ) ; verifyObserverMock ( mockObserverBeforeConnect , 1 , 3 ) ; verifyObserverMock ( mockObserverAfterConnect , 1 , 3 ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( mockObserverBeforeConnect ) ; verifyNoMoreInteractions ( mockObserverAfterConnect ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Consumer < Throwable > sourceError = mock ( Consumer . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; final TestScheduler mockScheduler = new TestScheduler ( ) ; Observer < Integer > mockObserverBeforeConnect = TestHelper . mockObserver ( ) ; Observer < Integer > mockObserverAfterConnect = TestHelper . mockObserver ( ) ; Function < Integer , Integer > mockFunc = mock ( Function . class ) ; IllegalArgumentException illegalArgumentException = new IllegalArgumentException ( ) ; when ( mockFunc . apply ( 1 ) ) . thenReturn ( 1 ) ; when ( mockFunc . apply ( 2 ) ) . thenThrow ( illegalArgumentException ) ; ConnectableObservable < Integer > replay = Observable . just ( 1 , 2 , 3 ) . map ( mockFunc ) . doOnNext ( sourceNext ) . doOnDispose ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . doOnError ( sourceError ) . subscribeOn ( mockScheduler ) . replay ( ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( mockObserverAfterConnect ) ; verify ( mockObserverBeforeConnect ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( mockObserverAfterConnect ) . onSubscribe ( ( Disposable ) any ( ) ) ; mockScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceError , times ( 1 ) ) . accept ( illegalArgumentException ) ; verifyObserver ( mockObserverBeforeConnect , 1 , 1 , illegalArgumentException ) ; verifyObserver ( mockObserverAfterConnect , 1 , 1 , illegalArgumentException ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceError ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( mockObserverBeforeConnect ) ; verifyNoMoreInteractions ( mockObserverAfterConnect ) ; 
return spy ( new InprocessWorker ( mockDisposable ) ) ; 
action . run ( ) ; return mockDisposable ; 
unsubscribed = true ; 
return unsubscribed ; 
BoundedReplayBuffer < Integer > buf = new BoundedReplayBuffer < Integer > ( false ) private static final long serialVersionUID = - 5182053207244406872L ; @ Override void truncate ( ) ; buf . addLast ( new Node ( 1 ) ) ; buf . addLast ( new Node ( 2 ) ) ; buf . addLast ( new Node ( 3 ) ) ; buf . addLast ( new Node ( 4 ) ) ; buf . addLast ( new Node ( 5 ) ) ; List < Integer > values = new ArrayList < > ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , values ) ; buf . removeSome ( 2 ) ; buf . removeFirst ( ) ; buf . removeSome ( 2 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; buf . addLast ( new Node ( 5 ) ) ; buf . addLast ( new Node ( 6 ) ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 , 6 ) , values ) ; 
TestScheduler test = new TestScheduler ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = new SizeAndTimeBoundReplayBuffer < > ( 2 , 2000 , TimeUnit . MILLISECONDS , test , false ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . next ( 2 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . complete ( ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; Assert . assertEquals ( 1 , buf . size ) ; Assert . assertTrue ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; 
TestScheduler test = new TestScheduler ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = new SizeAndTimeBoundReplayBuffer < > ( 2 , 2000 , TimeUnit . MILLISECONDS , test , false ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . next ( 2 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . error ( new TestException ( ) ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; Assert . assertEquals ( 1 , buf . size ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertTrue ( buf . hasError ( ) ) ; 
SizeBoundReplayBuffer < Integer > buf = new SizeBoundReplayBuffer < > ( 2 , false ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; buf . next ( 2 ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 4 , 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; buf . complete ( ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 4 , 5 ) , values ) ; Assert . assertEquals ( 3 , buf . size ) ; Assert . assertTrue ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; 
Observable < Integer > source = Observable . range ( 0 , 1000 ) . replay ( ) . autoConnect ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; source . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; List < Integer > onNextEvents = to . values ( ) ; assertEquals ( 1000 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < String > o = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; System . out . println ( "published Observable being executed" ) ; observer . onNext ( "one" ) ; observer . onComplete ( ) ; ) . start ( ) ; ) . replay ( ) . autoConnect ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
Action unsubscribe = mock ( Action . class ) ; Observable < Integer > o = Observable . just ( 1 ) . doOnDispose ( unsubscribe ) . replay ( ) . autoConnect ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; verify ( unsubscribe , never ( ) ) . run ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable < Integer > cached = Observable . range ( 1 , 100 ) . replay ( ) . autoConnect ( ) ; cached . take ( 10 ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable < Integer > source = Observable . range ( 1 , 10000 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestObserverEx < Integer > to1 = new TestObserverEx < > ( ) ; Observable < Integer > cached = source . replay ( ) . autoConnect ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( to1 ) ; to1 . awaitDone ( 2 , TimeUnit . SECONDS ) ; to1 . assertNoErrors ( ) ; to1 . assertTerminated ( ) ; assertEquals ( 10000 , to1 . values ( ) . size ( ) ) ; TestObserverEx < Integer > to2 = new TestObserverEx < > ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( to2 ) ; to2 . awaitDone ( 2 , TimeUnit . SECONDS ) ; to2 . assertNoErrors ( ) ; to2 . assertTerminated ( ) ; assertEquals ( 10000 , to2 . values ( ) . size ( ) ) ; 
Observable < Long > source = Observable . interval ( 1 , 1 , TimeUnit . MILLISECONDS ) . take ( 1000 ) . subscribeOn ( Schedulers . io ( ) ) ; Observable < Long > cached = source . replay ( ) . autoConnect ( ) ; Observable < Long > output = cached . observeOn ( Schedulers . computation ( ) ) ; List < TestObserverEx < Long > > list = new ArrayList < > ( 100 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestObserverEx < Long > to = new TestObserverEx < > ( ) ; list . add ( to ) ; output . skip ( i * 10 ) . take ( 10 ) . subscribe ( to ) ; List < Long > expected = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) expected . add ( ( long ) ( i - 10 ) ) ; int j = 0 ; for ( TestObserverEx < Long > to : list ) to . awaitDone ( 3 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; for ( int i = j * 10 ; i < j * 10 + 10 ; i ++ ) expected . set ( i - j * 10 , ( long ) i ) ; to . assertValueSequence ( expected ) ; j ++ ; 
final int m = 4 * 1000 * 1000 ; Observable < Integer > firehose = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > t ) t . onSubscribe ( Disposable . empty ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) t . onNext ( i ) ; t . onComplete ( ) ; ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; firehose . replay ( ) . autoConnect ( ) . observeOn ( Schedulers . computation ( ) ) . takeLast ( 100 ) . subscribe ( to ) ; to . awaitDone ( 3 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; assertEquals ( 100 , to . values ( ) . size ( ) ) ; 
Observable < Integer > source = Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . replay ( ) . autoConnect ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; source . subscribe ( to ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; to . assertNotComplete ( ) ; Assert . assertEquals ( 1 , to . errors ( ) . size ( ) ) ; TestObserverEx < Integer > to2 = new TestObserverEx < > ( ) ; source . subscribe ( to2 ) ; to2 . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; to2 . assertNotComplete ( ) ; Assert . assertEquals ( 1 , to2 . errors ( ) . size ( ) ) ; 
Observable . just ( 1 ) . replay ( 1 , TimeUnit . MINUTES ) . autoConnect ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . replay ( 1 , 1 , TimeUnit . MILLISECONDS ) . autoConnect ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . replay ( Functions . < Observable < Integer > > identity ( ) , 1 , TimeUnit . MINUTES ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . range ( 1 , 2 ) . replay ( Integer . MAX_VALUE ) . autoConnect ( ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable < Integer > source = Observable . range ( 1 , 3 ) ; assertSame ( source , ( ( ( HasUpstreamObservableSource < ? > ) source . replay ( ) ) ) . source ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . range ( 1 , 3 ) . replay ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) co . connect ( ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . range ( 1 , 3 ) . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; final TestObserver < Integer > to2 = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . range ( 1 , 3 ) . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; final TestObserver < Integer > to2 = new TestObserver < > ( ) ; co . subscribe ( to1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
Observable . range ( 1 , 2 ) . replay ( Integer . MAX_VALUE ) . autoConnect ( ) . test ( true ) . assertEmpty ( ) ; 
ConnectableObservable < Integer > co = PublishSubject . < Integer > create ( ) . replay ( Integer . MAX_VALUE ) ; co . test ( ) ; co . autoConnect ( ) . test ( true ) . assertEmpty ( ) ; 
ConnectableObservable < Integer > co = Observable . range ( 1 , 2 ) . replay ( ) ; try co . connect ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable t ) throws Exception throw new TestException ( ) ; ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) co . test ( ) . assertEmpty ( ) . dispose ( ) ; co . connect ( ) ; co . test ( ) . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; . replay ( ) . autoConnect ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final ConnectableObservable < Integer > co = ps . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) ps . onNext ( j ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final ConnectableObservable < Integer > co = ps . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; co . subscribe ( to1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) ps . onNext ( j ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . range ( 1 , 1000 ) . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; co . connect ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; super . onNext ( t ) ; ; ps . replay ( ) . autoConnect ( ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 , 2 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; super . onNext ( t ) ; ; ps . replay ( 10 ) . autoConnect ( ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 , 2 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) ps . onNext ( 2 ) ; dispose ( ) ; super . onNext ( t ) ; ; ps . replay ( ) . autoConnect ( ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertValues ( 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) ps . onNext ( 2 ) ; dispose ( ) ; super . onNext ( t ) ; ; ps . replay ( 10 ) . autoConnect ( ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertValues ( 1 ) ; 
final Observer < ? > [ ] sub = null ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) sub [ 0 ] = observer ; . replay ( ) . connect ( ) . dispose ( ) ; Disposable bs = Disposable . empty ( ) ; sub [ 0 ] . onSubscribe ( bs ) ; assertTrue ( bs . isDisposed ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > source = Observable . just ( 1 ) . replay ( 2 , TimeUnit . SECONDS , scheduler ) . autoConnect ( ) ; source . test ( ) . assertResult ( 1 ) ; source . test ( ) . assertResult ( 1 ) ; scheduler . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; source . test ( ) . assertResult ( ) ; 
Observable . just ( 1 ) . replay ( new Function < Observable < Integer > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Integer > v ) throws Exception return null ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The selector returned a null ObservableSource" ) ; 
ObservableReplay . multicastSelector ( Functions . justSupplier ( ( ConnectableObservable < Integer > ) null ) , Functions . justFunction ( Observable . just ( 1 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The connectableFactory returned a null ConnectableObservable" ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; assertNotNull ( buf . get ( ) . value ) ; buf . trimHead ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , TimeUnit . MILLISECONDS , sch ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; sch . advanceTimeBy ( 2 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; assertNotNull ( buf . get ( ) . value ) ; buf . trimHead ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
Observable < byte [ ] > source = Observable . range ( 1 , 200 ) . map ( new Function < Integer , byte [ ] > ( ) @ Override public byte [ ] apply ( Integer v ) throws Exception return new byte [ 1024 * 1024 ] ; ) . replay ( new Function < Observable < byte [ ] > , Observable < byte [ ] > > ( ) @ Override public Observable < byte [ ] > apply ( final Observable < byte [ ] > o ) throws Exception return o . take ( 1 ) . concatMap ( new Function < byte [ ] , Observable < byte [ ] > > ( ) @ Override public Observable < byte [ ] > apply ( byte [ ] v ) throws Exception return o ; ) ; , 1 ) . takeLast ( 1 ) ; System . out . println ( "Bounded Replay Leak check: Wait before GC" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check: GC" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long initial = memHeap . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; final AtomicLong after = new AtomicLong ( ) ; source . subscribe ( new Consumer < byte [ ] > ( ) @ Override public void accept ( byte [ ] v ) throws Exception System . out . println ( "Bounded Replay Leak check: Wait before GC 2" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check:  GC 2" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; after . set ( memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ) ; ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after . get ( ) / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after . get ( ) ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after . get ( ) / 1024.0 / 1024.0 ) ; 
ConnectableObservable < Object > co = Observable . never ( ) . replay ( ) ; co . connect ( ) ; co . connect ( d -> throw new TestException ( ) ; ) ; 
ConnectableObservable < Object > co = Observable . never ( ) . replay ( ) ; co . reset ( ) ; 
ConnectableObservable < Object > co = Observable . never ( ) . replay ( ) ; co . connect ( ) ; co . reset ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = ps . replay ( ) ; TestObserver < Integer > to = co . test ( ) ; Disposable d = co . connect ( ) ; ps . onNext ( 1 ) ; d . dispose ( ) ; to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertEmpty ( ) ; ps . onNext ( 2 ) ; to . assertValuesOnly ( 2 ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; observer = TestHelper . mockObserver ( ) ; 
Observable < Observable < String > > source = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > outerObserver ) outerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( outerObserver , 50 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 70 , "one" ) ; publishNext ( innerObserver , 100 , "two" ) ; publishCompleted ( innerObserver , 200 ) ; ) ) ; publishCompleted ( outerObserver , 60 ) ; ) ; Observable < String > sampled = Observable . switchOnNext ( source ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 350 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 2 ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Observable < String > > source = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > outerObserver ) outerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( outerObserver , 10 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 0 , "one" ) ; publishNext ( innerObserver , 10 , "two" ) ; publishCompleted ( innerObserver , 20 ) ; ) ) ; publishNext ( outerObserver , 100 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 0 , "three" ) ; publishNext ( innerObserver , 10 , "four" ) ; publishCompleted ( innerObserver , 20 ) ; ) ) ; publishCompleted ( outerObserver , 200 ) ; ) ; Observable < String > sampled = Observable . switchOnNext ( source ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 150 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "four" ) ; scheduler . advanceTimeTo ( 250 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Observable < String > > source = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > outerObserver ) outerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( outerObserver , 50 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 60 , "one" ) ; publishNext ( innerObserver , 100 , "two" ) ; ) ) ; publishNext ( outerObserver , 200 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 0 , "three" ) ; publishNext ( innerObserver , 100 , "four" ) ; ) ) ; publishCompleted ( outerObserver , 250 ) ; ) ; Observable < String > sampled = Observable . switchOnNext ( source ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 125 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 175 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 225 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 350 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "four" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Observable < String > > source = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > outerObserver ) outerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( outerObserver , 50 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 50 , "one" ) ; publishNext ( innerObserver , 100 , "two" ) ; ) ) ; publishNext ( outerObserver , 200 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 0 , "three" ) ; publishNext ( innerObserver , 100 , "four" ) ; ) ) ; publishError ( outerObserver , 250 , new TestException ( ) ) ; ) ; Observable < String > sampled = Observable . switchOnNext ( source ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 125 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 175 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 225 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 350 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Observable < Observable < String > > source = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > outerObserver ) outerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( outerObserver , 50 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 50 , "one" ) ; publishNext ( innerObserver , 100 , "two" ) ; ) ) ; publishNext ( outerObserver , 130 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishCompleted ( innerObserver , 0 ) ; ) ) ; publishNext ( outerObserver , 150 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 50 , "three" ) ; ) ) ; ) ; Observable < String > sampled = Observable . switchOnNext ( source ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 125 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 250 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Observable < String > > source = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( observer , 50 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( observer , 50 , "one" ) ; publishNext ( observer , 100 , "two" ) ; ) ) ; publishNext ( observer , 130 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; publishError ( observer , 0 , new TestException ( ) ) ; ) ) ; publishNext ( observer , 150 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( observer , 50 , "three" ) ; ) ) ; ) ; Observable < String > sampled = Observable . switchOnNext ( source ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 125 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 250 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Observable < Observable < String > > source = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > outerObserver ) outerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( outerObserver , 0 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 10 , "1-one" ) ; publishNext ( innerObserver , 20 , "1-two" ) ; publishNext ( innerObserver , 30 , "1-three" ) ; publishCompleted ( innerObserver , 40 ) ; ) ) ; publishNext ( outerObserver , 25 , Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 10 , "2-one" ) ; publishNext ( innerObserver , 20 , "2-two" ) ; publishNext ( innerObserver , 30 , "2-three" ) ; publishCompleted ( innerObserver , 40 ) ; ) ) ; publishCompleted ( outerObserver , 30 ) ; ) ; Observable < String > sampled = Observable . switchOnNext ( source ) ; sampled . subscribe ( observer ) ; scheduler . advanceTimeTo ( 1000 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "1-one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "1-two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "2-one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "2-two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "2-three" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final AtomicBoolean isUnsubscribed = new AtomicBoolean ( ) ; Observable . switchOnNext ( Observable . unsafeCreate ( new ObservableSource < Observable < Integer > > ( ) @ Override public void subscribe ( final Observer < ? super Observable < Integer > > observer ) Disposable bs = Disposable . empty ( ) ; observer . onSubscribe ( bs ) ; observer . onNext ( Observable . just ( 1 ) ) ; isUnsubscribed . set ( bs . isDisposed ( ) ) ; ) ) . take ( 1 ) . subscribe ( ) ; assertTrue ( "Switch doesn't propagate 'unsubscribe'" , isUnsubscribed . get ( ) ) ; 
Observable < String > oneItem = Observable . just ( "Hello" ) . mergeWith ( Observable . < String > never ( ) ) ; Observable < String > src = oneItem . switchMap ( new Function < String , Observable < String > > ( ) @ Override public Observable < String > apply ( final String s ) return Observable . just ( s ) . mergeWith ( Observable . interval ( 10 , TimeUnit . MILLISECONDS ) . map ( new Function < Long , String > ( ) @ Override public String apply ( Long i ) return s + " " + i ; ) ) . take ( 250 ) ; ) . share ( ) ; TestObserverEx < String > to = new TestObserverEx < String > ( ) @ Override public void onNext ( String t ) super . onNext ( t ) ; if ( values ( ) . size ( ) == 250 ) onComplete ( ) ; dispose ( ) ; ; src . subscribe ( to ) ; to . awaitDone ( 10 , TimeUnit . SECONDS ) ; System . out . println ( "> testIssue2654: " + to . values ( ) . size ( ) ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; Assert . assertEquals ( 250 , to . values ( ) . size ( ) ) ; 
PublishSubject < ObservableSource < Integer > > source = PublishSubject . create ( ) ; TestObserverEx < Integer > to = source . switchMapDelayError ( Functions . < ObservableSource < Integer > > identity ( ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; source . onNext ( Observable . just ( 1 ) ) ; source . onNext ( Observable . < Integer > error ( new TestException ( "Forced failure 1" ) ) ) ; source . onNext ( Observable . just ( 2 , 3 , 4 ) ) ; source . onNext ( Observable . < Integer > error ( new TestException ( "Forced failure 2" ) ) ) ; source . onNext ( Observable . just ( 5 ) ) ; source . onError ( new TestException ( "Forced failure 3" ) ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 ) . assertNotComplete ( ) . assertError ( CompositeException . class ) ; List < Throwable > errors = ExceptionHelper . flatten ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Forced failure 1" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Forced failure 2" ) ; TestHelper . assertError ( errors , 2 , TestException . class , "Forced failure 3" ) ; 
PublishSubject < Observable < Integer > > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . switchOnNextDelayError ( ps ) . test ( ) ; ps . onNext ( Observable . just ( 1 ) ) ; ps . onNext ( Observable . range ( 2 , 4 ) ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
PublishSubject < Observable < Integer > > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . switchOnNextDelayError ( ps ) . test ( ) ; ps . onNext ( Observable . just ( 1 ) ) ; ps . onNext ( Observable . < Integer > error ( new TestException ( ) ) ) ; ps . onNext ( Observable . range ( 2 , 4 ) ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
PublishSubject < Observable < Integer > > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . switchOnNextDelayError ( ps , 2 ) . test ( ) ; ps . onNext ( Observable . just ( 1 ) ) ; ps . onNext ( Observable . range ( 2 , 4 ) ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
assertSame ( Observable . empty ( ) , Observable . < Object > empty ( ) . switchMapDelayError ( new Function < Object , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , 16 ) ) ; 
Observable . just ( 0 ) . switchMapDelayError ( new Function < Object , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , 16 ) . test ( ) . assertResult ( 1 ) ; 
assertSame ( Observable . empty ( ) , Observable . < Object > empty ( ) . switchMap ( new Function < Object , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , 16 ) ) ; 
Observable . just ( 0 ) . switchMap ( new Function < Object , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , 16 ) . test ( ) . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( 1 ) . switchMap ( Functions . justFunction ( ps ) ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; 
Observable . just ( 0 ) . switchMapSingle ( new Function < Object , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Object v ) throws Exception return Single . just ( 1 ) ; ) . test ( ) . assertResult ( 1 ) ; 
Observable . just ( 0 ) . switchMapSingle ( new Function < Object , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Object v ) throws Exception return null ; ) . test ( ) . assertError ( NullPointerException . class ) ; 
Observable . just ( 0 ) . switchMapSingle ( new Function < Object , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Object v ) throws Exception return new SingleSource < Integer > ( ) @ Override public void subscribe ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSuccess ( 1 ) ; ; ) . test ( ) . assertResult ( 1 ) ; 
final AtomicBoolean completed = new AtomicBoolean ( ) ; Observable . just ( 0 , 1 ) . switchMapSingleDelayError ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 0 ) return Single . error ( new RuntimeException ( ) ) ; else return Single . just ( 1 ) . doOnSuccess ( new Consumer < Integer > ( ) @ Override public void accept ( Integer n ) throws Exception completed . set ( true ) ; ) ; ) . test ( ) . assertValue ( 1 ) . assertError ( RuntimeException . class ) ; assertTrue ( completed . get ( ) ) ; 
Observable . switchOnNext ( Observable . just ( Observable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . switchOnNextDelayError ( Observable . just ( Observable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Observable . switchOnNext ( Observable . just ( Observable . just ( 1 ) ) . hide ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; ps1 . switchMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ps2 ; return Observable . never ( ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onNext ( 2 ) ; ; final TestException ex = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; for ( Throwable e : errors ) assertTrue ( e . toString ( ) , e instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; ps1 . switchMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ps2 ; return Observable . never ( ) ; ) . test ( ) ; ps1 . onNext ( 1 ) ; final TestException ex1 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex1 ) ; ; final TestException ex2 = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; for ( Throwable e : errors ) assertTrue ( e . getCause ( ) . toString ( ) , e . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps1 . switchMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . never ( ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onNext ( 2 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Observable . just ( 1 ) . hide ( ) . switchMap ( new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . switchMap ( Functions . justFunction ( Observable . never ( ) ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . range ( 1 , 5 ) . switchMap ( Functions . justFunction ( Observable . empty ( ) ) ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 5 ) . switchMap ( Functions . justFunction ( Observable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ps . onComplete ( ) ; ; Observable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( ps ) ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; ps . onError ( new TestException ( ) ) ; ; Observable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( ps ) ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertFailure ( TestException . class , 1 ) ; 
final PublishSubject < Integer > main = PublishSubject . create ( ) ; final PublishSubject < Integer > inner = PublishSubject . create ( ) ; TestObserver < Integer > to = main . switchMap ( Functions . justFunction ( inner ) ) . test ( ) ; assertTrue ( main . hasObservers ( ) ) ; main . onNext ( 1 ) ; assertTrue ( inner . hasObservers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( inner . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Observer < ? super Integer > > obs1 = new AtomicReference < > ( ) ; final Observable < Integer > ps1 = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) obs1 . set ( observer ) ; ; final AtomicReference < Observer < ? super Integer > > obs2 = new AtomicReference < > ( ) ; final Observable < Integer > ps2 = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) obs2 . set ( observer ) ; ; ps1 . switchMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception if ( v == 1 ) return ps2 ; return Observable . never ( ) ; ) . test ( ) ; obs1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; obs1 . get ( ) . onNext ( 1 ) ; obs2 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; final TestException ex1 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) obs1 . get ( ) . onError ( ex1 ) ; ; final TestException ex2 = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) obs2 . get ( ) . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; for ( Throwable e : errors ) assertTrue ( e . toString ( ) , e . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( Observable . range ( 1 , 5 ) . observeOn ( ImmediateThinScheduler . INSTANCE ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . hide ( ) . switchMap ( Functions . justFunction ( Maybe . just ( 1 ) . toObservable ( ) ) ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Observable . range ( 1 , 5 ) . hide ( ) . switchMap ( Functions . justFunction ( Single . just ( 1 ) . toObservable ( ) ) ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Observable . range ( 1 , 5 ) . hide ( ) . switchMap ( Functions . justFunction ( Completable . complete ( ) . toObservable ( ) ) ) . test ( ) . assertResult ( ) ; 
Observable . just ( 1 ) . hide ( ) . switchMap ( Functions . justFunction ( TestHelper . rejectObservableFusion ( ) ) ) . test ( ) . assertEmpty ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . switchMap ( Functions . justFunction ( Observable . range ( 1 , 5 ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > observableStripBoundary ( ) ) ) ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . switchMapDelayError ( Functions . justFunction ( Observable . range ( 1 , 5 ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > observableStripBoundary ( ) ) ) ) . test ( ) ; to . assertEmpty ( ) ; ps . onNext ( 1 ) ; assertTrue ( ps . hasObservers ( ) ) ; to . assertEmpty ( ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
String thread = Thread . currentThread ( ) . getName ( ) ; TestObserver < Object > to = Observable . range ( 1 , 10000 ) . switchMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . just ( 2 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer w ) throws Exception return Thread . currentThread ( ) . getName ( ) ; ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; for ( Object o : to . values ( ) ) assertNotEquals ( thread , o ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Throwable to . dispose ( ) ; throw new TestException ( ) ; ) . switchMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . range ( 1 , 2 ) . switchMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . fromIterable ( Arrays . asList ( v * 10 ) ) ; ) . test ( ) . assertResult ( 10 , 20 ) ; 
Observable . range ( 1 , 2 ) . switchMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . fromIterable ( Arrays . asList ( v * 10 ) ) . hide ( ) ; ) . test ( ) . assertResult ( 10 , 20 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( f -> f . switchMap ( v -> Observable . never ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) AtomicReference < Observer < ? super Integer > > ref = new AtomicReference < > ( ) ; Observable < Integer > o = new Observable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Observer < ? super @ NonNull Integer > observer ) ref . set ( observer ) ; ; TestObserver < Object > to = o . switchMap ( v -> Observable . never ( ) ) . test ( ) ; ref . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; TestHelper . race ( ( ) -> ref . get ( ) . onComplete ( ) , ( ) -> to . dispose ( ) ) ; 
TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) AtomicReference < Observer < ? super Integer > > ref1 = new AtomicReference < > ( ) ; Observable < Integer > o1 = new Observable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Observer < ? super @ NonNull Integer > observer ) ref1 . set ( observer ) ; ; AtomicReference < Observer < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Observable < Integer > o2 = new Observable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Observer < ? super @ NonNull Integer > observer ) ref2 . set ( observer ) ; ; o1 . switchMap ( v -> o2 ) . test ( ) ; ref1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref2 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; TestHelper . race ( ( ) -> ref1 . get ( ) . onComplete ( ) , ( ) -> ref2 . get ( ) . onError ( ex ) ) ; 
AtomicReference < Observer < ? super Integer > > ref1 = new AtomicReference < > ( ) ; Observable < Integer > o1 = new Observable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Observer < ? super @ NonNull Integer > observer ) ref1 . set ( observer ) ; ; AtomicReference < Observer < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Observable < Integer > o2 = new Observable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Observer < ? super @ NonNull Integer > observer ) ref2 . set ( observer ) ; ; o1 . switchMap ( v -> o2 ) . test ( ) ; ref1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref1 . get ( ) . onComplete ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . switchMap ( v -> Observable . range ( v , 5 ) ) . doOnNext ( v -> if ( v == 1 ) ps . onNext ( 2 ) ; ) . test ( ) ; ps . onNext ( 1 ) ; to . assertValuesOnly ( 1 , 2 , 3 , 4 , 5 , 6 ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = ps1 . switchMapDelayError ( v -> ps2 ) . test ( ) ; ps1 . onNext ( 1 ) ; ps1 . onComplete ( ) ; ps2 . onComplete ( ) ; to . assertResult ( ) ; 
TestHelper . withErrorTracking ( errors -> PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Object > to = ps . switchMap ( v -> if ( v == 1 ) return Observable . unsafeCreate ( s -> s . onSubscribe ( Disposable . empty ( ) ) ; ps . onNext ( 2 ) ; s . onError ( new TestException ( ) ) ; ) ; return Observable . never ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
AtomicInteger outer = new AtomicInteger ( ) ; AtomicInteger inner = new AtomicInteger ( ) ; int n = 10_000 ; for ( int i = 0 ; i < n ; i ++ ) Observable . < Integer > create ( it -> it . onNext ( 0 ) ; ) . switchMap ( v -> createObservable ( inner ) ) . observeOn ( Schedulers . computation ( ) ) . doFinally ( ( ) -> outer . incrementAndGet ( ) ; ) . take ( 1 ) . blockingSubscribe ( v -> , Throwable :: printStackTrace ) ; Thread . sleep ( 100 ) ; assertEquals ( inner . get ( ) , outer . get ( ) ) ; assertEquals ( n , inner . get ( ) ) ; 
return Observable . < Integer > unsafeCreate ( s -> SerializedObserver < Integer > it = new SerializedObserver < > ( s ) ; it . onSubscribe ( Disposable . empty ( ) ) ; Schedulers . io ( ) . scheduleDirect ( ( ) -> it . onNext ( 1 ) ; , 0 , TimeUnit . MILLISECONDS ) ; Schedulers . io ( ) . scheduleDirect ( ( ) -> it . onNext ( 2 ) ; , 0 , TimeUnit . MILLISECONDS ) ; ) . doFinally ( ( ) -> inner . incrementAndGet ( ) ; ) ; 
concat2Strings = new BiFunction < String , String , String > ( ) @ Override public String apply ( String t1 , String t2 ) return t1 + "-" + t2 ; ; s1 = PublishSubject . create ( ) ; s2 = PublishSubject . create ( ) ; zipped = Observable . zip ( s1 , s2 , concat2Strings ) ; observer = TestHelper . mockObserver ( ) ; inOrder = inOrder ( observer ) ; zipped . subscribe ( observer ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s1 . onComplete ( ) ; s2 . onNext ( "1" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a-1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b-2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; s1 . onNext ( "a" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a-1" ) ; s1 . onNext ( "b" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b-2" ) ; s1 . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; s2 . onComplete ( ) ; s1 . onNext ( "a" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a-1" ) ; s1 . onNext ( "b" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b-2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s2 . onNext ( "1" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a-1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b-2" ) ; s2 . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
return new Function < Integer , Observable < T > > ( ) @ Override public Observable < T > apply ( Integer t1 ) return observable ; ; 
MockitoAnnotations . openMocks ( this ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > m = source1 . join ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , add ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; source1 . onNext ( 2 ) ; source1 . onNext ( 4 ) ; source2 . onNext ( 16 ) ; source2 . onNext ( 32 ) ; source2 . onNext ( 64 ) ; source1 . onComplete ( ) ; source2 . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( 17 ) ; verify ( observer , times ( 1 ) ) . onNext ( 18 ) ; verify ( observer , times ( 1 ) ) . onNext ( 20 ) ; verify ( observer , times ( 1 ) ) . onNext ( 33 ) ; verify ( observer , times ( 1 ) ) . onNext ( 34 ) ; verify ( observer , times ( 1 ) ) . onNext ( 36 ) ; verify ( observer , times ( 1 ) ) . onNext ( 65 ) ; verify ( observer , times ( 1 ) ) . onNext ( 66 ) ; verify ( observer , times ( 1 ) ) . onNext ( 68 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; PublishSubject < Integer > duration1 = PublishSubject . create ( ) ; Observable < Integer > m = source1 . join ( source2 , just ( duration1 ) , just ( Observable . never ( ) ) , add ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; source1 . onNext ( 2 ) ; source2 . onNext ( 16 ) ; duration1 . onNext ( 1 ) ; source1 . onNext ( 4 ) ; source1 . onNext ( 8 ) ; source1 . onComplete ( ) ; source2 . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( 17 ) ; verify ( observer , times ( 1 ) ) . onNext ( 18 ) ; verify ( observer , times ( 1 ) ) . onNext ( 20 ) ; verify ( observer , times ( 1 ) ) . onNext ( 24 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > m = source1 . join ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , add ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; source1 . onNext ( 2 ) ; source1 . onComplete ( ) ; source2 . onNext ( 16 ) ; source2 . onNext ( 32 ) ; source2 . onNext ( 64 ) ; source2 . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( 17 ) ; verify ( observer , times ( 1 ) ) . onNext ( 18 ) ; verify ( observer , times ( 1 ) ) . onNext ( 33 ) ; verify ( observer , times ( 1 ) ) . onNext ( 34 ) ; verify ( observer , times ( 1 ) ) . onNext ( 65 ) ; verify ( observer , times ( 1 ) ) . onNext ( 66 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > m = source1 . join ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , add ) ; m . subscribe ( observer ) ; source2 . onNext ( 1 ) ; source1 . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > m = source1 . join ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , add ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; source2 . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > duration1 = Observable . < Integer > error ( new RuntimeException ( "Forced failure" ) ) ; Observable < Integer > m = source1 . join ( source2 , just ( duration1 ) , just ( Observable . never ( ) ) , add ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Observable < Integer > duration1 = Observable . < Integer > error ( new RuntimeException ( "Forced failure" ) ) ; Observable < Integer > m = source1 . join ( source2 , just ( Observable . never ( ) ) , just ( duration1 ) , add ) ; m . subscribe ( observer ) ; source2 . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > fail = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) throw new RuntimeException ( "Forced failure" ) ; ; Observable < Integer > m = source1 . join ( source2 , fail , just ( Observable . never ( ) ) , add ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > fail = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) throw new RuntimeException ( "Forced failure" ) ; ; Observable < Integer > m = source1 . join ( source2 , just ( Observable . never ( ) ) , fail , add ) ; m . subscribe ( observer ) ; source2 . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source1 = PublishSubject . create ( ) ; PublishSubject < Integer > source2 = PublishSubject . create ( ) ; BiFunction < Integer , Integer , Integer > fail = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throw new RuntimeException ( "Forced failure" ) ; ; Observable < Integer > m = source1 . join ( source2 , just ( Observable . never ( ) ) , just ( Observable . never ( ) ) , fail ) ; m . subscribe ( observer ) ; source1 . onNext ( 1 ) ; source2 . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; 
TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . join ( Observable . just ( 1 ) , Functions . justFunction ( Observable . never ( ) ) , Functions . justFunction ( Observable . never ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
Observable . just ( 1 ) . join ( Observable . just ( 2 ) , Functions . justFunction ( Observable . never ( ) ) , Functions . justFunction ( Observable . never ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . take ( 1 ) . test ( ) . assertResult ( 3 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . join ( Observable . just ( 2 ) , Functions . justFunction ( Observable . never ( ) ) , Functions . justFunction ( Observable . empty ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertEmpty ( ) ; ps . onNext ( 1 ) ; to . assertEmpty ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . join ( Observable . just ( 2 ) , Functions . justFunction ( Observable . never ( ) ) , Functions . justFunction ( Observable . never ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onError ( new TestException ( "Second" ) ) ; . join ( Observable . just ( 2 ) , Functions . justFunction ( Observable . never ( ) ) , Functions . justFunction ( Observable . never ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try @ SuppressWarnings ( "rawtypes" ) final Observer [ ] o = null ; TestObserverEx < Integer > to = Observable . just ( 1 ) . join ( Observable . just ( 2 ) , Functions . justFunction ( Observable . never ( ) ) , Functions . justFunction ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) o [ 0 ] = observer ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; o [ 0 ] . onError ( new TestException ( "Second" ) ) ; to . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = ps1 . join ( ps2 , v -> Observable . never ( ) , v -> Observable . never ( ) , ( a , b ) -> a + b ) . doOnNext ( v -> ps1 . onComplete ( ) ; ps2 . onNext ( 2 ) ; ps2 . onComplete ( ) ; ) . test ( ) ; ps1 . onNext ( 0 ) ; ps2 . onNext ( 1 ) ; to . assertComplete ( ) ; 
try Observable . just ( 1 ) . lift ( new ObservableOperator < Object , Integer > ( ) @ Override public Observer < ? super Integer > apply ( Observer < ? super Object > o ) throws Exception throw new TestException ( ) ; ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof TestException ) ; 
Subject < String > s = PublishSubject . create ( ) ; Iterator < String > it = mostRecent ( s , "default" ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "default" , it . next ( ) ) ; assertEquals ( "default" , it . next ( ) ) ; s . onNext ( "one" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; s . onNext ( "two" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "two" , it . next ( ) ) ; assertEquals ( "two" , it . next ( ) ) ; s . onComplete ( ) ; assertFalse ( it . hasNext ( ) ) ; 
Subject < String > s = PublishSubject . create ( ) ; Iterator < String > it = mostRecent ( s , "default" ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "default" , it . next ( ) ) ; assertEquals ( "default" , it . next ( ) ) ; s . onError ( new TestException ( ) ) ; assertTrue ( it . hasNext ( ) ) ; it . next ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Long > source = Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 10 ) ; Iterable < Long > iter = source . blockingMostRecent ( - 1L ) ; for ( int j = 0 ; j < 3 ; j ++ ) Iterator < Long > it = iter . iterator ( ) ; Assert . assertEquals ( Long . valueOf ( - 1 ) , it . next ( ) ) ; for ( int i = 0 ; i < 9 ; i ++ ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertTrue ( it . hasNext ( ) ) ; Assert . assertEquals ( Long . valueOf ( i ) , it . next ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertFalse ( it . hasNext ( ) ) ; 
Iterator < Integer > it = Observable . < Integer > empty ( ) . blockingMostRecent ( 1 ) . iterator ( ) ; try it . next ( ) ; fail ( "Should have thrown" ) ; catch ( NoSuchElementException ex ) try it . remove ( ) ; fail ( "Should have thrown" ) ; catch ( UnsupportedOperationException ex ) 
stringObserver = TestHelper . mockObserver ( ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) List < Observable < String > > os = new ArrayList < > ( ) ; os . add ( Observable . just ( "one" , "two" , "three" , "four" , "five" ) . subscribeOn ( Schedulers . newThread ( ) ) ) ; os . add ( Observable . just ( "one" , "two" , "three" , "four" , "five" ) . subscribeOn ( Schedulers . newThread ( ) ) ) ; os . add ( Observable . just ( "one" , "two" , "three" , "four" , "five" ) . subscribeOn ( Schedulers . newThread ( ) ) ) ; List < String > expected = Arrays . asList ( "one" , "two" , "three" , "four" , "five" , "one" , "two" , "three" , "four" , "five" , "one" , "two" , "three" , "four" , "five" ) ; Iterator < String > iter = Observable . merge ( os , 1 ) . blockingIterable ( ) . iterator ( ) ; List < String > actual = new ArrayList < > ( ) ; while ( iter . hasNext ( ) ) actual . add ( iter . next ( ) ) ; assertEquals ( expected , actual ) ; 
for ( int times = 0 ; times < 100 ; times ++ ) int observableCount = 100 ; int maxConcurrent = 2 + ( times % 10 ) ; AtomicInteger subscriptionCount = new AtomicInteger ( 0 ) ; List < Observable < String > > os = new ArrayList < > ( ) ; List < SubscriptionCheckObservable > scos = new ArrayList < > ( ) ; for ( int i = 0 ; i < observableCount ; i ++ ) SubscriptionCheckObservable sco = new SubscriptionCheckObservable ( subscriptionCount , maxConcurrent ) ; scos . add ( sco ) ; os . add ( Observable . unsafeCreate ( sco ) ) ; Iterator < String > iter = Observable . merge ( os , maxConcurrent ) . blockingIterable ( ) . iterator ( ) ; List < String > actual = new ArrayList < > ( ) ; while ( iter . hasNext ( ) ) actual . add ( iter . next ( ) ) ; assertEquals ( 5 * observableCount , actual . size ( ) ) ; for ( SubscriptionCheckObservable sco : scos ) assertFalse ( sco . failed ) ; 
t1 . onSubscribe ( Disposable . empty ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) if ( subscriptionCount . incrementAndGet ( ) > maxConcurrent ) failed = true ; t1 . onNext ( "one" ) ; t1 . onNext ( "two" ) ; t1 . onNext ( "three" ) ; t1 . onNext ( "four" ) ; t1 . onNext ( "five" ) ; subscriptionCount . decrementAndGet ( ) ; t1 . onComplete ( ) ; ) . start ( ) ; 
int n = 10000 ; List < Observable < Integer > > sourceList = new ArrayList < > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) sourceList . add ( Observable . just ( i ) ) ; Iterator < Integer > it = Observable . merge ( Observable . fromIterable ( sourceList ) , 1 ) . blockingIterable ( ) . iterator ( ) ; int j = 0 ; while ( it . hasNext ( ) ) assertEquals ( ( Integer ) j , it . next ( ) ) ; j ++ ; assertEquals ( j , n ) ; 
int n = 10000 ; List < Observable < Integer > > sourceList = new ArrayList < > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) sourceList . add ( Observable . just ( i ) ) ; Iterator < Integer > it = Observable . merge ( Observable . fromIterable ( sourceList ) , 1 ) . take ( n / 2 ) . blockingIterable ( ) . iterator ( ) ; int j = 0 ; while ( it . hasNext ( ) ) assertEquals ( ( Integer ) j , it . next ( ) ) ; j ++ ; assertEquals ( j , n / 2 ) ; 
for ( int i = 1 ; i < 100 ; i ++ ) TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; List < Observable < Integer > > sourceList = new ArrayList < > ( i ) ; List < Integer > result = new ArrayList < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) sourceList . add ( Observable . just ( j ) ) ; result . add ( j ) ; Observable . merge ( sourceList , i ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; to . assertValueSequence ( result ) ; 
for ( int i = 2 ; i < 100 ; i ++ ) TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; List < Observable < Integer > > sourceList = new ArrayList < > ( i ) ; List < Integer > result = new ArrayList < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) sourceList . add ( Observable . just ( j ) ) ; result . add ( j ) ; Observable . merge ( sourceList , i - 1 ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; to . assertValueSequence ( result ) ; 
IoScheduler ios = ( IoScheduler ) Schedulers . io ( ) ; int c = ios . size ( ) ; for ( int i = 0 ; i < 200 ; i ++ ) simpleAsync ( ) ; int c1 = ios . size ( ) ; if ( c + 60 < c1 ) throw new AssertionError ( "Worker leak: " + c + " - " + c1 ) ; 
for ( int i = 1 ; i < 50 ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; List < Observable < Integer > > sourceList = new ArrayList < > ( i ) ; Set < Integer > expected = new HashSet < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) sourceList . add ( Observable . just ( j ) . subscribeOn ( Schedulers . io ( ) ) ) ; expected . add ( j ) ; Observable . merge ( sourceList , i ) . subscribe ( to ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; Set < Integer > actual = new HashSet < > ( to . values ( ) ) ; assertEquals ( expected , actual ) ; 
for ( int i = 0 ; i < 200 ; i ++ ) simpleOneLessAsync ( ) ; 
long t = System . currentTimeMillis ( ) ; for ( int i = 2 ; i < 50 ; i ++ ) if ( System . currentTimeMillis ( ) - t > TimeUnit . SECONDS . toMillis ( 9 ) ) break ; TestObserver < Integer > to = new TestObserver < > ( ) ; List < Observable < Integer > > sourceList = new ArrayList < > ( i ) ; Set < Integer > expected = new HashSet < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) sourceList . add ( Observable . just ( j ) . subscribeOn ( Schedulers . io ( ) ) ) ; expected . add ( j ) ; Observable . merge ( sourceList , i - 1 ) . subscribe ( to ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; Set < Integer > actual = new HashSet < > ( to . values ( ) ) ; assertEquals ( expected , actual ) ; 
List < Observable < Integer > > sourceList = new ArrayList < > ( 3 ) ; sourceList . add ( Observable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; sourceList . add ( Observable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; sourceList . add ( Observable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . merge ( sourceList , 2 ) . take ( 5 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertValueCount ( 5 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . publish ( ) . autoConnect ( 0 ) ; assertTrue ( ps . hasObservers ( ) ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . count ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . count ( ) . toObservable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Long > > ( ) @ Override public ObservableSource < Long > apply ( Observable < Object > o ) throws Exception return o . count ( ) . toObservable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Object > , SingleSource < Long > > ( ) @ Override public SingleSource < Long > apply ( Observable < Object > o ) throws Exception return o . count ( ) ; ) ; 
Observable < String > skip = Observable . just ( "one" , "two" , "three" ) . skip ( - 99 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; skip . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > skip = Observable . just ( "one" , "two" , "three" ) . skip ( 0 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; skip . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > skip = Observable . just ( "one" , "two" , "three" ) . skip ( 1 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; skip . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > skip = Observable . just ( "one" , "two" , "three" ) . skip ( 2 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; skip . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . empty ( ) ; Observable < String > skip = w . skip ( 1 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; skip . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > skip = Observable . just ( "one" , "two" , "three" ) . skip ( 2 ) ; Observer < String > observer1 = TestHelper . mockObserver ( ) ; skip . subscribe ( observer1 ) ; Observer < String > observer2 = TestHelper . mockObserver ( ) ; skip . subscribe ( observer2 ) ; verify ( observer1 , times ( 1 ) ) . onNext ( any ( String . class ) ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; verify ( observer2 , times ( 1 ) ) . onNext ( any ( String . class ) ) ; verify ( observer2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; 
Exception e = new Exception ( ) ; Observable < String > ok = Observable . just ( "one" ) ; Observable < String > error = Observable . error ( e ) ; Observable < String > skip = Observable . concat ( ok , error ) . skip ( 100 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; skip . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , times ( 1 ) ) . onError ( e ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . range ( 1 , 10 ) . skip ( 5 ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; assertEquals ( Arrays . asList ( 6 , 7 , 8 , 9 , 10 ) , to . values ( ) ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . skip ( 2 ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > o ) throws Exception return o . skip ( 1 ) ; ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . mergeWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . onNext ( 100 ) ; ) ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . mergeWith ( Completable . complete ( ) ) . take ( 3 ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
Observable . error ( new TestException ( ) ) . mergeWith ( Completable . complete ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . never ( ) . mergeWith ( Completable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( 1 ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onNext ( 1 ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; . mergeWith ( Completable . complete ( ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , ps . hasObservers ( ) ) ; assertFalse ( "other has observers" , cs . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; CompletableSubject cs = CompletableSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; cs . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , ps . hasObservers ( ) ) ; assertFalse ( "other has observers" , cs . hasObservers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . mergeWith ( Completable . complete ( ) . hide ( ) ) ; ) ; 
Observable < String > obs = Observable . just ( "one" ) ; Future < String > f = obs . toFuture ( ) ; assertEquals ( "one" , f . get ( ) ) ; 
Observable < String > obs = Observable . just ( "one" , "two" , "three" ) ; Future < List < String > > f = obs . toList ( ) . toFuture ( ) ; assertEquals ( "one" , f . get ( ) . get ( 0 ) ) ; assertEquals ( "two" , f . get ( ) . get ( 1 ) ) ; assertEquals ( "three" , f . get ( ) . get ( 2 ) ) ; 
Observable < String > obs = Observable . just ( "one" , "two" ) ; Future < String > f = obs . toFuture ( ) ; try f . get ( ) ; fail ( "Should have thrown!" ) ; catch ( ExecutionException e ) throw e . getCause ( ) ; 
Observable < String > obs = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onError ( new TestException ( ) ) ; ) ; Future < String > f = obs . toFuture ( ) ; try f . get ( ) ; fail ( "expected exception" ) ; catch ( Throwable e ) assertEquals ( TestException . class , e . getCause ( ) . getClass ( ) ) ; 
Observable < String > obs = Observable . never ( ) ; Future < String > f = obs . toFuture ( ) ; boolean cancelled = f . cancel ( true ) ; assertTrue ( cancelled ) ; f . get ( ) ; 
Observable < String > obs = Observable . never ( ) ; Future < String > f = obs . toFuture ( ) ; boolean cancelled = f . cancel ( true ) ; assertTrue ( cancelled ) ; f . get ( Long . MAX_VALUE , TimeUnit . NANOSECONDS ) ; 
Observable < String > obs = Observable . empty ( ) ; Future < String > f = obs . toFuture ( ) ; try f . get ( ) ; catch ( ExecutionException e ) throw e . getCause ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Long > source = Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 10 ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertTrue ( it . hasNext ( ) ) ; Assert . assertEquals ( Long . valueOf ( i ) , it . next ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertFalse ( it . hasNext ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Long > source = Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 10 ) ; Iterable < Long > iter = source . blockingLatest ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) Iterator < Long > it = iter . iterator ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertTrue ( it . hasNext ( ) ) ; Assert . assertEquals ( Long . valueOf ( i ) , it . next ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertFalse ( it . hasNext ( ) ) ; 
Observable < Long > source = Observable . < Long > empty ( ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; Assert . assertFalse ( it . hasNext ( ) ) ; it . next ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Long > source = Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 10 ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertEquals ( Long . valueOf ( i ) , it . next ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Long > source = Observable . < Long > error ( new RuntimeException ( "Forced failure!" ) ) . subscribeOn ( scheduler ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; it . hasNext ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Long > source = Observable . < Long > error ( new RuntimeException ( "Forced failure!" ) ) . subscribeOn ( scheduler ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; it . next ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > blocker = source ; Iterable < Integer > iter = blocker . blockingLatest ( ) ; Iterator < Integer > it = iter . iterator ( ) ; source . onNext ( 1 ) ; Assert . assertEquals ( Integer . valueOf ( 1 ) , it . next ( ) ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; Assert . assertEquals ( Integer . valueOf ( 3 ) , it . next ( ) ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; Assert . assertEquals ( Integer . valueOf ( 6 ) , it . next ( ) ) ; source . onNext ( 7 ) ; source . onComplete ( ) ; Assert . assertFalse ( it . hasNext ( ) ) ; 
Observable . never ( ) . blockingLatest ( ) . iterator ( ) . remove ( ) ; 
Observable . empty ( ) . blockingLatest ( ) . iterator ( ) . next ( ) ; 
Observable . error ( new TestException ( ) ) . blockingLatest ( ) . iterator ( ) . next ( ) ; 
Iterator < Object > it = Observable . error ( new TestException ( ) ) . blockingLatest ( ) . iterator ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) try it . hasNext ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) 
Iterator < Object > it = Observable . never ( ) . blockingLatest ( ) . iterator ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try it . hasNext ( ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; Thread . interrupted ( ) ; 
Iterator < Object > it = Observable . never ( ) . blockingLatest ( ) . iterator ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ( ( Observer < Object > ) it ) . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
assertEquals ( 1 , Observable . range ( 1 , 10 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingFirst ( ) . intValue ( ) ) ; 
assertEquals ( 1 , Observable . < Integer > empty ( ) . subscribeOn ( Schedulers . computation ( ) ) . blockingFirst ( 1 ) . intValue ( ) ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Observable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Observable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , Functions . emptyConsumer ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; TestException ex = new TestException ( ) ; Consumer < Object > cons = new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( v ) ; ; Observable . range ( 1 , 5 ) . concatWith ( Observable . < Integer > error ( ex ) ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( cons , cons ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , ex ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Consumer < Object > cons = new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( v ) ; ; Observable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( cons , cons , new Action ( ) @ Override public void run ( ) throws Exception list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 100 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Observable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Observer < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onNext ( Object value ) list . add ( value ) ; @ Override public void onError ( Throwable e ) list . add ( e ) ; @ Override public void onComplete ( ) list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 100 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; final TestException ex = new TestException ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Observable . < Integer > error ( ex ) ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Observer < Object > ( ) @ Override public void onSubscribe ( Disposable d ) @ Override public void onNext ( Object value ) list . add ( value ) ; @ Override public void onError ( Throwable e ) list . add ( e ) ; @ Override public void onComplete ( ) list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , ex ) , list ) ; 
Observable . just ( 1 ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) ; 
Observable . empty ( ) . blockingFirst ( ) ; 
Observable . empty ( ) . blockingLast ( ) ; 
assertEquals ( 1 , Observable . just ( 1 , 2 ) . blockingFirst ( 3 ) . intValue ( ) ) ; 
assertEquals ( 2 , Observable . just ( 1 , 2 ) . blockingLast ( 3 ) . intValue ( ) ) ; 
Observable . empty ( ) . blockingSingle ( ) ; 
TestHelper . checkUtilityClass ( ObservableBlockingSubscribe . class ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; to . dispose ( ) ; Observable . just ( 1 ) . blockingSubscribe ( to ) ; to . assertEmpty ( ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; final Observer [ ] s = null ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ SuppressWarnings ( "unchecked" ) @ Override public void run ( ) to . dispose ( ) ; s [ 0 ] . onNext ( 1 ) ; , 200 , TimeUnit . MILLISECONDS ) ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; s [ 0 ] = observer ; . blockingSubscribe ( to ) ; while ( ! to . isDisposed ( ) ) Thread . sleep ( 100 ) ; to . assertEmpty ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Thread . currentThread ( ) . interrupt ( ) ; Observable . never ( ) . blockingSubscribe ( to ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . empty ( ) . delay ( 100 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( to ) ; to . assertResult ( ) ; 
BlockingFirstObserver < Integer > o = new BlockingFirstObserver < > ( ) ; assertFalse ( o . isDisposed ( ) ) ; o . dispose ( ) ; assertTrue ( o . isDisposed ( ) ) ; Disposable d = Disposable . empty ( ) ; o . onSubscribe ( d ) ; assertTrue ( d . isDisposed ( ) ) ; Thread . currentThread ( ) . interrupt ( ) ; try o . blockingGet ( ) ; fail ( "Should have thrown" ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; Thread . interrupted ( ) ; o . onError ( new TestException ( ) ) ; try o . blockingGet ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) 
Observable . just ( 1 ) . startWith ( Completable . complete ( ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . empty ( ) . startWith ( Completable . complete ( ) ) . test ( ) . assertResult ( ) ; 
Runnable run = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . startWith ( Completable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Observable . just ( 1 ) . startWith ( Single . just ( 2 ) ) . test ( ) . assertResult ( 2 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . startWith ( Single . just ( 2 ) ) . test ( ) . assertResult ( 2 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . startWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Observable . just ( 1 ) . startWith ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 2 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . startWith ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 2 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . startWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Observable . just ( 1 ) . startWith ( Observable . just ( 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . startWith ( Observable . just ( 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Runnable run2 = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . startWith ( Observable . fromRunnable ( run2 ) ) . test ( ) . assertResult ( ) ; verify ( run ) . run ( ) ; verify ( run2 ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . startWith ( Observable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
w = TestHelper . mockObserver ( ) ; 
Observable < String > src = Observable . empty ( ) ; src . distinct ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > src = Observable . empty ( ) ; src . distinct ( TO_UPPER_WITH_EXCEPTION ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" , "c" , "c" , "b" , "b" , "a" , "e" ) ; src . distinct ( ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "e" ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > src = Observable . just ( "a" , "B" , "c" , "C" , "c" , "B" , "b" , "a" , "E" ) ; src . distinct ( TO_UPPER_WITH_EXCEPTION ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "B" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "E" ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable . error ( new TestException ( ) ) . distinct ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Observable . just ( 1 , 1 , 2 , 1 , 3 , 2 , 4 , 5 , 4 ) . distinct ( ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . distinct ( ) . subscribe ( to ) ; TestHelper . emit ( us , 1 , 1 , 2 , 1 , 3 , 2 , 4 , 5 , 4 ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . just ( 1 , 1 , 2 , 1 , 3 , 2 , 4 , 5 , 4 ) . distinct ( ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) QueueDisposable < ? > qd = ( QueueDisposable < ? > ) d ; assertFalse ( qd . isEmpty ( ) ) ; qd . clear ( ) ; assertTrue ( qd . isEmpty ( ) ) ; @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Observable . just ( 1 ) . distinct ( Functions . identity ( ) , new Supplier < Collection < Object > > ( ) @ Override public Collection < Object > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . distinct ( Functions . identity ( ) , new Supplier < Collection < Object > > ( ) @ Override public Collection < Object > get ( ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( NullPointerException . class ) . assertErrorMessage ( ExceptionHelper . nullWarning ( "The collectionSupplier returned a null Collection." ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . distinct ( ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
final List < String > list = new ArrayList < > ( ) ; final List < List < String > > lists = new ArrayList < > ( ) ; Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; push ( innerObserver , "one" , 10 ) ; push ( innerObserver , "two" , 60 ) ; push ( innerObserver , "three" , 110 ) ; push ( innerObserver , "four" , 160 ) ; push ( innerObserver , "five" , 210 ) ; complete ( innerObserver , 500 ) ; ) ; Observable < Object > openings = Observable . unsafeCreate ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; push ( innerObserver , new Object ( ) , 50 ) ; push ( innerObserver , new Object ( ) , 200 ) ; complete ( innerObserver , 250 ) ; ) ; Function < Object , Observable < Object > > closer = new Function < Object , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Object opening ) return Observable . unsafeCreate ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; push ( innerObserver , new Object ( ) , 100 ) ; complete ( innerObserver , 101 ) ; ) ; ; Observable < Observable < String > > windowed = source . window ( openings , closer ) ; windowed . subscribe ( observeWindow ( list , lists ) ) ; scheduler . advanceTimeTo ( 500 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , lists . size ( ) ) ; assertEquals ( lists . get ( 0 ) , list ( "two" , "three" ) ) ; assertEquals ( lists . get ( 1 ) , list ( "five" ) ) ; 
return new Consumer < Observable < String > > ( ) @ Override public void accept ( Observable < String > stringObservable ) stringObservable . subscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) lists . add ( new ArrayList < > ( list ) ) ; list . clear ( ) ; @ Override public void onError ( Throwable e ) fail ( e . getMessage ( ) ) ; @ Override public void onNext ( String args ) list . add ( args ) ; ) ; ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > open = PublishSubject . create ( ) ; final PublishSubject < Integer > close = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = new TestObserver < > ( ) ; source . window ( open , new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return close ; ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . subscribe ( to ) ; open . onNext ( 1 ) ; source . onNext ( 1 ) ; assertTrue ( open . hasObservers ( ) ) ; assertTrue ( close . hasObservers ( ) ) ; close . onNext ( 1 ) ; assertFalse ( close . hasObservers ( ) ) ; source . onComplete ( ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; to . assertValueCount ( 1 ) ; assertFalse ( open . hasObservers ( ) ) ; assertFalse ( close . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > open = PublishSubject . create ( ) ; final PublishSubject < Integer > close = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = new TestObserver < > ( ) ; source . window ( open , new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return close ; ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . subscribe ( to ) ; open . onNext ( 1 ) ; assertTrue ( open . hasObservers ( ) ) ; assertTrue ( close . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( open . hasObservers ( ) ) ; assertTrue ( close . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > start = PublishSubject . create ( ) ; final PublishSubject < Integer > end = PublishSubject . create ( ) ; TestObserver < Integer > to = source . window ( start , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return end ; ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; start . onNext ( 0 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; start . onNext ( 1 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; end . onNext ( 1 ) ; start . onNext ( 2 ) ; TestHelper . emit ( source , 7 , 8 ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 5 , 6 , 6 , 7 , 8 ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > start = PublishSubject . create ( ) ; final PublishSubject < Integer > end = PublishSubject . create ( ) ; TestObserver < Integer > to = source . window ( start , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return end ; ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; start . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( "Source has observers!" , source . hasObservers ( ) ) ; assertFalse ( "Start has observers!" , start . hasObservers ( ) ) ; assertFalse ( "End has observers!" , end . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > start = PublishSubject . create ( ) ; final PublishSubject < Integer > end = PublishSubject . create ( ) ; TestObserver < Integer > to = source . window ( start , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return end ; ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; start . onNext ( 1 ) ; end . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( "Source has observers!" , source . hasObservers ( ) ) ; assertFalse ( "Start has observers!" , start . hasObservers ( ) ) ; assertFalse ( "End has observers!" , end . hasObservers ( ) ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . window ( Observable . just ( 2 ) , Functions . justFunction ( Observable . never ( ) ) ) ) ; 
final Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( BehaviorSubject . createDefault ( 1 ) , Functions . justFunction ( Observable . never ( ) ) ) . flatMap ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return v ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Object > , Object > ( ) @ Override public Object apply ( Observable < Object > o ) throws Exception return o . window ( Observable . just ( 1 ) , Functions . justFunction ( Observable . never ( ) ) ) ; , false , 1 , 1 , ( Object [ ] ) null ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BehaviorSubject . createDefault ( 1 ) . window ( BehaviorSubject . createDefault ( 1 ) , new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer f ) throws Exception return new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; ; ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
return Observable . just ( 1 ) . concatWith ( Observable . < Integer > never ( ) ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception ref . set ( true ) ; ) ; 
AtomicBoolean mainDisposed = new AtomicBoolean ( ) ; AtomicBoolean openDisposed = new AtomicBoolean ( ) ; final AtomicBoolean closeDisposed = new AtomicBoolean ( ) ; observableDisposed ( mainDisposed ) . window ( observableDisposed ( openDisposed ) , new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return observableDisposed ( closeDisposed ) ; ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . to ( TestHelper . < Observable < Integer > > testConsumer ( ) ) . assertSubscribed ( ) . assertNoErrors ( ) . assertNotComplete ( ) . dispose ( ) ; assertTrue ( mainDisposed . get ( ) ) ; assertTrue ( openDisposed . get ( ) ) ; assertTrue ( closeDisposed . get ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( Observable . just ( 1 ) . concatWith ( Observable . < Integer > never ( ) ) , Functions . justFunction ( Observable . never ( ) ) ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < Observable < Integer > > inner = new AtomicReference < > ( ) ; TestObserver < Observable < Integer > > to = ps . window ( Observable . < Integer > just ( 1 ) . concatWith ( Observable . < Integer > never ( ) ) , Functions . justFunction ( Observable . never ( ) ) ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; to . assertValueCount ( 1 ) ; ps . onNext ( 1 ) ; assertTrue ( ps . hasObservers ( ) ) ; to . dispose ( ) ; to . assertValueCount ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = source . window ( boundary , new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer end ) throws Throwable throw new TestException ( ) ; ) . test ( ) ; to . assertEmpty ( ) ; boundary . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( boundary . hasObservers ( ) ) ; 
Observable . error ( new TestException ( ) ) . window ( Observable . never ( ) , Functions . justFunction ( Observable . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . window ( Observable . never ( ) , v -> Observable . never ( ) ) ) ; 
TestHelper . withErrorTracking ( errors -> TestException ex1 = new TestException ( ) ; TestException ex2 = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) AtomicReference < Observer < ? super Integer > > ref1 = new AtomicReference < > ( ) ; AtomicReference < Observer < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Observable < Integer > o1 = Observable . < Integer > unsafeCreate ( ref1 :: set ) ; Observable < Integer > o2 = Observable . < Integer > unsafeCreate ( ref2 :: set ) ; TestObserver < Observable < Integer > > to = BehaviorSubject . createDefault ( 1 ) . window ( o1 , v -> o2 ) . doOnNext ( w -> w . test ( ) ) . test ( ) ; ref1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref2 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; TestHelper . race ( ( ) -> ref1 . get ( ) . onError ( ex1 ) , ( ) -> ref2 . get ( ) . onError ( ex2 ) ) ; to . assertError ( RuntimeException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; errors . clear ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> AtomicReference < Observer < ? super Integer > > ref1 = new AtomicReference < > ( ) ; AtomicReference < Observer < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Observable < Integer > o1 = Observable . < Integer > unsafeCreate ( ref1 :: set ) ; Observable < Integer > o2 = Observable . < Integer > unsafeCreate ( ref2 :: set ) ; TestObserver < Integer > to = BehaviorSubject . createDefault ( 1 ) . window ( o1 , v -> o2 ) . flatMap ( v -> v ) . test ( ) ; ref1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref2 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref2 . get ( ) . onError ( new TestException ( ) ) ; ref2 . get ( ) . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Observable . error ( new TestException ( ) ) . window ( Observable . never ( ) , v -> Observable . never ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
AtomicReference < Observer < ? super Integer > > ref1 = new AtomicReference < > ( ) ; PublishSubject < Object > ps = PublishSubject . create ( ) ; Observable < Integer > o1 = Observable . < Integer > unsafeCreate ( ref1 :: set ) ; AtomicInteger counter = new AtomicInteger ( ) ; TestObserver < Observable < Object > > to = ps . window ( o1 , v -> Observable . never ( ) ) . doOnNext ( w -> if ( counter . getAndIncrement ( ) == 0 ) ref1 . get ( ) . onNext ( 2 ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; w . test ( ) ; ) . test ( ) ; ref1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; to . assertComplete ( ) ; 
AtomicReference < Observer < ? super Integer > > ref1 = new AtomicReference < > ( ) ; PublishSubject < Object > ps = PublishSubject . create ( ) ; Observable < Integer > o1 = Observable . < Integer > unsafeCreate ( ref1 :: set ) ; AtomicInteger counter = new AtomicInteger ( ) ; TestObserver < Observable < Object > > to = ps . window ( o1 , v -> Observable . never ( ) ) . doOnNext ( w -> if ( counter . getAndIncrement ( ) == 0 ) ref1 . get ( ) . onNext ( 2 ) ; ps . onNext ( 1 ) ; ps . onError ( new TestException ( ) ) ; w . test ( ) ; ) . test ( ) ; ref1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; to . assertError ( TestException . class ) ; 
AtomicReference < Observer < ? super Integer > > ref1 = new AtomicReference < > ( ) ; PublishSubject < Object > ps = PublishSubject . create ( ) ; Observable < Integer > o1 = Observable . < Integer > unsafeCreate ( ref1 :: set ) ; TestObserver < Observable < Object > > to = ps . window ( o1 , v -> Observable . never ( ) ) . take ( 1 ) . doOnNext ( w -> w . test ( ) ; ) . test ( ) ; ref1 . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref1 . get ( ) . onNext ( 2 ) ; to . assertValueCount ( 1 ) ; 
TestHelper . withErrorTracking ( errors -> Observable . unsafeCreate ( s -> s . onSubscribe ( Disposable . empty ( ) ) ; s . onNext ( 1 ) ; s . onError ( new IOException ( ) ) ; ) . window ( BehaviorSubject . createDefault ( 1 ) , v -> Observable . error ( new TestException ( ) ) ) . doOnNext ( w -> w . test ( ) ) . test ( ) . assertError ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Observable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Action run = new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ; Observable . fromAction ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Observable . fromAction ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Observable < Object > source = Observable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; source . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Observable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final int [ ] counter = 0 ; Observable < Void > m = Observable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception counter [ 0 ] ++ ; ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof Supplier ) ; assertNull ( ( ( Supplier < Void > ) m ) . get ( ) ) ; assertEquals ( 1 , counter [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Object > to = Observable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Action run = mock ( Action . class ) ; Observable . fromAction ( run ) . test ( true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; Observable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . dispose ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Action action = mock ( Action . class ) ; Observable . fromAction ( action ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . SYNC ) ; Action action = mock ( Action . class ) ; Observable . fromAction ( action ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
Observable < Integer > src = Observable . just ( 1 , 2 , 3 , 4 , 5 ) ; src . skipWhile ( INDEX_LESS_THAN_THREE ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > src = Observable . empty ( ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > src = Observable . just ( 1 , 2 , 3 , 4 , 3 , 2 , 1 ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > src = Observable . just ( 5 , 3 , 1 ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > src = Observable . just ( 1 , 2 , 3 , 4 , 5 , 3 , 1 , 5 ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > src = Observable . just ( 1 , 2 , 42 , 5 , 3 , 1 ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; inOrder . verify ( w , never ( ) ) . onComplete ( ) ; inOrder . verify ( w , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; 
Observable < Integer > src = Observable . range ( 1 , 10 ) . skipWhile ( LESS_THAN_FIVE ) ; int n = 5 ; for ( int i = 0 ; i < n ; i ++ ) Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; src . subscribe ( o ) ; for ( int j = 5 ; j < 10 ; j ++ ) inOrder . verify ( o ) . onNext ( j ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . skipWhile ( Functions . alwaysFalse ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . skipWhile ( Functions . alwaysFalse ( ) ) ; ) ; 
Observable . error ( new TestException ( ) ) . skipWhile ( Functions . alwaysFalse ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
int num = 10 ; final AtomicInteger count = new AtomicInteger ( ) ; int value = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( final Observer < ? super Integer > o ) o . onNext ( count . incrementAndGet ( ) ) ; o . onComplete ( ) ; ) . repeat ( ) . subscribeOn ( Schedulers . computation ( ) ) . take ( num ) . blockingLast ( ) ; assertEquals ( num , value ) ; 
Observable < Integer > xs = Observable . just ( 1 , 2 ) ; Object [ ] ys = xs . repeat ( ) . subscribeOn ( Schedulers . newThread ( ) ) . take ( 4 ) . toList ( ) . blockingGet ( ) . toArray ( ) ; assertArrayEquals ( new Object [ ] 1 , 2 , 1 , 2 , ys ) ; 
Observable . just ( 1 ) . repeat ( ) . subscribeOn ( Schedulers . newThread ( ) ) . take ( 100000 ) . blockingLast ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < Integer > oi = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > sub ) sub . onSubscribe ( Disposable . empty ( ) ) ; counter . incrementAndGet ( ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onComplete ( ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) ; Object [ ] ys = oi . repeat ( ) . subscribeOn ( Schedulers . newThread ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 ; ) . take ( 4 ) . toList ( ) . blockingGet ( ) . toArray ( ) ; assertEquals ( 2 , counter . get ( ) ) ; assertArrayEquals ( new Object [ ] 1 , 2 , 1 , 2 , ys ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . just ( 1 ) . repeat ( ) . take ( 10 ) . subscribe ( o ) ; verify ( o , times ( 10 ) ) . onNext ( 1 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . just ( 1 ) . repeat ( 10 ) . subscribe ( o ) ; verify ( o , times ( 10 ) ) . onNext ( 1 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . error ( new TestException ( ) ) . repeat ( 10 ) . subscribe ( o ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . just ( 1 ) . repeat ( 0 ) . subscribe ( o ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Observable . just ( 1 ) . repeat ( 1 ) . subscribe ( o ) ; verify ( o ) . onComplete ( ) ; verify ( o , times ( 1 ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > src = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) . take ( 3 ) . repeat ( 3 ) . distinct ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; src . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; to . assertValues ( 1 , 2 , 3 ) ; 
final List < Integer > concatBase = new ArrayList < > ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . repeat ( 5 ) . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer x ) System . out . println ( "testRepeatRetarget -> " + x ) ; concatBase . add ( x ) ; return Observable . < Integer > empty ( ) . delay ( 200 , TimeUnit . MILLISECONDS ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; assertEquals ( Arrays . asList ( 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 , 1 , 2 ) , concatBase ) ; 
Observable . just ( 1 ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
try Observable . just ( 1 ) . repeat ( - 99 ) ; fail ( "Should have thrown" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "times >= 0 required but it was -99" , ex . getMessage ( ) ) ; 
Observable . error ( new TestException ( ) ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return true ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return true ; ) . test ( ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
final PublishSubject < Object > subject = PublishSubject . create ( ) ; final Disposable disposable = Observable . just ( "Leak" ) . repeatWhen ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > completions ) throws Exception return completions . switchMap ( new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object ignore ) throws Exception return subject ; ) ; ) . subscribe ( ) ; assertTrue ( subject . hasObservers ( ) ) ; disposable . dispose ( ) ; assertFalse ( subject . hasObservers ( ) ) ; 
Observable . error ( new TestException ( ) ) . repeatWhen ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > v ) throws Exception return v . delay ( 10 , TimeUnit . SECONDS ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 3 ) . repeatWhen ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > handler ) throws Exception return handler . take ( 2 ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 1 , 2 , 3 ) ; 
Observable . range ( 1 , 3 ) . repeatWhen ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > v ) throws Exception return v . map ( new Function < Object , Object > ( ) @ Override public Object apply ( Object w ) throws Exception throw new TestException ( ) ; ) ; ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . repeat ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; final AtomicInteger times = new AtomicInteger ( ) ; source . repeatUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return times . getAndIncrement ( ) == 4 ; ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; final AtomicInteger times = new AtomicInteger ( ) ; source . repeatWhen ( new Function < Observable < Object > , ObservableSource < ? > > ( ) @ Override public ObservableSource < ? > apply ( Observable < Object > e ) throws Exception return e . takeWhile ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) throws Exception return times . getAndIncrement ( ) < 4 ; ) ; ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > signaller = PublishSubject . create ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = source . take ( 1 ) . repeatWhen ( new Function < Observable < Object > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Object > v ) throws Exception return signaller ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) source . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) signaller . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . dispose ( ) ; if ( ! errors . isEmpty ( ) ) for ( Throwable e : errors ) e . printStackTrace ( ) ; fail ( errors + "" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < 10 ; i ++ ) try refCountAsyncActual ( ) ; return ; catch ( AssertionError ex ) if ( i == 9 ) throw ex ; Thread . sleep ( ( int ) ( 200 * ( Math . random ( ) * 10 + 1 ) ) ) ; 
final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger nextCount = new AtomicInteger ( ) ; Observable < Long > r = Observable . interval ( 0 , 25 , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) subscribeCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Long > ( ) @ Override public void accept ( Long l ) nextCount . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; Disposable d1 = r . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long l ) receivedCount . incrementAndGet ( ) ; ) ; Disposable d2 = r . subscribe ( ) ; try Thread . sleep ( 260 ) ; catch ( InterruptedException e ) d2 . dispose ( ) ; d1 . dispose ( ) ; System . out . println ( "onNext: " + nextCount . get ( ) ) ; assertEquals ( nextCount . get ( ) , receivedCount . get ( ) ) ; assertEquals ( 1 , subscribeCount . get ( ) ) ; 
final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger nextCount = new AtomicInteger ( ) ; Observable < Integer > r = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) subscribeCount . incrementAndGet ( ) ; ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer l ) nextCount . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; Disposable d1 = r . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer l ) receivedCount . incrementAndGet ( ) ; ) ; Disposable d2 = r . subscribe ( ) ; try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) d2 . dispose ( ) ; d1 . dispose ( ) ; System . out . println ( "onNext Count: " + nextCount . get ( ) ) ; assertEquals ( nextCount . get ( ) , receivedCount . get ( ) * 2 ) ; assertEquals ( 2 , subscribeCount . get ( ) ) ; 
final AtomicInteger nextCount = new AtomicInteger ( ) ; Observable < Integer > r = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer l ) System . out . println ( "onNext --------> " + l ) ; nextCount . incrementAndGet ( ) ; ) . take ( 4 ) . publish ( ) . refCount ( ) ; final AtomicInteger receivedCount = new AtomicInteger ( ) ; r . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer l ) receivedCount . incrementAndGet ( ) ; ) ; System . out . println ( "onNext: " + nextCount . get ( ) ) ; assertEquals ( 4 , receivedCount . get ( ) ) ; assertEquals ( 4 , receivedCount . get ( ) ) ; 
final AtomicInteger subscribeCount = new AtomicInteger ( ) ; final AtomicInteger unsubscribeCount = new AtomicInteger ( ) ; Observable < Long > r = Observable . interval ( 0 , 1 , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) System . out . println ( "******************************* Subscribe received" ) ; subscribeCount . incrementAndGet ( ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) System . out . println ( "******************************* Unsubscribe received" ) ; unsubscribeCount . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) TestObserver < Long > to1 = new TestObserver < > ( ) ; TestObserver < Long > to2 = new TestObserver < > ( ) ; r . subscribe ( to1 ) ; r . subscribe ( to2 ) ; try Thread . sleep ( 50 ) ; catch ( InterruptedException e ) to1 . dispose ( ) ; to2 . dispose ( ) ; to1 . assertNoErrors ( ) ; to2 . assertNoErrors ( ) ; assertTrue ( to1 . values ( ) . size ( ) > 0 ) ; assertTrue ( to2 . values ( ) . size ( ) > 0 ) ; assertEquals ( 10 , subscribeCount . get ( ) ) ; assertEquals ( 10 , unsubscribeCount . get ( ) ) ; 
final CountDownLatch unsubscribeLatch = new CountDownLatch ( 1 ) ; final CountDownLatch subscribeLatch = new CountDownLatch ( 1 ) ; Observable < Long > o = synchronousInterval ( ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) System . out . println ( "******************************* Subscribe received" ) ; subscribeLatch . countDown ( ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) System . out . println ( "******************************* Unsubscribe received" ) ; unsubscribeLatch . countDown ( ) ; ) ; TestObserverEx < Long > observer = new TestObserverEx < > ( ) ; o . publish ( ) . refCount ( ) . subscribeOn ( Schedulers . newThread ( ) ) . subscribe ( observer ) ; System . out . println ( "send unsubscribe" ) ; subscribeLatch . await ( ) ; observer . dispose ( ) ; System . out . println ( "DONE sending unsubscribe ... now waiting" ) ; if ( ! unsubscribeLatch . await ( 3000 , TimeUnit . MILLISECONDS ) ) System . out . println ( "Errors: " + observer . errors ( ) ) ; if ( observer . errors ( ) . size ( ) > 0 ) observer . errors ( ) . get ( 0 ) . printStackTrace ( ) ; fail ( "timed out waiting for unsubscribe" ) ; observer . assertNoErrors ( ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) connectUnsubscribeRaceCondition ( ) ; 
final AtomicInteger subUnsubCount = new AtomicInteger ( ) ; Observable < Long > o = synchronousInterval ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) System . out . println ( "******************************* Unsubscribe received" ) ; subUnsubCount . decrementAndGet ( ) ; ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) System . out . println ( "******************************* SUBSCRIBE received" ) ; subUnsubCount . incrementAndGet ( ) ; ) ; TestObserverEx < Long > observer = new TestObserverEx < > ( ) ; o . publish ( ) . refCount ( ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( observer ) ; System . out . println ( "send unsubscribe" ) ; observer . dispose ( ) ; Thread . sleep ( 10 ) ; int counter = 200 ; while ( subUnsubCount . get ( ) != 0 && counter -- != 0 ) Thread . sleep ( 10 ) ; assertEquals ( 0 , subUnsubCount . get ( ) ) ; System . out . println ( "DONE sending unsubscribe ... now waiting" ) ; System . out . println ( "Errors: " + observer . errors ( ) ) ; if ( observer . errors ( ) . size ( ) > 0 ) observer . errors ( ) . get ( 0 ) . printStackTrace ( ) ; observer . assertNoErrors ( ) ; 
return Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( Observer < ? super Long > observer ) final AtomicBoolean cancel = new AtomicBoolean ( ) ; observer . onSubscribe ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) cancel . set ( true ) ; ) ) ; for ( ; ; ) if ( cancel . get ( ) ) break ; try Thread . sleep ( 100 ) ; catch ( InterruptedException e ) observer . onNext ( 1L ) ; ) ; 
final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; final AtomicInteger unsubscriptionCount = new AtomicInteger ( ) ; Observable < Integer > o = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) subscriptionCount . incrementAndGet ( ) ; observer . onSubscribe ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) unsubscriptionCount . incrementAndGet ( ) ; ) ) ; ) ; Observable < Integer > refCounted = o . publish ( ) . refCount ( ) ; Disposable first = refCounted . subscribe ( ) ; assertEquals ( 1 , subscriptionCount . get ( ) ) ; Disposable second = refCounted . subscribe ( ) ; assertEquals ( 1 , subscriptionCount . get ( ) ) ; first . dispose ( ) ; assertEquals ( 0 , unsubscriptionCount . get ( ) ) ; second . dispose ( ) ; assertEquals ( 1 , unsubscriptionCount . get ( ) ) ; 
TestScheduler s = new TestScheduler ( ) ; Observable < Long > interval = Observable . interval ( 100 , TimeUnit . MILLISECONDS , s ) . publish ( ) . refCount ( ) ; final List < Long > list1 = new ArrayList < > ( ) ; Disposable d1 = interval . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long t1 ) list1 . add ( t1 ) ; ) ; s . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , list1 . size ( ) ) ; assertEquals ( 0L , list1 . get ( 0 ) . longValue ( ) ) ; assertEquals ( 1L , list1 . get ( 1 ) . longValue ( ) ) ; final List < Long > list2 = new ArrayList < > ( ) ; Disposable d2 = interval . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long t1 ) list2 . add ( t1 ) ; ) ; s . advanceTimeBy ( 300 , TimeUnit . MILLISECONDS ) ; assertEquals ( 5 , list1 . size ( ) ) ; assertEquals ( 2L , list1 . get ( 2 ) . longValue ( ) ) ; assertEquals ( 3L , list1 . get ( 3 ) . longValue ( ) ) ; assertEquals ( 4L , list1 . get ( 4 ) . longValue ( ) ) ; assertEquals ( 3 , list2 . size ( ) ) ; assertEquals ( 2L , list2 . get ( 0 ) . longValue ( ) ) ; assertEquals ( 3L , list2 . get ( 1 ) . longValue ( ) ) ; assertEquals ( 4L , list2 . get ( 2 ) . longValue ( ) ) ; d1 . dispose ( ) ; s . advanceTimeBy ( 300 , TimeUnit . MILLISECONDS ) ; assertEquals ( 5 , list1 . size ( ) ) ; assertEquals ( 6 , list2 . size ( ) ) ; assertEquals ( 5L , list2 . get ( 3 ) . longValue ( ) ) ; assertEquals ( 6L , list2 . get ( 4 ) . longValue ( ) ) ; assertEquals ( 7L , list2 . get ( 5 ) . longValue ( ) ) ; d2 . dispose ( ) ; s . advanceTimeBy ( 1000 , TimeUnit . MILLISECONDS ) ; final List < Long > list3 = new ArrayList < > ( ) ; interval . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long t1 ) list3 . add ( t1 ) ; ) ; s . advanceTimeBy ( 200 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , list3 . size ( ) ) ; assertEquals ( 0L , list3 . get ( 0 ) . longValue ( ) ) ; assertEquals ( 1L , list3 . get ( 1 ) . longValue ( ) ) ; 
Observer < Integer > done = DisposingObserver . INSTANCE ; Observer < Integer > o = TestHelper . mockObserver ( ) ; Observable < Integer > result = Observable . just ( 1 ) . publish ( ) . refCount ( ) ; result . subscribe ( done ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
ReplaySubject < Integer > source = ReplaySubject . create ( ) ; Observer < Integer > done = DisposingObserver . INSTANCE ; Observer < Integer > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; Observable < Integer > result = source . publish ( ) . refCount ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; result . subscribe ( done ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o1 = Observable . just ( 10 ) ; Observable < Integer > o2 = Observable . just ( 20 ) ; Observable < Integer > combined = Observable . combineLatest ( o1 , o2 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . publish ( ) . refCount ( ) ; TestObserverEx < Integer > to1 = new TestObserverEx < > ( ) ; TestObserverEx < Integer > to2 = new TestObserverEx < > ( ) ; combined . subscribe ( to1 ) ; combined . subscribe ( to2 ) ; to1 . assertTerminated ( ) ; to1 . assertNoErrors ( ) ; to1 . assertValue ( 30 ) ; to2 . assertTerminated ( ) ; to2 . assertNoErrors ( ) ; to2 . assertValue ( 30 ) ; 
final AtomicInteger intervalSubscribed = new AtomicInteger ( ) ; Observable < String > interval = Observable . interval ( 200 , TimeUnit . MILLISECONDS ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) System . out . println ( "Subscribing to interval " + intervalSubscribed . incrementAndGet ( ) ) ; ) . flatMap ( new Function < Long , Observable < String > > ( ) @ Override public Observable < String > apply ( Long t1 ) return Observable . defer ( new Supplier < Observable < String > > ( ) @ Override public Observable < String > get ( ) return Observable . < String > error ( new Exception ( "Some exception" ) ) ; ) ; ) . onErrorResumeNext ( new Function < Throwable , Observable < String > > ( ) @ Override public Observable < String > apply ( Throwable t1 ) return Observable . < String > error ( t1 ) ; ) . publish ( ) . refCount ( ) ; interval . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) System . out . println ( "Observer 1 onError: " + t1 ) ; ) . retry ( 5 ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) System . out . println ( "Observer 1: " + t1 ) ; ) ; Thread . sleep ( 100 ) ; interval . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) System . out . println ( "Observer 2 onError: " + t1 ) ; ) . retry ( 5 ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) System . out . println ( "Observer 2: " + t1 ) ; ) ; Thread . sleep ( 1300 ) ; System . out . println ( intervalSubscribed . get ( ) ) ; assertEquals ( 6 , intervalSubscribed . get ( ) ) ; 
d . dispose ( ) ; 
$EMPTY$
$EMPTY$
$EMPTY$
TestHelper . checkDisposed ( Observable . just ( 1 ) . publish ( ) . refCount ( ) ) ; 
final int [ ] calls = 0 ; Observable < Integer > o = new ConnectableObservable < Integer > ( ) @ Override public void connect ( Consumer < ? super Disposable > connection ) calls [ 0 ] ++ ; @ Override public void reset ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . disposed ( ) ) ; . refCount ( ) ; o . test ( ) ; o . test ( ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
calls [ 0 ] ++ ; 
$EMPTY$
observer . onSubscribe ( Disposable . disposed ( ) ) ; 
System . gc ( ) ; Thread . sleep ( 100 ) ; long start = ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; source = Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return new byte [ 100 * 1000 * 1000 ] ; ) . replay ( 1 ) . refCount ( ) ; source . subscribe ( ) ; long after = TestHelper . awaitGC ( GC_SLEEP_TIME , 20 , start + 20 * 1000 * 1000 ) ; source = null ; assertTrue ( String . format ( "%,3d -> %,3d%n" , start , after ) , start + 20 * 1000 * 1000 > after ) ; 
System . gc ( ) ; Thread . sleep ( 100 ) ; long start = ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; source = Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return new byte [ 100 * 1000 * 1000 ] ; ) . concatWith ( Observable . never ( ) ) . replay ( 1 ) . refCount ( ) ; Disposable d1 = source . subscribe ( ) ; Disposable d2 = source . subscribe ( ) ; d1 . dispose ( ) ; d2 . dispose ( ) ; d1 = null ; d2 = null ; long after = TestHelper . awaitGC ( GC_SLEEP_TIME , 20 , start + 20 * 1000 * 1000 ) ; source = null ; assertTrue ( String . format ( "%,3d -> %,3d%n" , start , after ) , start + 20 * 1000 * 1000 > after ) ; 
System . gc ( ) ; Thread . sleep ( GC_SLEEP_TIME ) ; source = Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new ExceptionData ( new byte [ 100 * 1000 * 1000 ] ) ; ) . publish ( ) . refCount ( ) ; long start = ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; source . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; long after = TestHelper . awaitGC ( GC_SLEEP_TIME , 20 , start + 20 * 1000 * 1000 ) ; source = null ; assertTrue ( String . format ( "%,3d -> %,3d%n" , start , after ) , start + 20 * 1000 * 1000 > after ) ; 
System . gc ( ) ; Thread . sleep ( GC_SLEEP_TIME ) ; long start = ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; source = Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return new byte [ 100 * 1000 * 1000 ] ; ) . concatWith ( Observable . never ( ) ) . publish ( ) . refCount ( ) ; Disposable d1 = source . test ( ) ; Disposable d2 = source . test ( ) ; d1 . dispose ( ) ; d2 . dispose ( ) ; d1 = null ; d2 = null ; long after = TestHelper . awaitGC ( GC_SLEEP_TIME , 20 , start + 20 * 1000 * 1000 ) ; source = null ; assertTrue ( String . format ( "%,3d -> %,3d%n" , start , after ) , start + 20 * 1000 * 1000 > after ) ; 
ConnectableObservable < Integer > co = Observable . just ( 1 ) . concatWith ( Observable . < Integer > never ( ) ) . replay ( ) ; if ( co instanceof Disposable ) assertTrue ( ( ( Disposable ) co ) . isDisposed ( ) ) ; Disposable connection = co . connect ( ) ; assertFalse ( ( ( Disposable ) co ) . isDisposed ( ) ) ; connection . dispose ( ) ; assertTrue ( ( ( Disposable ) co ) . isDisposed ( ) ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
$EMPTY$
throw new TestException ( "subscribeActual" ) ; 
throw new TestException ( "dispose" ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; 
throw new TestException ( "connect" ) ; 
$EMPTY$
observer . onSubscribe ( Disposable . empty ( ) ) ; 
BadObservableSubscribe bo = new BadObservableSubscribe ( ) ; try bo . refCount ( ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . getCause ( ) instanceof TestException ) ; 
BadObservableDispose bo = new BadObservableDispose ( ) ; try bo . refCount ( ) . test ( ) . dispose ( ) ; fail ( "Should have thrown" ) ; catch ( TestException expected ) 
BadObservableConnect bo = new BadObservableConnect ( ) ; try bo . refCount ( ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . getCause ( ) instanceof TestException ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
$EMPTY$
if ( ++ count == 1 ) observer . onSubscribe ( Disposable . empty ( ) ) ; else throw new TestException ( "subscribeActual" ) ; 
BadObservableSubscribe2 bo = new BadObservableSubscribe2 ( ) ; Observable < Object > o = bo . refCount ( ) ; o . test ( ) ; try o . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . getCause ( ) instanceof TestException ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
throw new TestException ( "dispose" ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; 
BadObservableConnect2 bo = new BadObservableConnect2 ( ) ; try bo . refCount ( ) . test ( ) ; fail ( "Should have thrown" ) ; catch ( NullPointerException ex ) assertTrue ( ex . getCause ( ) instanceof TestException ) ; 
BehaviorSubject < Integer > bs = BehaviorSubject . createDefault ( 1 ) ; Observable < Integer > o = bs . replay ( 1 ) . refCount ( ) ; o . subscribe ( ) ; final AtomicBoolean interrupted = new AtomicBoolean ( ) ; o . switchMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > emitter ) throws Exception while ( ! emitter . isDisposed ( ) ) Thread . sleep ( 100 ) ; interrupted . set ( true ) ; ) ; ) . take ( 500 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; assertTrue ( interrupted . get ( ) ) ; 
final int [ ] subscriptions = 0 ; Observable < Integer > source = Observable . range ( 1 , 5 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception subscriptions [ 0 ] ++ ; ) . publish ( ) . refCount ( 2 ) ; for ( int i = 0 ; i < 3 ; i ++ ) TestObserver < Integer > to1 = source . test ( ) ; to1 . withTag ( "to1 " + i ) ; to1 . assertEmpty ( ) ; TestObserver < Integer > to2 = source . test ( ) ; to2 . withTag ( "to2 " + i ) ; to1 . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; to2 . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 3 , subscriptions [ 0 ] ) ; 
final int [ ] subscriptions = 0 ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observable < Integer > source = ps . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception subscriptions [ 0 ] ++ ; ) . publish ( ) . refCount ( 500 , TimeUnit . MILLISECONDS ) ; TestObserver < Integer > to1 = source . test ( ) ; assertEquals ( 1 , subscriptions [ 0 ] ) ; to1 . dispose ( ) ; Thread . sleep ( 100 ) ; to1 = source . test ( ) ; assertEquals ( 1 , subscriptions [ 0 ] ) ; Thread . sleep ( 500 ) ; assertEquals ( 1 , subscriptions [ 0 ] ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; ps . onNext ( 3 ) ; ps . onNext ( 4 ) ; ps . onNext ( 5 ) ; ps . onComplete ( ) ; to1 . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
final int [ ] subscriptions = 0 ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observable < Integer > source = ps . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception subscriptions [ 0 ] ++ ; ) . publish ( ) . refCount ( 1 , 100 , TimeUnit . MILLISECONDS ) ; TestObserver < Integer > to1 = source . test ( ) ; assertEquals ( 1 , subscriptions [ 0 ] ) ; to1 . dispose ( ) ; assertTrue ( ps . hasObservers ( ) ) ; Thread . sleep ( 200 ) ; assertFalse ( ps . hasObservers ( ) ) ; 
Observable . < Integer > error ( new IOException ( ) ) . publish ( ) . refCount ( 500 , TimeUnit . MILLISECONDS ) . test ( ) . assertFailure ( IOException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observable < Integer > source = ps . publish ( ) . refCount ( 1 ) ; TestObserver < Integer > to1 = source . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) TestObserver < Integer > to2 = source . test ( ) ; to1 . dispose ( ) ; to1 = to2 ; to1 . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) final Observable < Integer > source = Observable . range ( 1 , 5 ) . replay ( ) . refCount ( 1 ) ; final TestObserver < Integer > to1 = source . test ( ) ; final TestObserver < Integer > to2 = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) source . subscribe ( to2 ) ; ; TestHelper . race ( r1 , r2 , Schedulers . single ( ) ) ; to2 . withTag ( "Round: " + i ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
try connection . accept ( Disposable . empty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
$EMPTY$
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( ) ) ; 
$EMPTY$
return false ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new BadObservableDoubleOnX ( ) . refCount ( ) . test ( ) . assertResult ( ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new BadObservableDoubleOnX ( ) . refCount ( 1 ) . test ( ) . assertResult ( ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new BadObservableDoubleOnX ( ) . refCount ( 5 , TimeUnit . SECONDS , Schedulers . single ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ObservableRefCount < Object > o = ( ObservableRefCount < Object > ) PublishSubject . create ( ) . publish ( ) . refCount ( ) ; o . cancel ( new RefConnection ( o ) ) ; RefConnection rc = new RefConnection ( o ) ; o . connection = null ; rc . subscriberCount = 0 ; o . timeout ( rc ) ; rc . subscriberCount = 1 ; o . timeout ( rc ) ; o . connection = rc ; o . timeout ( rc ) ; rc . subscriberCount = 0 ; o . timeout ( rc ) ; rc . subscriberCount = 2 ; rc . connected = false ; o . connection = rc ; o . cancel ( rc ) ; rc . subscriberCount = 1 ; rc . connected = false ; o . connection = rc ; o . cancel ( rc ) ; rc . subscriberCount = 2 ; rc . connected = true ; o . connection = rc ; o . cancel ( rc ) ; rc . subscriberCount = 1 ; rc . connected = true ; o . connection = rc ; rc . lazySet ( null ) ; o . cancel ( rc ) ; o . connection = rc ; o . cancel ( new RefConnection ( o ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) Observable < Integer > observable = Observable . just ( 1 ) . replay ( 1 ) . refCount ( ) ; TestObserver < Integer > observer1 = observable . subscribeOn ( Schedulers . io ( ) ) . test ( ) ; TestObserver < Integer > observer2 = observable . subscribeOn ( Schedulers . io ( ) ) . test ( ) ; observer1 . withTag ( "" + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; observer2 . withTag ( "" + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestConnectableObservable < Object > tco = new TestConnectableObservable < > ( ) ; ObservableRefCount < Object > o = ( ObservableRefCount < Object > ) tco . refCount ( ) ; RefConnection rc = new RefConnection ( o ) ; rc . set ( Disposable . empty ( ) ) ; o . connection = rc ; o . timeout ( rc ) ; assertTrue ( tco . reset ) ; 
BehaviorSubject < Integer > subject = BehaviorSubject . create ( ) ; Observable < Integer > observable = subject . replay ( 1 ) . refCount ( ) ; observable . takeUntil ( Observable . just ( 1 ) ) . test ( ) ; subject . onNext ( 2 ) ; observable . take ( 1 ) . test ( ) . assertResult ( 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) Observable < Integer > observable = Observable . just ( 1 ) . publish ( ) . refCount ( ) ; TestObserver < Integer > observer1 = observable . subscribeOn ( Schedulers . io ( ) ) . test ( ) ; TestObserver < Integer > observer2 = observable . subscribeOn ( Schedulers . io ( ) ) . test ( ) ; observer1 . withTag ( "observer1 " + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; observer2 . withTag ( "observer2 " + i ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
ReplaySubject < Integer > rs = ReplaySubject . create ( ) ; rs . onNext ( 1 ) ; rs . onComplete ( ) ; Observable < Integer > shared = rs . share ( ) ; shared . buffer ( shared . debounce ( 5 , TimeUnit . SECONDS ) ) . test ( ) . assertValueCount ( 2 ) ; shared . buffer ( shared . debounce ( 5 , TimeUnit . SECONDS ) ) . test ( ) . assertValueCount ( 2 ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; final String [ ] o = "1" , "3" , "5" , "7" ; final String [ ] e = "2" , "4" , "6" ; final Observable < String > odds = Observable . fromArray ( o ) ; final Observable < String > even = Observable . fromArray ( e ) ; Observable < String > concat = Observable . concat ( odds , even ) ; concat . subscribe ( observer ) ; verify ( observer , times ( 7 ) ) . onNext ( anyString ( ) ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; final String [ ] o = "1" , "3" , "5" , "7" ; final String [ ] e = "2" , "4" , "6" ; final Observable < String > odds = Observable . fromArray ( o ) ; final Observable < String > even = Observable . fromArray ( e ) ; final List < Observable < String > > list = new ArrayList < > ( ) ; list . add ( odds ) ; list . add ( even ) ; Observable < String > concat = Observable . concat ( Observable . fromIterable ( list ) ) ; concat . subscribe ( observer ) ; verify ( observer , times ( 7 ) ) . onNext ( anyString ( ) ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; final String [ ] o = "1" , "3" , "5" , "7" ; final String [ ] e = "2" , "4" , "6" ; final Observable < String > odds = Observable . fromArray ( o ) ; final Observable < String > even = Observable . fromArray ( e ) ; Observable < Observable < String > > observableOfObservables = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( odds ) ; observer . onNext ( even ) ; observer . onComplete ( ) ; ) ; Observable < String > concat = Observable . concat ( observableOfObservables ) ; concat . subscribe ( observer ) ; verify ( observer , times ( 7 ) ) . onNext ( anyString ( ) ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( odds ) ; observer . onNext ( even ) ; observer . onComplete ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; TestObservable < String > o1 = new TestObservable < > ( "one" , "two" , "three" ) ; TestObservable < String > o2 = new TestObservable < > ( "four" , "five" , "six" ) ; Observable . concat ( Observable . unsafeCreate ( o1 ) , Observable . unsafeCreate ( o2 ) ) . subscribe ( observer ) ; try o1 . t . join ( ) ; o2 . t . join ( ) ; catch ( Throwable e ) throw new RuntimeException ( "failed waiting on threads" ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "five" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "six" ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) if ( i % 10 == 0 ) System . out . println ( "testNestedAsyncConcat >> " + i ) ; nestedAsyncConcat ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; final TestObservable < String > o1 = new TestObservable < > ( "one" , "two" , "three" ) ; final TestObservable < String > o2 = new TestObservable < > ( "four" , "five" , "six" ) ; final TestObservable < String > o3 = new TestObservable < > ( "seven" , "eight" , "nine" ) ; final CountDownLatch allowThird = new CountDownLatch ( 1 ) ; final AtomicReference < Thread > parent = new AtomicReference < > ( ) ; final CountDownLatch parentHasStarted = new CountDownLatch ( 1 ) ; final CountDownLatch parentHasFinished = new CountDownLatch ( 1 ) ; Observable < Observable < String > > observableOfObservables = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( final Observer < ? super Observable < String > > observer ) final Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; parent . set ( new Thread ( new Runnable ( ) @ Override public void run ( ) try if ( ! d . isDisposed ( ) ) System . out . println ( "Emit o1" ) ; observer . onNext ( Observable . unsafeCreate ( o1 ) ) ; if ( ! d . isDisposed ( ) ) System . out . println ( "Emit o2" ) ; observer . onNext ( Observable . unsafeCreate ( o2 ) ) ; try allowThird . await ( ) ; catch ( InterruptedException e ) observer . onError ( e ) ; if ( ! d . isDisposed ( ) ) System . out . println ( "Emit o3" ) ; observer . onNext ( Observable . unsafeCreate ( o3 ) ) ; catch ( Throwable e ) observer . onError ( e ) ; finally System . out . println ( "Done parent Observable" ) ; observer . onComplete ( ) ; parentHasFinished . countDown ( ) ; ) ) ; parent . get ( ) . start ( ) ; parentHasStarted . countDown ( ) ; ) ; Observable . concat ( observableOfObservables ) . subscribe ( observer ) ; parentHasStarted . await ( ) ; try System . out . println ( "Thread1 is starting ... waiting for it to complete ..." ) ; o1 . waitForThreadDone ( ) ; System . out . println ( "Thread2 is starting ... waiting for it to complete ..." ) ; o2 . waitForThreadDone ( ) ; catch ( Throwable e ) throw new RuntimeException ( "failed waiting on threads" , e ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "five" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "six" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "seven" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "eight" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "nine" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; allowThird . countDown ( ) ; try o3 . waitForThreadDone ( ) ; catch ( Throwable e ) throw new RuntimeException ( "failed waiting on threads" , e ) ; try if ( ! parentHasFinished . await ( 5 , TimeUnit . SECONDS ) ) fail ( "Parent didn't finish within the time limit" ) ; catch ( Throwable e ) throw new RuntimeException ( "failed waiting on threads" , e ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "seven" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "eight" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "nine" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; final String [ ] o = "1" , "3" , "5" , "7" ; final String [ ] e = "2" , "4" , "6" ; final Observable < String > odds = Observable . fromArray ( o ) ; final Observable < String > even = Observable . fromArray ( e ) ; final CountDownLatch callOnce = new CountDownLatch ( 1 ) ; final CountDownLatch okToContinue = new CountDownLatch ( 1 ) ; TestObservable < Observable < String > > observableOfObservables = new TestObservable < > ( callOnce , okToContinue , odds , even ) ; Observable < String > concatF = Observable . concat ( Observable . unsafeCreate ( observableOfObservables ) ) ; concatF . subscribe ( observer ) ; try callOnce . await ( ) ; catch ( Throwable ex ) ex . printStackTrace ( ) ; fail ( ex . getMessage ( ) ) ; verify ( observer , times ( 1 ) ) . onNext ( "1" ) ; verify ( observer , times ( 1 ) ) . onNext ( "3" ) ; verify ( observer , times ( 1 ) ) . onNext ( "5" ) ; verify ( observer , times ( 1 ) ) . onNext ( "7" ) ; try okToContinue . countDown ( ) ; observableOfObservables . t . join ( ) ; catch ( Throwable ex ) ex . printStackTrace ( ) ; fail ( ex . getMessage ( ) ) ; verify ( observer , times ( 1 ) ) . onNext ( "2" ) ; verify ( observer , times ( 1 ) ) . onNext ( "4" ) ; verify ( observer , times ( 1 ) ) . onNext ( "6" ) ; 
final TestObservable < String > w1 = new TestObservable < > ( "one" , "two" , "three" ) ; final TestObservable < String > w2 = new TestObservable < > ( "hello" , Integer . MAX_VALUE ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObservable < Observable < String > > observableOfObservables = new TestObservable < > ( Observable . unsafeCreate ( w1 ) , Observable . unsafeCreate ( w2 ) ) ; Observable < String > concatF = Observable . concat ( Observable . unsafeCreate ( observableOfObservables ) ) ; concatF . take ( 50 ) . subscribe ( observer ) ; try w1 . waitForThreadDone ( ) ; w2 . waitForThreadDone ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 47 ) ) . onNext ( "hello" ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final CountDownLatch okToContinueW1 = new CountDownLatch ( 1 ) ; final CountDownLatch okToContinueW2 = new CountDownLatch ( 1 ) ; final TestObservable < String > w1 = new TestObservable < > ( null , okToContinueW1 , "one" , "two" , "three" ) ; final TestObservable < String > w2 = new TestObservable < > ( null , okToContinueW2 , "four" , "five" , "six" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < Observable < String > > observableOfObservables = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( Observable . unsafeCreate ( w1 ) ) ; observer . onNext ( Observable . unsafeCreate ( w2 ) ) ; observer . onComplete ( ) ; ) ; Observable < String > concat = Observable . concat ( observableOfObservables ) ; concat . subscribe ( observer ) ; verify ( observer , times ( 0 ) ) . onComplete ( ) ; try okToContinueW1 . countDown ( ) ; okToContinueW2 . countDown ( ) ; w1 . t . join ( ) ; w2 . t . join ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "five" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "six" ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
final CountDownLatch callOnce = new CountDownLatch ( 1 ) ; final CountDownLatch okToContinue = new CountDownLatch ( 1 ) ; final TestObservable < String > w1 = new TestObservable < > ( "one" , "two" , "three" ) ; final TestObservable < String > w2 = new TestObservable < > ( callOnce , okToContinue , "four" , "five" , "six" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; final Observable < String > concat = Observable . concat ( Observable . unsafeCreate ( w1 ) , Observable . unsafeCreate ( w2 ) ) ; try concat . subscribe ( to ) ; callOnce . await ( ) ; to . dispose ( ) ; okToContinue . countDown ( ) ; w1 . t . join ( ) ; w2 . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "five" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "six" ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; 
final CountDownLatch callOnce = new CountDownLatch ( 1 ) ; final CountDownLatch okToContinue = new CountDownLatch ( 1 ) ; final TestObservable < String > w1 = new TestObservable < > ( "one" , "two" , "three" ) ; final TestObservable < String > w2 = new TestObservable < > ( callOnce , okToContinue , "four" , "five" , "six" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; TestObservable < Observable < String > > observableOfObservables = new TestObservable < > ( Observable . unsafeCreate ( w1 ) , Observable . unsafeCreate ( w2 ) ) ; Observable < String > concatF = Observable . concat ( Observable . unsafeCreate ( observableOfObservables ) ) ; concatF . subscribe ( to ) ; try callOnce . await ( ) ; to . dispose ( ) ; okToContinue . countDown ( ) ; w1 . t . join ( ) ; w2 . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "five" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "six" ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
threadHasStarted . await ( ) ; t . join ( ) ; 
Observer < Object > o1 = TestHelper . mockObserver ( ) ; Observer < Object > o2 = TestHelper . mockObserver ( ) ; TestScheduler s = new TestScheduler ( ) ; Observable < Long > timer = Observable . interval ( 500 , TimeUnit . MILLISECONDS , s ) . take ( 2 ) ; Observable < Long > o = Observable . concat ( timer , timer ) ; o . subscribe ( o1 ) ; o . subscribe ( o2 ) ; InOrder inOrder1 = inOrder ( o1 ) ; InOrder inOrder2 = inOrder ( o2 ) ; s . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; inOrder1 . verify ( o1 , times ( 1 ) ) . onNext ( 0L ) ; inOrder2 . verify ( o2 , times ( 1 ) ) . onNext ( 0L ) ; s . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; inOrder1 . verify ( o1 , times ( 1 ) ) . onNext ( 1L ) ; inOrder2 . verify ( o2 , times ( 1 ) ) . onNext ( 1L ) ; s . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; inOrder1 . verify ( o1 , times ( 1 ) ) . onNext ( 0L ) ; inOrder2 . verify ( o2 , times ( 1 ) ) . onNext ( 0L ) ; s . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; inOrder1 . verify ( o1 , times ( 1 ) ) . onNext ( 1L ) ; inOrder2 . verify ( o2 , times ( 1 ) ) . onNext ( 1L ) ; inOrder1 . verify ( o1 , times ( 1 ) ) . onComplete ( ) ; inOrder2 . verify ( o2 , times ( 1 ) ) . onComplete ( ) ; verify ( o1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final int n = 10000 ; Observable < Observable < Integer > > source = Observable . range ( 0 , n ) . map ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; Single < List < Integer > > result = Observable . concat ( source ) . toList ( ) ; SingleObserver < List < Integer > > o = TestHelper . mockSingleObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; List < Integer > list = new ArrayList < > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) list . add ( i ) ; inOrder . verify ( o ) . onSuccess ( list ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final int n = 10000 ; Observable < Observable < Integer > > source = Observable . range ( 0 , n ) . map ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; Single < List < Integer > > result = Observable . concat ( source ) . take ( n / 2 ) . toList ( ) ; SingleObserver < List < Integer > > o = TestHelper . mockSingleObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; List < Integer > list = new ArrayList < > ( n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) list . add ( i ) ; inOrder . verify ( o ) . onSuccess ( list ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
assertEquals ( 1 , ( int ) Observable . < Integer > empty ( ) . concatWith ( Observable . just ( 1 ) ) . take ( 1 ) . blockingSingle ( ) ) ; 
Observable < String > o = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "hello" ) ; observer . onComplete ( ) ; observer . onComplete ( ) ; ) ; TestObserverEx < String > to = new TestObserverEx < > ( ) ; Observable . concat ( o , o ) . subscribe ( to ) ; to . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; to . assertValues ( "hello" , "hello" ) ; 
final ExecutorService executor = Executors . newFixedThreadPool ( 2 ) ; final Scheduler sch = Schedulers . from ( executor ) ; Function < Integer , Observable < Integer > > func = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) Observable < Integer > o = Observable . just ( t ) . subscribeOn ( sch ) ; Subject < Integer > subject = UnicastSubject . create ( ) ; o . subscribe ( subject ) ; return subject ; ; int n = 5000 ; final AtomicInteger counter = new AtomicInteger ( ) ; Observable . range ( 1 , n ) . concatMap ( func ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onNext ( Integer t ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) if ( counter . getAndIncrement ( ) % 100 == 0 ) System . out . println ( "testIssue2890NoStackoverflow -> " + counter . get ( ) ) ; ; @ Override public void onComplete ( ) executor . shutdown ( ) ; @ Override public void onError ( Throwable e ) executor . shutdown ( ) ; ) ; long awaitTerminationTimeout = 100_000 ; if ( ! executor . awaitTermination ( awaitTerminationTimeout , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( "Completed " + counter . get ( ) + "/" + n + " before timed out after " + awaitTerminationTimeout + " milliseconds." ) ; assertEquals ( n , counter . get ( ) ) ; 
final long durationSeconds = 2 ; final long startTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; ; i ++ ) if ( System . currentTimeMillis ( ) - startTime > TimeUnit . SECONDS . toMillis ( durationSeconds ) ) return ; if ( i % 1000 == 0 ) System . out . println ( "concatMapRangeAsyncLoop > " + i ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . range ( 0 , 1000 ) . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return Observable . fromIterable ( Arrays . asList ( t ) ) ; ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 2500 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; assertEquals ( 1000 , to . values ( ) . size ( ) ) ; assertEquals ( ( Integer ) 999 , to . values ( ) . get ( 999 ) ) ; 
Observable . concat ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Observable . concat ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Observable . concatArrayDelayError ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Observable . concatArrayDelayError ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 4 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 ) ; 
Observable . concatDelayError ( Arrays . asList ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Observable . concatDelayError ( Arrays . asList ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 4 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 ) ; 
Observable . concatDelayError ( Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Observable . concatDelayError ( Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 4 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 ) ; 
Observable . concatDelayError ( Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 4 ) ) , 2 , false ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; 
Observable . concatDelayError ( Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 4 ) ) , 2 , true ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 ) ; 
Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . concatMapDelayError ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . just ( Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 2 ) ) . concatMapDelayError ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Observable . just ( 1 , 2 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 5 ) ; 
assertSame ( Observable . empty ( ) , Observable . concatArrayDelayError ( ) ) ; 
assertSame ( Observable . never ( ) , Observable . concatArrayDelayError ( Observable . never ( ) ) ) ; 
assertSame ( Observable . empty ( ) , Observable . < Object > empty ( ) . concatMapDelayError ( new Function < Object , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , true , 16 ) ) ; 
Observable . just ( 0 ) . concatMapDelayError ( new Function < Object , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , true , 16 ) . test ( ) . assertResult ( 1 ) ; 
assertSame ( Observable . empty ( ) , Observable . concatArray ( ) ) ; 
assertSame ( Observable . never ( ) , Observable . concatArray ( Observable . never ( ) ) ) ; 
assertSame ( Observable . empty ( ) , Observable . < Object > empty ( ) . concatMap ( new Function < Object , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , 16 ) ) ; 
Observable . just ( 0 ) . concatMap ( new Function < Object , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , 16 ) . test ( ) . assertResult ( 1 ) ; 
final int [ ] calls = 0 ; Observable < Integer > source = Observable . create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onNext ( 1 ) ; s . onComplete ( ) ; ) ; Observable . concatArray ( source , source ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Observable < Integer > source = Observable . create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onNext ( 1 ) ; s . onComplete ( ) ; ) ; Observable . concatArrayDelayError ( source , source ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Observable < Integer > source = Observable . create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onNext ( 1 ) ; s . onComplete ( ) ; ) ; Observable . concat ( Arrays . asList ( source , source ) ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Observable < Integer > source = Observable . create ( new ObservableOnSubscribe < Integer > ( ) @ Override public void subscribe ( ObservableEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onNext ( 1 ) ; s . onComplete ( ) ; ) ; Observable . concatDelayError ( Arrays . asList ( source , source ) ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final Disposable [ ] disposable = null ; Observable . concat ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) disposable [ 0 ] = d ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; assertTrue ( disposable [ 0 ] . isDisposed ( ) ) ; 
final Disposable [ ] disposable = null ; Observable . concatArrayDelayError ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) disposable [ 0 ] = d ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; assertTrue ( disposable [ 0 ] . isDisposed ( ) ) ; 
final Disposable [ ] disposable = null ; Observable . concat ( Observable . just ( 1 ) , Observable . < Integer > error ( new TestException ( ) ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) disposable [ 0 ] = d ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; assertTrue ( disposable [ 0 ] . isDisposed ( ) ) ; 
final Disposable [ ] disposable = null ; Observable . concatArrayDelayError ( Observable . just ( 1 ) , Observable . < Integer > error ( new TestException ( ) ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) disposable [ 0 ] = d ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; assertTrue ( disposable [ 0 ] . isDisposed ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; Observable . concatArray ( source , source , source , source , source ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; Observable . concat ( Arrays . asList ( source , source , source , source , source ) ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
Observable < Integer > source = Observable . range ( 0 , 3 ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . retry ( retryTwice ) . subscribe ( o ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > source = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) int count ; @ Override public void subscribe ( Observer < ? super Integer > t1 ) t1 . onSubscribe ( Disposable . empty ( ) ) ; count ++ ; t1 . onNext ( 0 ) ; t1 . onNext ( 1 ) ; if ( count == 1 ) t1 . onError ( new TestException ( ) ) ; return ; t1 . onNext ( 2 ) ; t1 . onNext ( 3 ) ; t1 . onComplete ( ) ; ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . retry ( retryTwice ) . subscribe ( o ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > source = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > t1 ) t1 . onSubscribe ( Disposable . empty ( ) ) ; t1 . onNext ( 0 ) ; t1 . onNext ( 1 ) ; t1 . onError ( new TestException ( ) ) ; ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . retry ( retryTwice ) . subscribe ( o ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observable < Integer > source = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) int count ; @ Override public void subscribe ( Observer < ? super Integer > t1 ) t1 . onSubscribe ( Disposable . empty ( ) ) ; count ++ ; t1 . onNext ( 0 ) ; t1 . onNext ( 1 ) ; if ( count == 1 ) t1 . onError ( new IOException ( ) ) ; return ; t1 . onNext ( 2 ) ; t1 . onNext ( 3 ) ; t1 . onComplete ( ) ; ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . retry ( retryOnTestException ) . subscribe ( o ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final IOException ioe = new IOException ( ) ; final TestException te = new TestException ( ) ; Observable < Integer > source = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) int count ; @ Override public void subscribe ( Observer < ? super Integer > t1 ) t1 . onSubscribe ( Disposable . empty ( ) ) ; count ++ ; t1 . onNext ( 0 ) ; t1 . onNext ( 1 ) ; if ( count == 1 ) t1 . onError ( ioe ) ; return ; t1 . onNext ( 2 ) ; t1 . onNext ( 3 ) ; t1 . onError ( te ) ; ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . retry ( retryOnTestException ) . subscribe ( o ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 0 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onError ( te ) ; verify ( o , never ( ) ) . onError ( ioe ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > subject = PublishSubject . create ( ) ; final AtomicInteger count = new AtomicInteger ( 0 ) ; Disposable sub = subject . retry ( retryTwice ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer n ) count . incrementAndGet ( ) ; ) ; subject . onNext ( 1 ) ; sub . dispose ( ) ; subject . onNext ( 2 ) ; assertEquals ( 1 , count . get ( ) ) ; 
Observer < Long > observer = TestHelper . mockObserver ( ) ; ObservableRetryTest . SlowObservable so = new ObservableRetryTest . SlowObservable ( 100 , 0 , "testUnsubscribeAfterError" ) ; Observable < Long > o = Observable . unsafeCreate ( so ) . retry ( retry5 ) ; ObservableRetryTest . AsyncObserver < Long > async = new ObservableRetryTest . AsyncObserver < > ( observer ) ; o . subscribe ( async ) ; async . await ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; assertEquals ( "Start 6 threads, retry 5 then fail on 6" , 6 , so . efforts . get ( ) ) ; assertEquals ( "Only 1 active subscription" , 1 , so . maxActive . get ( ) ) ; 
Observer < Long > observer = TestHelper . mockObserver ( ) ; ObservableRetryTest . SlowObservable so = new ObservableRetryTest . SlowObservable ( 100 , 10 , "testTimeoutWithRetry" ) ; Observable < Long > o = Observable . unsafeCreate ( so ) . timeout ( 80 , TimeUnit . MILLISECONDS ) . retry ( retry5 ) ; ObservableRetryTest . AsyncObserver < Long > async = new ObservableRetryTest . AsyncObserver < > ( observer ) ; o . subscribe ( async ) ; async . await ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; assertEquals ( "Start 6 threads, retry 5 then fail on 6" , 6 , so . efforts . get ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; final RuntimeException e = new RuntimeException ( "You shall not pass" ) ; final AtomicInteger c = new AtomicInteger ( ) ; Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) c . incrementAndGet ( ) ; throw e ; ) . retry ( retry5 ) . subscribe ( to ) ; to . assertTerminated ( ) ; assertEquals ( 6 , c . get ( ) ) ; assertEquals ( Collections . singletonList ( e ) , to . errors ( ) ) ; 
final AtomicBoolean throwException = new AtomicBoolean ( true ) ; int value = Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) if ( throwException . compareAndSet ( true , false ) ) throw new TestException ( ) ; return t1 ; ) . retry ( 1 ) . blockingSingle ( ) ; assertEquals ( 1 , value ) ; 
final List < Long > list = new CopyOnWriteArrayList < > ( ) ; final AtomicBoolean isFirst = new AtomicBoolean ( true ) ; Observable . < Long > just ( 1L , 2L , 3L ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long x ) System . out . println ( "map " + x ) ; if ( x == 2 && isFirst . getAndSet ( false ) ) throw new RuntimeException ( "retryable error" ) ; return x ; ) . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer t1 , Throwable t2 ) return true ; ) . forEach ( new Consumer < Long > ( ) @ Override public void accept ( Long t ) System . out . println ( t ) ; list . add ( t ) ; ) ; assertEquals ( Arrays . asList ( 1L , 1L , 2L , 3L ) , list ) ; 
final List < Long > list = new CopyOnWriteArrayList < > ( ) ; final AtomicBoolean isFirst = new AtomicBoolean ( true ) ; Observable . < Long > just ( 1L , 2L , 3L ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long x ) System . out . println ( "map " + x ) ; if ( x == 2 && isFirst . getAndSet ( false ) ) throw new RuntimeException ( "retryable error" ) ; return x ; ) . retry ( ) . forEach ( new Consumer < Long > ( ) @ Override public void accept ( Long t ) System . out . println ( t ) ; list . add ( t ) ; ) ; assertEquals ( Arrays . asList ( 1L , 1L , 2L , 3L ) , list ) ; 
TestObserverEx < Object > to = Observable . error ( new TestException ( "Outer" ) ) . retry ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
Observable . error ( new TestException ( "Outer" ) ) . retry ( Functions . alwaysFalse ( ) ) . to ( TestHelper . testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Outer" ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . retry ( Functions . alwaysTrue ( ) ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
TestObserverEx < Object > to = Observable . error ( new TestException ( "Outer" ) ) . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer n , Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . to ( TestHelper . testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . retry ( new BiPredicate < Object , Object > ( ) @ Override public boolean test ( Object t1 , Object t2 ) throws Exception return true ; ) . test ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
observer = TestHelper . mockObserver ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Timed < Integer > > m = source . timestamp ( scheduler ) ; m . subscribe ( observer ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 1 , 0 , TimeUnit . MILLISECONDS ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 2 , 100 , TimeUnit . MILLISECONDS ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 3 , 200 , TimeUnit . MILLISECONDS ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
