PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > debounceSel = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . debounce ( debounceSel ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > debounceSel = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return Flowable . error ( new TestException ( ) ) ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . debounce ( debounceSel ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . debounce ( 100 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > debouncer = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > debounceSel = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return debouncer ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . debounce ( debounceSel ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; debouncer . onComplete ( ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; TestSubscriberEx < Integer > subscriber = new TestSubscriberEx < > ( ) ; Flowable . merge ( Flowable . just ( 1 ) , Flowable . just ( 2 ) . delay ( 10 , TimeUnit . MILLISECONDS , scheduler ) ) . debounce ( 20 , TimeUnit . MILLISECONDS , scheduler ) . take ( 1 ) . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 30 , TimeUnit . MILLISECONDS ) ; subscriber . assertValue ( 2 ) ; subscriber . assertTerminated ( ) ; subscriber . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 1000 ) . debounce ( 1 , TimeUnit . SECONDS ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValue ( 1000 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . just ( 1 ) . debounce ( 1 , TimeUnit . SECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . debounce ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . debounce ( Functions . justFunction ( Flowable . never ( ) ) ) ) ; Disposable d = new FlowableDebounceTimed . DebounceEmitter < > ( 1 , 1 , null ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . debounce ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . debounce ( new Function < Integer , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Integer v ) throws Exception return Flowable . timer ( 1 , TimeUnit . SECONDS ) ; ) ; , false , 1 , 1 , 1 ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( final Flowable < Integer > f ) throws Exception return Flowable . just ( 1 ) . debounce ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return f ; ) ; , false , 1 , 1 , 1 ) ; 
Flowable . just ( 1 ) . debounce ( Functions . justFunction ( Flowable . empty ( ) ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . debounce ( Functions . justFunction ( Flowable . timer ( 1 , TimeUnit . MILLISECONDS ) ) ) . test ( 0L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( MissingBackpressureException . class ) ; 
Flowable . just ( 1 ) . debounce ( 1 , TimeUnit . MILLISECONDS ) . test ( 0L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( MissingBackpressureException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . debounce ( Functions . justFunction ( Flowable . never ( ) ) ) ; ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; BehaviorProcessor . createDefault ( 1 ) . debounce ( new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer o ) throws Exception ts . cancel ( ) ; return Flowable . never ( ) ; ) . subscribeWith ( ts ) . assertEmpty ( ) ; assertTrue ( ts . isCancelled ( ) ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ts . cancel ( ) ; subscriber . onComplete ( ) ; . debounce ( Functions . justFunction ( Flowable . never ( ) ) ) . subscribeWith ( ts ) . assertEmpty ( ) ; 
final AtomicReference < Subscriber < ? super Integer > > ref = new AtomicReference < > ( ) ; TestSubscriber < Integer > ts = Flowable . range ( 1 , 2 ) . debounce ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer o ) throws Exception if ( o != 1 ) return Flowable . never ( ) ; return new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( subscriber ) ; ; ) . test ( ) ; ref . get ( ) . onNext ( 1 ) ; ts . assertResult ( 2 ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . debounce ( Functions . justFunction ( Flowable . never ( ) ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . debounce ( 1 , TimeUnit . SECONDS ) ; ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( org . reactivestreams . Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; ts . cancel ( ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; . debounce ( 1 , TimeUnit . SECONDS ) . subscribe ( ts ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . debounce ( 1 , TimeUnit . SECONDS ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; DebounceTimedSubscriber < Integer > sub = new DebounceTimedSubscriber < > ( ts , 1 , TimeUnit . SECONDS , new TestScheduler ( ) . createWorker ( ) ) ; sub . onSubscribe ( new BooleanSubscription ( ) ) ; DebounceEmitter < Integer > de = new DebounceEmitter < > ( 1 , 50 , sub ) ; de . emit ( ) ; de . emit ( ) ; ts . assertEmpty ( ) ; 
Flowable . error ( new TestException ( ) ) . debounce ( 1 , TimeUnit . SECONDS ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . empty ( ) . debounce ( new Function < Object , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Object o ) return Flowable . just ( new Object ( ) ) ; ) . subscribe ( ) ; 
Flowable < Integer > src = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) ; src . skipWhile ( INDEX_LESS_THAN_THREE ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > src = Flowable . empty ( ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > src = Flowable . just ( 1 , 2 , 3 , 4 , 3 , 2 , 1 ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > src = Flowable . just ( 5 , 3 , 1 ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > src = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 3 , 1 , 5 ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > src = Flowable . just ( 1 , 2 , 42 , 5 , 3 , 1 ) ; src . skipWhile ( LESS_THAN_FIVE ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyInt ( ) ) ; inOrder . verify ( w , never ( ) ) . onComplete ( ) ; inOrder . verify ( w , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; 
Flowable < Integer > src = Flowable . range ( 1 , 10 ) . skipWhile ( LESS_THAN_FIVE ) ; int n = 5 ; for ( int i = 0 ; i < n ; i ++ ) Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; src . subscribe ( subscriber ) ; for ( int j = 5 ; j < 10 ; j ++ ) inOrder . verify ( subscriber ) . onNext ( j ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . skipWhile ( Functions . alwaysFalse ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . skipWhile ( Functions . alwaysFalse ( ) ) ; ) ; 
Flowable . error ( new TestException ( ) ) . skipWhile ( Functions . alwaysFalse ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . mergeWith ( Single . just ( 100 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
Flowable . range ( 1 , 512 ) . mergeWith ( Single . just ( 100 ) ) . test ( ) . assertValueCount ( 513 ) . assertComplete ( ) ; 
Flowable . range ( 1 , 512 ) . mergeWith ( Single . just ( 100 ) ) . test ( 513 ) . assertValueCount ( 513 ) . assertComplete ( ) ; 
Flowable . range ( 1 , 5 ) . mergeWith ( Single . just ( 100 ) ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Flowable . range ( 1 , 5 ) . mergeWith ( Single . just ( 100 ) ) . subscribe ( ts ) ; ts . assertEmpty ( ) . requestMore ( 2 ) . assertValues ( 100 , 1 ) . requestMore ( 2 ) . assertValues ( 100 , 1 , 2 , 3 ) . requestMore ( 2 ) . assertResult ( 100 , 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . error ( new TestException ( ) ) . mergeWith ( Single . just ( 100 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . never ( ) . mergeWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < 10000 ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onSuccess ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 , 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onNext ( 2 ) ; ) ; pp . onNext ( 1 ) ; cs . onSuccess ( 3 ) ; pp . onNext ( 4 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 3 , 4 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cs . onSuccess ( 2 ) ; ) ; pp . onNext ( 1 ) ; pp . onNext ( 3 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < Integer > ( 1 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cs . onSuccess ( 2 ) ; ) ; pp . onNext ( 1 ) ; pp . onNext ( 3 ) ; pp . onComplete ( ) ; ts . request ( 2 ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
for ( int i = 0 ; i < 10000 ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < > ( 0 ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cs . onSuccess ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 2 ) ; ; TestHelper . race ( r1 , r2 ) ; pp . onNext ( 2 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Subscriber < ? > > subscriber = new AtomicReference < > ( ) ; TestSubscriber < Integer > ts = new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . set ( s ) ; . mergeWith ( Single . < Integer > error ( new IOException ( ) ) ) . test ( ) ; subscriber . get ( ) . onError ( new TestException ( ) ) ; ts . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . error ( new IOException ( ) ) . mergeWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < 10000 ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; final TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . test ( 0 ) ; pp . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . request ( 3 ) ; ; TestHelper . race ( r1 , r2 ) ; cs . onSuccess ( 1 ) ; pp . onComplete ( ) ; ts . assertResult ( 0 , 1 , 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . mergeWith ( Single . just ( 1 ) ) ; ) ; 
Flowable . empty ( ) . mergeWith ( Single . error ( new TestException ( ) ) ) . test ( 0 ) . assertFailure ( TestException . class ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . take ( 2 ) . subscribeWith ( new TestSubscriber < Integer > ( 2 ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cs . onSuccess ( 2 ) ; ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . request ( 2 ) ; ts . assertResult ( 1 , 2 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final SingleSubject < Integer > cs = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( cs ) . subscribeWith ( new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) for ( int i = 0 ; i < Flowable . bufferSize ( ) - 1 ; i ++ ) pp . onNext ( i + 2 ) ; ) ; cs . onSuccess ( 1 ) ; pp . onComplete ( ) ; ts . request ( 2 ) ; ts . assertValueCount ( Flowable . bufferSize ( ) ) ; ts . assertComplete ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( ss ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( ss . hasObservers ( ) ) ; pp . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , pp . hasSubscribers ( ) ) ; assertFalse ( "other has observers" , ss . hasObservers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = pp . mergeWith ( ss ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; assertTrue ( ss . hasObservers ( ) ) ; ss . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , pp . hasSubscribers ( ) ) ; assertFalse ( "other has observers" , ss . hasObservers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . mergeWith ( Single . just ( 1 ) . hide ( ) ) ; ) ; 
SingleSubject < Integer > ss = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . mergeWith ( ss ) . doOnNext ( v -> if ( v == 1 ) ss . onSuccess ( 6 ) ; ts . cancel ( ) ; ) . subscribe ( ts ) ; ts . assertValuesOnly ( 1 ) ; 
TestFlowable f = new TestFlowable ( "one" ) ; Flowable < String > w = Flowable . unsafeCreate ( f ) ; final AtomicReference < Throwable > capturedException = new AtomicReference < > ( ) ; Flowable < String > flowable = w . onErrorReturn ( new Function < Throwable , String > ( ) @ Override public String apply ( Throwable e ) capturedException . set ( e ) ; return "failure" ; ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; try f . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "failure" ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; assertNotNull ( capturedException . get ( ) ) ; 
TestFlowable f = new TestFlowable ( "one" ) ; Flowable < String > w = Flowable . unsafeCreate ( f ) ; final AtomicReference < Throwable > capturedException = new AtomicReference < > ( ) ; Flowable < String > flowable = w . onErrorReturn ( new Function < Throwable , String > ( ) @ Override public String apply ( Throwable e ) capturedException . set ( e ) ; throw new RuntimeException ( "exception from function" ) ; ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; try f . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 0 ) ) . onComplete ( ) ; assertNotNull ( capturedException . get ( ) ) ; 
Flowable < String > w = Flowable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; w = w . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; System . out . println ( "BadMapper:" + s ) ; return s ; ) ; Flowable < String > flowable = w . onErrorReturn ( new Function < Throwable , String > ( ) @ Override public String apply ( Throwable t1 ) return "resume" ; ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber , Long . MAX_VALUE ) ; flowable . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "resume" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , 100000 ) . onErrorReturn ( new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable t1 ) return 1 ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t1 ) if ( c ++ <= 1 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; System . out . println ( "TestFlowable subscribed to ..." ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestFlowable thread" ) ; for ( String s : values ) System . out . println ( "TestFlowable onNext: " + s ) ; subscriber . onNext ( s ) ; throw new RuntimeException ( "Forced Failure" ) ; catch ( Throwable e ) subscriber . onError ( e ) ; ) ; System . out . println ( "starting TestFlowable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestFlowable thread" ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . onErrorReturn ( new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable e ) return 3 ; ) . subscribe ( ts ) ; ts . request ( 2 ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onError ( new TestException ( "Forced failure" ) ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . error ( new TestException ( ) ) . onErrorReturnItem ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . onErrorReturnItem ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . onErrorReturnItem ( 1 ) ; ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( ) ) ; s . onError ( new TestException ( ) ) ; . onErrorReturnItem ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Flowable < String > flowable = Flowable . < String > empty ( ) . skipLast ( 2 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > flowable = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) . skipLast ( 2 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; flowable . subscribe ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > flowable = Flowable . fromIterable ( Arrays . asList ( "one" , "two" ) ) . skipLast ( 2 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . just ( "one" , "two" ) ; Flowable < String > flowable = w . skipLast ( 0 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > f = Flowable . range ( 0 , Flowable . bufferSize ( ) * 2 ) . skipLast ( Flowable . bufferSize ( ) + 10 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; f . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( ( Flowable . bufferSize ( ) ) - 10 , ts . values ( ) . size ( ) ) ; 
Flowable . just ( "one" ) . skipLast ( - 1 ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . skipLast ( 1 ) ) ; 
Flowable . error ( new TestException ( ) ) . skipLast ( 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . skipLast ( 1 ) ; ) ; 
Subscriber < String > w = TestHelper . mockSubscriber ( ) ; PublishProcessor < String > w1 = PublishProcessor . create ( ) ; PublishProcessor < String > w2 = PublishProcessor . create ( ) ; Flowable < String > combined = Flowable . combineLatest ( w1 , w2 , new BiFunction < String , String , String > ( ) @ Override public String apply ( String v1 , String v2 ) throw new RuntimeException ( "I don't work." ) ; ) ; combined . subscribe ( w ) ; w1 . onNext ( "first value of w1" ) ; w2 . onNext ( "first value of w2" ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onComplete ( ) ; verify ( w , times ( 1 ) ) . onError ( Mockito . < RuntimeException > any ( ) ) ; 
Subscriber < String > w = TestHelper . mockSubscriber ( ) ; PublishProcessor < String > w1 = PublishProcessor . create ( ) ; PublishProcessor < String > w2 = PublishProcessor . create ( ) ; PublishProcessor < String > w3 = PublishProcessor . create ( ) ; Flowable < String > combineLatestW = Flowable . combineLatest ( w1 , w2 , w3 , getConcat3StringsCombineLatestFunction ( ) ) ; combineLatestW . subscribe ( w ) ; w1 . onNext ( "1a" ) ; w2 . onNext ( "2a" ) ; w3 . onNext ( "3a" ) ; w1 . onComplete ( ) ; w2 . onNext ( "2b" ) ; w2 . onComplete ( ) ; w3 . onNext ( "3b" ) ; w3 . onNext ( "3c" ) ; w3 . onNext ( "3d" ) ; w3 . onComplete ( ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w ) . onNext ( "1a2a3a" ) ; inOrder . verify ( w ) . onNext ( "1a2b3a" ) ; inOrder . verify ( w ) . onNext ( "1a2b3b" ) ; inOrder . verify ( w ) . onNext ( "1a2b3c" ) ; inOrder . verify ( w ) . onNext ( "1a2b3d" ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Subscriber < String > w = TestHelper . mockSubscriber ( ) ; PublishProcessor < String > w1 = PublishProcessor . create ( ) ; PublishProcessor < String > w2 = PublishProcessor . create ( ) ; PublishProcessor < String > w3 = PublishProcessor . create ( ) ; Flowable < String > combineLatestW = Flowable . combineLatest ( w1 , w2 , w3 , getConcat3StringsCombineLatestFunction ( ) ) ; combineLatestW . subscribe ( w ) ; w1 . onNext ( "1a" ) ; w1 . onNext ( "1b" ) ; w1 . onNext ( "1c" ) ; w1 . onNext ( "1d" ) ; w1 . onComplete ( ) ; w2 . onNext ( "2a" ) ; w2 . onNext ( "2b" ) ; w2 . onComplete ( ) ; w3 . onNext ( "3a" ) ; w3 . onComplete ( ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "1d2b3a" ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Subscriber < String > w = TestHelper . mockSubscriber ( ) ; PublishProcessor < String > w1 = PublishProcessor . create ( ) ; PublishProcessor < String > w2 = PublishProcessor . create ( ) ; PublishProcessor < String > w3 = PublishProcessor . create ( ) ; Flowable < String > combineLatestW = Flowable . combineLatest ( w1 , w2 , w3 , getConcat3StringsCombineLatestFunction ( ) ) ; combineLatestW . subscribe ( w ) ; w1 . onNext ( "1a" ) ; w2 . onNext ( "2a" ) ; w2 . onNext ( "2b" ) ; w3 . onNext ( "3a" ) ; w1 . onNext ( "1b" ) ; w2 . onNext ( "2c" ) ; w2 . onNext ( "2d" ) ; w3 . onNext ( "3b" ) ; w1 . onComplete ( ) ; w2 . onComplete ( ) ; w3 . onComplete ( ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w ) . onNext ( "1a2b3a" ) ; inOrder . verify ( w ) . onNext ( "1b2b3a" ) ; inOrder . verify ( w ) . onNext ( "1b2c3a" ) ; inOrder . verify ( w ) . onNext ( "1b2d3a" ) ; inOrder . verify ( w ) . onNext ( "1b2d3b" ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
BiFunction < String , Integer , String > combineLatestFunction = getConcatStringIntegerCombineLatestFunction ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > w = Flowable . combineLatest ( Flowable . just ( "one" , "two" ) , Flowable . just ( 2 , 3 , 4 ) , combineLatestFunction ) ; w . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two2" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two3" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two4" ) ; 
Function3 < String , Integer , int [ ] , String > combineLatestFunction = getConcatStringIntegerIntArrayCombineLatestFunction ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > w = Flowable . combineLatest ( Flowable . just ( "one" , "two" ) , Flowable . just ( 2 ) , Flowable . just ( new int [ ] 4 , 5 , 6 ) , combineLatestFunction ) ; w . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two2[4, 5, 6]" ) ; 
Function3 < String , Integer , int [ ] , String > combineLatestFunction = getConcatStringIntegerIntArrayCombineLatestFunction ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > w = Flowable . combineLatest ( Flowable . just ( "one" ) , Flowable . just ( 2 ) , Flowable . just ( new int [ ] 4 , 5 , 6 , new int [ ] 7 , 8 ) , combineLatestFunction ) ; w . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one2[4, 5, 6]" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one2[7, 8]" ) ; 
Function3 < String , String , String , String > combineLatestFunction = new Function3 < String , String , String , String > ( ) @ Override public String apply ( String a1 , String a2 , String a3 ) if ( a1 == null ) a1 = "" ; if ( a2 == null ) a2 = "" ; if ( a3 == null ) a3 = "" ; return a1 + a2 + a3 ; ; return combineLatestFunction ; 
BiFunction < String , Integer , String > combineLatestFunction = new BiFunction < String , Integer , String > ( ) @ Override public String apply ( String s , Integer i ) return getStringValue ( s ) + getStringValue ( i ) ; ; return combineLatestFunction ; 
return new Function3 < String , Integer , int [ ] , String > ( ) @ Override public String apply ( String s , Integer i , int [ ] iArray ) return getStringValue ( s ) + getStringValue ( i ) + getStringValue ( iArray ) ; ; 
if ( o == null ) return "" ; else if ( o instanceof int [ ] ) return Arrays . toString ( ( int [ ] ) o ) ; else return String . valueOf ( o ) ; 
PublishProcessor < Integer > a = PublishProcessor . create ( ) ; PublishProcessor < Integer > b = PublishProcessor . create ( ) ; Flowable < Integer > source = Flowable . combineLatest ( a , b , or ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . subscribe ( subscriber ) ; a . onNext ( 1 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; a . onNext ( 2 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; b . onNext ( 0x10 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 0x12 ) ; b . onNext ( 0x20 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 0x22 ) ; b . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; a . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; a . onNext ( 3 ) ; b . onNext ( 0x30 ) ; a . onComplete ( ) ; b . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > a = PublishProcessor . create ( ) ; PublishProcessor < Integer > b = PublishProcessor . create ( ) ; Flowable < Integer > source = Flowable . combineLatest ( a , b , or ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; Subscriber < Object > subscriber2 = TestHelper . mockSubscriber ( ) ; InOrder inOrder1 = inOrder ( subscriber1 ) ; InOrder inOrder2 = inOrder ( subscriber2 ) ; source . subscribe ( subscriber1 ) ; source . subscribe ( subscriber2 ) ; a . onNext ( 1 ) ; inOrder1 . verify ( subscriber1 , never ( ) ) . onNext ( any ( ) ) ; inOrder2 . verify ( subscriber2 , never ( ) ) . onNext ( any ( ) ) ; a . onNext ( 2 ) ; inOrder1 . verify ( subscriber1 , never ( ) ) . onNext ( any ( ) ) ; inOrder2 . verify ( subscriber2 , never ( ) ) . onNext ( any ( ) ) ; b . onNext ( 0x10 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 0x12 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 0x12 ) ; b . onNext ( 0x20 ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 0x22 ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 0x22 ) ; b . onComplete ( ) ; inOrder1 . verify ( subscriber1 , never ( ) ) . onComplete ( ) ; inOrder2 . verify ( subscriber2 , never ( ) ) . onComplete ( ) ; a . onComplete ( ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; a . onNext ( 3 ) ; b . onNext ( 0x30 ) ; a . onComplete ( ) ; b . onComplete ( ) ; inOrder1 . verifyNoMoreInteractions ( ) ; inOrder2 . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > a = PublishProcessor . create ( ) ; PublishProcessor < Integer > b = PublishProcessor . create ( ) ; Flowable < Integer > source = Flowable . combineLatest ( a , b , or ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . subscribe ( subscriber ) ; b . onNext ( 0x10 ) ; b . onNext ( 0x20 ) ; a . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > a = PublishProcessor . create ( ) ; PublishProcessor < Integer > b = PublishProcessor . create ( ) ; Flowable < Integer > source = Flowable . combineLatest ( a , b , or ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . subscribe ( subscriber ) ; a . onNext ( 0x1 ) ; a . onNext ( 0x2 ) ; b . onComplete ( ) ; a . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
int n = 30 ; Function < Object [ ] , List < Object > > func = new Function < Object [ ] , List < Object > > ( ) @ Override public List < Object > apply ( Object [ ] args ) return Arrays . asList ( args ) ; ; for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( "test1ToNSources: " + i + " sources" ) ; List < Flowable < Integer > > sources = new ArrayList < > ( ) ; List < Object > values = new ArrayList < > ( ) ; for ( int j = 0 ; j < i ; j ++ ) sources . add ( Flowable . just ( j ) ) ; values . add ( j ) ; Flowable < List < Object > > result = Flowable . combineLatest ( sources , func ) ; Subscriber < List < Object > > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( values ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
int n = 10 ; Function < Object [ ] , List < Object > > func = new Function < Object [ ] , List < Object > > ( ) @ Override public List < Object > apply ( Object [ ] args ) return Arrays . asList ( args ) ; ; for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( "test1ToNSourcesScheduled: " + i + " sources" ) ; List < Flowable < Integer > > sources = new ArrayList < > ( ) ; List < Object > values = new ArrayList < > ( ) ; for ( int j = 0 ; j < i ; j ++ ) sources . add ( Flowable . just ( j ) . subscribeOn ( Schedulers . io ( ) ) ) ; values . add ( j ) ; Flowable < List < Object > > result = Flowable . combineLatest ( sources , func ) ; final Subscriber < List < Object > > subscriber = TestHelper . mockSubscriber ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Subscriber < List < Object > > s = new DefaultSubscriber < List < Object > > ( ) @ Override public void onNext ( List < Object > t ) subscriber . onNext ( t ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; cdl . countDown ( ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; cdl . countDown ( ) ; ; result . subscribe ( s ) ; cdl . await ( ) ; verify ( subscriber ) . onNext ( values ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > s1 = Flowable . just ( 1 ) ; Flowable < Integer > s2 = Flowable . just ( 2 ) ; Flowable < List < Integer > > result = Flowable . combineLatest ( s1 , s2 , new BiFunction < Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 ) return Arrays . asList ( t1 , t2 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > s1 = Flowable . just ( 1 ) ; Flowable < Integer > s2 = Flowable . just ( 2 ) ; Flowable < Integer > s3 = Flowable . just ( 3 ) ; Flowable < List < Integer > > result = Flowable . combineLatest ( s1 , s2 , s3 , new Function3 < Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 ) return Arrays . asList ( t1 , t2 , t3 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 , 3 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > s1 = Flowable . just ( 1 ) ; Flowable < Integer > s2 = Flowable . just ( 2 ) ; Flowable < Integer > s3 = Flowable . just ( 3 ) ; Flowable < Integer > s4 = Flowable . just ( 4 ) ; Flowable < List < Integer > > result = Flowable . combineLatest ( s1 , s2 , s3 , s4 , new Function4 < Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 ) return Arrays . asList ( t1 , t2 , t3 , t4 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > s1 = Flowable . just ( 1 ) ; Flowable < Integer > s2 = Flowable . just ( 2 ) ; Flowable < Integer > s3 = Flowable . just ( 3 ) ; Flowable < Integer > s4 = Flowable . just ( 4 ) ; Flowable < Integer > s5 = Flowable . just ( 5 ) ; Flowable < List < Integer > > result = Flowable . combineLatest ( s1 , s2 , s3 , s4 , s5 , new Function5 < Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > s1 = Flowable . just ( 1 ) ; Flowable < Integer > s2 = Flowable . just ( 2 ) ; Flowable < Integer > s3 = Flowable . just ( 3 ) ; Flowable < Integer > s4 = Flowable . just ( 4 ) ; Flowable < Integer > s5 = Flowable . just ( 5 ) ; Flowable < Integer > s6 = Flowable . just ( 6 ) ; Flowable < List < Integer > > result = Flowable . combineLatest ( s1 , s2 , s3 , s4 , s5 , s6 , new Function6 < Integer , Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 , t6 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > s1 = Flowable . just ( 1 ) ; Flowable < Integer > s2 = Flowable . just ( 2 ) ; Flowable < Integer > s3 = Flowable . just ( 3 ) ; Flowable < Integer > s4 = Flowable . just ( 4 ) ; Flowable < Integer > s5 = Flowable . just ( 5 ) ; Flowable < Integer > s6 = Flowable . just ( 6 ) ; Flowable < Integer > s7 = Flowable . just ( 7 ) ; Flowable < List < Integer > > result = Flowable . combineLatest ( s1 , s2 , s3 , s4 , s5 , s6 , s7 , new Function7 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 , t6 , t7 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > s1 = Flowable . just ( 1 ) ; Flowable < Integer > s2 = Flowable . just ( 2 ) ; Flowable < Integer > s3 = Flowable . just ( 3 ) ; Flowable < Integer > s4 = Flowable . just ( 4 ) ; Flowable < Integer > s5 = Flowable . just ( 5 ) ; Flowable < Integer > s6 = Flowable . just ( 6 ) ; Flowable < Integer > s7 = Flowable . just ( 7 ) ; Flowable < Integer > s8 = Flowable . just ( 8 ) ; Flowable < List < Integer > > result = Flowable . combineLatest ( s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , new Function8 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 , Integer t8 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 , t6 , t7 , t8 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > s1 = Flowable . just ( 1 ) ; Flowable < Integer > s2 = Flowable . just ( 2 ) ; Flowable < Integer > s3 = Flowable . just ( 3 ) ; Flowable < Integer > s4 = Flowable . just ( 4 ) ; Flowable < Integer > s5 = Flowable . just ( 5 ) ; Flowable < Integer > s6 = Flowable . just ( 6 ) ; Flowable < Integer > s7 = Flowable . just ( 7 ) ; Flowable < Integer > s8 = Flowable . just ( 8 ) ; Flowable < Integer > s9 = Flowable . just ( 9 ) ; Flowable < List < Integer > > result = Flowable . combineLatest ( s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , new Function9 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 , Integer t8 , Integer t9 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 , t6 , t7 , t8 , t9 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Object > result = Flowable . combineLatest ( Collections . < Flowable < Object > > emptyList ( ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] args ) return args ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
for ( int i = 0 ; i < 5000 ; i ++ ) backpressure ( ) ; 
BiFunction < String , Integer , String > combineLatestFunction = getConcatStringIntegerCombineLatestFunction ( ) ; int num = Flowable . bufferSize ( ) * 4 ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . combineLatest ( Flowable . just ( "one" , "two" ) , Flowable . range ( 2 , num ) , combineLatestFunction ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; List < String > events = ts . values ( ) ; assertEquals ( "two2" , events . get ( 0 ) ) ; assertEquals ( "two3" , events . get ( 1 ) ) ; assertEquals ( "two4" , events . get ( 2 ) ) ; assertEquals ( num , events . size ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicInteger count = new AtomicInteger ( ) ; final int SIZE = 2000 ; Flowable < Long > timer = Flowable . interval ( 0 , 1 , TimeUnit . MILLISECONDS ) . observeOn ( Schedulers . newThread ( ) ) . doOnEach ( new Consumer < Notification < Long > > ( ) @ Override public void accept ( Notification < Long > n ) if ( count . incrementAndGet ( ) >= SIZE ) latch . countDown ( ) ; ) . take ( SIZE ) ; TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; Flowable . combineLatest ( timer , Flowable . < Integer > never ( ) , new BiFunction < Long , Integer , Long > ( ) @ Override public Long apply ( Long t1 , Integer t2 ) return t1 ; ) . subscribe ( ts ) ; if ( ! latch . await ( SIZE + 2000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out" ) ; assertEquals ( SIZE , count . get ( ) ) ; 
List < Flowable < Integer > > sources = Arrays . asList ( Flowable . fromArray ( 1 , 2 , 3 , 4 ) , Flowable . fromArray ( 5 , 6 , 7 , 8 ) ) ; Flowable < Integer > f = Flowable . combineLatest ( sources , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] args ) return ( Integer ) args [ 0 ] ; ) ; final CountDownLatch latch = new CountDownLatch ( 4 ) ; f . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 2 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new RuntimeException ( e ) ; @ Override public void onNext ( Integer t ) latch . countDown ( ) ; request ( Long . MAX_VALUE - 1 ) ; ) ; assertTrue ( latch . await ( 10 , TimeUnit . SECONDS ) ) ; 
final AtomicBoolean errorOccurred = new AtomicBoolean ( false ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( 1 ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) errorOccurred . set ( true ) ; ) ; Flowable . combineLatest ( Collections . singletonList ( source ) , THROW_NON_FATAL ) . subscribe ( ts ) ; assertFalse ( errorOccurred . get ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . combineLatest ( Arrays . asList ( source , source ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] args ) return ( Integer ) args [ 0 ] + ( Integer ) args [ 1 ] ; ) . subscribe ( ts ) ; ts . assertValue ( 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
int n = Flowable . bufferSize ( ) * 3 ; List < Flowable < Integer > > sources = new ArrayList < > ( ) ; StringBuilder expected = new StringBuilder ( n * 2 ) ; for ( int i = 0 ; i < n ; i ++ ) sources . add ( Flowable . just ( i ) ) ; expected . append ( i ) ; TestSubscriber < String > ts = TestSubscriber . create ( ) ; Flowable . combineLatest ( sources , new Function < Object [ ] , String > ( ) @ Override public String apply ( Object [ ] args ) StringBuilder b = new StringBuilder ( ) ; for ( Object o : args ) b . append ( o ) ; return b . toString ( ) ; ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValue ( expected . toString ( ) ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . < Integer > error ( new TestException ( ) ) ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] args ) return ( ( Integer ) args [ 0 ] ) + ( ( Integer ) args [ 1 ] ) ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . < Integer > error ( new TestException ( ) ) , Flowable . just ( 1 ) ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] args ) return ( ( Integer ) args [ 0 ] ) + ( ( Integer ) args [ 1 ] ) ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . just ( 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 1 ) ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] args ) return ( ( Integer ) args [ 0 ] ) + ( ( Integer ) args [ 1 ] ) ; ) . subscribe ( ts ) ; ts . assertValues ( 11 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] args ) return ( ( Integer ) args [ 0 ] ) + ( ( Integer ) args [ 1 ] ) ; ) . subscribe ( ts ) ; ts . assertValues ( 11 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] args ) return ( ( Integer ) args [ 0 ] ) + ( ( Integer ) args [ 1 ] ) ; ) . subscribe ( ts ) ; ts . assertValues ( 11 ) ; ts . assertError ( CompositeException . class ) ; ts . assertNotComplete ( ) ; 
Flowable source = Flowable . just ( 1 ) ; for ( int i = 2 ; i < 10 ; i ++ ) Class < ? > [ ] types = new Class [ i + 1 ] ; Arrays . fill ( types , Publisher . class ) ; types [ i ] = i == 2 ? BiFunction . class : Class . forName ( "io.reactivex.rxjava3.functions.Function" + i ) ; Method m = Flowable . class . getMethod ( "combineLatest" , types ) ; Object [ ] params = new Object [ i + 1 ] ; Arrays . fill ( params , source ) ; params [ i ] = ArgsToString . INSTANCE ; StringBuilder b = new StringBuilder ( ) ; for ( int j = 0 ; j < i ; j ++ ) b . append ( '1' ) ; ( ( Flowable ) m . invoke ( null , params ) ) . test ( ) . assertResult ( b . toString ( ) ) ; for ( int j = 0 ; j < params . length ; j ++ ) Object [ ] params0 = params . clone ( ) ; params0 [ j ] = null ; try m . invoke ( null , params0 ) ; fail ( "Should have thrown @ " + m ) ; catch ( InvocationTargetException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof NullPointerException ) ; if ( j < i ) assertEquals ( "source" + ( j + 1 ) + " is null" , ex . getCause ( ) . getMessage ( ) ) ; else assertEquals ( "combiner is null" , ex . getCause ( ) . getMessage ( ) ) ; 
for ( int i = 1 ; i < 100 ; i ++ ) Flowable < Integer > [ ] sources = new Flowable [ i ] ; Arrays . fill ( sources , Flowable . just ( 1 ) ) ; List < Object > expected = new ArrayList < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) expected . add ( 1 ) ; Flowable . combineLatestArray ( sources , new Function < Object [ ] , List < Object > > ( ) @ Override public List < Object > apply ( Object [ ] t ) throws Exception return Arrays . asList ( t ) ; ) . test ( ) . assertResult ( expected ) ; Flowable . combineLatestArrayDelayError ( sources , new Function < Object [ ] , List < Object > > ( ) @ Override public List < Object > apply ( Object [ ] t ) throws Exception return Arrays . asList ( t ) ; ) . test ( ) . assertResult ( expected ) ; 
Flowable . combineLatestArray ( new Flowable [ ] Flowable . just ( 1 ) , Flowable . just ( 2 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertResult ( "[1, 2]" ) ; 
Flowable . combineLatestArrayDelayError ( new Flowable [ ] Flowable . just ( 1 ) , Flowable . just ( 2 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertResult ( "[1, 2]" ) ; 
Flowable . combineLatestArrayDelayError ( new Flowable [ ] Flowable . just ( 1 ) , Flowable . just ( 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertFailure ( TestException . class , "[1, 2]" ) ; 
Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertResult ( "[1, 2]" ) ; 
Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertFailure ( TestException . class , "[1, 2]" ) ; 
assertSame ( Flowable . empty ( ) , Flowable . combineLatestArray ( new Flowable [ 0 ] , Functions . < Object [ ] > identity ( ) , 16 ) ) ; 
assertSame ( Flowable . empty ( ) , Flowable . combineLatestArrayDelayError ( new Flowable [ 0 ] , Functions . < Object [ ] > identity ( ) , 16 ) ) ; 
Flowable . combineLatest ( Flowable . never ( ) , Flowable . error ( new TestException ( ) ) , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Flowable . combineLatest ( Flowable . never ( ) , Flowable . never ( ) , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . combineLatest ( Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception ts . cancel ( ) ; ) , Flowable . never ( ) , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . subscribe ( ts ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = Flowable . combineLatest ( pp1 , pp2 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . errors ( ) . size ( ) != 0 ) if ( ts . errors ( ) . get ( 0 ) instanceof CompositeException ) ts . assertSubscribed ( ) . assertNotComplete ( ) . assertNoValues ( ) ; for ( Throwable e : TestHelper . errorList ( ts ) ) assertTrue ( e . toString ( ) , e instanceof TestException ) ; else ts . assertFailure ( TestException . class ) ; for ( Throwable e : errors ) assertTrue ( e . toString ( ) , e . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 1000 ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable . combineLatest ( source , source , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . take ( 500 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . combineLatestArrayDelayError ( new Publisher [ ] Flowable . error ( new TestException ( ) ) , Flowable . just ( 1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return a ; , 128 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . combineLatestArrayDelayError ( new Publisher [ ] Flowable . error ( new TestException ( ) ) . startWithItem ( 1 ) , Flowable . empty ( ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return a ; , 128 ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final int [ ] count = 0 ; Flowable . combineLatest ( Flowable . empty ( ) , Flowable . error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception count [ 0 ] ++ ; ) , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return 0 ; ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , count [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final int [ ] count = 0 ; Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . empty ( ) , Flowable . error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) throws Exception count [ 0 ] ++ ; ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return 0 ; ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , count [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriber < Object > testSubscriber = TestSubscriber . create ( ) ; TestScheduler testScheduler = new TestScheduler ( ) ; Flowable < Integer > emptyFlowable = Flowable . timer ( 10 , TimeUnit . MILLISECONDS , testScheduler ) . flatMap ( new Function < Long , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Long aLong ) throws Exception return Flowable . error ( new Exception ( ) ) ; ) ; Flowable < Object > errorFlowable = Flowable . timer ( 100 , TimeUnit . MILLISECONDS , testScheduler ) . map ( new Function < Long , Object > ( ) @ Override public Object apply ( Long aLong ) throws Exception throw new Exception ( ) ; ) ; Flowable . combineLatestDelayError ( Arrays . asList ( emptyFlowable . doOnEach ( new Consumer < Notification < Integer > > ( ) @ Override public void accept ( Notification < Integer > integerNotification ) throws Exception System . out . println ( "emptyFlowable: " + integerNotification ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception System . out . println ( "emptyFlowable: doFinally" ) ; ) , errorFlowable . doOnEach ( new Consumer < Notification < Object > > ( ) @ Override public void accept ( Notification < Object > integerNotification ) throws Exception System . out . println ( "errorFlowable: " + integerNotification ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception System . out . println ( "errorFlowable: doFinally" ) ; ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] objects ) throws Exception return 0 ; ) . doOnEach ( new Consumer < Notification < Object > > ( ) @ Override public void accept ( Notification < Object > integerNotification ) throws Exception System . out . println ( "combineLatestDelayError: " + integerNotification ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception System . out . println ( "combineLatestDelayError: doFinally" ) ; ) . subscribe ( testSubscriber ) ; testScheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; testSubscriber . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; if ( pp1 . hasSubscribers ( ) ) onError ( new IllegalStateException ( "pp1 not disposed" ) ) ; else if ( pp2 . hasSubscribers ( ) ) onError ( new IllegalStateException ( "pp2 not disposed" ) ) ; else onComplete ( ) ; ; Flowable . combineLatest ( pp1 , pp2 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throws Exception return t1 + t2 ; ) . subscribe ( ts ) ; pp1 . onNext ( 1 ) ; pp2 . onNext ( 2 ) ; ts . assertResult ( 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . combineLatest ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throws Exception return null ; ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertFailureAndMessage ( NullPointerException . class , "The combiner returned a null value" ) ; 
Flowable . combineLatestDelayError ( Arrays . asList ( Flowable . just ( 21 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 21 ) . delay ( 100 , TimeUnit . MILLISECONDS ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return ( Integer ) a [ 0 ] + ( Integer ) a [ 1 ] ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class , 42 ) ; 
Publisher < Integer > source = new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) Flowable . just ( 1 ) . subscribe ( subscriber ) ; ; Flowable . combineLatest ( Arrays . asList ( source , source ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] t ) throws Throwable return 2 ; ) . test ( ) . assertResult ( 2 ) ; 
Flowable < Integer > source = new Flowable < Integer > ( ) @ Override public void subscribeActual ( Subscriber < ? super Integer > s ) Flowable . just ( 1 ) . subscribe ( s ) ; ; Flowable . combineLatest ( Arrays . asList ( source , source ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] t ) throws Throwable return 2 ; ) . test ( ) . assertResult ( 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable . combineLatest ( pp , Flowable . never ( ) , ( a , b ) -> a ) . subscribe ( ts ) ; TestHelper . race ( ( ) -> pp . onComplete ( ) , ( ) -> ts . cancel ( ) ) ; 
TestHelper . withErrorTracking ( errors -> TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestSubscriberEx < Object [ ] > ts = new TestSubscriberEx < > ( ) ; AtomicReference < Subscriber < ? super Object > > ref = new AtomicReference < > ( ) ; Flowable < Object > f = new Flowable < Object > ( ) @ Override public void subscribeActual ( Subscriber < ? super Object > s ) ref . set ( s ) ; ; Flowable . combineLatestDelayError ( Arrays . asList ( f , Flowable . never ( ) ) , ( a ) -> a ) . subscribe ( ts ) ; ref . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; TestHelper . race ( ( ) -> ref . get ( ) . onError ( ex ) , ( ) -> ts . cancel ( ) ) ; if ( ts . errors ( ) . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . combineLatest ( pp1 , pp2 , ( a , b ) -> a + b ) . doOnNext ( v -> if ( v == 2 ) pp2 . onNext ( 3 ) ; pp2 . onComplete ( ) ; pp1 . onComplete ( ) ; ) . test ( ) ; pp1 . onNext ( 1 ) ; pp2 . onNext ( 1 ) ; ts . assertResult ( 2 , 4 ) ; 
Flowable . combineLatest ( Arrays . asList ( Flowable . never ( ) , null ) , ( a ) -> a ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestHelper . assertBadRequestReported ( Flowable . combineLatest ( Flowable . never ( ) , Flowable . never ( ) , ( a , b ) -> a ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . combineLatest ( Flowable . never ( ) , Flowable . never ( ) , ( a , b ) -> a ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ; Flowable . combineLatest ( Flowable . never ( ) , Flowable . never ( ) , ( a , b ) -> a ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . combineLatest ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , ( a , b ) -> a + b ) . subscribeWith ( ts ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . combineLatest ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , ( a , b ) -> a + b ) . parallel ( ) . sequential ( ) . subscribeWith ( ts ) . assertResult ( 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . combineLatest ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , ( a , b ) -> a + b ) . compose ( TestHelper . flowableStripBoundary ( ) ) . parallel ( ) . sequential ( ) . subscribeWith ( ts ) . assertResult ( 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . combineLatest ( Flowable . just ( 1 ) , Flowable . < Integer > error ( new TestException ( ) ) , ( a , b ) -> a + b ) . subscribeWith ( ts ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . combineLatest ( pp , Flowable . just ( 1 ) , ( a , b ) -> a + b ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; ) . test ( ) ; pp . onNext ( 0 ) ; ts . assertResult ( 1 , 3 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < List < Object > > ts = Flowable . combineLatestDelayError ( Arrays . asList ( pp , Flowable . just ( 1 ) ) , a -> Arrays . asList ( a ) ) . doOnNext ( v -> if ( ( ( Integer ) v . get ( 0 ) ) == 0 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; ) . test ( ) ; pp . onNext ( 0 ) ; ts . assertResult ( Arrays . asList ( 0 , 1 ) , Arrays . asList ( 2 , 1 ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . combineLatest ( Flowable . just ( 1 ) , Flowable . just ( 1 ) , ( a , b ) -> throw new TestException ( ) ; ) . subscribeWith ( ts ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertFailure ( TestException . class ) ; 
Flowable . combineLatest ( Flowable . just ( 1 ) , Flowable . just ( 1 ) , ( a , b ) -> throw new TestException ( ) ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) . rebatchRequests ( 10 ) . test ( ) . assertFailure ( TestException . class ) ; 
new Thread ( ) @ Override public void run ( ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) o . onNext ( value ) ; . start ( ) ; 
new Thread ( ) @ Override public void run ( ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) o . onError ( new TestException ( ) ) ; . start ( ) ; 
FlowableProcessor < String > obs = PublishProcessor . create ( ) ; Iterator < String > it = obs . blockingNext ( ) . iterator ( ) ; fireOnNextInNewThread ( obs , "one" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; fireOnNextInNewThread ( obs , "two" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "two" , it . next ( ) ) ; fireOnNextInNewThread ( obs , "three" ) ; try assertEquals ( "three" , it . next ( ) ) ; catch ( NoSuchElementException e ) fail ( "Calling next() without hasNext() should wait for next fire" ) ; obs . onComplete ( ) ; assertFalse ( it . hasNext ( ) ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) assertFalse ( it . hasNext ( ) ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) 
FlowableProcessor < String > obs = PublishProcessor . create ( ) ; Iterator < String > it = obs . blockingNext ( ) . iterator ( ) ; fireOnNextInNewThread ( obs , "one" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; fireOnErrorInNewThread ( obs ) ; try it . hasNext ( ) ; fail ( "Expected an TestException" ) ; catch ( TestException e ) assertErrorAfterObservableFail ( it ) ; 
Flowable < String > obs = Flowable . < String > empty ( ) . observeOn ( Schedulers . newThread ( ) ) ; Iterator < String > it = obs . blockingNext ( ) . iterator ( ) ; assertFalse ( it . hasNext ( ) ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) assertFalse ( it . hasNext ( ) ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) 
FlowableProcessor < String > obs = PublishProcessor . create ( ) ; Iterator < String > it = obs . blockingNext ( ) . iterator ( ) ; obs . onError ( new TestException ( ) ) ; try it . hasNext ( ) ; fail ( "Expected an TestException" ) ; catch ( TestException e ) assertErrorAfterObservableFail ( it ) ; 
FlowableProcessor < String > obs = PublishProcessor . create ( ) ; Iterator < String > it = obs . blockingNext ( ) . iterator ( ) ; fireOnErrorInNewThread ( obs ) ; try it . hasNext ( ) ; fail ( "Expected an TestException" ) ; catch ( TestException e ) assertErrorAfterObservableFail ( it ) ; 
try it . hasNext ( ) ; fail ( "hasNext should throw a TestException" ) ; catch ( TestException e ) try it . next ( ) ; fail ( "next should throw a TestException" ) ; catch ( TestException e ) 
FlowableProcessor < String > obs = PublishProcessor . create ( ) ; Iterator < String > it = obs . blockingNext ( ) . iterator ( ) ; fireOnNextInNewThread ( obs , "one" ) ; assertEquals ( "one" , it . next ( ) ) ; fireOnNextInNewThread ( obs , "two" ) ; assertEquals ( "two" , it . next ( ) ) ; obs . onComplete ( ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) 
FlowableProcessor < String > obs = PublishProcessor . create ( ) ; Iterator < String > it = obs . blockingNext ( ) . iterator ( ) ; fireOnNextInNewThread ( obs , "one" ) ; assertTrue ( it . hasNext ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; obs . onComplete ( ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) 
int repeat = 0 ; for ( ; ; ) final SerialDisposable task = new SerialDisposable ( ) ; try final CountDownLatch finished = new CountDownLatch ( 1 ) ; final int COUNT = 30 ; final CountDownLatch timeHasPassed = new CountDownLatch ( COUNT ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; final AtomicInteger count = new AtomicInteger ( 0 ) ; final Flowable < Integer > obs = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; task . replace ( Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) try while ( running . get ( ) && ! task . isDisposed ( ) ) subscriber . onNext ( count . incrementAndGet ( ) ) ; timeHasPassed . countDown ( ) ; subscriber . onComplete ( ) ; catch ( Throwable e ) subscriber . onError ( e ) ; finally finished . countDown ( ) ; ) ) ; ) ; Iterator < Integer > it = obs . blockingNext ( ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; int a = it . next ( ) ; assertTrue ( it . hasNext ( ) ) ; int b = it . next ( ) ; assertTrue ( "a and b should be different" , a != b ) ; timeHasPassed . await ( 8000 , TimeUnit . MILLISECONDS ) ; assertTrue ( it . hasNext ( ) ) ; int c = it . next ( ) ; assertTrue ( "c should not just be the next in sequence" , c != ( b + 1 ) ) ; assertTrue ( "expected that c [" + c + "] is higher than or equal to " + COUNT , c >= COUNT ) ; assertTrue ( it . hasNext ( ) ) ; int d = it . next ( ) ; assertTrue ( d > c ) ; running . set ( false ) ; finished . await ( ) ; assertFalse ( it . hasNext ( ) ) ; System . out . println ( "a: " + a + " b: " + b + " c: " + c ) ; break ; catch ( AssertionError ex ) if ( ++ repeat == 3 ) throw ex ; Thread . sleep ( ( int ) ( 1000 * Math . pow ( 2 , repeat - 1 ) ) ) ; finally task . dispose ( ) ; 
Flowable < Long > f = Flowable . interval ( 250 , TimeUnit . MILLISECONDS ) ; PublishProcessor < Integer > terminal = PublishProcessor . create ( ) ; Flowable < Long > source = f . takeUntil ( terminal ) ; Iterable < Long > iter = source . blockingNext ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) BlockingFlowableNext . NextIterator < Long > it = ( BlockingFlowableNext . NextIterator < Long > ) iter . iterator ( ) ; for ( long i = 0 ; i < 10 ; i ++ ) Assert . assertTrue ( it . hasNext ( ) ) ; Assert . assertEquals ( j + "th iteration next" , Long . valueOf ( i ) , it . next ( ) ) ; terminal . onNext ( 1 ) ; 
assertEquals ( 1 , BehaviorProcessor . createDefault ( 1 ) . take ( 1 ) . blockingSingle ( ) . intValue ( ) ) ; assertEquals ( 2 , BehaviorProcessor . createDefault ( 2 ) . blockingIterable ( ) . iterator ( ) . next ( ) . intValue ( ) ) ; assertEquals ( 3 , BehaviorProcessor . createDefault ( 3 ) . blockingNext ( ) . iterator ( ) . next ( ) . intValue ( ) ) ; 
Flowable . never ( ) . blockingNext ( ) . iterator ( ) . remove ( ) ; 
Iterator < Object > it = Flowable . never ( ) . blockingNext ( ) . iterator ( ) ; try Thread . currentThread ( ) . interrupt ( ) ; it . next ( ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
NextSubscriber < Integer > no = new NextSubscriber < > ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try no . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
NextSubscriber < Integer > no = new NextSubscriber < > ( ) ; no . setWaiting ( ) ; no . onNext ( Notification . createOnNext ( 1 ) ) ; no . setWaiting ( ) ; no . onNext ( Notification . createOnNext ( 1 ) ) ; assertEquals ( 1 , no . takeNext ( ) . getValue ( ) . intValue ( ) ) ; 
NextSubscriber < Integer > no = new NextSubscriber < > ( ) ; no . setWaiting ( ) ; no . onNext ( Notification . < Integer > createOnComplete ( ) ) ; no . setWaiting ( ) ; no . onNext ( Notification . createOnNext ( 1 ) ) ; assertTrue ( no . takeNext ( ) . isOnComplete ( ) ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; 
TestSingleThreadedObservable onSubscribe = new TestSingleThreadedObservable ( "one" , "two" , "three" ) ; Flowable < String > w = Flowable . unsafeCreate ( onSubscribe ) ; w . serialize ( ) . subscribe ( subscriber ) ; onSubscribe . waitToFinish ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" ) ; Flowable < String > w = Flowable . unsafeCreate ( onSubscribe ) ; BusyObserver busyobserver = new BusyObserver ( ) ; w . serialize ( ) . subscribe ( busyobserver ) ; onSubscribe . waitToFinish ( ) ; assertEquals ( 3 , busyobserver . onNextCount . get ( ) ) ; assertFalse ( busyobserver . onError ) ; assertTrue ( busyobserver . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busyobserver . maxConcurrentThreads . get ( ) ) ; 
int max = 9 ; for ( int i = 0 ; i <= max ; i ++ ) try multiThreadedWithNPE ( ) ; return ; catch ( AssertionError ex ) if ( i == max ) throw ex ; Thread . sleep ( ( long ) ( 1000 * Math . random ( ) + 100 ) ) ; 
TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" , null ) ; Flowable < String > w = Flowable . unsafeCreate ( onSubscribe ) ; BusyObserver busyobserver = new BusyObserver ( ) ; w . serialize ( ) . subscribe ( busyobserver ) ; onSubscribe . waitToFinish ( ) ; System . out . println ( "maxConcurrentThreads: " + onSubscribe . maxConcurrentThreads . get ( ) ) ; assertTrue ( busyobserver . onNextCount . get ( ) < 4 ) ; assertTrue ( busyobserver . onError ) ; assertFalse ( busyobserver . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busyobserver . maxConcurrentThreads . get ( ) ) ; 
int max = 9 ; for ( int i = 0 ; i <= max ; i ++ ) try multiThreadedWithNPEinMiddle ( ) ; return ; catch ( AssertionError ex ) if ( i == max ) throw ex ; Thread . sleep ( ( long ) ( 1000 * Math . random ( ) + 100 ) ) ; 
boolean lessThan9 = false ; for ( int i = 0 ; i < 3 ; i ++ ) TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" , null , "four" , "five" , "six" , "seven" , "eight" , "nine" ) ; Flowable < String > w = Flowable . unsafeCreate ( onSubscribe ) ; BusyObserver busyobserver = new BusyObserver ( ) ; w . serialize ( ) . subscribe ( busyobserver ) ; onSubscribe . waitToFinish ( ) ; System . out . println ( "maxConcurrentThreads: " + onSubscribe . maxConcurrentThreads . get ( ) ) ; System . out . println ( "onNext count: " + busyobserver . onNextCount . get ( ) ) ; if ( busyobserver . onNextCount . get ( ) < 9 ) lessThan9 = true ; assertTrue ( busyobserver . onError ) ; assertFalse ( busyobserver . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busyobserver . maxConcurrentThreads . get ( ) ) ; assertTrue ( lessThan9 ) ; 
for ( int i = 0 ; i < numStringsToSend ; i ++ ) subscriber . onNext ( "aString" ) ; 
if ( waitOnThese != null ) for ( Future < ? > f : waitOnThese ) try f . get ( ) ; catch ( Throwable e ) System . err . println ( "Error while waiting on future in CompletionThread" ) ; if ( event == TestConcurrencyobserverEvent . onError ) subscriber . onError ( new RuntimeException ( "mocked exception" ) ) ; else if ( event == TestConcurrencyobserverEvent . onComplete ) subscriber . onComplete ( ) ; else throw new IllegalArgumentException ( "Expecting either onError or onComplete" ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; System . out . println ( "TestSingleThreadedObservable subscribed to ..." ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestSingleThreadedObservable thread" ) ; for ( String s : values ) System . out . println ( "TestSingleThreadedObservable onNext: " + s ) ; subscriber . onNext ( s ) ; subscriber . onComplete ( ) ; catch ( Throwable e ) throw new RuntimeException ( e ) ; ) ; System . out . println ( "starting TestSingleThreadedObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestSingleThreadedObservable thread" ) ; 
try t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; System . out . println ( "TestMultiThreadedObservable subscribed to ..." ) ; final NullPointerException npe = new NullPointerException ( ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestMultiThreadedObservable thread" ) ; for ( final String s : values ) threadPool . execute ( new Runnable ( ) @ Override public void run ( ) threadsRunning . incrementAndGet ( ) ; try if ( s == null ) System . out . println ( "TestMultiThreadedObservable onNext: null" ) ; throw npe ; else try Thread . sleep ( 10 ) ; catch ( InterruptedException ex ) System . out . println ( "TestMultiThreadedObservable onNext: " + s ) ; subscriber . onNext ( s ) ; int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; catch ( Throwable e ) subscriber . onError ( e ) ; finally threadsRunning . decrementAndGet ( ) ; ) ; threadPool . shutdown ( ) ; catch ( Throwable e ) throw new RuntimeException ( e ) ; try threadPool . awaitTermination ( 2 , TimeUnit . SECONDS ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; subscriber . onComplete ( ) ; ) ; System . out . println ( "starting TestMultiThreadedObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestMultiThreadedObservable thread" ) ; 
try t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; 
threadsRunning . incrementAndGet ( ) ; System . out . println ( ">>> Busyobserver received onComplete" ) ; onComplete = true ; int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; threadsRunning . decrementAndGet ( ) ; 
threadsRunning . incrementAndGet ( ) ; System . out . println ( ">>> Busyobserver received onError: " + e . getMessage ( ) ) ; onError = true ; int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; threadsRunning . decrementAndGet ( ) ; 
threadsRunning . incrementAndGet ( ) ; try onNextCount . incrementAndGet ( ) ; System . out . println ( ">>> Busyobserver received onNext: " + args ) ; try Thread . sleep ( 200 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; finally int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; threadsRunning . decrementAndGet ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; SimpleScalarSubscription < Integer > ws = new SimpleScalarSubscription < > ( 1 , ts ) ; ts . onSubscribe ( ws ) ; ws . request ( 0 ) ; ts . assertEmpty ( ) ; ws . request ( 1 ) ; ts . assertResult ( 1 ) ; ws . request ( 1 ) ; ts . assertResult ( 1 ) ; 
Flowable . range ( 1 , 10000 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) throws Exception String name = Thread . currentThread ( ) . getName ( ) ; if ( name . contains ( "RxSingleScheduler" ) ) return "RxSingleScheduler" ; return name ; ) . concatMap ( new Function < String , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( String v ) throws Exception return Flowable . just ( v ) ; ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( "RxSingleScheduler" ) ; 
Flowable < Integer > just = Flowable . just ( 1 ) ; int n = 1000 ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Flowable < Integer > > source = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = source . concatMap ( v -> v , n + 1 ) . test ( 1L ) ; TestHelper . race ( ( ) -> for ( int j = 0 ; j < n ; j ++ ) source . onNext ( just ) ; , ( ) -> for ( int j = 0 ; j < n ; j ++ ) ts . request ( 1 ) ; ) ; ts . assertValueCount ( n ) ; 
Flowable < Integer > just = Flowable . just ( 1 ) ; int n = 1000 ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Flowable < Integer > > source = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = source . concatMapDelayError ( v -> v , true , n + 1 ) . test ( 1L ) ; TestHelper . race ( ( ) -> for ( int j = 0 ; j < n ; j ++ ) source . onNext ( just ) ; , ( ) -> for ( int j = 0 ; j < n ; j ++ ) ts . request ( 1 ) ; ) ; ts . assertValueCount ( n ) ; 
Flowable . range ( 1 , 10000 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) throws Exception String name = Thread . currentThread ( ) . getName ( ) ; if ( name . contains ( "RxSingleScheduler" ) ) return "RxSingleScheduler" ; return name ; ) . concatMapDelayError ( new Function < String , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( String v ) throws Exception return Flowable . just ( v ) ; ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( "RxSingleScheduler" ) ; 
Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > flowableStripBoundary ( ) ) . concatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > flowableStripBoundary ( ) ) . concatMapDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . range ( 1 , 5 ) . concatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
Flowable . just ( 1 , 2 , 3 , 101 , 102 , 23 , 890 , 120 , 32 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( final Integer integer ) throws Exception return Flowable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception if ( integer >= 100 ) throw new NullPointerException ( "test null exp" ) ; return integer ; ) ; ) . test ( ) . assertFailure ( CompositeException . class , 1 , 2 , 3 , 23 , 32 ) ; 
Flowable . just ( 1 , 2 , 3 , 101 , 102 , 23 , 890 , 120 , 32 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( final Integer integer ) throws Exception return Flowable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception if ( integer >= 100 ) throw new NullPointerException ( "test null exp" ) ; return integer ; ) ; , false , 2 ) . test ( ) . assertFailure ( NullPointerException . class , 1 , 2 , 3 ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; , false , 2 ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; , true , 2 ) ; ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; up . onComplete ( ) ; up . concatMap ( v -> Flowable . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . fromCallable ( ( ) -> 1 ) . concatMap ( v -> Flowable . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable < String > obs = Flowable . just ( "one" , "two" , "six" ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onSuccess ( true ) ; verifyNoMoreInteractions ( observer ) ; 
Flowable < String > obs = Flowable . just ( "one" , "two" , "three" , "six" ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onSuccess ( false ) ; verifyNoMoreInteractions ( observer ) ; 
Flowable < String > obs = Flowable . empty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onSuccess ( true ) ; verifyNoMoreInteractions ( observer ) ; 
Throwable error = new Throwable ( ) ; Flowable < String > obs = Flowable . error ( error ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onError ( error ) ; verifyNoMoreInteractions ( observer ) ; 
Flowable < Integer > f = Flowable . fromArray ( 1 , 3 , 5 , 6 ) ; Single < Boolean > allOdd = f . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i % 2 == 1 ; ) ; assertFalse ( allOdd . blockingGet ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return false ; ) . flatMapPublisher ( new Function < Boolean , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Boolean t1 ) return Flowable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ; ) ; assertEquals ( ( Object ) 2 , source . blockingFirst ( ) ) ; 
TestObserverEx < Boolean > to = new TestObserverEx < > ( ) ; Flowable . empty ( ) . all ( new Predicate < Object > ( ) @ Override public boolean test ( Object t ) return false ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; to . assertValue ( true ) ; 
TestObserverEx < Boolean > to = new TestObserverEx < > ( ) ; final IllegalArgumentException ex = new IllegalArgumentException ( ) ; Flowable . just ( "Boo!" ) . all ( new Predicate < String > ( ) @ Override public boolean test ( String v ) throw ex ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( ex ) ; 
Flowable < String > obs = Flowable . just ( "one" , "two" , "six" ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . toFlowable ( ) . subscribe ( subscriber ) ; verify ( subscriber ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( subscriber ) . onNext ( true ) ; verify ( subscriber ) . onComplete ( ) ; verifyNoMoreInteractions ( subscriber ) ; 
Flowable < String > obs = Flowable . just ( "one" , "two" , "three" , "six" ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . toFlowable ( ) . subscribe ( subscriber ) ; verify ( subscriber ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( subscriber ) . onNext ( false ) ; verify ( subscriber ) . onComplete ( ) ; verifyNoMoreInteractions ( subscriber ) ; 
Flowable < String > obs = Flowable . empty ( ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . toFlowable ( ) . subscribe ( subscriber ) ; verify ( subscriber ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( subscriber ) . onNext ( true ) ; verify ( subscriber ) . onComplete ( ) ; verifyNoMoreInteractions ( subscriber ) ; 
Throwable error = new Throwable ( ) ; Flowable < String > obs = Flowable . error ( error ) ; Subscriber < Boolean > subscriber = TestHelper . mockSubscriber ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . toFlowable ( ) . subscribe ( subscriber ) ; verify ( subscriber ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( subscriber ) . onError ( error ) ; verifyNoMoreInteractions ( subscriber ) ; 
Flowable < Integer > f = Flowable . fromArray ( 1 , 3 , 5 , 6 ) ; Flowable < Boolean > allOdd = f . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i % 2 == 1 ; ) . toFlowable ( ) ; assertFalse ( allOdd . blockingFirst ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return false ; ) . toFlowable ( ) . flatMap ( new Function < Boolean , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Boolean t1 ) return Flowable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ; ) ; assertEquals ( ( Object ) 2 , source . blockingFirst ( ) ) ; 
TestSubscriber < Boolean > ts = new TestSubscriber < > ( 0L ) ; Flowable . empty ( ) . all ( new Predicate < Object > ( ) @ Override public boolean test ( Object t1 ) return false ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
TestSubscriberEx < Boolean > ts = new TestSubscriberEx < > ( 1L ) ; Flowable . empty ( ) . all ( new Predicate < Object > ( ) @ Override public boolean test ( Object t ) return false ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; ts . assertValue ( true ) ; 
TestSubscriberEx < Boolean > ts = new TestSubscriberEx < > ( ) ; final IllegalArgumentException ex = new IllegalArgumentException ( ) ; Flowable . just ( "Boo!" ) . all ( new Predicate < String > ( ) @ Override public boolean test ( String v ) throw ex ; ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( ex ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . all ( Functions . alwaysTrue ( ) ) . toFlowable ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . all ( Functions . alwaysTrue ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . all ( Functions . alwaysTrue ( ) ) ; , false , 1 , 1 , true ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . all ( Functions . alwaysTrue ( ) ) . toFlowable ( ) ; , false , 1 , 1 , true ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Boolean > > ( ) @ Override public Publisher < Boolean > apply ( Flowable < Object > f ) throws Exception return f . all ( Functions . alwaysTrue ( ) ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Object > , Single < Boolean > > ( ) @ Override public Single < Boolean > apply ( Flowable < Object > f ) throws Exception return f . all ( Functions . alwaysTrue ( ) ) ; ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; final String [ ] o = "1" , "3" , "5" , "7" ; final String [ ] e = "2" , "4" , "6" ; final Flowable < String > odds = Flowable . fromArray ( o ) ; final Flowable < String > even = Flowable . fromArray ( e ) ; Flowable < String > concat = Flowable . concat ( odds , even ) ; concat . subscribe ( subscriber ) ; verify ( subscriber , times ( 7 ) ) . onNext ( anyString ( ) ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; final String [ ] o = "1" , "3" , "5" , "7" ; final String [ ] e = "2" , "4" , "6" ; final Flowable < String > odds = Flowable . fromArray ( o ) ; final Flowable < String > even = Flowable . fromArray ( e ) ; final List < Flowable < String > > list = new ArrayList < > ( ) ; list . add ( odds ) ; list . add ( even ) ; Flowable < String > concat = Flowable . concat ( Flowable . fromIterable ( list ) ) ; concat . subscribe ( subscriber ) ; verify ( subscriber , times ( 7 ) ) . onNext ( anyString ( ) ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; final String [ ] o = "1" , "3" , "5" , "7" ; final String [ ] e = "2" , "4" , "6" ; final Flowable < String > odds = Flowable . fromArray ( o ) ; final Flowable < String > even = Flowable . fromArray ( e ) ; Flowable < Flowable < String > > flowableOfFlowables = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( odds ) ; subscriber . onNext ( even ) ; subscriber . onComplete ( ) ; ) ; Flowable < String > concat = Flowable . concat ( flowableOfFlowables ) ; concat . subscribe ( subscriber ) ; verify ( subscriber , times ( 7 ) ) . onNext ( anyString ( ) ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( odds ) ; subscriber . onNext ( even ) ; subscriber . onComplete ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestObservable < String > o1 = new TestObservable < > ( "one" , "two" , "three" ) ; TestObservable < String > o2 = new TestObservable < > ( "four" , "five" , "six" ) ; Flowable . concat ( Flowable . unsafeCreate ( o1 ) , Flowable . unsafeCreate ( o2 ) ) . subscribe ( subscriber ) ; try o1 . t . join ( ) ; o2 . t . join ( ) ; catch ( Throwable e ) throw new RuntimeException ( "failed waiting on threads" ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "five" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "six" ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) if ( i % 10 == 0 ) System . out . println ( "testNestedAsyncConcat >> " + i ) ; nestedAsyncConcat ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; final TestObservable < String > o1 = new TestObservable < > ( "one" , "two" , "three" ) ; final TestObservable < String > o2 = new TestObservable < > ( "four" , "five" , "six" ) ; final TestObservable < String > o3 = new TestObservable < > ( "seven" , "eight" , "nine" ) ; final CountDownLatch allowThird = new CountDownLatch ( 1 ) ; final AtomicReference < Thread > parent = new AtomicReference < > ( ) ; final CountDownLatch parentHasStarted = new CountDownLatch ( 1 ) ; final CountDownLatch parentHasFinished = new CountDownLatch ( 1 ) ; Flowable < Flowable < String > > observableOfObservables = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( final Subscriber < ? super Flowable < String > > subscriber ) final Disposable d = Disposable . empty ( ) ; subscriber . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) @ Override public void cancel ( ) d . dispose ( ) ; ) ; parent . set ( new Thread ( new Runnable ( ) @ Override public void run ( ) try if ( ! d . isDisposed ( ) ) System . out . println ( "Emit o1" ) ; subscriber . onNext ( Flowable . unsafeCreate ( o1 ) ) ; if ( ! d . isDisposed ( ) ) System . out . println ( "Emit o2" ) ; subscriber . onNext ( Flowable . unsafeCreate ( o2 ) ) ; try allowThird . await ( ) ; catch ( InterruptedException e ) subscriber . onError ( e ) ; if ( ! d . isDisposed ( ) ) System . out . println ( "Emit o3" ) ; subscriber . onNext ( Flowable . unsafeCreate ( o3 ) ) ; catch ( Throwable e ) subscriber . onError ( e ) ; finally System . out . println ( "Done parent Flowable" ) ; subscriber . onComplete ( ) ; parentHasFinished . countDown ( ) ; ) ) ; parent . get ( ) . start ( ) ; parentHasStarted . countDown ( ) ; ) ; Flowable . concat ( observableOfObservables ) . subscribe ( subscriber ) ; parentHasStarted . await ( ) ; try System . out . println ( "Thread1 is starting ... waiting for it to complete ..." ) ; o1 . waitForThreadDone ( ) ; System . out . println ( "Thread2 is starting ... waiting for it to complete ..." ) ; o2 . waitForThreadDone ( ) ; catch ( Throwable e ) throw new RuntimeException ( "failed waiting on threads" , e ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "five" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "six" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "seven" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "eight" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "nine" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; allowThird . countDown ( ) ; try o3 . waitForThreadDone ( ) ; catch ( Throwable e ) throw new RuntimeException ( "failed waiting on threads" , e ) ; try if ( ! parentHasFinished . await ( 5 , TimeUnit . SECONDS ) ) fail ( "Parent didn't finish within the time limit" ) ; catch ( Throwable e ) throw new RuntimeException ( "failed waiting on threads" , e ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "seven" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "eight" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "nine" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; final String [ ] o = "1" , "3" , "5" , "7" ; final String [ ] e = "2" , "4" , "6" ; final Flowable < String > odds = Flowable . fromArray ( o ) ; final Flowable < String > even = Flowable . fromArray ( e ) ; final CountDownLatch callOnce = new CountDownLatch ( 1 ) ; final CountDownLatch okToContinue = new CountDownLatch ( 1 ) ; TestObservable < Flowable < String > > observableOfObservables = new TestObservable < > ( callOnce , okToContinue , odds , even ) ; Flowable < String > concatF = Flowable . concat ( Flowable . unsafeCreate ( observableOfObservables ) ) ; concatF . subscribe ( subscriber ) ; try callOnce . await ( ) ; catch ( Throwable ex ) ex . printStackTrace ( ) ; fail ( ex . getMessage ( ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "1" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "3" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "5" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "7" ) ; try okToContinue . countDown ( ) ; observableOfObservables . t . join ( ) ; catch ( Throwable ex ) ex . printStackTrace ( ) ; fail ( ex . getMessage ( ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "2" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "4" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "6" ) ; 
final TestObservable < String > w1 = new TestObservable < > ( "one" , "two" , "three" ) ; final TestObservable < String > w2 = new TestObservable < > ( "hello" , Integer . MAX_VALUE ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestObservable < Flowable < String > > observableOfObservables = new TestObservable < > ( Flowable . unsafeCreate ( w1 ) , Flowable . unsafeCreate ( w2 ) ) ; Flowable < String > concatF = Flowable . concat ( Flowable . unsafeCreate ( observableOfObservables ) ) ; concatF . take ( 50 ) . subscribe ( subscriber ) ; try w1 . waitForThreadDone ( ) ; w2 . waitForThreadDone ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 47 ) ) . onNext ( "hello" ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final CountDownLatch okToContinueW1 = new CountDownLatch ( 1 ) ; final CountDownLatch okToContinueW2 = new CountDownLatch ( 1 ) ; final TestObservable < String > w1 = new TestObservable < > ( null , okToContinueW1 , "one" , "two" , "three" ) ; final TestObservable < String > w2 = new TestObservable < > ( null , okToContinueW2 , "four" , "five" , "six" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < Flowable < String > > observableOfObservables = Flowable . unsafeCreate ( new Publisher < Flowable < String > > ( ) @ Override public void subscribe ( Subscriber < ? super Flowable < String > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( Flowable . unsafeCreate ( w1 ) ) ; subscriber . onNext ( Flowable . unsafeCreate ( w2 ) ) ; subscriber . onComplete ( ) ; ) ; Flowable < String > concat = Flowable . concat ( observableOfObservables ) ; concat . subscribe ( subscriber ) ; verify ( subscriber , times ( 0 ) ) . onComplete ( ) ; try okToContinueW1 . countDown ( ) ; okToContinueW2 . countDown ( ) ; w1 . t . join ( ) ; w2 . t . join ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "five" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "six" ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
final CountDownLatch callOnce = new CountDownLatch ( 1 ) ; final CountDownLatch okToContinue = new CountDownLatch ( 1 ) ; final TestObservable < String > w1 = new TestObservable < > ( "one" , "two" , "three" ) ; final TestObservable < String > w2 = new TestObservable < > ( callOnce , okToContinue , "four" , "five" , "six" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber , 0L ) ; final Flowable < String > concat = Flowable . concat ( Flowable . unsafeCreate ( w1 ) , Flowable . unsafeCreate ( w2 ) ) ; try concat . subscribe ( ts ) ; callOnce . await ( ) ; ts . cancel ( ) ; okToContinue . countDown ( ) ; w1 . t . join ( ) ; w2 . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "five" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "six" ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; 
final CountDownLatch callOnce = new CountDownLatch ( 1 ) ; final CountDownLatch okToContinue = new CountDownLatch ( 1 ) ; final TestObservable < String > w1 = new TestObservable < > ( "one" , "two" , "three" ) ; final TestObservable < String > w2 = new TestObservable < > ( callOnce , okToContinue , "four" , "five" , "six" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber , 0L ) ; TestObservable < Flowable < String > > observableOfObservables = new TestObservable < > ( Flowable . unsafeCreate ( w1 ) , Flowable . unsafeCreate ( w2 ) ) ; Flowable < String > concatF = Flowable . concat ( Flowable . unsafeCreate ( observableOfObservables ) ) ; concatF . subscribe ( ts ) ; try callOnce . await ( ) ; ts . cancel ( ) ; okToContinue . countDown ( ) ; w1 . t . join ( ) ; w2 . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "five" ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( "six" ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
threadHasStarted . await ( ) ; t . join ( ) ; 
Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; Subscriber < Object > subscriber2 = TestHelper . mockSubscriber ( ) ; TestScheduler s = new TestScheduler ( ) ; Flowable < Long > timer = Flowable . interval ( 500 , TimeUnit . MILLISECONDS , s ) . take ( 2 ) ; Flowable < Long > f = Flowable . concat ( timer , timer ) ; f . subscribe ( subscriber1 ) ; f . subscribe ( subscriber2 ) ; InOrder inOrder1 = inOrder ( subscriber1 ) ; InOrder inOrder2 = inOrder ( subscriber2 ) ; s . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 0L ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 0L ) ; s . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1L ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 1L ) ; s . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 0L ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 0L ) ; s . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1L ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 1L ) ; inOrder1 . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final int n = 10000 ; Flowable < Flowable < Integer > > source = Flowable . range ( 0 , n ) . map ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; Single < List < Integer > > result = Flowable . concat ( source ) . toList ( ) ; SingleObserver < List < Integer > > o = TestHelper . mockSingleObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; List < Integer > list = new ArrayList < > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) list . add ( i ) ; inOrder . verify ( o ) . onSuccess ( list ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final int n = 10000 ; Flowable < Flowable < Integer > > source = Flowable . range ( 0 , n ) . map ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; Single < List < Integer > > result = Flowable . concat ( source ) . take ( n / 2 ) . toList ( ) ; SingleObserver < List < Integer > > o = TestHelper . mockSingleObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; List < Integer > list = new ArrayList < > ( n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) list . add ( i ) ; inOrder . verify ( o ) . onSuccess ( list ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
assertEquals ( 1 , ( int ) Flowable . < Integer > empty ( ) . concatWith ( Flowable . just ( 1 ) ) . take ( 1 ) . blockingSingle ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , Flowable . bufferSize ( ) * 2 ) . concatWith ( Flowable . range ( 0 , Flowable . bufferSize ( ) * 2 ) ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , ( Flowable . bufferSize ( ) * 2 ) + 10 ) . concatWith ( Flowable . range ( 0 , ( Flowable . bufferSize ( ) * 2 ) + 10 ) ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( ( Flowable . bufferSize ( ) * 4 ) + 20 , ts . values ( ) . size ( ) ) ; 
Flowable < String > f = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( "hello" ) ; s . onComplete ( ) ; s . onComplete ( ) ; ) ; TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; Flowable . concat ( f , f ) . subscribe ( ts ) ; ts . awaitDone ( 500 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; ts . assertValues ( "hello" , "hello" ) ; 
final ExecutorService executor = Executors . newFixedThreadPool ( 2 ) ; final Scheduler sch = Schedulers . from ( executor ) ; Function < Integer , Flowable < Integer > > func = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) Flowable < Integer > flowable = Flowable . just ( t ) . subscribeOn ( sch ) ; FlowableProcessor < Integer > processor = UnicastProcessor . create ( ) ; flowable . subscribe ( processor ) ; return processor ; ; int n = 5000 ; final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . range ( 1 , n ) . concatMap ( func ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) if ( counter . getAndIncrement ( ) % 100 == 0 ) System . out . print ( "testIssue2890NoStackoverflow -> " ) ; System . out . println ( counter . get ( ) ) ; ; @ Override public void onComplete ( ) executor . shutdown ( ) ; @ Override public void onError ( Throwable e ) executor . shutdown ( ) ; ) ; long awaitTerminationTimeoutMillis = 100_000 ; if ( ! executor . awaitTermination ( awaitTerminationTimeoutMillis , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( "Completed " + counter . get ( ) + "/" + n + " before timed out after " + awaitTerminationTimeoutMillis + " milliseconds." ) ; assertEquals ( n , counter . get ( ) ) ; 
Flowable < Integer > f1 = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Integer > f2 = Flowable . just ( 4 , 5 , 6 ) ; final AtomicBoolean completed = new AtomicBoolean ( false ) ; f1 . concatWith ( f2 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) completed . set ( true ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) request ( 2 ) ; ) ; assertTrue ( completed . get ( ) ) ; 
final long durationSeconds = 2 ; final long startTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; ; i ++ ) if ( System . currentTimeMillis ( ) - startTime > TimeUnit . SECONDS . toMillis ( durationSeconds ) ) return ; if ( i % 1000 == 0 ) System . out . println ( "concatMapRangeAsyncLoop > " + i ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 0 , 1000 ) . concatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return Flowable . fromIterable ( Arrays . asList ( t ) ) ; ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 2500 , TimeUnit . MILLISECONDS ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; assertEquals ( 1000 , ts . values ( ) . size ( ) ) ; assertEquals ( ( Integer ) 999 , ts . values ( ) . get ( 999 ) ) ; 
Publisher < Integer > [ ] sources = new Publisher [ ] Flowable . just ( 1 ) , null , Flowable . range ( 2 , 3 ) , Flowable . error ( new TestException ( ) ) , Flowable . empty ( ) ; TestSubscriberEx < Integer > ts = Flowable . concatArrayDelayError ( sources ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ts . assertFailure ( CompositeException . class , 1 , 2 , 3 , 4 ) ; CompositeException composite = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; List < Throwable > list = composite . getExceptions ( ) ; assertTrue ( list . get ( 0 ) . toString ( ) , list . get ( 0 ) instanceof NullPointerException ) ; assertTrue ( list . get ( 1 ) . toString ( ) , list . get ( 1 ) instanceof TestException ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; Flowable . just ( 1 ) . concatWith ( Flowable . range ( 2 , 3 ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 5 ) ; ts . assertValues ( 1 , 2 , 3 , 4 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > empty ( ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 5 ) ; ts . assertValue ( 1 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; Flowable . range ( 1 , 2 ) . concatWith ( Flowable . < Integer > empty ( ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 5 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; Flowable . < Integer > empty ( ) . concatWith ( Flowable . just ( 1 ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 5 ) ; ts . assertValue ( 1 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
for ( int i = 2 ; i < 10 ; i ++ ) Flowable < Integer > [ ] obs = new Flowable [ i ] ; Arrays . fill ( obs , Flowable . just ( 1 ) ) ; Integer [ ] expected = new Integer [ i ] ; Arrays . fill ( expected , 1 ) ; Method m = Flowable . class . getMethod ( "concatArray" , Publisher [ ] . class ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ( ( Flowable < Integer > ) m . invoke ( null , new Object [ ] obs ) ) . subscribe ( ts ) ; ts . assertValues ( expected ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . just ( 1 ) ) . concatMap ( ( Function ) Functions . identity ( ) ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . range ( 1 , 5 ) ) . concatMap ( ( Function ) Functions . identity ( ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . just ( 1 ) ) . concatMapDelayError ( ( Function ) Functions . identity ( ) ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( Flowable . range ( 1 , 5 ) ) . concatMapDelayError ( ( Function ) Functions . identity ( ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
for ( int i = 2 ; i < 10 ; i ++ ) Object [ ] obs = new Object [ i ] ; Arrays . fill ( obs , 1 ) ; Integer [ ] expected = new Integer [ i ] ; Arrays . fill ( expected , 1 ) ; Method m = Flowable . class . getMethod ( "startWithArray" , Object [ ] . class ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; ( ( Flowable < Integer > ) m . invoke ( Flowable . empty ( ) , new Object [ ] obs ) ) . subscribe ( ts ) ; ts . assertValues ( expected ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
return true ; 
return count ++ ; 
$EMPTY$
return this ; 
Flowable . fromIterable ( new InfiniteIterator ( ) ) . concatWith ( Flowable . < Integer > empty ( ) ) . take ( 10 ) . test ( ) . assertResult ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; Flowable . concat ( source , source , source ) . test ( ) . assertResult ( 1 , 1 , 1 ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; Flowable . concat ( source , source , source , source ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 ) ; 
Flowable . concatArrayDelayError ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Flowable . concatArrayDelayError ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 4 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 ) ; 
Flowable . concatDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Flowable . concatDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 4 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 ) ; 
Flowable . concatDelayError ( Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) , Flowable . just ( 4 ) ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 ) ; 
Flowable . concatDelayError ( Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 4 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 ) ; 
Flowable . concatDelayError ( Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 4 ) ) , 2 , false ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; 
Flowable . concatDelayError ( Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) , Flowable . just ( 3 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 4 ) ) , 2 , true ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 ) ; 
Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) . concatMapDelayError ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . just ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) , Flowable . just ( 2 ) ) . concatMapDelayError ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Flowable . just ( 1 , 2 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; , 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 1 , 2 , 3 , 4 , 5 ) ; 
assertSame ( Flowable . empty ( ) , Flowable . concatArrayDelayError ( ) ) ; 
assertSame ( Flowable . never ( ) , Flowable . concatArrayDelayError ( Flowable . never ( ) ) ) ; 
assertSame ( Flowable . empty ( ) , Flowable . < Object > empty ( ) . concatMapDelayError ( new Function < Object , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , true , 16 ) ) ; 
Flowable . just ( 0 ) . concatMapDelayError ( new Function < Object , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , true , 16 ) . test ( ) . assertResult ( 1 ) ; 
assertSame ( Flowable . empty ( ) , Flowable . concatArray ( ) ) ; 
assertSame ( Flowable . never ( ) , Flowable . concatArray ( Flowable . never ( ) ) ) ; 
assertSame ( Flowable . empty ( ) , Flowable . < Object > empty ( ) . concatMap ( new Function < Object , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , 16 ) ) ; 
Flowable . just ( 0 ) . hide ( ) . concatMap ( new Function < Object , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , 16 ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 0 ) . hide ( ) . concatMapDelayError ( new Function < Object , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Object v ) throws Exception return Flowable . just ( 1 ) ; , false , 16 ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Flowable . just ( 2 ) ) ) . test ( 1L ) . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 2 ) ) ) . test ( 1L ) . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Flowable . empty ( ) ) ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Flowable . empty ( ) ) ) . test ( ) . assertResult ( ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) s . onNext ( i ) ; . concatMap ( Functions . justFunction ( Flowable . just ( 2 ) ) , 8 ) . test ( 0L ) . assertFailure ( IllegalStateException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Object > f ) throws Exception return f . concatMap ( Functions . justFunction ( Flowable . just ( 2 ) ) ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Object > f ) throws Exception return f . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 2 ) ) ) ; ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onError ( new TestException ( "First" ) ) ; ; pp . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onError ( new TestException ( "First" ) ) ; ; pp . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) . hide ( ) ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Flowable . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Flowable . error ( new TestException ( ) ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) . hide ( ) ) ) ; , true , 1 , 1 , 1 ) ; 
@ SuppressWarnings ( "rawtypes" ) final Subscriber [ ] ts0 = null ; TestSubscriberEx < Integer > ts = Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) ts0 [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "First" ) ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ts0 [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
@ SuppressWarnings ( "rawtypes" ) final Subscriber [ ] ts0 = null ; TestSubscriberEx < Integer > ts = Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) ts0 [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "First" ) ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ts0 [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 1 ) . hide ( ) ) ) ; , true , 1 , 1 , 1 ) ; 
Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 1 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 2 ) . concatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) ) ) ; TestHelper . checkDisposed ( Flowable . range ( 1 , 2 ) . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 1 ) ) ) ) ; 
Flowable . range ( 1 , 2 ) . concatMapDelayError ( Functions . justFunction ( Flowable . error ( new TestException ( ) ) ) , false , 16 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . concatMapDelayError ( Functions . justFunction ( Flowable . just ( 2 ) ) , false , 16 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . concatMap ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final int [ ] calls = 0 ; Flowable < Integer > source = Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onNext ( 1 ) ; s . onComplete ( ) ; , BackpressureStrategy . MISSING ) ; Flowable . concatArray ( source , source ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Flowable < Integer > source = Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onNext ( 1 ) ; s . onComplete ( ) ; , BackpressureStrategy . MISSING ) ; Flowable . concatArrayDelayError ( source , source ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Flowable < Integer > source = Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onNext ( 1 ) ; s . onComplete ( ) ; , BackpressureStrategy . MISSING ) ; Flowable . concat ( Arrays . asList ( source , source ) ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Flowable < Integer > source = Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > s ) throws Exception calls [ 0 ] ++ ; s . onNext ( 1 ) ; s . onComplete ( ) ; , BackpressureStrategy . MISSING ) ; Flowable . concatDelayError ( Arrays . asList ( source , source ) ) . firstElement ( ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; Flowable . concatArray ( source , source , source , source , source ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; Flowable . concat ( Arrays . asList ( source , source , source , source , source ) ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; Flowable . concatArrayDelayError ( Flowable . error ( new IOException ( ) ) , Flowable . error ( new TestException ( ) ) ) . subscribe ( ts ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , IOException . class , TestException . class ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; Flowable . concatArrayDelayError ( null , null ) . subscribe ( ts ) ; ts . assertFailure ( CompositeException . class ) ; TestHelper . assertCompositeExceptions ( ts , NullPointerException . class , NullPointerException . class ) ; 
objectSubscriber = TestHelper . mockSubscriber ( ) ; singleObserver = TestHelper . mockSingleObserver ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Flowable < Map < Integer , String > > mapped = source . toMap ( lengthFunc ) . toFlowable ( ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "a" ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , times ( 1 ) ) . onNext ( expected ) ; verify ( objectSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Flowable < Map < Integer , String > > mapped = source . toMap ( lengthFunc , duplicate ) . toFlowable ( ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "aa" ) ; expected . put ( 2 , "bbbb" ) ; expected . put ( 3 , "cccccc" ) ; expected . put ( 4 , "dddddddd" ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , times ( 1 ) ) . onNext ( expected ) ; verify ( objectSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Function < String , Integer > lengthFuncErr = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) if ( "bb" . equals ( t1 ) ) throw new RuntimeException ( "Forced Failure" ) ; return t1 . length ( ) ; ; Flowable < Map < Integer , String > > mapped = source . toMap ( lengthFuncErr ) . toFlowable ( ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "a" ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onNext ( expected ) ; verify ( objectSubscriber , never ( ) ) . onComplete ( ) ; verify ( objectSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Function < String , String > duplicateErr = new Function < String , String > ( ) @ Override public String apply ( String t1 ) if ( "bb" . equals ( t1 ) ) throw new RuntimeException ( "Forced failure" ) ; return t1 + t1 ; ; Flowable < Map < Integer , String > > mapped = source . toMap ( lengthFunc , duplicateErr ) . toFlowable ( ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "aa" ) ; expected . put ( 2 , "bbbb" ) ; expected . put ( 3 , "cccccc" ) ; expected . put ( 4 , "dddddddd" ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onNext ( expected ) ; verify ( objectSubscriber , never ( ) ) . onComplete ( ) ; verify ( objectSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Supplier < Map < Integer , String > > mapFactory = new Supplier < Map < Integer , String > > ( ) @ Override public Map < Integer , String > get ( ) return new LinkedHashMap < Integer , String > ( ) private static final long serialVersionUID = - 3296811238780863394L ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , String > eldest ) return size ( ) > 3 ; ; ; Function < String , Integer > lengthFunc = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) return t1 . length ( ) ; ; Flowable < Map < Integer , String > > mapped = source . toMap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) . toFlowable ( ) ; Map < Integer , String > expected = new LinkedHashMap < > ( ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , times ( 1 ) ) . onNext ( expected ) ; verify ( objectSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Supplier < Map < Integer , String > > mapFactory = new Supplier < Map < Integer , String > > ( ) @ Override public Map < Integer , String > get ( ) throw new RuntimeException ( "Forced failure" ) ; ; Function < String , Integer > lengthFunc = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) return t1 . length ( ) ; ; Flowable < Map < Integer , String > > mapped = source . toMap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) . toFlowable ( ) ; Map < Integer , String > expected = new LinkedHashMap < > ( ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onNext ( expected ) ; verify ( objectSubscriber , never ( ) ) . onComplete ( ) ; verify ( objectSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "a" ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc , duplicate ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "aa" ) ; expected . put ( 2 , "bbbb" ) ; expected . put ( 3 , "cccccc" ) ; expected . put ( 4 , "dddddddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Function < String , Integer > lengthFuncErr = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) if ( "bb" . equals ( t1 ) ) throw new RuntimeException ( "Forced Failure" ) ; return t1 . length ( ) ; ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFuncErr ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "a" ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Function < String , String > duplicateErr = new Function < String , String > ( ) @ Override public String apply ( String t1 ) if ( "bb" . equals ( t1 ) ) throw new RuntimeException ( "Forced failure" ) ; return t1 + t1 ; ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc , duplicateErr ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "aa" ) ; expected . put ( 2 , "bbbb" ) ; expected . put ( 3 , "cccccc" ) ; expected . put ( 4 , "dddddddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Supplier < Map < Integer , String > > mapFactory = new Supplier < Map < Integer , String > > ( ) @ Override public Map < Integer , String > get ( ) return new LinkedHashMap < Integer , String > ( ) private static final long serialVersionUID = - 3296811238780863394L ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , String > eldest ) return size ( ) > 3 ; ; ; Function < String , Integer > lengthFunc = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) return t1 . length ( ) ; ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) ; Map < Integer , String > expected = new LinkedHashMap < > ( ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Supplier < Map < Integer , String > > mapFactory = new Supplier < Map < Integer , String > > ( ) @ Override public Map < Integer , String > get ( ) throw new RuntimeException ( "Forced failure" ) ; ; Function < String , Integer > lengthFunc = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) return t1 . length ( ) ; ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) ; Map < Integer , String > expected = new LinkedHashMap < > ( ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; , true , Integer . MAX_VALUE ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 10 ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; , false , 3 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 10 ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; , false , 1 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return null ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailure ( NullPointerException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 11 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; , false , 1 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; , false , 2 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 2 ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . fromArray ( new String [ ] "1" , "a" , "2" ) . flatMapMaybe ( new Function < String , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( final String s ) throws NumberFormatException return Maybe . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws NumberFormatException return Integer . valueOf ( s ) ; ) ; ) . test ( ) . assertFailure ( NumberFormatException . class , 1 ) ; 
TestHelper . checkDisposed ( PublishProcessor . < Integer > create ( ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . < Integer > empty ( ) ; ) ) ; 
Flowable . range ( 1 , 1000 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 500 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . range ( 1 , 1000 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . < Integer > empty ( ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 500 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . < Integer > empty ( ) . subscribeOn ( Schedulers . computation ( ) ) ; , false , 128 ) . take ( 500 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . < Integer > error ( new TestException ( ) ) . subscribeOn ( Schedulers . computation ( ) ) ; , true , 128 ) . take ( 500 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( CompositeException . class ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . range ( 1 , 2 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) return pp . singleElement ( ) ; return Maybe . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . test ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class , 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . range ( 1 , 2 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) return pp . singleElement ( ) ; return Maybe . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . test ( ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Object > f ) throws Exception return f . flatMapMaybe ( Functions . justFunction ( Maybe . just ( 2 ) ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onError ( new TestException ( "Second" ) ) ; . flatMapMaybe ( Functions . justFunction ( Maybe . just ( 2 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . flatMapMaybe ( Functions . justFunction ( new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onError ( new TestException ( "Second" ) ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ; Flowable . just ( pp1 , pp2 ) . flatMapMaybe ( new Function < PublishProcessor < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( PublishProcessor < Integer > v ) throws Exception return v . singleElement ( ) ; ) . subscribe ( ts ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp3 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ; Flowable . just ( pp1 , pp2 , pp3 ) . flatMapMaybe ( new Function < PublishProcessor < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( PublishProcessor < Integer > v ) throws Exception return v . singleElement ( ) ; ) . subscribe ( ts ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; pp3 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Integer v ) throws Exception return new Maybe < Object > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ts . cancel ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( 1 ) . flatMapMaybe ( Functions . justFunction ( pp . singleElement ( ) ) ) . test ( ) ; pp . onNext ( 2 ) ; pp . onComplete ( ) ; ts . assertResult ( 2 ) ; 
TestSubscriber < Integer > ts = Flowable . just ( 1 ) . flatMapMaybe ( Functions . justFunction ( Maybe . just ( 2 ) ) ) . test ( 0L ) . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . flatMapMaybe ( Functions . justFunction ( Maybe . < Integer > error ( new TestException ( ) ) ) ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . flatMapMaybe ( Functions . justFunction ( Maybe . < Integer > error ( new TestException ( ) ) ) , true , 16 ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) . flatMapMaybe ( Functions . justFunction ( Maybe . just ( 2 ) ) ) . test ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . flatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . flatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; , true , 2 ) ; ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . flatMapMaybe ( v -> Maybe . never ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) MaybeSubject < Integer > ss1 = MaybeSubject . create ( ) ; MaybeSubject < Integer > ss2 = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( ss1 , ss2 ) . flatMapMaybe ( v -> v ) . test ( ) ; TestHelper . race ( ( ) -> ss1 . onSuccess ( 1 ) , ( ) -> ss2 . onSuccess ( 1 ) ) ; ts . assertResult ( 1 , 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) MaybeSubject < Integer > ss1 = MaybeSubject . create ( ) ; MaybeSubject < Integer > ss2 = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( ss1 , ss2 ) . flatMapMaybe ( v -> v ) . test ( ) ; TestHelper . race ( ( ) -> ss1 . onSuccess ( 1 ) , ( ) -> ss2 . onComplete ( ) ) ; ts . assertResult ( 1 ) ; 
MaybeSubject < Integer > ss1 = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( ss1 ) . hide ( ) . flatMapMaybe ( v -> v ) . test ( ) ; ss1 . onSuccess ( 1 ) ; ts . assertResult ( 1 ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 ) . singleElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 ) . singleElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . < Integer > empty ( ) . singleElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable . just ( 1 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) requests . add ( n ) ; ) . singleElement ( ) . toFlowable ( ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) request ( 2 ) ; ) ; assertEquals ( Arrays . asList ( Long . MAX_VALUE ) , requests ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable . just ( 1 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) requests . add ( n ) ; ) . singleElement ( ) . toFlowable ( ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 3 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) ) ; assertEquals ( Arrays . asList ( Long . MAX_VALUE ) , requests ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable . just ( 1 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) requests . add ( n ) ; ) . singleElement ( ) . toFlowable ( ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) ) ; assertEquals ( Arrays . asList ( Long . MAX_VALUE ) , requests ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 , 4 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 ) . single ( 2 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 ) . single ( 3 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . < Integer > empty ( ) . single ( 1 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 4 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 , 4 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 6 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 2 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 ) . singleElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = spy ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer integer ) request ( 1 ) ; ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . < Integer > empty ( ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final AtomicLong request = new AtomicLong ( ) ; Flowable . just ( 1 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) request . addAndGet ( n ) ; ) . blockingSingle ( ) ; assertEquals ( Long . MAX_VALUE , request . get ( ) ) ; 
final AtomicLong request = new AtomicLong ( ) ; try Flowable . empty ( ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) request . addAndGet ( n ) ; ) . blockingSingle ( ) ; catch ( NoSuchElementException e ) assertEquals ( Long . MAX_VALUE , request . get ( ) ) ; 
final AtomicLong request = new AtomicLong ( ) ; try Flowable . just ( 1 , 2 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) request . addAndGet ( n ) ; ) . blockingSingle ( ) ; catch ( IllegalArgumentException e ) assertEquals ( Long . MAX_VALUE , request . get ( ) ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 , 3 , 4 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 ) . single ( 2 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 ) . single ( 3 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . < Integer > empty ( ) . single ( 1 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 4 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 , 3 , 4 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 6 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 2 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Maybe < Integer > reduced = source . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 + i2 ; ) ; Integer r = reduced . blockingGet ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Flowable . empty ( ) . singleOrError ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Flowable . just ( 1 ) . singleOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Flowable . just ( 1 , 2 , 3 ) . singleOrError ( ) . test ( ) . assertNoValues ( ) . assertError ( IllegalArgumentException . class ) ; 
Flowable . error ( new RuntimeException ( "error" ) ) . singleOrError ( ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Flowable < Integer > reduced = source . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 + i2 ; ) . toFlowable ( ) ; Integer r = reduced . blockingFirst ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
final Throwable exception = new RuntimeException ( "some error" ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; try RxJavaPlugins . setErrorHandler ( new Consumer < Throwable > ( ) @ Override public void accept ( final Throwable throwable ) throws Exception error . set ( throwable ) ; ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) subscriber . onComplete ( ) ; subscriber . onError ( exception ) ; ) . singleElement ( ) . test ( ) . assertComplete ( ) ; assertSame ( exception , error . get ( ) . getCause ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . singleOrError ( ) ; , false , 1 , 1 , 1 ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . singleElement ( ) ; , false , 1 , 1 , 1 ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . singleOrError ( ) . toFlowable ( ) ; , false , 1 , 1 , 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Flowable < Object > f ) throws Exception return f . singleOrError ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . singleOrError ( ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToMaybe ( new Function < Flowable < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Flowable < Object > f ) throws Exception return f . singleElement ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . singleElement ( ) . toFlowable ( ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . singleOrError ( ) . toFlowable ( ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Flowable . empty ( ) . singleOrError ( ) . toFlowable ( ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . single ( 1 ) ) ; 
final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable ( "one" , "two" , null , "three" ) ; TestNotificationSubscriber observer = new TestNotificationSubscriber ( ) ; Flowable < Notification < String > > m = Flowable . unsafeCreate ( o1 ) . materialize ( ) ; m . subscribe ( observer ) ; try o1 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertFalse ( observer . onError ) ; assertTrue ( observer . onComplete ) ; assertEquals ( 3 , observer . notifications . size ( ) ) ; assertTrue ( observer . notifications . get ( 0 ) . isOnNext ( ) ) ; assertEquals ( "one" , observer . notifications . get ( 0 ) . getValue ( ) ) ; assertTrue ( observer . notifications . get ( 1 ) . isOnNext ( ) ) ; assertEquals ( "two" , observer . notifications . get ( 1 ) . getValue ( ) ) ; assertTrue ( observer . notifications . get ( 2 ) . isOnError ( ) ) ; assertEquals ( NullPointerException . class , observer . notifications . get ( 2 ) . getError ( ) . getClass ( ) ) ; 
final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable ( "one" , "two" , "three" ) ; TestNotificationSubscriber subscriber = new TestNotificationSubscriber ( ) ; Flowable < Notification < String > > m = Flowable . unsafeCreate ( o1 ) . materialize ( ) ; m . subscribe ( subscriber ) ; try o1 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertFalse ( subscriber . onError ) ; assertTrue ( subscriber . onComplete ) ; assertEquals ( 4 , subscriber . notifications . size ( ) ) ; assertTrue ( subscriber . notifications . get ( 0 ) . isOnNext ( ) ) ; assertEquals ( "one" , subscriber . notifications . get ( 0 ) . getValue ( ) ) ; assertTrue ( subscriber . notifications . get ( 1 ) . isOnNext ( ) ) ; assertEquals ( "two" , subscriber . notifications . get ( 1 ) . getValue ( ) ) ; assertTrue ( subscriber . notifications . get ( 2 ) . isOnNext ( ) ) ; assertEquals ( "three" , subscriber . notifications . get ( 2 ) . getValue ( ) ) ; assertTrue ( subscriber . notifications . get ( 3 ) . isOnComplete ( ) ) ; 
final TestAsyncErrorObservable o = new TestAsyncErrorObservable ( "one" , "two" , null , "three" ) ; Flowable < Notification < String > > m = Flowable . unsafeCreate ( o ) . materialize ( ) ; assertEquals ( 3 , m . toList ( ) . toFuture ( ) . get ( ) . size ( ) ) ; assertEquals ( 3 , m . toList ( ) . toFuture ( ) . get ( ) . size ( ) ) ; 
TestSubscriber < Notification < Integer > > ts = new TestSubscriber < > ( 0L ) ; Flowable . < Integer > empty ( ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValueCount ( 1 ) ; assertTrue ( ts . values ( ) . get ( 0 ) . isOnComplete ( ) ) ; ts . assertComplete ( ) ; 
TestSubscriber < Notification < Integer > > ts = new TestSubscriber < > ( 0L ) ; Flowable . just ( 1 , 2 , 3 ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValueCount ( 1 ) ; ts . request ( 2 ) ; ts . assertValueCount ( 3 ) ; ts . request ( 1 ) ; ts . assertValueCount ( 4 ) ; ts . assertComplete ( ) ; 
TestSubscriber < Notification < Integer > > ts = new TestSubscriber < > ( 0L ) ; Flowable . just ( 1 , 2 , 3 ) . materialize ( ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; Thread . sleep ( 100 ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; Thread . sleep ( 100 ) ; ts . assertValueCount ( 1 ) ; ts . request ( 2 ) ; Thread . sleep ( 100 ) ; ts . assertValueCount ( 3 ) ; ts . request ( 1 ) ; Thread . sleep ( 100 ) ; ts . assertValueCount ( 4 ) ; ts . assertComplete ( ) ; 
TestSubscriber < Notification < Integer > > ts = new TestSubscriber < > ( 0L ) ; Flowable . < Integer > error ( new IllegalArgumentException ( ) ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValueCount ( 1 ) ; ts . assertComplete ( ) ; 
TestSubscriber < Notification < Integer > > ts = new TestSubscriber < > ( 0L ) ; IllegalArgumentException ex = new IllegalArgumentException ( ) ; Flowable . fromIterable ( Arrays . asList ( 1 ) ) . concatWith ( Flowable . < Integer > error ( ex ) ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValueCount ( 1 ) ; assertTrue ( ts . values ( ) . get ( 0 ) . isOnNext ( ) ) ; ts . request ( 1 ) ; ts . assertValueCount ( 2 ) ; assertTrue ( ts . values ( ) . get ( 1 ) . isOnError ( ) ) ; assertEquals ( ex , ts . values ( ) . get ( 1 ) . getError ( ) ) ; ts . assertComplete ( ) ; 
TestSubscriberEx < Notification < Integer > > ts = new TestSubscriberEx < > ( ) ; final RuntimeException ex = new RuntimeException ( "boo" ) ; Flowable . < Integer > empty ( ) . materialize ( ) . doOnNext ( new Consumer < Object > ( ) @ Override public void accept ( Object t ) throw ex ; ) . subscribe ( ts ) ; ts . assertError ( ex ) ; ts . assertNoValues ( ) ; ts . assertTerminated ( ) ; 
TestSubscriber < Notification < Integer > > ts = new TestSubscriber < > ( 0L ) ; Flowable . < Integer > empty ( ) . materialize ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . cancel ( ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; 
this . onComplete = true ; 
this . onError = true ; 
this . notifications . add ( value ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) for ( String s : valuesToReturn ) if ( s == null ) System . out . println ( "throwing exception" ) ; try Thread . sleep ( 100 ) ; catch ( Throwable e ) subscriber . onError ( new NullPointerException ( ) ) ; return ; else subscriber . onNext ( s ) ; System . out . println ( "subscription complete" ) ; subscriber . onComplete ( ) ; ) ; t . start ( ) ; 
TestSubscriber < Notification < Integer > > ts = Flowable . range ( 1 , 5 ) . materialize ( ) . test ( 0 ) ; ts . assertEmpty ( ) ; ts . request ( 5 ) ; ts . assertValueCount ( 5 ) . assertNoErrors ( ) . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . assertValueCount ( 6 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . materialize ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Notification < Object > > > ( ) @ Override public Flowable < Notification < Object > > apply ( Flowable < Object > f ) throws Exception return f . materialize ( ) ; ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . materialize ( ) ; , false , null , null , Notification . createOnComplete ( ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . just ( 1 ) . materialize ( ) ) ; 
UIEventLoopScheduler uiEventLoop = new UIEventLoopScheduler ( ) ; try final ThreadSubscription subscription = new ThreadSubscription ( ) ; final AtomicReference < Thread > subscribeThread = new AtomicReference < > ( ) ; Flowable < Integer > w = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > t1 ) subscribeThread . set ( Thread . currentThread ( ) ) ; t1 . onSubscribe ( subscription ) ; t1 . onNext ( 1 ) ; t1 . onNext ( 2 ) ; ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; w . subscribeOn ( uiEventLoop ) . observeOn ( Schedulers . computation ( ) ) . unsubscribeOn ( uiEventLoop ) . take ( 2 ) . subscribe ( ts ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) ; Thread unsubscribeThread = subscription . getThread ( ) ; assertNotNull ( unsubscribeThread ) ; assertNotSame ( Thread . currentThread ( ) , unsubscribeThread ) ; assertNotNull ( subscribeThread . get ( ) ) ; assertNotSame ( Thread . currentThread ( ) , subscribeThread . get ( ) ) ; System . out . println ( "unsubscribeThread: " + unsubscribeThread ) ; System . out . println ( "subscribeThread.get(): " + subscribeThread . get ( ) ) ; assertSame ( unsubscribeThread , uiEventLoop . getThread ( ) ) ; ts . assertValues ( 1 , 2 ) ; ts . assertTerminated ( ) ; finally uiEventLoop . shutdown ( ) ; 
UIEventLoopScheduler uiEventLoop = new UIEventLoopScheduler ( ) ; try final ThreadSubscription subscription = new ThreadSubscription ( ) ; final AtomicReference < Thread > subscribeThread = new AtomicReference < > ( ) ; Flowable < Integer > w = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > t1 ) subscribeThread . set ( Thread . currentThread ( ) ) ; t1 . onSubscribe ( subscription ) ; t1 . onNext ( 1 ) ; t1 . onNext ( 2 ) ; ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; w . subscribeOn ( Schedulers . newThread ( ) ) . observeOn ( Schedulers . computation ( ) ) . unsubscribeOn ( uiEventLoop ) . take ( 2 ) . subscribe ( ts ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) ; Thread unsubscribeThread = subscription . getThread ( ) ; assertNotNull ( unsubscribeThread ) ; assertNotSame ( Thread . currentThread ( ) , unsubscribeThread ) ; assertNotNull ( subscribeThread . get ( ) ) ; assertNotSame ( Thread . currentThread ( ) , subscribeThread . get ( ) ) ; System . out . println ( "UI Thread: " + uiEventLoop . getThread ( ) ) ; System . out . println ( "unsubscribeThread: " + unsubscribeThread ) ; System . out . println ( "subscribeThread.get(): " + subscribeThread . get ( ) ) ; assertSame ( unsubscribeThread , uiEventLoop . getThread ( ) ) ; ts . assertValues ( 1 , 2 ) ; ts . assertTerminated ( ) ; finally uiEventLoop . shutdown ( ) ; 
System . out . println ( "unsubscribe invoked: " + Thread . currentThread ( ) ) ; thread = Thread . currentThread ( ) ; latch . countDown ( ) ; 
latch . await ( ) ; return thread ; 
return eventLoop . createWorker ( ) ; 
return t ; 
int elements = 1024 ; Flowable . range ( 0 , elements * 2 ) . unsubscribeOn ( Schedulers . single ( ) ) . take ( elements ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( elements ) . assertComplete ( ) . assertNoErrors ( ) . assertSubscribed ( ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . unsubscribeOn ( Schedulers . single ( ) ) ) ; 
final int [ ] calls = 0 ; Flowable . just ( 1 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception calls [ 0 ] ++ ; ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Flowable . error ( new TestException ( ) ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception calls [ 0 ] ++ ; ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . unsubscribeOn ( Schedulers . single ( ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . unsubscribeOn ( ImmediateThinScheduler . INSTANCE ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; create ( 1000 ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 1000 ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; create ( 1000 ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . request ( 10 ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 10 ) ; ts . assertNotComplete ( ) ; ts . request ( 1000 ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 1000 ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; create ( 1000 ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . request ( 10 ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 10 ) ; ts . assertNotComplete ( ) ; ts . request ( 1000 ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 1000 ) ; ts . assertComplete ( ) ; 
Assert . assertSame ( Flowable . empty ( ) , Flowable . fromArray ( new Object [ 0 ] ) ) ; 
Flowable < Integer > source = Flowable . fromArray ( new Integer [ ] 1 ) ; Assert . assertTrue ( source . getClass ( ) . toString ( ) , source instanceof ScalarSupplier ) ; 
Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestHelper . assertBadRequestReported ( Flowable . just ( 1 , 2 , 3 ) ) ; 
Flowable . fromArray ( new Integer [ ] null , 1 ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable . fromArray ( new Integer [ ] null , 1 ) . filter ( Functions . alwaysTrue ( ) ) . test ( 2L ) . assertFailure ( NullPointerException . class ) ; 
Flowable . fromArray ( new Integer [ ] 1 , 2 , 3 , 4 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . fromArray ( new Integer [ ] 1 , 2 , 3 , 4 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . test ( ) . assertResult ( 2 , 4 ) ; 
Flowable . fromArray ( new Integer [ ] 1 , 2 , 3 , 4 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . subscribeWith ( new TestSubscriber < Integer > ( 5L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cancel ( ) ; onComplete ( ) ; ) . assertResult ( 1 ) ; 
Flowable . fromArray ( new Integer [ ] 1 , 2 , 3 , 4 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v < 2 ; ) . subscribeWith ( new TestSubscriber < Integer > ( 5L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cancel ( ) ; onComplete ( ) ; ) . assertResult ( 1 ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; subscriber2 = TestHelper . mockSubscriber ( ) ; scheduler = new TestScheduler ( ) ; 
Flowable . timer ( 100 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( subscriber ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 0L ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; Flowable . interval ( 100 , 100 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( ts ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValue ( 0L ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValues ( 0L , 1L ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValues ( 0L , 1L , 2L ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValues ( 0L , 1L , 2L , 3L ) ; ts . cancel ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; ts . assertValues ( 0L , 1L , 2L , 3L ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; 
Flowable < Long > w = Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) ; TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; w . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; ts . assertValues ( 0L , 1L ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . cancel ( ) ; scheduler . advanceTimeTo ( 4 , TimeUnit . SECONDS ) ; ts . assertValues ( 0L , 1L ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
Flowable < Long > w = Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) ; TestSubscriber < Long > ts1 = new TestSubscriber < > ( ) ; TestSubscriber < Long > ts2 = new TestSubscriber < > ( ) ; w . subscribe ( ts1 ) ; w . subscribe ( ts2 ) ; ts1 . assertNoValues ( ) ; ts2 . assertNoValues ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; ts1 . assertValues ( 0L , 1L ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; ts2 . assertValues ( 0L , 1L ) ; ts2 . assertNoErrors ( ) ; ts2 . assertNotComplete ( ) ; ts1 . cancel ( ) ; ts2 . cancel ( ) ; scheduler . advanceTimeTo ( 4 , TimeUnit . SECONDS ) ; ts1 . assertValues ( 0L , 1L ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; ts2 . assertValues ( 0L , 1L ) ; ts2 . assertNoErrors ( ) ; ts2 . assertNotComplete ( ) ; 
Flowable < Long > w = Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) ; TestSubscriber < Long > ts1 = new TestSubscriber < > ( ) ; w . subscribe ( ts1 ) ; ts1 . assertNoErrors ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; TestSubscriber < Long > ts2 = new TestSubscriber < > ( ) ; w . subscribe ( ts2 ) ; ts1 . assertValues ( 0L , 1L ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; ts2 . assertNoValues ( ) ; scheduler . advanceTimeTo ( 4 , TimeUnit . SECONDS ) ; ts1 . assertValues ( 0L , 1L , 2L , 3L ) ; ts2 . assertValues ( 0L , 1L ) ; ts1 . cancel ( ) ; ts2 . cancel ( ) ; ts1 . assertValues ( 0L , 1L , 2L , 3L ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; ts2 . assertValues ( 0L , 1L ) ; ts2 . assertNoErrors ( ) ; ts2 . assertNotComplete ( ) ; 
ConnectableFlowable < Long > w = Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . publish ( ) ; TestSubscriber < Long > ts1 = new TestSubscriber < > ( ) ; w . subscribe ( ts1 ) ; w . connect ( ) ; ts1 . assertNoValues ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; TestSubscriber < Long > ts2 = new TestSubscriber < > ( ) ; w . subscribe ( ts2 ) ; ts1 . assertValues ( 0L , 1L ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; ts2 . assertNoValues ( ) ; scheduler . advanceTimeTo ( 4 , TimeUnit . SECONDS ) ; ts1 . assertValues ( 0L , 1L , 2L , 3L ) ; ts2 . assertValues ( 2L , 3L ) ; ts1 . cancel ( ) ; ts2 . cancel ( ) ; ts1 . assertValues ( 0L , 1L , 2L , 3L ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; ts2 . assertValues ( 2L , 3L ) ; ts2 . assertNoErrors ( ) ; ts2 . assertNotComplete ( ) ; 
Flowable < Long > source = Flowable . timer ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; source . safeSubscribe ( new DefaultSubscriber < Long > ( ) @ Override public void onNext ( Long t ) throw new TestException ( ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable < Long > source = Flowable . interval ( 100 , 100 , TimeUnit . MILLISECONDS , scheduler ) ; InOrder inOrder = inOrder ( subscriber ) ; source . safeSubscribe ( new DefaultSubscriber < Long > ( ) @ Override public void onNext ( Long t ) if ( t > 0 ) throw new TestException ( ) ; subscriber . onNext ( t ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; inOrder . verify ( subscriber ) . onNext ( 0L ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
TestHelper . checkDisposed ( Flowable . timer ( 1 , TimeUnit . DAYS ) ) ; 
Flowable . timer ( 1 , TimeUnit . MILLISECONDS ) . test ( 0L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( MissingBackpressureException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; final TestScheduler scheduler = new TestScheduler ( ) ; Flowable . timer ( 1 , TimeUnit . SECONDS , scheduler ) . subscribe ( ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try for ( int i = 0 ; i < 1000 ; i ++ ) Flowable . timer ( 0 , TimeUnit . MILLISECONDS ) . blockingFirst ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try for ( Scheduler s : new Scheduler [ ] Schedulers . single ( ) , Schedulers . computation ( ) , Schedulers . newThread ( ) , Schedulers . io ( ) , Schedulers . from ( exec , true ) ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; TestSubscriber < Long > ts = Flowable . timer ( 1 , TimeUnit . MILLISECONDS , s ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long v ) throws Exception try Thread . sleep ( 3000 ) ; catch ( InterruptedException ex ) interrupted . set ( true ) ; return v ; ) . test ( ) ; Thread . sleep ( 500 ) ; ts . cancel ( ) ; Thread . sleep ( 500 ) ; assertTrue ( s . getClass ( ) . getSimpleName ( ) , interrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
TestHelper . assertBadRequestReported ( Flowable . timer ( 1 , TimeUnit . MINUTES ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . publish ( ) . autoConnect ( 0 ) ; assertTrue ( pp . hasSubscribers ( ) ) ; 
final AtomicBoolean unsubscribed = new AtomicBoolean ( false ) ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) . doOnCancel ( new Action ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) ) . subscribe ( ) . dispose ( ) ; assertTrue ( unsubscribed . get ( ) ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) requests . add ( n ) ; ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 3 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) request ( t ) ; ) ; assertEquals ( Arrays . asList ( 3L , 1L , 2L , 3L , 4L , 5L ) , requests ) ; 
Subscriber < Long > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . rangeLong ( 2 , 3 ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2L ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 3L ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 4L ) ; verify ( subscriber , never ( ) ) . onNext ( 5L ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Subscriber < Long > subscriber = TestHelper . mockSubscriber ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . rangeLong ( 1 , 1000 ) . doOnNext ( new Consumer < Long > ( ) @ Override public void accept ( Long t1 ) count . incrementAndGet ( ) ; ) . take ( 3 ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1L ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2L ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 3L ) ; verify ( subscriber , never ( ) ) . onNext ( 4L ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; assertEquals ( 3 , count . get ( ) ) ; 
Flowable . rangeLong ( 1 , 0 ) ; 
Flowable . rangeLong ( Long . MAX_VALUE , 0 ) ; 
Flowable . rangeLong ( 1 , Long . MAX_VALUE ) ; 
Flowable . rangeLong ( 2 , Long . MAX_VALUE ) ; 
assertFalse ( Flowable . rangeLong ( Long . MIN_VALUE , 0 ) . blockingIterable ( ) . iterator ( ) . hasNext ( ) ) ; 
Flowable < Long > f = Flowable . rangeLong ( 1 , Flowable . bufferSize ( ) ) ; TestSubscriberEx < Long > ts = new TestSubscriberEx < > ( 0L ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; f . subscribe ( ts ) ; ts . assertValue ( 1L ) ; ts . request ( 2 ) ; ts . assertValues ( 1L , 2L , 3L ) ; ts . request ( 3 ) ; ts . assertValues ( 1L , 2L , 3L , 4L , 5L , 6L ) ; ts . request ( Flowable . bufferSize ( ) ) ; ts . assertTerminated ( ) ; 
ArrayList < Long > list = new ArrayList < > ( Flowable . bufferSize ( ) * 2 ) ; for ( long i = 1 ; i <= Flowable . bufferSize ( ) * 2 + 1 ; i ++ ) list . add ( i ) ; Flowable < Long > f = Flowable . rangeLong ( 1 , list . size ( ) ) ; TestSubscriberEx < Long > ts = new TestSubscriberEx < > ( 0L ) ; ts . assertNoValues ( ) ; ts . request ( Long . MAX_VALUE ) ; f . subscribe ( ts ) ; ts . assertValueSequence ( list ) ; ts . assertTerminated ( ) ; 
for ( long i = 0 ; i < 100 ; i ++ ) withBackpressureOneByOne ( i ) ; 
for ( long i = 0 ; i < 100 ; i ++ ) withBackpressureAllAtOnce ( i ) ; 
Flowable < Long > source = Flowable . rangeLong ( 50 , 100 ) ; TestSubscriberEx < Long > ts = new TestSubscriberEx < > ( 0L ) ; ts . request ( 150 ) ; source . subscribe ( ts ) ; List < Long > list = new ArrayList < > ( 100 ) ; for ( long i = 0 ; i < 100 ; i ++ ) list . add ( i + 50 ) ; ts . request ( 50 ) ; ts . assertValueSequence ( list ) ; ts . assertTerminated ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; int n = 10 ; Flowable . rangeLong ( 1 , n ) . subscribe ( new DefaultSubscriber < Long > ( ) @ Override public void onStart ( ) request ( 2 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new RuntimeException ( e ) ; @ Override public void onNext ( Long t ) count . incrementAndGet ( ) ; request ( Long . MAX_VALUE - 1 ) ; ) ; assertEquals ( n , count . get ( ) ) ; 
final AtomicBoolean completed = new AtomicBoolean ( false ) ; Flowable . rangeLong ( 1 , 0 ) . subscribe ( new DefaultSubscriber < Long > ( ) @ Override public void onStart ( ) @ Override public void onComplete ( ) completed . set ( true ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long t ) ) ; assertTrue ( completed . get ( ) ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; Flowable . rangeLong ( Long . MAX_VALUE - 1L , 2L ) . subscribe ( ts ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertValues ( Long . MAX_VALUE - 1L , Long . MAX_VALUE ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( 3L ) ; Flowable . rangeLong ( Long . MAX_VALUE - 1L , 2L ) . subscribe ( ts ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertValues ( Long . MAX_VALUE - 1L , Long . MAX_VALUE ) ; 
try Flowable . rangeLong ( 1L , - 1L ) ; fail ( "Should have thrown IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "count >= 0 required but it was -1" , ex . getMessage ( ) ) ; 
Flowable . rangeLong ( 5495454L , 1L ) . test ( ) . assertResult ( 5495454L ) ; 
TestSubscriberEx < Long > ts = new TestSubscriberEx < Long > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . rangeLong ( 1 , 2 ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1L , 2L ) ; 
TestSubscriberEx < Long > ts = new TestSubscriberEx < Long > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . rangeLong ( 1 , 2 ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1L , 2L ) ; 
TestHelper . checkDisposed ( Flowable . rangeLong ( 1 , 2 ) ) ; 
TestHelper . checkFusedIsEmptyClear ( Flowable . rangeLong ( 1 , 2 ) ) ; 
Flowable . rangeLong ( Long . MAX_VALUE - 1 , 2 ) ; Flowable . rangeLong ( Long . MIN_VALUE , 2 ) ; Flowable . rangeLong ( Long . MIN_VALUE , Long . MAX_VALUE ) ; 
Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
TestHelper . assertBadRequestReported ( Flowable . rangeLong ( 1L , 5L ) ) ; TestHelper . assertBadRequestReported ( Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) . test ( 5 ) . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) . take ( 5 ) . test ( ) . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) . take ( 5 ) . test ( ) . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
Flowable . rangeLong ( 1L , 5L ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < Long > ( 2L ) @ Override public void onNext ( Long t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . rangeLong ( 1L , 5L ) . subscribe ( ts ) ; ts . assertResult ( 1L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < Long > ( ) @ Override public void onNext ( Long t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . rangeLong ( 1L , 5L ) . subscribe ( ts ) ; ts . assertResult ( 1L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < Long > ( 1L ) @ Override public void onNext ( Long t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertResult ( 1L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < Long > ( ) @ Override public void onNext ( Long t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertResult ( 1L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < Long > ( 1L ) @ Override public void onNext ( Long t ) super . onNext ( t ) ; request ( 1 ) ; ; Flowable . rangeLong ( 1L , 5L ) . filter ( new Predicate < Long > ( ) @ Override public boolean test ( Long v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertResult ( 2L , 4L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < Long > ( 1L ) @ Override public void onNext ( Long t ) super . onNext ( t ) ; request ( 1 ) ; ; Flowable . rangeLong ( 1L , 5L ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < Long > ( ) @ Override public void onNext ( Long t ) super . onNext ( t ) ; if ( t == 5L ) cancel ( ) ; onComplete ( ) ; ; Flowable . rangeLong ( 1L , 5L ) . subscribe ( ts ) ; ts . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < Long > ( ) @ Override public void onNext ( Long t ) super . onNext ( t ) ; if ( t == 5L ) cancel ( ) ; onComplete ( ) ; ; Flowable . rangeLong ( 1L , 5L ) . filter ( new Predicate < Long > ( ) @ Override public boolean test ( Long v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertResult ( 2L , 4L ) ; 
Flowable . rangeLong ( 1 , 2 ) . take ( 2 ) . test ( ) . assertResult ( 1L , 2L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; Flowable . rangeLong ( 1 , 2 ) . compose ( TestHelper . conditional ( ) ) . doOnNext ( v -> if ( v == 2L ) ts . cancel ( ) ; ) . subscribe ( ts ) ; ts . assertValuesOnly ( 1L , 2L ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( 4 ) ; Flowable . rangeLong ( 1 , 3 ) . compose ( TestHelper . conditional ( ) ) . doOnNext ( v -> if ( v == 2L ) ts . cancel ( ) ; ) . subscribe ( ts ) ; ts . assertValuesOnly ( 1L , 2L ) ; 
Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . toFlowable ( ) . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . < Integer > toFlowable ( ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return null ; ) . < Integer > toFlowable ( ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailure ( NullPointerException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; , true , Integer . MAX_VALUE ) . toFlowable ( ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Flowable . range ( 1 , 100 ) . subscribeOn ( Schedulers . computation ( ) ) . ignoreElements ( ) ; ) . toFlowable ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Flowable . range ( 1 , 100 ) . subscribeOn ( Schedulers . computation ( ) ) . ignoreElements ( ) ; , false , 3 ) . toFlowable ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . < Integer > toFlowable ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 11 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . < Integer > toFlowable ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; , false , Integer . MAX_VALUE ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . < Integer > toFlowable ( ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = pp . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestObserver < Void > to = pp . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return null ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; to . assertFailure ( NullPointerException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; , true , Integer . MAX_VALUE ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 1000 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Flowable . range ( 1 , 100 ) . subscribeOn ( Schedulers . computation ( ) ) . ignoreElements ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestObserverEx < Void > to = Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 11 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
TestObserverEx < Void > to = Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; , false , Integer . MAX_VALUE ) . test ( ) . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . < Integer > toFlowable ( ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) ) ; 
Flowable . range ( 1 , 1000 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Flowable . range ( 1 , 100 ) . subscribeOn ( Schedulers . computation ( ) ) . ignoreElements ( ) ; , false , 3 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . toFlowable ( ) ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) ; , false , 1 , null ) ; 
Flowable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . toFlowable ( ) . subscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) QueueSubscription < ? > qs = ( QueueSubscription < ? > ) s ; try assertNull ( qs . poll ( ) ) ; catch ( Throwable ex ) throw new RuntimeException ( ex ) ; assertTrue ( qs . isEmpty ( ) ) ; qs . clear ( ) ; @ Override public void onNext ( Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; 
Flowable . range ( 1 , 3 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ( ( Disposable ) observer ) . dispose ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; ) . toFlowable ( ) . test ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . toFlowable ( ) ; , false , 1 , null ) ; 
Flowable . range ( 1 , 3 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ( ( Disposable ) observer ) . dispose ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; ) . test ( ) ; 
Flowable . range ( 1 , 3 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception if ( v == 2 ) return Completable . error ( new TestException ( ) ) ; return Completable . complete ( ) ; , true , 1 ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 3 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception if ( v == 2 ) return Completable . error ( new TestException ( ) ) ; return Completable . complete ( ) ; , true , 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int itemCount = 1 ; itemCount <= 100000 ; itemCount *= 10 ) for ( int concurrency = 1 ; concurrency <= 256 ; concurrency *= 2 ) Flowable . range ( 1 , itemCount ) . flatMapCompletable ( Functions . justFunction ( Completable . complete ( ) . subscribeOn ( Schedulers . computation ( ) ) ) , false , concurrency ) . test ( ) . withTag ( "itemCount=" + itemCount + ", concurrency=" + concurrency ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return upstream . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Flowable < Integer > upstream ) return upstream . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; , true , 2 ) ; ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . flatMapCompletable ( v -> Completable . never ( ) ) . toFlowable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToCompletable ( f -> f . flatMapCompletable ( v -> Completable . never ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; pp1 . flatMapCompletable ( v -> TestHelper . raceOther ( ( ) -> ts . cancel ( ) ; , cdl ) ; return Completable . complete ( ) ; ) . toFlowable ( ) . subscribe ( ts ) ; pp1 . onNext ( 1 ) ; cdl . await ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; TestObserver < Void > to = new TestObserver < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; pp1 . flatMapCompletable ( v -> TestHelper . raceOther ( ( ) -> to . dispose ( ) ; , cdl ) ; return Completable . complete ( ) ; ) . subscribe ( to ) ; pp1 . onNext ( 1 ) ; cdl . await ( ) ; 
Flowable < String > source = Flowable . just ( "one" , "two" , "three" , "four" , "five" , "six" ) ; Flowable < GroupedFlowable < Integer , String > > grouped = source . groupBy ( length ) ; Map < Integer , Collection < String > > map = toMap ( grouped ) ; assertEquals ( 3 , map . size ( ) ) ; assertArrayEquals ( Arrays . asList ( "one" , "two" , "six" ) . toArray ( ) , map . get ( 3 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( "four" , "five" ) . toArray ( ) , map . get ( 4 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( "three" ) . toArray ( ) , map . get ( 5 ) . toArray ( ) ) ; 
Flowable < String > source = Flowable . just ( "one" , "two" , "three" , "four" , "five" , "six" ) ; Flowable < GroupedFlowable < Integer , Integer > > grouped = source . groupBy ( length , length ) ; Map < Integer , Collection < Integer > > map = toMap ( grouped ) ; assertEquals ( 3 , map . size ( ) ) ; assertArrayEquals ( Arrays . asList ( 3 , 3 , 3 ) . toArray ( ) , map . get ( 3 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( 4 , 4 ) . toArray ( ) , map . get ( 4 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( 5 ) . toArray ( ) , map . get ( 5 ) . toArray ( ) ) ; 
Flowable < String > source = Flowable . just ( "one" , "two" , "three" , "four" , "five" , "six" ) ; Flowable < GroupedFlowable < Integer , Integer > > grouped = source . groupBy ( length , length ) ; Map < Integer , Collection < Integer > > map = toMap ( grouped ) ; assertEquals ( 3 , map . size ( ) ) ; assertArrayEquals ( Arrays . asList ( 3 , 3 , 3 ) . toArray ( ) , map . get ( 3 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( 4 , 4 ) . toArray ( ) , map . get ( 4 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( 5 ) . toArray ( ) , map . get ( 5 ) . toArray ( ) ) ; 
Flowable < String > source = Flowable . empty ( ) ; Flowable < GroupedFlowable < Integer , String > > grouped = source . groupBy ( length ) ; Map < Integer , Collection < String > > map = toMap ( grouped ) ; assertTrue ( map . isEmpty ( ) ) ; 
Flowable < String > sourceStrings = Flowable . just ( "one" , "two" , "three" , "four" , "five" , "six" ) ; Flowable < String > errorSource = Flowable . error ( new TestException ( "forced failure" ) ) ; Flowable < String > source = Flowable . concat ( sourceStrings , errorSource ) ; Flowable < GroupedFlowable < Integer , String > > grouped = source . groupBy ( length ) ; final AtomicInteger groupCounter = new AtomicInteger ( ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; grouped . flatMap ( new Function < GroupedFlowable < Integer , String > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Integer , String > f ) groupCounter . incrementAndGet ( ) ; return f . map ( new Function < String , String > ( ) @ Override public String apply ( String v ) return "Event => key: " + f . getKey ( ) + " value: " + v ; ) ; ) . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) error . set ( e ) ; @ Override public void onNext ( String v ) eventCounter . incrementAndGet ( ) ; System . out . println ( v ) ; ) ; assertEquals ( 3 , groupCounter . get ( ) ) ; assertEquals ( 6 , eventCounter . get ( ) ) ; assertNotNull ( error . get ( ) ) ; assertTrue ( "" + error . get ( ) , error . get ( ) instanceof TestException ) ; assertEquals ( error . get ( ) . getMessage ( ) , "forced failure" ) ; 
final ConcurrentHashMap < K , Collection < V > > result = new ConcurrentHashMap < > ( ) ; flowable . doOnNext ( new Consumer < GroupedFlowable < K , V > > ( ) @ Override public void accept ( final GroupedFlowable < K , V > f ) result . put ( f . getKey ( ) , new ConcurrentLinkedQueue < > ( ) ) ; f . subscribe ( new Consumer < V > ( ) @ Override public void accept ( V v ) result . get ( f . getKey ( ) ) . add ( v ) ; ) ; ) . blockingSubscribe ( ) ; return result ; 
final AtomicInteger eventCounter = new AtomicInteger ( ) ; final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger groupCounter = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int count = 100 ; final int groupCount = 2 ; Flowable < Event > es = Flowable . unsafeCreate ( new Publisher < Event > ( ) @ Override public void subscribe ( final Subscriber < ? super Event > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; System . out . println ( "*** Subscribing to EventStream ***" ) ; subscribeCounter . incrementAndGet ( ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < count ; i ++ ) Event e = new Event ( ) ; e . source = i % groupCount ; e . message = "Event-" + i ; subscriber . onNext ( e ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) ; es . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . flatMap ( new Function < GroupedFlowable < Integer , Event > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( GroupedFlowable < Integer , Event > eventGroupedFlowable ) System . out . println ( "GroupedFlowable Key: " + eventGroupedFlowable . getKey ( ) ) ; groupCounter . incrementAndGet ( ) ; return eventGroupedFlowable . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "Source: " + event . source + "  Message: " + event . message ; ) ; ) . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String outputMessage ) System . out . println ( outputMessage ) ; eventCounter . incrementAndGet ( ) ; ) ; latch . await ( 5000 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , subscribeCounter . get ( ) ) ; assertEquals ( groupCount , groupCounter . get ( ) ) ; assertEquals ( count , eventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream ( SYNC_INFINITE_OBSERVABLE_OF_EVENT ( 2 , subscribeCounter , sentEventCounter ) , subscribeCounter ) ; Thread . sleep ( 500 ) ; assertEquals ( 39 , sentEventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream ( ASYNC_INFINITE_OBSERVABLE_OF_EVENT ( 2 , subscribeCounter , sentEventCounter ) , subscribeCounter ) ; Thread . sleep ( 500 ) ; assertEquals ( 39 , sentEventCounter . get ( ) ) ; 
final AtomicInteger eventCounter = new AtomicInteger ( ) ; final AtomicInteger groupCounter = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; es . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . take ( 1 ) . flatMap ( new Function < GroupedFlowable < Integer , Event > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( GroupedFlowable < Integer , Event > eventGroupedFlowable ) System . out . println ( "testUnsubscribe => GroupedFlowable Key: " + eventGroupedFlowable . getKey ( ) ) ; groupCounter . incrementAndGet ( ) ; return eventGroupedFlowable . take ( 20 ) . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "testUnsubscribe => Source: " + event . source + "  Message: " + event . message ; ) ; ) . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String outputMessage ) System . out . println ( outputMessage ) ; eventCounter . incrementAndGet ( ) ; ) ; if ( ! latch . await ( 2000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out so likely did not unsubscribe correctly" ) ; assertEquals ( 1 , subscribeCounter . get ( ) ) ; assertEquals ( 1 , groupCounter . get ( ) ) ; assertEquals ( 20 , eventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; SYNC_INFINITE_OBSERVABLE_OF_EVENT ( 4 , subscribeCounter , sentEventCounter ) . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . take ( 2 ) . flatMap ( new Function < GroupedFlowable < Integer , Event > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( GroupedFlowable < Integer , Event > eventGroupedFlowable ) return eventGroupedFlowable . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "testUnsubscribe => Source: " + event . source + "  Message: " + event . message ; ) ; ) . take ( 30 ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; assertEquals ( 30 , eventCounter . get ( ) ) ; assertEquals ( 58 , sentEventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; SYNC_INFINITE_OBSERVABLE_OF_EVENT ( 4 , subscribeCounter , sentEventCounter ) . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . take ( 2 ) . flatMap ( new Function < GroupedFlowable < Integer , Event > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( GroupedFlowable < Integer , Event > eventGroupedFlowable ) int numToTake = 0 ; if ( eventGroupedFlowable . getKey ( ) == 1 ) numToTake = 10 ; else if ( eventGroupedFlowable . getKey ( ) == 2 ) numToTake = 5 ; return eventGroupedFlowable . take ( numToTake ) . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "testUnsubscribe => Source: " + event . source + "  Message: " + event . message ; ) ; ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; assertEquals ( 15 , eventCounter . get ( ) ) ; assertEquals ( 37 , sentEventCounter . get ( ) ) ; 
final AtomicInteger eventCounter = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Flowable . range ( 0 , 100 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i % 2 ; ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( GroupedFlowable < Integer , Integer > group ) if ( group . getKey ( ) == 0 ) return group . delay ( 100 , TimeUnit . MILLISECONDS ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t * 10 ; ) ; else return group ; ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) System . out . println ( "=> onComplete" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( Integer s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; if ( ! latch . await ( 3000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out" ) ; assertEquals ( 100 , eventCounter . get ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; Flowable . range ( 0 , 100 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i % 2 ; ) . subscribe ( new DefaultSubscriber < GroupedFlowable < Integer , Integer > > ( ) @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( GroupedFlowable < Integer , Integer > s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; if ( ! latch . await ( 500 , TimeUnit . MILLISECONDS ) ) fail ( "timed out - never got completion" ) ; assertEquals ( 100 , eventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; SYNC_INFINITE_OBSERVABLE_OF_EVENT ( 4 , subscribeCounter , sentEventCounter ) . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . flatMap ( new Function < GroupedFlowable < Integer , Event > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( GroupedFlowable < Integer , Event > eventGroupedFlowable ) Flowable < Event > eventStream = eventGroupedFlowable ; if ( eventGroupedFlowable . getKey ( ) >= 2 ) eventStream = eventGroupedFlowable . filter ( new Predicate < Event > ( ) @ Override public boolean test ( Event t1 ) return false ; ) ; return eventStream . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "testUnsubscribe => Source: " + event . source + "  Message: " + event . message ; ) ; ) . take ( 30 ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; assertEquals ( 30 , eventCounter . get ( ) ) ; assertEquals ( 60 , sentEventCounter . get ( ) ) ; 
final CountDownLatch first = new CountDownLatch ( 2 ) ; final ArrayList < String > results = new ArrayList < > ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > sub ) sub . onSubscribe ( new BooleanSubscription ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; try first . await ( ) ; catch ( InterruptedException e ) sub . onError ( e ) ; return ; sub . onNext ( 3 ) ; sub . onNext ( 3 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Integer , Integer > group ) if ( group . getKey ( ) < 3 ) return group . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "first groups: " + t1 ; ) . take ( 2 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) first . countDown ( ) ; ) ; else return group . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "last group: " + t1 ; ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 6 , results . size ( ) ) ; 
System . err . println ( "----------------------------------------------------------------------------------------------" ) ; final CountDownLatch first = new CountDownLatch ( 2 ) ; final ArrayList < String > results = new ArrayList < > ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > sub ) sub . onSubscribe ( new BooleanSubscription ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; try first . await ( ) ; catch ( InterruptedException e ) sub . onError ( e ) ; return ; sub . onNext ( 3 ) ; sub . onNext ( 3 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Integer , Integer > group ) if ( group . getKey ( ) < 3 ) return group . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "first groups: " + t1 ; ) . take ( 2 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) first . countDown ( ) ; ) ; else return group . subscribeOn ( Schedulers . newThread ( ) ) . delay ( 400 , TimeUnit . MILLISECONDS ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "last group: " + t1 ; ) . doOnEach ( new Consumer < Notification < String > > ( ) @ Override public void accept ( Notification < String > t1 ) System . err . println ( "subscribeOn notification => " + t1 ) ; ) ; ) . doOnEach ( new Consumer < Notification < String > > ( ) @ Override public void accept ( Notification < String > t1 ) System . err . println ( "outer notification => " + t1 ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 6 , results . size ( ) ) ; 
final CountDownLatch first = new CountDownLatch ( 2 ) ; final ArrayList < String > results = new ArrayList < > ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > sub ) sub . onSubscribe ( new BooleanSubscription ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; try first . await ( ) ; catch ( InterruptedException e ) sub . onError ( e ) ; return ; sub . onNext ( 3 ) ; sub . onNext ( 3 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Integer , Integer > group ) if ( group . getKey ( ) < 3 ) return group . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "first groups: " + t1 ; ) . take ( 2 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) first . countDown ( ) ; ) ; else return group . observeOn ( Schedulers . newThread ( ) ) . delay ( 400 , TimeUnit . MILLISECONDS ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "last group: " + t1 ; ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 6 , results . size ( ) ) ; 
final ArrayList < String > results = new ArrayList < > ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > sub ) sub . onSubscribe ( new BooleanSubscription ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Integer , Integer > group ) return group . subscribeOn ( Schedulers . newThread ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) System . out . println ( "Received: " + t1 + " on group : " + group . getKey ( ) ) ; return "first groups: " + t1 ; ) ; ) . doOnEach ( new Consumer < Notification < String > > ( ) @ Override public void accept ( Notification < String > t1 ) System . out . println ( "notification => " + t1 ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 4 , results . size ( ) ) ; 
final ArrayList < String > results = new ArrayList < > ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > sub ) sub . onSubscribe ( new BooleanSubscription ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Integer , Integer > group ) return group . observeOn ( Schedulers . newThread ( ) ) . delay ( 400 , TimeUnit . MILLISECONDS ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "first groups: " + t1 ; ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 4 , results . size ( ) ) ; 
return "Event => source: " + source + " message: " + message ; 
Flowable < Long > source = Flowable . interval ( 10 , TimeUnit . MILLISECONDS ) . take ( 1 ) ; Flowable < GroupedFlowable < Boolean , Long > > stream = source . groupBy ( IS_EVEN ) ; Subscriber < GroupedFlowable < Boolean , Long > > f1 = TestHelper . mockSubscriber ( ) ; Subscriber < GroupedFlowable < Boolean , Long > > f2 = TestHelper . mockSubscriber ( ) ; stream . subscribe ( f1 ) ; stream . subscribe ( f2 ) ; verify ( f1 , never ( ) ) . onError ( Mockito . < Throwable > any ( ) ) ; verify ( f2 , never ( ) ) . onError ( Mockito . < Throwable > any ( ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 4000 ) . groupBy ( IS_EVEN2 ) . flatMap ( new Function < GroupedFlowable < Boolean , Integer > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Boolean , Integer > g ) return g . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer l ) if ( g . getKey ( ) ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return l + " is even." ; else return l + " is odd." ; ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
Flowable < String > source = Flowable . fromIterable ( Arrays . asList ( "  foo" , " FoO " , "baR  " , "foO " , " Baz   " , "  qux " , "   bar" , " BAR  " , "FOO " , "baz  " , " bAZ " , "    fOo    " ) ) ; Function < String , String > keysel = new Function < String , String > ( ) @ Override public String apply ( String t1 ) return t1 . trim ( ) . toLowerCase ( ) ; ; Function < String , String > valuesel = new Function < String , String > ( ) @ Override public String apply ( String t1 ) return t1 + t1 ; ; Flowable < String > m = source . groupBy ( keysel , valuesel ) . flatMap ( new Function < GroupedFlowable < String , String > , Publisher < String > > ( ) @ Override public Publisher < String > apply ( final GroupedFlowable < String , String > g ) System . out . println ( "-----------> NEXT: " + g . getKey ( ) ) ; return g . take ( 2 ) . map ( new Function < String , String > ( ) int count ; @ Override public String apply ( String v ) System . out . println ( v ) ; return g . getKey ( ) + "-" + count ++ ; ) ; ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; m . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; System . out . println ( "ts .get " + ts . values ( ) ) ; ts . assertNoErrors ( ) ; assertEquals ( ts . values ( ) , Arrays . asList ( "foo-0" , "foo-1" , "bar-0" , "foo-0" , "baz-0" , "qux-0" , "bar-1" , "bar-0" , "foo-1" , "baz-1" , "baz-0" , "foo-0" ) ) ; 
Flowable < Integer > source = Flowable . just ( 0 , 1 , 2 , 3 , 4 , 5 , 6 ) ; Flowable < Integer > m = source . groupBy ( fail ( 0 ) , dbl ) . flatMap ( FLATTEN_INTEGER ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; m . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; ts . assertNoValues ( ) ; 
Flowable < Integer > source = Flowable . just ( 0 , 1 , 2 , 3 , 4 , 5 , 6 ) ; Flowable < Integer > m = source . groupBy ( identity , fail ( 0 ) ) . flatMap ( FLATTEN_INTEGER ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; m . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; ts . assertNoValues ( ) ; 
Flowable < Integer > source = Flowable . just ( 0 ) ; Flowable < Integer > m = source . groupBy ( identity , dbl ) . flatMap ( FLATTEN_INTEGER ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; m . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; System . out . println ( ts . values ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 0 ) ; final AtomicReference < GroupedFlowable < Integer , Integer > > inner = new AtomicReference < > ( ) ; Flowable < GroupedFlowable < Integer , Integer > > m = source . groupBy ( identity , dbl ) ; m . subscribe ( new Consumer < GroupedFlowable < Integer , Integer > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Integer > t1 ) inner . set ( t1 ) ; ) ; inner . get ( ) . subscribe ( ) ; Subscriber < Integer > subscriber2 = TestHelper . mockSubscriber ( ) ; inner . get ( ) . subscribe ( subscriber2 ) ; verify ( subscriber2 , never ( ) ) . onComplete ( ) ; verify ( subscriber2 , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( subscriber2 ) . onError ( any ( IllegalStateException . class ) ) ; 
Flowable < Integer > source = Flowable . concat ( Flowable . just ( 0 ) , Flowable . < Integer > error ( new TestException ( "Forced failure" ) ) ) ; Flowable < Integer > m = source . groupBy ( identity , dbl ) . flatMap ( FLATTEN_INTEGER ) ; TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; m . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; ts . assertValueCount ( 1 ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 4000 ) . groupBy ( IS_EVEN2 ) . flatMap ( new Function < GroupedFlowable < Boolean , Integer > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Boolean , Integer > g ) return g . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "//////////////////// COMPLETED-A" ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , String > ( ) int c ; @ Override public String apply ( Integer l ) if ( g . getKey ( ) ) if ( c ++ < 400 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return l + " is even." ; else return l + " is odd." ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "//////////////////// COMPLETED-B" ) ; ) ; ) . doOnEach ( new Consumer < Notification < String > > ( ) @ Override public void accept ( Notification < String > t1 ) System . out . println ( "NEXT: " + t1 ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 4000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) System . out . println ( "testgroupByBackpressure2 >> " + v ) ; ) . groupBy ( IS_EVEN2 ) . flatMap ( new Function < GroupedFlowable < Boolean , Integer > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( final GroupedFlowable < Boolean , Integer > g ) return g . take ( 2 ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer l ) if ( g . getKey ( ) ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return l + " is even." ; else return l + " is odd." ; ) ; , 4000 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
final String [ ] key = new String [ ] "uninitialized" ; final List < String > values = new ArrayList < > ( ) ; Flowable . just ( "a" , "b" , "c" ) . groupBy ( new Function < String , String > ( ) @ Override public String apply ( String value ) return null ; ) . subscribe ( new Consumer < GroupedFlowable < String , String > > ( ) @ Override public void accept ( GroupedFlowable < String , String > groupedFlowable ) key [ 0 ] = groupedFlowable . getKey ( ) ; groupedFlowable . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) values . add ( s ) ; ) ; ) ; assertNull ( key [ 0 ] ) ; assertEquals ( Arrays . asList ( "a" , "b" , "c" ) , values ) ; 
final Subscription s = mock ( Subscription . class ) ; Flowable < Integer > f = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( s ) ; ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; f . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer integer ) return null ; ) . subscribe ( ts ) ; ts . cancel ( ) ; verify ( s ) . cancel ( ) ; 
final Throwable e = new RuntimeException ( "Oops" ) ; final TestSubscriberEx < Integer > inner1 = new TestSubscriberEx < > ( ) ; final TestSubscriberEx < Integer > inner2 = new TestSubscriberEx < > ( ) ; final TestSubscriberEx < GroupedFlowable < Integer , Integer > > outer = new TestSubscriberEx < > ( new DefaultSubscriber < GroupedFlowable < Integer , Integer > > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( GroupedFlowable < Integer , Integer > f ) if ( f . getKey ( ) == 0 ) f . subscribe ( inner1 ) ; else f . subscribe ( inner2 ) ; ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 0 ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( e ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i % 2 ; ) . subscribe ( outer ) ; assertEquals ( Arrays . asList ( e ) , outer . errors ( ) ) ; assertEquals ( Arrays . asList ( e ) , inner1 . errors ( ) ) ; assertEquals ( Arrays . asList ( e ) , inner2 . errors ( ) ) ; 
final AtomicBoolean completed = new AtomicBoolean ( false ) ; Flowable . just ( 1 , 2 , 3 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return 1 ; ) . concatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( GroupedFlowable < Integer , Integer > g ) return g ; ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 2 ) ; @ Override public void onComplete ( ) completed . set ( true ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) System . out . println ( t ) ; request ( Long . MAX_VALUE - 1 ) ; ) ; assertTrue ( completed . get ( ) ) ; 
int n = 500 ; for ( int j = 0 ; j < 1000 ; j ++ ) Flowable . merge ( Flowable . range ( 0 , n ) . groupBy ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer i ) return i % ( Flowable . bufferSize ( ) + 2 ) ; ) . observeOn ( Schedulers . computation ( ) , false , n ) , n ) . blockingLast ( ) ; 
for ( int j = 0 ; j < 1000 ; j ++ ) Flowable . merge ( Flowable . range ( 0 , 500 ) . groupBy ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer i ) return i % ( Flowable . bufferSize ( ) + 2 ) ; ) . observeOn ( Schedulers . computation ( ) ) ) . blockingLast ( ) ; 
TestSubscriber < GroupedFlowable < Integer , Integer > > ts = new TestSubscriber < > ( 0L ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) . doOnNext ( new Consumer < GroupedFlowable < Integer , Integer > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Integer > g ) g . subscribe ( ) ; ) . subscribe ( ts ) ; ts . request ( 1 ) ; pp . onNext ( 1 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 1 ) ; 
TestSubscriber < GroupedFlowable < Integer , Integer > > ts = new TestSubscriber < > ( 1 ) ; Flowable . fromArray ( 1 , 2 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) . doOnNext ( new Consumer < GroupedFlowable < Integer , Integer > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Integer > g ) g . subscribe ( ) ; ) . subscribe ( ts ) ; ts . assertValueCount ( 1 ) . assertError ( MissingBackpressureException . class ) . assertNotComplete ( ) ; 
TestSubscriber < Object > ts1 = new TestSubscriber < > ( 1L ) ; final TestSubscriber < Object > ts2 = new TestSubscriber < > ( 0L ) ; Flowable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . groupBy ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) return 1 ; ) . doOnNext ( new Consumer < GroupedFlowable < Object , Integer > > ( ) @ Override public void accept ( GroupedFlowable < Object , Integer > g ) g . subscribe ( ts2 ) ; ) . subscribe ( ts1 ) ; ts1 . assertValueCount ( 1 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; ts2 . assertNoValues ( ) ; ts2 . assertNoErrors ( ) ; ts2 . assertNotComplete ( ) ; ts2 . request ( Flowable . bufferSize ( ) * 2 ) ; ts2 . assertValueCount ( Flowable . bufferSize ( ) * 2 ) ; ts2 . assertNoErrors ( ) ; ts2 . assertComplete ( ) ; 
final TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; final TestSubscriberEx < GroupedFlowable < Integer , Integer > > ts2 = new TestSubscriberEx < GroupedFlowable < Integer , Integer > > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 10 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return 1 ; , new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v + 1 ; ) . doOnNext ( new Consumer < GroupedFlowable < Integer , Integer > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Integer > g ) g . subscribe ( ts1 ) ; ) . subscribe ( ts2 ) ; ts1 . assertFusionMode ( QueueFuseable . NONE ) . assertValues ( 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ) . assertNoErrors ( ) . assertComplete ( ) ; ts2 . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . groupBy ( Functions . < Integer > identity ( ) , true ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( GroupedFlowable < Integer , Integer > g ) throws Exception return g ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . groupBy ( Functions . < Integer > identity ( ) , Functions . < Integer > identity ( ) , true ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( GroupedFlowable < Integer , Integer > g ) throws Exception return g ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . groupBy ( Functions . justFunction ( 1 ) ) ) ; Flowable . just ( 1 ) . groupBy ( Functions . justFunction ( 1 ) ) . doOnNext ( new Consumer < GroupedFlowable < Integer , Integer > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Integer > g ) throws Exception TestHelper . checkDisposed ( g ) ; ) . test ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onComplete ( ) ; ; Flowable . merge ( pp . groupBy ( Functions . justFunction ( 1 ) ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onComplete ( ) ; dispose ( ) ; ; Flowable . merge ( pp . groupBy ( Functions . justFunction ( 1 ) ) ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertSubscribed ( ) . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
Flowable . just ( 1 ) . groupBy ( Functions . justFunction ( 1 ) , true ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertResult ( 1 ) ; 
TestSubscriberEx < Flowable < Integer > > ts = new TestSubscriberEx < Flowable < Integer > > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . just ( 1 ) . groupBy ( Functions . justFunction ( 1 ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertValueCount ( 1 ) . assertComplete ( ) . assertNoErrors ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . groupBy ( Functions . justFunction ( 1 ) ) ; , false , 1 , 1 , ( Object [ ] ) null ) ; 
TestHelper . assertBadRequestReported ( Flowable . just ( 1 ) . hide ( ) . groupBy ( Functions . justFunction ( 1 ) ) ) ; 
Flowable . just ( 1 ) . hide ( ) . groupBy ( Functions . justFunction ( 1 ) ) . doOnNext ( g -> TestHelper . assertBadRequestReported ( g ) ; ) . test ( ) . assertNoErrors ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < GroupedFlowable < Integer , Object > > > ( ) @ Override public Publisher < GroupedFlowable < Integer , Object > > apply ( Flowable < Object > f ) throws Exception return f . groupBy ( Functions . justFunction ( 1 ) ) ; ) ; 
Flowable . just ( 1 ) . groupBy ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return null ; ) . flatMap ( new Function < GroupedFlowable < Object , Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( GroupedFlowable < Object , Integer > g ) throws Exception return g . take ( 1 ) ; ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . groupBy ( Functions . justFunction ( 1 ) , true ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( GroupedFlowable < Integer , Integer > g ) throws Exception return g . hide ( ) ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Flowable . just ( 1 ) . groupBy ( Functions . justFunction ( 1 ) , true ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( GroupedFlowable < Integer , Integer > g ) throws Exception return g . hide ( ) ; ) . test ( ) . assertResult ( 1 ) ; 
final IOException ex = new IOException ( "boo" ) ; Function < Consumer < Object > , Map < Integer , Object > > evictingMapFactory = new Function < Consumer < Object > , Map < Integer , Object > > ( ) @ Override public Map < Integer , Object > apply ( final Consumer < Object > notify ) throws Exception throw ex ; ; Flowable . just ( 1 ) . groupBy ( Functions . < Integer > identity ( ) , Functions . identity ( ) , true , 16 , evictingMapFactory ) . test ( ) . assertNoValues ( ) . assertError ( ex ) ; 
return new Function < GroupedFlowable < Integer , Integer > , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( final GroupedFlowable < Integer , Integer > g ) throws Exception return g . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception completed . add ( g . getKey ( ) ) ; ) ; ; 
return tick ; 
final List < Integer > completed = new CopyOnWriteArrayList < > ( ) ; Function < Consumer < Object > , Map < Integer , Object > > evictingMapFactory = createEvictingMapFactorySynchronousOnly ( 1 ) ; PublishSubject < Integer > subject = PublishSubject . create ( ) ; TestSubscriberEx < Integer > ts = subject . toFlowable ( BackpressureStrategy . BUFFER ) . groupBy ( Functions . < Integer > identity ( ) , Functions . < Integer > identity ( ) , true , 16 , evictingMapFactory ) . flatMap ( addCompletedKey ( completed ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; subject . onNext ( 1 ) ; subject . onNext ( 2 ) ; subject . onNext ( 3 ) ; ts . assertValues ( 1 , 2 , 3 ) . assertNotTerminated ( ) ; assertEquals ( Arrays . asList ( 1 , 2 ) , completed ) ; subject . onComplete ( ) ; ts . assertComplete ( ) ; ts . assertValueCount ( 3 ) ; 
Function < Consumer < Object > , Map < Integer , Object > > evictingMapFactory = createEvictingMapFactorySynchronousOnly ( 1 ) ; PublishSubject < Integer > subject = PublishSubject . create ( ) ; TestSubscriber < Integer > ts = subject . toFlowable ( BackpressureStrategy . BUFFER ) . groupBy ( Functions . < Integer > identity ( ) , Functions . < Integer > identity ( ) , true , 16 , evictingMapFactory ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( GroupedFlowable < Integer , Integer > g ) throws Exception return g ; ) . test ( ) ; RuntimeException ex = new RuntimeException ( ) ; subject . onError ( ex ) ; ts . assertNoValues ( ) . assertError ( ex ) ; 
final List < Integer > completed = new CopyOnWriteArrayList < > ( ) ; AtomicReference < Cache < Integer , Object > > cacheOut = new AtomicReference < > ( ) ; Function < Consumer < Object > , Map < Integer , Object > > evictingMapFactory = createEvictingMapFactoryGuava ( 3 , cacheOut ) ; int numValues = 1000 ; TestSubscriber < Integer > ts = Flowable . range ( 1 , numValues ) . groupBy ( mod5 , Functions . < Integer > identity ( ) , true , 16 , evictingMapFactory ) . flatMap ( addCompletedKey ( completed ) ) . test ( ) . assertComplete ( ) ; ts . assertValueCount ( numValues ) ; assertTrue ( completed . size ( ) > numValues * 0.9 ) ; cacheOut . get ( ) . invalidateAll ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final TestTicker testTicker = new TestTicker ( ) ; Function < Consumer < Object > , Map < Integer , Object > > mapFactory = new Function < Consumer < Object > , Map < Integer , Object > > ( ) @ Override public Map < Integer , Object > apply ( final Consumer < Object > action ) throws Exception return CacheBuilder . newBuilder ( ) . expireAfterAccess ( 5 , TimeUnit . SECONDS ) . removalListener ( new RemovalListener < Object , Object > ( ) @ Override public void onRemoval ( RemovalNotification < Object , Object > notification ) try action . accept ( notification . getValue ( ) ) ; catch ( Throwable ex ) throw new RuntimeException ( ex ) ; ) . ticker ( testTicker ) . < Integer , Object > build ( ) . asMap ( ) ; ; final List < String > list = new CopyOnWriteArrayList < > ( ) ; Flowable < Integer > stream = source . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "Source canceled" ) ; ) . < Integer , Integer > groupBy ( Functions . < Integer > identity ( ) , Functions . < Integer > identity ( ) , false , Flowable . bufferSize ( ) , mapFactory ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( GroupedFlowable < Integer , Integer > group ) throws Exception return group . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "Group completed" ) ; ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "Group canceled" ) ; ) ; ) ; TestSubscriber < Integer > ts = stream . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "Outer group by canceled" ) ; ) . test ( ) ; source . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 1 ) ; ts . awaitCount ( 3 ) ; testTicker . tick = TimeUnit . SECONDS . toNanos ( 6 ) ; source . onNext ( 1 ) ; ts . awaitCount ( 4 ) ; ts . cancel ( ) ; System . out . println ( list ) ; assertTrue ( list . contains ( "Source canceled" ) ) ; assertEquals ( Arrays . asList ( "Group completed" , "Outer group by canceled" , "Group canceled" , "Source canceled" ) , list ) ; 
return map . size ( ) ; 
return map . isEmpty ( ) ; 
return map . containsKey ( key ) ; 
return map . containsValue ( value ) ; 
return map . get ( key ) ; 
list . remove ( key ) ; return map . remove ( key ) ; 
for ( Entry < ? extends K , ? extends V > entry : m . entrySet ( ) ) put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
list . clear ( ) ; map . clear ( ) ; 
return map . keySet ( ) ; 
return map . values ( ) ; 
return map . entrySet ( ) ; 
final AtomicBoolean cancelled = new AtomicBoolean ( ) ; Flowable . just ( 1 ) . repeat ( ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception cancelled . set ( true ) ; ) . groupBy ( Functions . < Integer > identity ( ) , Functions . < Integer > identity ( ) ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < ? extends Object > > ( ) @ Override public Publisher < ? extends Object > apply ( GroupedFlowable < Integer , Integer > g ) throws Exception return g . first ( 0 ) . toFlowable ( ) ; ) . take ( 4 ) . test ( ) . assertComplete ( ) ; assertTrue ( cancelled . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Throwable return v % 10 ; , Functions . < Integer > identity ( ) , false , 2048 ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , GroupedFlowable < Integer , Integer > > ( ) @ Override public GroupedFlowable < Integer , Integer > apply ( GroupedFlowable < Integer , Integer > v ) throws Throwable return v ; ) . subscribe ( ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) pp . onNext ( j ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertFalse ( "Round " + i , pp . hasSubscribers ( ) ) ; 
final List < GroupedFlowable < Integer , Integer > > groups = new ArrayList < > ( ) ; Flowable . range ( 1 , 1000 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Throwable return v % 10 ; ) . doOnNext ( new Consumer < GroupedFlowable < Integer , Integer > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Integer > v ) throws Throwable groups . add ( v ) ; ) . test ( ) . assertValueCount ( 1000 ) . assertComplete ( ) . assertNoErrors ( ) ; Flowable . concat ( groups ) . test ( ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestSubscriber < Object > ts1 = new TestSubscriber < > ( ) ; final TestSubscriber < Object > ts2 = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . groupBy ( Functions . < Integer > identity ( ) , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Throwable throw new TestException ( ) ; ) . doOnNext ( new Consumer < GroupedFlowable < Integer , Object > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Object > g ) throws Throwable g . subscribe ( ts2 ) ; ) . subscribe ( ts1 ) ; ts1 . assertValueCount ( 1 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; ts2 . assertFailure ( TestException . class ) ; 
TestSubscriber < Object > ts1 = new TestSubscriber < > ( ) ; final TestSubscriber < Object > ts2 = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . groupBy ( Functions . justFunction ( 1 ) , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Throwable if ( v == 2 ) throw new TestException ( ) ; return v ; ) . doOnNext ( new Consumer < GroupedFlowable < Integer , Object > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Object > g ) throws Throwable g . subscribe ( ts2 ) ; ) . subscribe ( ts1 ) ; ts1 . assertValueCount ( 1 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; ts2 . assertFailure ( TestException . class , 1 ) ; 
Flowable . range ( 0 , 500000 ) . subscribeOn ( Schedulers . single ( ) ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) throws Throwable return i % 2 ; ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( GroupedFlowable < Integer , Integer > g ) return g . getKey ( ) == 0 ? g . parallel ( ) . runOn ( Schedulers . computation ( ) ) . map ( Functions . < Integer > identity ( ) ) . sequential ( ) : g . map ( Functions . < Integer > identity ( ) ) ; ) . test ( ) . awaitDone ( 20 , TimeUnit . SECONDS ) . assertValueCount ( 500000 ) . assertComplete ( ) . assertNoErrors ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriberEx < GroupedFlowable < Integer , Integer > > ts = pp . groupBy ( Functions . justFunction ( 1 ) , new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) throws Throwable throw new TestException ( ) ; ) . subscribeWith ( new TestSubscriberEx < > ( 0L ) ) ; assertTrue ( pp . offer ( 1 ) ) ; ts . assertFailure ( MissingBackpressureException . class ) ; assertTrue ( "" + ts . errors ( ) . get ( 0 ) . getCause ( ) , ts . errors ( ) . get ( 0 ) . getCause ( ) instanceof TestException ) ; 
Flowable . just ( 1 ) . groupBy ( Functions . < Integer > identity ( ) ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( GroupedFlowable < Integer , Integer > g ) throws Throwable return g . observeOn ( ImmediateThinScheduler . INSTANCE ) . take ( 1 ) ; ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 100 ) . groupBy ( Functions . < Integer , Integer > justFunction ( 1 ) ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( GroupedFlowable < Integer , Integer > g ) throws Throwable return g . observeOn ( Schedulers . io ( ) ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Throwable Thread . sleep ( 100 ) ; ) . take ( 1 ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
final List < TestSubscriber < Integer > > tss = new ArrayList < > ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicBoolean done = new AtomicBoolean ( ) ; Flowable . range ( 1 , 1000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception counter . getAndIncrement ( ) ; ) . groupBy ( Functions . justFunction ( 1 ) ) . subscribe ( new Consumer < GroupedFlowable < Integer , Integer > > ( ) @ Override public void accept ( GroupedFlowable < Integer , Integer > v ) throws Exception TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; tss . add ( ts ) ; v . subscribe ( ts ) ; , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) throws Exception done . set ( true ) ; ) ; while ( ! done . get ( ) ) tss . remove ( 0 ) . cancel ( ) ; assertEquals ( 1000 , counter . get ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . groupBy ( v -> 1 , true ) . flatMap ( g -> g . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; ) ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
Flowable . just ( 1 ) . groupBy ( v -> 1 ) . doOnNext ( g -> g . subscribeWith ( new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . SYNC ) ) . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) ; ) . test ( ) . assertComplete ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; pp . groupBy ( v -> 1 ) . doOnNext ( g -> TestHelper . raceOther ( ( ) -> g . subscribe ( ts ) ; , cdl ) ; ) . test ( ) ; pp . onNext ( 1 ) ; cdl . await ( ) ; ts . assertValueCount ( 1 ) ; 
FlowableTransformer < Integer , Integer > operation = source -> source . publish ( shared -> shared . firstElement ( ) . flatMapPublisher ( firstElement -> Flowable . just ( firstElement ) . concatWith ( shared ) ) ) ; issue6974Run ( 20 , 500_000 , 20 - 1 , 20 * 2 , operation , false ) ; issue6974Run ( 20 , 500_000 , 20 , 20 * 2 , operation , false ) ; 
final int groups = 20 ; int groupByBufferSize = groups * 2 ; int flatMapMaxConcurrency = 2 * groups ; boolean notifyOnExplicitEviction = false ; issue6974RunPart2 ( groupByBufferSize , flatMapMaxConcurrency , groups , notifyOnExplicitEviction ) ; 
final int groups = 20 ; int groupByBufferSize = groups * 30 ; int flatMapMaxConcurrency = 2 * groups ; boolean notifyOnExplicitEviction = true ; issue6974RunPart2 ( groupByBufferSize , flatMapMaxConcurrency , groups , notifyOnExplicitEviction ) ; 
final int groups = 20 ; int groupByBufferSize = groups * 2 ; int flatMapMaxConcurrency = 2 * groups ; boolean notifyOnExplicitEviction = false ; issue6974RunPart2NoEvict ( groupByBufferSize , flatMapMaxConcurrency , groups , notifyOnExplicitEviction ) ; 
final int groups = 20 ; int groupByBufferSize = groups * 2 ; int flatMapMaxConcurrency = 2 * groups ; boolean notifyOnExplicitEviction = false ; Flowable . range ( 1 , 500_000 ) . map ( i -> i % groups ) . doOnCancel ( ( ) -> System . out . println ( "Cancelling upstream" ) ; ) . groupBy ( i -> i , i -> i , false , groupByBufferSize , sizeCap ( groups * 2 , notifyOnExplicitEviction ) ) . flatMap ( gf -> gf . observeOn ( Schedulers . computation ( ) ) . take ( 10 , TimeUnit . MILLISECONDS ) , flatMapMaxConcurrency ) . subscribeWith ( new TestSubscriberEx < > ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertTerminated ( ) ; 
final int groups = 20 ; int groupByBufferSize = groups * 2 ; int flatMapMaxConcurrency = 2 * groups ; boolean notifyOnExplicitEviction = false ; Flowable . range ( 1 , 500_000 ) . map ( i -> i % groups ) . doOnCancel ( ( ) -> System . out . println ( "Cancelling upstream" ) ) . groupBy ( i -> i , i -> i , false , groupByBufferSize , sizeCap ( groups * 2 , notifyOnExplicitEviction ) ) . flatMap ( gf -> gf . hide ( ) . observeOn ( Schedulers . computation ( ) ) . take ( 10 , TimeUnit . MILLISECONDS ) , flatMapMaxConcurrency ) . subscribeWith ( new TestSubscriberEx < > ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertTerminated ( ) ; 
final int groups = 20 ; int flatMapMaxConcurrency = 1_000_000 ; Flowable . range ( 1 , 500_000 ) . map ( i -> i % groups ) . doOnRequest ( v -> System . out . println ( "Source: " + v ) ; ) . groupBy ( i -> i ) . flatMap ( gf -> gf . observeOn ( Schedulers . computation ( ) ) . take ( 10 , TimeUnit . MILLISECONDS ) , flatMapMaxConcurrency ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
final int groups = 20 ; int flatMapMaxConcurrency = 1_000_000 ; Flowable . range ( 1 , 500_000 ) . map ( i -> i % groups ) . doOnRequest ( v -> System . out . println ( "Source: " + v ) ; ) . groupBy ( i -> i ) . flatMap ( gf -> gf . hide ( ) . observeOn ( Schedulers . computation ( ) ) . take ( 10 , TimeUnit . MILLISECONDS ) , flatMapMaxConcurrency ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
final int groups = 20 ; int groupByBufferSize = groups * 2 ; int flatMapMaxConcurrency = 2 * groups ; boolean notifyOnExplicitEviction = false ; Flowable . range ( 1 , 500_000 ) . map ( i -> i % groups ) . doOnCancel ( ( ) -> System . out . println ( "Cancelling upstream" ) ) . groupBy ( i -> i , i -> i , false , groupByBufferSize , sizeCap ( groups * 2 , notifyOnExplicitEviction ) ) . flatMap ( gf -> gf . observeOn ( Schedulers . computation ( ) ) . filter ( v -> true ) . take ( 10 , TimeUnit . MILLISECONDS ) , flatMapMaxConcurrency ) . subscribeWith ( new TestSubscriberEx < > ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertTerminated ( ) ; 
final int groups = 20 ; int groupByBufferSize = groups * 2 ; int flatMapMaxConcurrency = 2 * groups ; boolean notifyOnExplicitEviction = false ; Flowable . range ( 1 , 500_000 ) . map ( i -> i % groups ) . doOnCancel ( ( ) -> System . out . println ( "Cancelling upstream" ) ) . groupBy ( i -> i , i -> i , false , groupByBufferSize , sizeCap ( groups * 2 , notifyOnExplicitEviction ) ) . flatMap ( gf -> gf . hide ( ) . observeOn ( Schedulers . computation ( ) ) . filter ( v -> true ) . take ( 10 , TimeUnit . MILLISECONDS ) , flatMapMaxConcurrency ) . subscribeWith ( new TestSubscriberEx < > ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertTerminated ( ) ; 
return itemEvictConsumer -> CacheBuilder . newBuilder ( ) . expireAfterWrite ( ttl ) . removalListener ( n -> if ( n . getCause ( ) != com . google . common . cache . RemovalCause . EXPLICIT ) try itemEvictConsumer . accept ( n . getValue ( ) ) ; catch ( Throwable throwable ) throw new RuntimeException ( throwable ) ; ) . < T , Object > build ( ) . asMap ( ) ; 
final int groups = 20 ; int groupByBufferSize = 2 ; int flatMapMaxConcurrency = 200 * groups ; Flowable . range ( 1 , 500_000 ) . map ( i -> i % groups ) . groupBy ( i -> i , i -> i , false , groupByBufferSize , ttlCapGuava ( Duration . ofMillis ( 10 ) ) ) . flatMap ( gf -> gf . observeOn ( Schedulers . computation ( ) ) , flatMapMaxConcurrency ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
final int groups = 20 ; int groupByBufferSize = groups * 30 ; int flatMapMaxConcurrency = groups * 500 ; Flowable . range ( 1 , 500_000 ) . map ( i -> i % groups ) . groupBy ( i -> i , i -> i , false , groupByBufferSize , ttlCapGuava ( Duration . ofMillis ( 10 ) ) ) . flatMap ( gf -> gf . observeOn ( Schedulers . computation ( ) ) , flatMapMaxConcurrency ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestHelper . checkUtilityClass ( FlowableInternalHelper . class ) ; 
TestHelper . checkEnum ( FlowableInternalHelper . RequestMax . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 2 ) . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return Math . max ( a , b ) ; ) . toFlowable ( ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Arrays . asList ( v , v + 1 ) ; ) . subscribe ( ts ) ; ts . assertValues ( 2 , 3 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatMapIterable ( mapper ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . flatMapIterable ( mapper ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; Flowable . range ( 1 , 5 ) . concatMapIterable ( mapper ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 7 ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; int n = 1000 * 1000 ; Flowable . range ( 1 , n ) . concatMapIterable ( mapper ) . subscribe ( ts ) ; ts . assertValueCount ( n * 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; int n = 1000 * 1000 ; Flowable . range ( 1 , n ) . concatMapIterable ( mapper ) . concatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) . subscribe ( ts ) ; ts . assertValueCount ( n * 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . concatMapIterable ( mapper ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapIterable ( mapper ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . < Integer > empty ( ) . concatMapIterable ( mapper ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . < Integer > just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . concatMapIterable ( mapper ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) throw new TestException ( ) ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; Flowable . range ( 1 , 2 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return it ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) throw new TestException ( ) ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; Flowable . just ( 1 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return it ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count >= 2 ) throw new TestException ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; Flowable . range ( 1 , 2 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return it ; ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; Flowable . range ( 1 , 2 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return it ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return it ; ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; Assert . assertFalse ( "PublishProcessor has Subscribers?!" , pp . hasSubscribers ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , 1000 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return ( v % 2 ) == 0 ? Collections . singleton ( 1 ) : Collections . < Integer > emptySet ( ) ; ) . subscribe ( ts ) ; ts . assertValueCount ( 500 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Flowable . range ( 1 , 2 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return v == 2 ? Collections . singleton ( 1 ) : Collections . < Integer > emptySet ( ) ; ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1 ) ; Flowable . range ( 1 , 1000 ) . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return v == 1000 ? Collections . singleton ( 1 ) : Collections . < Integer > emptySet ( ) ; ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; final Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) counter . getAndIncrement ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . concatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return it ; ) . take ( 1 ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; Assert . assertFalse ( "PublishProcessor has Subscribers?!" , pp . hasSubscribers ( ) ) ; Assert . assertEquals ( 1 , counter . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . flatMapIterable ( mapper , 2 ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 1 , 5 ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Collections . singletonList ( 1 ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return a * 10 + b ; , 2 ) . subscribe ( ts ) ; ts . assertValues ( 11 , 21 , 31 , 41 , 51 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . just ( 1 , 2 ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer t ) throws Exception return Arrays . asList ( t * 10 ) ; , 1 ) . test ( ) . assertResult ( 10 , 20 ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . flatMapIterable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Arrays . asList ( 10 , 20 ) ; ) ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . flatMapIterable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Arrays . asList ( 10 , 20 ) ; ) ; , false , 1 , 1 , 10 , 20 ) ; 
Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) . flatMapIterable ( Functions . justFunction ( Arrays . asList ( 1 , 2 , 3 ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 , 2 ) . flatMapIterable ( Functions . justFunction ( Arrays . asList ( 1 , 2 , 3 ) ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < Integer > qs = ( QueueSubscription < Integer > ) s ; assertEquals ( QueueFuseable . SYNC , qs . requestFusion ( QueueFuseable . ANY ) ) ; try assertFalse ( "Source reports being empty!" , qs . isEmpty ( ) ) ; assertEquals ( 1 , qs . poll ( ) . intValue ( ) ) ; assertFalse ( "Source reports being empty!" , qs . isEmpty ( ) ) ; assertEquals ( 2 , qs . poll ( ) . intValue ( ) ) ; assertFalse ( "Source reports being empty!" , qs . isEmpty ( ) ) ; qs . clear ( ) ; assertTrue ( "Source reports not empty!" , qs . isEmpty ( ) ) ; assertNull ( qs . poll ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; 
Flowable . just ( 1 , 2 , 3 ) . flatMapIterable ( Functions . justFunction ( Arrays . asList ( 1 , 2 , 3 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 ) ; 
Flowable . just ( 1 , 2 , 3 ) . hide ( ) . flatMapIterable ( Functions . justFunction ( Collections . emptyList ( ) ) , 1 ) . test ( ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . just ( 1 , 2 , 3 ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception if ( ( v & 1 ) == 0 ) return Collections . emptyList ( ) ; return Arrays . asList ( 1 , 2 ) ; ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 1 , 2 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . just ( 1 , 2 , 3 ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception if ( ( v & 1 ) == 1 ) return Collections . emptyList ( ) ; return Arrays . asList ( 1 , 2 ) ; ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . just ( 1 , 2 , 3 ) . hide ( ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return Arrays . asList ( 1 , 2 ) ; ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 1 , 2 , 1 , 2 ) ; 
Flowable . just ( 1 , 2 , 3 ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception if ( ( v & 1 ) == 0 ) return Collections . emptyList ( ) ; return Arrays . asList ( v ) ; ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < Integer > qs = ( QueueSubscription < Integer > ) s ; assertEquals ( QueueFuseable . SYNC , qs . requestFusion ( QueueFuseable . ANY ) ) ; try assertFalse ( "Source reports being empty!" , qs . isEmpty ( ) ) ; assertEquals ( 1 , qs . poll ( ) . intValue ( ) ) ; assertFalse ( "Source reports being empty!" , qs . isEmpty ( ) ) ; assertEquals ( 3 , qs . poll ( ) . intValue ( ) ) ; assertTrue ( "Source reports being non-empty!" , qs . isEmpty ( ) ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; 
Flowable . range ( 1 , 3 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . flatMapIterable ( Functions . justFunction ( Collections . emptyList ( ) ) , 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 3 ) . flatMapIterable ( Functions . justFunction ( Arrays . asList ( 1 ) ) , 1 ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; . flatMapIterable ( Functions . justFunction ( Arrays . asList ( 1 ) ) , 1 ) . test ( 0L ) . assertFailure ( MissingBackpressureException . class ) ; 
Flowable . range ( 1 , 3 ) . hide ( ) . flatMapIterable ( Functions . justFunction ( Arrays . asList ( 1 ) ) , 1 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 1 , 1 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 3 ) . hide ( ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new Iterable < Integer > ( ) int count ; @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) if ( ++ count == 2 ) ts . cancel ( ) ; ts . onComplete ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
Iterable < Integer > it = Flowable . range ( 1 , 300 ) . blockingIterable ( ) ; Flowable . just ( it , it ) . flatMapIterable ( Functions . < Iterable < Integer > > identity ( ) ) . share ( ) . share ( ) . count ( ) . test ( ) . assertResult ( 600L ) ; 
Iterable < Integer > it = Flowable . range ( 1 , 300 ) . blockingIterable ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) Flowable < Integer > f = Flowable . just ( it , it ) . flatMapIterable ( Functions . < Iterable < Integer > > identity ( ) ) ; for ( int j = 0 ; j < i ; j ++ ) f = f . share ( ) ; f . count ( ) . test ( ) . withTag ( "Share: " + i ) . assertResult ( 600L ) ; 
Iterable < Integer > it = Flowable . range ( 1 , 300 ) . blockingIterable ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) Flowable < Integer > f = Flowable . just ( it , it ) . flatMapIterable ( Functions . < Iterable < Integer > > identity ( ) ) . hide ( ) ; for ( int j = 0 ; j < i ; j ++ ) f = f . share ( ) ; f . count ( ) . test ( ) . withTag ( "Share: " + i ) . assertResult ( 600L ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception counter . getAndIncrement ( ) ; ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , counter . get ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . flatMapIterable ( Functions . justFunction ( Collections . emptyList ( ) ) ) ; ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; FlattenIterableSubscriber < Integer , Integer > f = new FlattenIterableSubscriber < > ( ts , Functions . justFunction ( Collections . < Integer > emptyList ( ) ) , 128 ) ; final AtomicLong requested = new AtomicLong ( ) ; f . onSubscribe ( new QueueSubscription < Integer > ( ) @ Override public int requestFusion ( int mode ) return 0 ; @ Override public boolean offer ( Integer value ) return false ; @ Override public boolean offer ( Integer v1 , Integer v2 ) return false ; @ Override public Integer poll ( ) throws Exception return null ; @ Override public boolean isEmpty ( ) return false ; @ Override public void clear ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; assertEquals ( 128 , requested . get ( ) ) ; assertNotNull ( f . queue ) ; ts . assertEmpty ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; FlattenIterableSubscriber < Integer , Integer > f = new FlattenIterableSubscriber < > ( ts , Functions . justFunction ( Collections . < Integer > emptyList ( ) ) , 128 ) ; f . onSubscribe ( new BooleanSubscription ( ) ) ; f . onError ( new TestException ( "first" ) ) ; ts . assertFailureAndMessage ( TestException . class , "first" ) ; assertTrue ( errors . isEmpty ( ) ) ; f . done = false ; f . onError ( new TestException ( "second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . flatMapIterable ( Functions . justFunction ( Collections . emptyList ( ) ) ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; FlattenIterableSubscriber < Integer , Integer > f = new FlattenIterableSubscriber < > ( ts , Functions . justFunction ( Arrays . < Integer > asList ( 1 , 2 ) ) , 128 ) ; f . onSubscribe ( new BooleanSubscription ( ) ) ; f . onNext ( 1 ) ; assertFalse ( f . isEmpty ( ) ) ; assertEquals ( 1 , f . poll ( ) . intValue ( ) ) ; assertFalse ( f . isEmpty ( ) ) ; assertEquals ( 2 , f . poll ( ) . intValue ( ) ) ; assertTrue ( f . isEmpty ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; FlattenIterableSubscriber < Integer , Integer > f = new FlattenIterableSubscriber < > ( ts , Functions . justFunction ( Arrays . < Integer > asList ( 1 , 2 ) ) , 128 ) ; f . onSubscribe ( new BooleanSubscription ( ) ) ; f . fusionMode = QueueFuseable . NONE ; assertEquals ( QueueFuseable . NONE , f . requestFusion ( QueueFuseable . SYNC ) ) ; assertEquals ( QueueFuseable . NONE , f . requestFusion ( QueueFuseable . ASYNC ) ) ; f . fusionMode = QueueFuseable . SYNC ; assertEquals ( QueueFuseable . SYNC , f . requestFusion ( QueueFuseable . SYNC ) ) ; assertEquals ( QueueFuseable . NONE , f . requestFusion ( QueueFuseable . ASYNC ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . skipLast ( 1000 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; scheduler . advanceTimeBy ( 950 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 5 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 6 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . skipLast ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 1050 , TimeUnit . MILLISECONDS ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . skipLast ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . skipLast ( 1 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ) . skipLast ( 300 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ) . skipLast ( 300 , TimeUnit . MILLISECONDS , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ) . skipLast ( 300 , TimeUnit . MILLISECONDS , Schedulers . io ( ) , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . skipLast ( 1 , TimeUnit . DAYS ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . skipLast ( 1 , TimeUnit . DAYS ) ; ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . skipLast ( 1 , TimeUnit . DAYS , scheduler ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Flowable . error ( new TestException ( ) ) . skipLast ( 1 , TimeUnit . DAYS , new TestScheduler ( ) , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . skipLast ( 0 , TimeUnit . SECONDS ) . take ( 1 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 1000 ) . skipLast ( 0 , TimeUnit . SECONDS ) . observeOn ( Schedulers . single ( ) , false , 16 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 1000 ) . assertComplete ( ) . assertNoErrors ( ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . skipLast ( 1 , TimeUnit . MINUTES ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . skipLast ( 0 , TimeUnit . MILLISECONDS , true ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 1 ) ; pp . onComplete ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertComplete ( ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; Completable cmp = Flowable . just ( "Hello World!" ) . ignoreElements ( ) ; cmp . < String > toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertNoValues ( ) ; subscriber . assertComplete ( ) ; subscriber . assertNoErrors ( ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; IllegalArgumentException error = new IllegalArgumentException ( "Error" ) ; Completable cmp = Flowable . < String > error ( error ) . ignoreElements ( ) ; cmp . < String > toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertError ( error ) ; subscriber . assertNoValues ( ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; Completable cmp = Flowable . just ( "First" , "Second" ) . ignoreElements ( ) ; cmp . < String > toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertNoErrors ( ) ; subscriber . assertNoValues ( ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; Completable cmp = Flowable . < String > empty ( ) . ignoreElements ( ) ; cmp . < String > toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertNoErrors ( ) ; subscriber . assertNoValues ( ) ; subscriber . assertComplete ( ) ; 
TestSubscriberEx < String > subscriber = new TestSubscriberEx < > ( ) ; Completable cmp = Flowable . < String > never ( ) . ignoreElements ( ) ; cmp . < String > toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertNotTerminated ( ) ; subscriber . assertNoValues ( ) ; 
TestSubscriber < String > subscriber = TestSubscriber . create ( ) ; final AtomicBoolean unsubscribed = new AtomicBoolean ( false ) ; Completable cmp = Flowable . just ( "Hello World!" ) . doOnCancel ( new Action ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; ) . ignoreElements ( ) ; cmp . < String > toFlowable ( ) . subscribe ( subscriber ) ; subscriber . assertComplete ( ) ; assertFalse ( unsubscribed . get ( ) ) ; 
Flowable . fromMaybe ( Maybe . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . fromMaybe ( Maybe . empty ( ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . fromMaybe ( Maybe . error ( new TestException ( ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestSubscriber < Integer > ts = Flowable . fromMaybe ( ms ) . test ( ) ; ts . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( ms . hasObservers ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . fromMaybe ( Maybe . just ( 1 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . fromMaybe ( Maybe . just ( 1 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 ) ; 
final List < Object > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) . forEachWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v < 3 ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) . forEachWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 100 ) , list ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . forEachWhile ( v -> true ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > f = Flowable . just ( 1 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) count . incrementAndGet ( ) ; ) ; f . subscribe ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; assertEquals ( 3 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > f = Flowable . just ( 1 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) count . incrementAndGet ( ) ; ) . take ( 1 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) count . incrementAndGet ( ) ; ) ; f . subscribe ( ) ; assertEquals ( 2 , count . get ( ) ) ; 
final AtomicInteger onSubscribed = new AtomicInteger ( ) ; final AtomicInteger countBefore = new AtomicInteger ( ) ; final AtomicInteger countAfter = new AtomicInteger ( ) ; final AtomicReference < Subscriber < ? super Integer > > sref = new AtomicReference < > ( ) ; Flowable < Integer > f = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; onSubscribed . incrementAndGet ( ) ; sref . set ( s ) ; ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) countBefore . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) countAfter . incrementAndGet ( ) ; ) ; f . subscribe ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; assertEquals ( 1 , countBefore . get ( ) ) ; assertEquals ( 1 , onSubscribed . get ( ) ) ; assertEquals ( 3 , countAfter . get ( ) ) ; sref . get ( ) . onComplete ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; assertEquals ( 2 , countBefore . get ( ) ) ; assertEquals ( 2 , onSubscribed . get ( ) ) ; assertEquals ( 6 , countAfter . get ( ) ) ; 
Flowable < String > w = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Flowable < String > take = w . take ( 2 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; take . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Flowable < String > take = w . take ( 1 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; take . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . take ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new IllegalArgumentException ( "some error" ) ; ) . blockingSingle ( ) ; 
Flowable < Integer > w = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . take ( 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new IllegalArgumentException ( "some error" ) ; ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; w . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > w = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . take ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new IllegalArgumentException ( "some error" ) ; ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; w . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onError ( new Throwable ( "test failed" ) ) ; ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; source . take ( 1 ) . subscribe ( subscriber ) ; verify ( subscriber ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verifyNoMoreInteractions ( subscriber ) ; TestHelper . assertUndeliverable ( errors , 0 , Throwable . class , "test failed" ) ; finally RxJavaPlugins . reset ( ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onError ( new Throwable ( "test failed" ) ) ; 
Flowable . error ( new TestException ( ) ) . take ( 1 ) . test ( ) . assertNoValues ( ) . assertError ( TestException . class ) ; 
TestSubscriber < Integer > ts = Flowable . just ( 1 , 2 , 3 ) . take ( 3 ) . test ( 0 ) ; ts . requestMore ( 1 ) . assertValues ( 1 ) . assertNotComplete ( ) . requestMore ( Long . MAX_VALUE ) . assertValues ( 1 , 2 , 3 ) ; 
TestFlowableFunc f = new TestFlowableFunc ( "one" , "two" , "three" ) ; Flowable < String > w = Flowable . unsafeCreate ( f ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > take = w . take ( 1 ) ; take . subscribe ( subscriber ) ; try f . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; System . out . println ( "TestFlowable thread finished" ) ; verify ( subscriber ) . onSubscribe ( ( Subscription ) notNull ( ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verifyNoMoreInteractions ( subscriber ) ; 
final AtomicLong count = new AtomicLong ( ) ; INFINITE_OBSERVABLE . take ( 10 ) . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long l ) count . set ( l ) ; ) ; assertEquals ( 10 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) BooleanSubscription bs = new BooleanSubscription ( ) ; s . onSubscribe ( bs ) ; for ( int i = 0 ; ! bs . isCancelled ( ) ; i ++ ) System . out . println ( "Emit: " + i ) ; count . incrementAndGet ( ) ; s . onNext ( i ) ; ) . take ( 100 ) . take ( 1 ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) System . out . println ( "Receive: " + t1 ) ; ) ; assertEquals ( 1 , count . get ( ) ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( subscriber ) ; INFINITE_OBSERVABLE . onBackpressureDrop ( ) . observeOn ( Schedulers . newThread ( ) ) . take ( 1 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; verify ( subscriber ) . onNext ( 1L ) ; verify ( subscriber , never ( ) ) . onNext ( 2L ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 3 ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . take ( 3 ) . subscribe ( ts ) ; assertEquals ( 3 , requested . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 3 ) ; final AtomicLong requested = new AtomicLong ( ) ; Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) requested . set ( n ) ; @ Override public void cancel ( ) ) ; ) . take ( 1 ) . subscribe ( ts ) ; assertEquals ( 1 , requested . get ( ) ) ; 
final AtomicReference < Object > exception = new AtomicReference < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . take ( 1 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) try Thread . sleep ( 100 ) ; catch ( Exception e ) exception . set ( e ) ; e . printStackTrace ( ) ; finally latch . countDown ( ) ; ) ; latch . await ( ) ; assertNull ( exception . get ( ) ) ; 
final AtomicLong requests = new AtomicLong ( ) ; TestSubscriber < Long > ts = new TestSubscriber < > ( 0L ) ; Flowable . interval ( 100 , TimeUnit . MILLISECONDS ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) System . out . println ( n ) ; requests . addAndGet ( n ) ; ) . take ( 2 ) . subscribe ( ts ) ; Thread . sleep ( 50 ) ; ts . request ( 1 ) ; ts . request ( 1 ) ; ts . request ( 1 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; assertEquals ( 2 , requests . get ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) . take ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) throw new TestException ( ) ; ; source . safeSubscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
final PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . take ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) source . onNext ( 2 ) ; ) . subscribe ( ts ) ; source . onNext ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
try Flowable . just ( 1 ) . take ( - 99 ) ; fail ( "Should have thrown" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "count >= 0 required but it was -99" , ex . getMessage ( ) ) ; 
Flowable . just ( 1 ) . take ( 0 ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . take ( 2 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . take ( 2 ) ; ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . take ( 1 ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = Flowable . range ( 1 , 2 ) . take ( 2 ) . test ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; TestHelper . race ( r1 , r1 ) ; ts . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . error ( new TestException ( ) ) . take ( 0 ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . toFlowable ( BackpressureStrategy . ERROR ) ) ; 
TestHelper . assertBadRequestReported ( Observable . just ( 1 ) . toFlowable ( BackpressureStrategy . ERROR ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return new FlowableOnBackpressureError < > ( f ) ; ) ; 
TestHelper . < Integer > checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return new FlowableOnBackpressureError < > ( f ) ; , false , 1 , 1 , 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestSubscriber < Integer > ts = ps . toFlowable ( BackpressureStrategy . ERROR ) . test ( 0L ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertFalse ( ps . hasObservers ( ) ) ; ts . assertFailure ( MissingBackpressureException . class ) ; 
Flowable < String > w = Flowable . just ( "one" , "two" , "three" ) ; Flowable < String > flowable = w . filter ( new Predicate < String > ( ) @ Override public boolean test ( String t1 ) return t1 . equals ( "two" ) ; ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . just ( "one" , "two" , "three" ) ; Flowable < String > f = w . filter ( new Predicate < String > ( ) @ Override public boolean test ( String t1 ) return t1 . equals ( "three" ) ; ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; TestSubscriber < String > ts = new TestSubscriber < String > ( ) @ Override public void onComplete ( ) System . out . println ( "onComplete" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String t ) System . out . println ( "Received: " + t ) ; request ( 1 ) ; ; ts . request ( 2 ) ; f . subscribe ( ts ) ; latch . await ( ) ; 
Flowable < Integer > w = Flowable . range ( 1 , Flowable . bufferSize ( ) * 2 ) ; Flowable < Integer > f = w . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 > 100 ; ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onComplete ( ) System . out . println ( "onComplete" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( Integer t ) System . out . println ( "Received: " + t ) ; request ( 1 ) ; ; ts . request ( 1 ) ; f . subscribe ( ts ) ; latch . await ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; pp . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throw new TestException ( ) ; ) . subscribe ( ts ) ; Assert . assertTrue ( "Not subscribed?" , pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; Assert . assertFalse ( "Subscribed?" , pp . hasSubscribers ( ) ) ; ts . assertError ( TestException . class ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0L ) ; Flowable . range ( 1 , 10 ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 10 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . filter ( Functions . alwaysFalse ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysFalse ( ) ) . filter ( Functions . alwaysFalse ( ) ) . test ( ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysFalse ( ) ) . filter ( Functions . alwaysFalse ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . filter ( Functions . alwaysTrue ( ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onNext ( 3 ) ; up . onNext ( 4 ) ; up . onNext ( 5 ) ; up . onComplete ( ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . filter ( Functions . alwaysTrue ( ) ) . filter ( Functions . alwaysFalse ( ) ) . subscribe ( ts ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onNext ( 3 ) ; up . onNext ( 4 ) ; up . onNext ( 5 ) ; up . onComplete ( ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . filter ( Functions . alwaysFalse ( ) ) . filter ( Functions . alwaysFalse ( ) ) . subscribe ( ts ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onNext ( 3 ) ; up . onNext ( 4 ) ; up . onNext ( 5 ) ; up . onComplete ( ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) ConditionalSubscriber < ? super Integer > cs = ( ConditionalSubscriber < ? super Integer > ) s ; cs . onSubscribe ( new BooleanSubscription ( ) ) ; cs . tryOnNext ( 1 ) ; cs . tryOnNext ( 2 ) ; cs . onError ( new IOException ( ) ) ; cs . onComplete ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysFalse ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysFalse ( ) ) . filter ( Functions . alwaysFalse ( ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) ConditionalSubscriber < ? super Integer > cs = ( ConditionalSubscriber < ? super Integer > ) s ; cs . onSubscribe ( new BooleanSubscription ( ) ) ; cs . tryOnNext ( 1 ) ; cs . tryOnNext ( 2 ) ; cs . onError ( new IOException ( ) ) ; cs . onComplete ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . filter ( Functions . alwaysTrue ( ) ) ; ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 2 , 4 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 2 , 4 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ; Flowable . range ( 1 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 2 , 4 ) ; 
Flowable . range ( 1 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . startWith ( Completable . complete ( ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . empty ( ) . startWith ( Completable . complete ( ) ) . test ( ) . assertResult ( ) ; 
Runnable run = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . startWith ( Completable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Flowable . just ( 1 ) . startWith ( Single . just ( 2 ) ) . test ( ) . assertResult ( 2 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . startWith ( Single . just ( 2 ) ) . test ( ) . assertResult ( 2 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . startWith ( Single . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Flowable . just ( 1 ) . startWith ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 2 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . startWith ( Maybe . just ( 2 ) ) . test ( ) . assertResult ( 2 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . startWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
Flowable . just ( 1 ) . startWith ( Flowable . just ( 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 , 1 ) ; 
Runnable run = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . startWith ( Flowable . just ( 2 , 3 , 4 , 5 ) ) . test ( ) . assertResult ( 2 , 3 , 4 , 5 ) ; verify ( run ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Runnable run2 = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . startWith ( Flowable . fromRunnable ( run2 ) ) . test ( ) . assertResult ( ) ; verify ( run ) . run ( ) ; verify ( run2 ) . run ( ) ; 
Runnable run = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . startWith ( Flowable . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; verify ( run , never ( ) ) . run ( ) ; 
underlyingSubject = PublishProcessor . create ( ) ; testScheduler = new TestScheduler ( ) ; withTimeout = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; withTimeout . subscribe ( ts ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; verify ( subscriber ) . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; ts . cancel ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; withTimeout . subscribe ( ts ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "Two" ) ; verify ( subscriber ) . onNext ( "Two" ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; ts . cancel ( ) ; 
TestSubscriberEx < String > subscriber = new TestSubscriberEx < > ( ) ; withTimeout . subscribe ( subscriber ) ; testScheduler . advanceTimeBy ( TIMEOUT + 1 , TimeUnit . SECONDS ) ; subscriber . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( TIMEOUT , TIME_UNIT ) ) ; 
TestSubscriberEx < String > subscriber = new TestSubscriberEx < > ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; withTimeout . subscribe ( subscriber ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; subscriber . assertValue ( "One" ) ; testScheduler . advanceTimeBy ( TIMEOUT + 1 , TimeUnit . SECONDS ) ; subscriber . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( TIMEOUT , TIME_UNIT ) , "One" ) ; ts . cancel ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; withTimeout . subscribe ( subscriber ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onComplete ( ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; ts . cancel ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; withTimeout . subscribe ( subscriber ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onError ( new UnsupportedOperationException ( ) ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; verify ( subscriber ) . onError ( any ( UnsupportedOperationException . class ) ) ; ts . cancel ( ) ; 
Flowable < String > other = Flowable . just ( "a" , "b" , "c" ) ; Flowable < String > source = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler , other ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; source . subscribe ( ts ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 4 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "Two" ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "One" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; ts . cancel ( ) ; 
Flowable < String > other = Flowable . just ( "a" , "b" , "c" ) ; Flowable < String > source = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler , other ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; source . subscribe ( ts ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 4 , TimeUnit . SECONDS ) ; underlyingSubject . onError ( new UnsupportedOperationException ( ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "One" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; ts . cancel ( ) ; 
Flowable < String > other = Flowable . just ( "a" , "b" , "c" ) ; Flowable < String > source = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler , other ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; source . subscribe ( ts ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 4 , TimeUnit . SECONDS ) ; underlyingSubject . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "One" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; ts . cancel ( ) ; 
PublishProcessor < String > other = PublishProcessor . create ( ) ; Flowable < String > source = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler , other ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( subscriber ) ; source . subscribe ( ts ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 4 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "Two" ) ; other . onNext ( "a" ) ; other . onNext ( "b" ) ; ts . cancel ( ) ; other . onNext ( "c" ) ; other . onNext ( "d" ) ; other . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "One" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final CountDownLatch exit = new CountDownLatch ( 1 ) ; final CountDownLatch timeoutSetuped = new CountDownLatch ( 1 ) ; final TestSubscriberEx < String > subscriber = new TestSubscriberEx < > ( ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; try timeoutSetuped . countDown ( ) ; exit . await ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; subscriber . onNext ( "a" ) ; subscriber . onComplete ( ) ; ) . timeout ( 1 , TimeUnit . SECONDS , testScheduler ) . subscribe ( subscriber ) ; ) . start ( ) ; timeoutSetuped . await ( ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; subscriber . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( 1 , TimeUnit . SECONDS ) ) ; exit . countDown ( ) ; 
final Subscription s = mock ( Subscription . class ) ; Flowable < String > never = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( s ) ; ) ; TestScheduler testScheduler = new TestScheduler ( ) ; Flowable < String > observableWithTimeout = never . timeout ( 1000 , TimeUnit . MILLISECONDS , testScheduler ) ; TestSubscriberEx < String > subscriber = new TestSubscriberEx < > ( ) ; observableWithTimeout . subscribe ( subscriber ) ; testScheduler . advanceTimeBy ( 2000 , TimeUnit . MILLISECONDS ) ; subscriber . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( 1000 , TimeUnit . MILLISECONDS ) ) ; verify ( s , times ( 1 ) ) . cancel ( ) ; 
final PublishProcessor < String > processor = PublishProcessor . create ( ) ; final TestScheduler scheduler = new TestScheduler ( ) ; final TestSubscriber < String > subscriber = processor . timeout ( 100 , TimeUnit . MILLISECONDS , scheduler ) . test ( ) ; assertTrue ( processor . hasSubscribers ( ) ) ; subscriber . cancel ( ) ; assertFalse ( processor . hasSubscribers ( ) ) ; 
Flowable . never ( ) . timeout ( 100 , TimeUnit . MILLISECONDS , Flowable . just ( 1 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . timeout ( 1 , TimeUnit . DAYS ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . timeout ( 1 , TimeUnit . DAYS , Flowable . just ( 1 ) ) ) ; 
Flowable . error ( new TestException ( ) ) . timeout ( 1 , TimeUnit . DAYS , Flowable . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . empty ( ) . timeout ( 1 , TimeUnit . DAYS , Flowable . just ( 1 ) ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . timeout ( 1 , TimeUnit . DAYS , Flowable . just ( 3 ) ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . timeout ( 1 , TimeUnit . DAYS ) . take ( 1 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertResult ( 1 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . timeout ( 1 , TimeUnit . DAYS , Flowable . just ( 2 ) ) . take ( 1 ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; assertFalse ( pp . hasSubscribers ( ) ) ; ts . assertResult ( 1 ) ; 
Flowable . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , Flowable . error ( new TestException ( ) ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestScheduler sch = new TestScheduler ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = pp . timeout ( 1 , TimeUnit . SECONDS , sch ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . values ( ) . size ( ) != 0 ) if ( ts . errors ( ) . size ( ) != 0 ) ts . assertFailure ( TimeoutException . class , 1 ) ; ts . assertErrorMessage ( timeoutMessage ( 1 , TimeUnit . SECONDS ) ) ; else ts . assertValuesOnly ( 1 ) ; else ts . assertFailure ( TimeoutException . class ) ; ts . assertErrorMessage ( timeoutMessage ( 1 , TimeUnit . SECONDS ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestScheduler sch = new TestScheduler ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = pp . timeout ( 1 , TimeUnit . SECONDS , sch , Flowable . just ( 2 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; if ( ts . isTerminated ( ) ) int c = ts . values ( ) . size ( ) ; if ( c == 1 ) int v = ts . values ( ) . get ( 0 ) ; assertTrue ( "" + v , v == 1 || v == 2 ) ; else ts . assertResult ( 1 , 2 ) ; else ts . assertValuesOnly ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . timeout ( 1 , TimeUnit . MINUTES , Flowable . < Object > never ( ) ) ) ; 
Flowable . just ( 1 ) . throttleLatest ( 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 5 ) . throttleLatest ( 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( 1 ) ; 
Flowable . range ( 1 , 5 ) . throttleLatest ( 1 , TimeUnit . MINUTES , true ) . test ( ) . assertResult ( 1 , 5 ) ; 
Flowable . error ( new TestException ( ) ) . throttleLatest ( 1 , TimeUnit . MINUTES ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . throttleLatest ( 1 , TimeUnit . MINUTES ) ; ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . throttleLatest ( 1 , TimeUnit . MINUTES ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . throttleLatest ( 1 , TimeUnit . SECONDS , sch ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 1 ) ; pp . onNext ( 3 ) ; ts . assertValuesOnly ( 1 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValuesOnly ( 1 , 3 ) ; pp . onNext ( 4 ) ; ts . assertValuesOnly ( 1 , 3 ) ; pp . onNext ( 5 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValuesOnly ( 1 , 3 , 5 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValuesOnly ( 1 , 3 , 5 ) ; pp . onNext ( 6 ) ; ts . assertValuesOnly ( 1 , 3 , 5 , 6 ) ; pp . onNext ( 7 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 3 , 5 , 6 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertResult ( 1 , 3 , 5 , 6 ) ; 
TestScheduler sch = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . throttleLatest ( 1 , TimeUnit . SECONDS , sch , true ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 1 ) ; pp . onNext ( 3 ) ; ts . assertValuesOnly ( 1 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValuesOnly ( 1 , 3 ) ; pp . onNext ( 4 ) ; ts . assertValuesOnly ( 1 , 3 ) ; pp . onNext ( 5 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValuesOnly ( 1 , 3 , 5 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertValuesOnly ( 1 , 3 , 5 ) ; pp . onNext ( 6 ) ; ts . assertValuesOnly ( 1 , 3 , 5 , 6 ) ; pp . onNext ( 7 ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 3 , 5 , 6 , 7 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertResult ( 1 , 3 , 5 , 6 , 7 ) ; 
TestScheduler sch = new TestScheduler ( ) ; Action onCancel = mock ( Action . class ) ; Flowable . just ( 1 , 2 ) . doOnCancel ( onCancel ) . throttleLatest ( 1 , TimeUnit . MINUTES , sch ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; verify ( onCancel ) . run ( ) ; 
TestScheduler sch = new TestScheduler ( ) ; Action onCancel = mock ( Action . class ) ; TestSubscriber < Integer > ts = Flowable . just ( 1 , 2 ) . concatWith ( Flowable . < Integer > never ( ) ) . doOnCancel ( onCancel ) . throttleLatest ( 1 , TimeUnit . SECONDS , sch , true ) . test ( 1 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertFailure ( MissingBackpressureException . class , 1 ) ; verify ( onCancel ) . run ( ) ; 
TestScheduler sch = new TestScheduler ( ) ; Action onCancel = mock ( Action . class ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . doOnCancel ( onCancel ) . throttleLatest ( 1 , TimeUnit . SECONDS , sch , true ) . test ( 1 ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 1 ) ; pp . onComplete ( ) ; ts . assertFailure ( MissingBackpressureException . class , 1 ) ; verify ( onCancel , never ( ) ) . run ( ) ; 
Action onCancel = mock ( Action . class ) ; Flowable . range ( 1 , 5 ) . doOnCancel ( onCancel ) . throttleLatest ( 1 , TimeUnit . MINUTES ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; verify ( onCancel ) . run ( ) ; 
TestScheduler sch = new TestScheduler ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onNext ( 2 ) ; if ( t == 2 ) pp . onComplete ( ) ; ; pp . throttleLatest ( 1 , TimeUnit . SECONDS , sch ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; final List < Subscriber < Object > > values = new ArrayList < > ( ) ; Subscriber < Flowable < Integer > > wo = new DefaultSubscriber < Flowable < Integer > > ( ) @ Override public void onNext ( Flowable < Integer > args ) final Subscriber < Object > mo = TestHelper . mockSubscriber ( ) ; values . add ( mo ) ; args . subscribe ( mo ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ; source . window ( boundary ) . subscribe ( wo ) ; int n = 30 ; for ( int i = 0 ; i < n ; i ++ ) source . onNext ( i ) ; if ( i % 3 == 2 && i < n - 1 ) boundary . onNext ( i / 3 ) ; source . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; assertEquals ( n / 3 , values . size ( ) ) ; int j = 0 ; for ( Subscriber < Object > mo : values ) verify ( mo , never ( ) ) . onError ( any ( Throwable . class ) ) ; for ( int i = 0 ; i < 3 ; i ++ ) verify ( mo ) . onNext ( j + i ) ; verify ( mo ) . onComplete ( ) ; j += 3 ; verify ( subscriber ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; final List < Subscriber < Object > > values = new ArrayList < > ( ) ; Subscriber < Flowable < Integer > > wo = new DefaultSubscriber < Flowable < Integer > > ( ) @ Override public void onNext ( Flowable < Integer > args ) final Subscriber < Object > mo = TestHelper . mockSubscriber ( ) ; values . add ( mo ) ; args . subscribe ( mo ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ; source . window ( boundary ) . subscribe ( wo ) ; int n = 30 ; for ( int i = 0 ; i < n ; i ++ ) source . onNext ( i ) ; if ( i % 3 == 2 && i < n - 1 ) boundary . onNext ( i / 3 ) ; boundary . onComplete ( ) ; assertEquals ( n / 3 , values . size ( ) ) ; int j = 0 ; for ( Subscriber < Object > mo : values ) for ( int i = 0 ; i < 3 ; i ++ ) verify ( mo ) . onNext ( j + i ) ; verify ( mo ) . onComplete ( ) ; verify ( mo , never ( ) ) . onError ( any ( Throwable . class ) ) ; j += 3 ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; final List < Subscriber < Object > > values = new ArrayList < > ( ) ; Subscriber < Flowable < Integer > > wo = new DefaultSubscriber < Flowable < Integer > > ( ) @ Override public void onNext ( Flowable < Integer > args ) final Subscriber < Object > mo = TestHelper . mockSubscriber ( ) ; values . add ( mo ) ; args . subscribe ( mo ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ; source . window ( boundary ) . subscribe ( wo ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; boundary . onError ( new TestException ( ) ) ; assertEquals ( 1 , values . size ( ) ) ; Subscriber < Object > mo = values . get ( 0 ) ; verify ( mo ) . onNext ( 0 ) ; verify ( mo ) . onNext ( 1 ) ; verify ( mo ) . onNext ( 2 ) ; verify ( mo ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; final Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; final List < Subscriber < Object > > values = new ArrayList < > ( ) ; Subscriber < Flowable < Integer > > wo = new DefaultSubscriber < Flowable < Integer > > ( ) @ Override public void onNext ( Flowable < Integer > args ) final Subscriber < Object > mo = TestHelper . mockSubscriber ( ) ; values . add ( mo ) ; args . subscribe ( mo ) ; @ Override public void onError ( Throwable e ) subscriber . onError ( e ) ; @ Override public void onComplete ( ) subscriber . onComplete ( ) ; ; source . window ( boundary ) . subscribe ( wo ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertEquals ( 1 , values . size ( ) ) ; Subscriber < Object > mo = values . get ( 0 ) ; verify ( mo ) . onNext ( 0 ) ; verify ( mo ) . onNext ( 1 ) ; verify ( mo ) . onNext ( 2 ) ; verify ( mo ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . window ( Flowable . never ( ) ) ) ; 
TestSubscriberEx < Object > ts = Flowable . error ( new TestException ( ) ) . window ( Flowable . never ( ) ) . flatMap ( Functions . < Flowable < Object > > identity ( ) , true ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return Flowable . just ( 1 ) . window ( f ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return v ; ) ; , false , 1 , 1 , ( Object [ ] ) null ) ; 
final FlowableProcessor < Integer > ps = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( BehaviorProcessor . createDefault ( 1 ) ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return v ; ) . subscribe ( ts ) ; ps . onNext ( 1 ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . window ( Flowable . never ( ) ) . flatMap ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > v ) throws Exception return v ; ) ; , false , 1 , 1 , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BehaviorProcessor . create ( ) . window ( Flowable . error ( new TestException ( ) ) ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BehaviorProcessor . createDefault ( 1 ) . window ( Flowable . error ( new TestException ( ) ) ) . test ( 0 ) . assertFailure ( MissingBackpressureException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
BehaviorProcessor . createDefault ( 1 ) . window ( Flowable . just ( 1 ) ) . test ( 1 ) . assertError ( MissingBackpressureException . class ) . assertNotComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Flowable < Object > > > ( ) @ Override public Publisher < Flowable < Object > > apply ( Flowable < Object > f ) throws Exception return f . window ( Flowable . never ( ) ) . takeLast ( 1 ) ; ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = source . window ( boundary ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > w ) throws Exception return w . take ( 1 ) ; ) . test ( ) ; source . onNext ( 1 ) ; assertFalse ( "source not disposed" , source . hasSubscribers ( ) ) ; assertFalse ( "boundary not disposed" , boundary . hasSubscribers ( ) ) ; ts . assertResult ( 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Subscriber < ? super Object > > ref = new AtomicReference < > ( ) ; TestSubscriberEx < Flowable < Object > > ts = Flowable . error ( new TestException ( "main" ) ) . window ( new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( subscriber ) ; ) . doOnNext ( new Consumer < Flowable < Object > > ( ) @ Override public void accept ( Flowable < Object > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . to ( TestHelper . < Flowable < Object > > testConsumer ( ) ) ; ts . assertValueCount ( 1 ) . assertError ( TestException . class ) . assertErrorMessage ( "main" ) . assertNotComplete ( ) ; ref . get ( ) . onError ( new TestException ( "inner" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "inner" ) ; finally RxJavaPlugins . reset ( ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Subscriber < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Subscriber < ? super Object > > ref = new AtomicReference < > ( ) ; TestSubscriberEx < Flowable < Object > > ts = new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; refMain . set ( subscriber ) ; . window ( new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( subscriber ) ; ) . to ( TestHelper . < Flowable < Object > > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) refMain . get ( ) . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ref . get ( ) . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValueCount ( 1 ) . assertTerminated ( ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicReference < Subscriber < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Subscriber < ? super Object > > ref = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Object > > ts = new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; refMain . set ( subscriber ) ; . window ( new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( subscriber ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) refMain . get ( ) . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ref . get ( ) . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertValueCount ( 2 ) . assertNotComplete ( ) . assertNoErrors ( ) ; 
final AtomicReference < Subscriber < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Subscriber < ? super Object > > ref = new AtomicReference < > ( ) ; TestSubscriberEx < Flowable < Object > > ts = new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; refMain . set ( subscriber ) ; . window ( new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( subscriber ) ; ) . to ( TestHelper . < Flowable < Object > > testConsumer ( ) ) ; ts . assertValueCount ( 1 ) . assertNotTerminated ( ) . cancel ( ) ; ref . get ( ) . onNext ( 1 ) ; ts . assertValueCount ( 1 ) . assertNotTerminated ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicReference < Subscriber < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Subscriber < ? super Object > > ref = new AtomicReference < > ( ) ; final TestSubscriber < Flowable < Object > > ts = new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; refMain . set ( subscriber ) ; . window ( new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) final AtomicInteger counter = new AtomicInteger ( ) ; subscriber . onSubscribe ( new Subscription ( ) @ Override public void cancel ( ) for ( int i = 0 ; i < 100 ; i ++ ) counter . incrementAndGet ( ) ; @ Override public void request ( long n ) ) ; ref . set ( subscriber ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) Subscriber < Object > subscriber = ref . get ( ) ; subscriber . onNext ( 1 ) ; subscriber . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final AtomicReference < Subscriber < ? super Object > > refMain = new AtomicReference < > ( ) ; final AtomicReference < Subscriber < ? super Object > > ref = new AtomicReference < > ( ) ; final TestSubscriber < Flowable < Object > > ts = new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; refMain . set ( subscriber ) ; . window ( new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) final AtomicInteger counter = new AtomicInteger ( ) ; subscriber . onSubscribe ( new Subscription ( ) @ Override public void cancel ( ) for ( int i = 0 ; i < 100 ; i ++ ) counter . incrementAndGet ( ) ; @ Override public void request ( long n ) ) ; ref . set ( subscriber ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) Subscriber < Object > subscriber = ref . get ( ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > inner = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( Flowable . < Integer > never ( ) ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertValueCount ( 1 ) ; pp . onNext ( 1 ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
return new Function < Integer , Flowable < T > > ( ) @ Override public Flowable < T > apply ( Integer t1 ) return flowable ; ; 
MockitoAnnotations . openMocks ( this ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > m = source1 . join ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , add ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; source1 . onNext ( 2 ) ; source1 . onNext ( 4 ) ; source2 . onNext ( 16 ) ; source2 . onNext ( 32 ) ; source2 . onNext ( 64 ) ; source1 . onComplete ( ) ; source2 . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 17 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 18 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 20 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 33 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 34 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 36 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 65 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 66 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 68 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; PublishProcessor < Integer > duration1 = PublishProcessor . create ( ) ; Flowable < Integer > m = source1 . join ( source2 , just ( duration1 ) , just ( Flowable . never ( ) ) , add ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; source1 . onNext ( 2 ) ; source2 . onNext ( 16 ) ; duration1 . onNext ( 1 ) ; source1 . onNext ( 4 ) ; source1 . onNext ( 8 ) ; source1 . onComplete ( ) ; source2 . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 17 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 18 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 20 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 24 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > m = source1 . join ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , add ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; source1 . onNext ( 2 ) ; source1 . onComplete ( ) ; source2 . onNext ( 16 ) ; source2 . onNext ( 32 ) ; source2 . onNext ( 64 ) ; source2 . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 17 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 18 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 33 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 34 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 65 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 66 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > m = source1 . join ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , add ) ; m . subscribe ( subscriber ) ; source2 . onNext ( 1 ) ; source1 . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > m = source1 . join ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , add ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; source2 . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > duration1 = Flowable . < Integer > error ( new RuntimeException ( "Forced failure" ) ) ; Flowable < Integer > m = source1 . join ( source2 , just ( duration1 ) , just ( Flowable . never ( ) ) , add ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Flowable < Integer > duration1 = Flowable . < Integer > error ( new RuntimeException ( "Forced failure" ) ) ; Flowable < Integer > m = source1 . join ( source2 , just ( Flowable . never ( ) ) , just ( duration1 ) , add ) ; m . subscribe ( subscriber ) ; source2 . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > fail = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) throw new RuntimeException ( "Forced failure" ) ; ; Flowable < Integer > m = source1 . join ( source2 , fail , just ( Flowable . never ( ) ) , add ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > fail = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) throw new RuntimeException ( "Forced failure" ) ; ; Flowable < Integer > m = source1 . join ( source2 , just ( Flowable . never ( ) ) , fail , add ) ; m . subscribe ( subscriber ) ; source2 . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
PublishProcessor < Integer > source1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > source2 = PublishProcessor . create ( ) ; BiFunction < Integer , Integer , Integer > fail = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throw new RuntimeException ( "Forced failure" ) ; ; Flowable < Integer > m = source1 . join ( source2 , just ( Flowable . never ( ) ) , just ( Flowable . never ( ) ) , fail ) ; m . subscribe ( subscriber ) ; source1 . onNext ( 1 ) ; source2 . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; 
TestHelper . checkDisposed ( PublishProcessor . < Integer > create ( ) . join ( Flowable . just ( 1 ) , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
Flowable . just ( 1 ) . join ( Flowable . just ( 2 ) , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . take ( 1 ) . test ( ) . assertResult ( 3 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . join ( Flowable . just ( 2 ) , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( Flowable . empty ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertEmpty ( ) ; pp . onNext ( 1 ) ; ts . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . join ( Flowable . just ( 2 ) , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onError ( new TestException ( "Second" ) ) ; . join ( Flowable . just ( 2 ) , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try @ SuppressWarnings ( "rawtypes" ) final Subscriber [ ] o = null ; TestSubscriberEx < Integer > ts = Flowable . just ( 1 ) . join ( Flowable . just ( 2 ) , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) o [ 0 ] = subscriber ; subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; o [ 0 ] . onError ( new TestException ( "Second" ) ) ; ts . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Object > ts = pp1 . join ( pp2 , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( 0L ) ; pp1 . onNext ( 1 ) ; pp2 . onNext ( 2 ) ; ts . assertFailure ( MissingBackpressureException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Object > ts = pp1 . join ( pp2 , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( 0L ) ; pp2 . onNext ( 2 ) ; pp1 . onNext ( 1 ) ; ts . assertFailure ( MissingBackpressureException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestHelper . assertBadRequestReported ( pp1 . join ( pp2 , Functions . justFunction ( Flowable . never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) , ( a , b ) -> a + b ) ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp1 . join ( pp2 , v -> Flowable . never ( ) , v -> Flowable . never ( ) , ( a , b ) -> a + b ) . doOnNext ( v -> pp1 . onComplete ( ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ) . test ( ) ; pp1 . onNext ( 0 ) ; pp2 . onNext ( 1 ) ; ts . assertComplete ( ) ; 
Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 ) ; Flowable < String > m = flowable . scan ( "" , new BiFunction < String , Integer , String > ( ) @ Override public String apply ( String s , Integer n ) return s + n . toString ( ) ; ) ; m . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "1" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "12" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "123" ) ; verify ( subscriber , times ( 4 ) ) . onNext ( anyString ( ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Integer > m = flowable . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) ; m . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( 0 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 6 ) ; verify ( subscriber , times ( 3 ) ) . onNext ( anyInt ( ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < Integer > flowable = Flowable . just ( 1 ) ; Flowable < Integer > m = flowable . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) ; m . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( 0 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( anyInt ( ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 100 ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 > 0 ; ) . subscribe ( ts ) ; assertEquals ( 100 , ts . values ( ) . size ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable . range ( 1 , 100 ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 10 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) Assert . fail ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; @ Override public void onNext ( Integer t ) count . incrementAndGet ( ) ; ) ; assertEquals ( 10 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable . range ( 1 , 100 ) . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 10 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) Assert . fail ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; @ Override public void onNext ( Integer t ) count . incrementAndGet ( ) ; ) ; assertEquals ( 10 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable . range ( 1 , 100 ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) Assert . fail ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; @ Override public void onNext ( Integer t ) count . incrementAndGet ( ) ; ) ; assertEquals ( 101 , count . get ( ) ) ; 
Single < List < Integer > > o = Flowable . range ( 1 , 10 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer t2 ) list . add ( t2 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) , o . blockingGet ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) , o . blockingGet ( ) ) ; 
Flowable < List < Integer > > f = Flowable . range ( 1 , 10 ) . collect ( new Supplier < List < Integer > > ( ) @ Override public List < Integer > get ( ) return new ArrayList < > ( ) ; , new BiConsumer < List < Integer > , Integer > ( ) @ Override public void accept ( List < Integer > list , Integer t2 ) list . add ( t2 ) ; ) . toFlowable ( ) . takeLast ( 1 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) , f . blockingSingle ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) , f . blockingSingle ( ) ) ; 
Flowable < Integer > f = Flowable . just ( 1 , 2 ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) . take ( 1 ) ; TestSubscriberEx < Integer > subscriber = new TestSubscriberEx < > ( ) ; f . subscribe ( subscriber ) ; subscriber . assertValue ( 0 ) ; subscriber . assertTerminated ( ) ; subscriber . assertNoErrors ( ) ; 
final AtomicReference < Subscription > producer = new AtomicReference < > ( ) ; Flowable < Integer > f = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( final Subscriber < ? super Integer > subscriber ) Subscription p = spy ( new Subscription ( ) private AtomicBoolean requested = new AtomicBoolean ( false ) ; @ Override public void request ( long n ) if ( requested . compareAndSet ( false , true ) ) subscriber . onNext ( 1 ) ; subscriber . onComplete ( ) ; @ Override public void cancel ( ) ) ; producer . set ( p ) ; subscriber . onSubscribe ( p ) ; ) . scan ( 100 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 ; ) ; f . subscribe ( new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer integer ) request ( 1 ) ; ) ; verify ( producer . get ( ) , never ( ) ) . request ( 0 ) ; verify ( producer . get ( ) , times ( 1 ) ) . request ( Flowable . bufferSize ( ) - 1 ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . scan ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ) ; TestHelper . checkDisposed ( PublishProcessor . < Integer > create ( ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . scan ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . scan ( 0 , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ; ) ; 
Flowable . error ( new TestException ( ) ) . scan ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . < Integer > never ( ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertValue ( 0 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
FlowableEventStream . getEventStream ( "HTTP-ClusterB" , 20 ) . scan ( new HashMap < > ( ) , new BiFunction < HashMap < String , String > , Event , HashMap < String , String > > ( ) @ Override public HashMap < String , String > apply ( HashMap < String , String > accum , Event perInstanceEvent ) accum . put ( "instance" , perInstanceEvent . instanceId ) ; return accum ; ) . take ( 10 ) . blockingForEach ( new Consumer < HashMap < String , String > > ( ) @ Override public void accept ( HashMap < String , String > v ) System . out . println ( v ) ; ) ; 
final List < Throwable > list = new CopyOnWriteArrayList < > ( ) ; Consumer < Throwable > errorConsumer = new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throws Exception list . add ( t ) ; ; try RxJavaPlugins . setErrorHandler ( errorConsumer ) ; final RuntimeException e = new RuntimeException ( ) ; final RuntimeException e2 = new RuntimeException ( ) ; Burst . items ( 1 ) . error ( e2 ) . scan ( 0 , throwingBiFunction ( e ) ) . test ( ) . assertValues ( 0 ) . assertError ( e ) ; assertEquals ( "" + list , 1 , list . size ( ) ) ; assertTrue ( "" + list , list . get ( 0 ) instanceof UndeliverableException ) ; assertEquals ( e2 , list . get ( 0 ) . getCause ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; Burst . item ( 1 ) . create ( ) . scan ( 0 , throwingBiFunction ( e ) ) . test ( ) . assertValue ( 0 ) . assertError ( e ) ; 
final RuntimeException e = new RuntimeException ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Burst . items ( 1 , 2 ) . create ( ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer n1 , Integer n2 ) throws Exception count . incrementAndGet ( ) ; throw e ; ) . test ( ) . assertValues ( 0 ) . assertError ( e ) ; assertEquals ( 1 , count . get ( ) ) ; 
Flowable . just ( 1 , 2 , 3 ) . scan ( 0 , SUM ) . test ( ) . assertValues ( 0 , 1 , 3 , 6 ) . assertComplete ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; Flowable . just ( 1 , 2 , 3 ) . scanWith ( throwingSupplier ( e ) , SUM ) . test ( ) . assertError ( e ) . assertNoValues ( ) ; 
Flowable . just ( 1 , 2 , 3 ) . scan ( SUM ) . test ( ) . assertValues ( 1 , 3 , 6 ) . assertComplete ( ) ; 
final List < Throwable > list = new CopyOnWriteArrayList < > ( ) ; Consumer < Throwable > errorConsumer = new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) throws Exception list . add ( t ) ; ; try RxJavaPlugins . setErrorHandler ( errorConsumer ) ; final RuntimeException e = new RuntimeException ( ) ; final RuntimeException e2 = new RuntimeException ( ) ; Burst . items ( 1 , 2 ) . error ( e2 ) . scan ( throwingBiFunction ( e ) ) . test ( ) . assertValue ( 1 ) . assertError ( e ) ; assertEquals ( "" + list , 1 , list . size ( ) ) ; assertTrue ( "" + list , list . get ( 0 ) instanceof UndeliverableException ) ; assertEquals ( e2 , list . get ( 0 ) . getCause ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final RuntimeException e = new RuntimeException ( ) ; Burst . items ( 1 , 2 ) . create ( ) . scan ( throwingBiFunction ( e ) ) . test ( ) . assertValue ( 1 ) . assertError ( e ) ; 
final RuntimeException e = new RuntimeException ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Burst . items ( 1 , 2 , 3 ) . create ( ) . scan ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer n1 , Integer n2 ) throws Exception count . incrementAndGet ( ) ; throw e ; ) . test ( ) . assertValue ( 1 ) . assertError ( e ) ; assertEquals ( 1 , count . get ( ) ) ; 
return new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer n1 , Integer n2 ) throws Exception throw e ; ; 
return new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception throw e ; ; 
Flowable . < Integer > empty ( ) . scan ( 0 , SUM ) . test ( 1 ) . assertResult ( 0 ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . scan ( 0 , SUM ) . test ( 0 ) . assertFailure ( TestException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; onComplete ( ) ; cancel ( ) ; ; Flowable . range ( 1 , 10 ) . scan ( 0 , SUM ) . subscribe ( ts ) ; ts . assertResult ( 0 ) ; 
int n = 2 * Flowable . bufferSize ( ) ; for ( int b = 1 ; b <= n ; b *= 2 ) List < Integer > list = Flowable . range ( 1 , n ) . scan ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return b ; ) . rebatchRequests ( b ) . toList ( ) . blockingGet ( ) ; for ( int i = 0 ; i <= n ; i ++ ) assertEquals ( i , list . get ( i ) . intValue ( ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . < Integer > never ( ) . scanWith ( ( ) -> 1 , ( a , b ) -> a + b ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . scanWith ( ( ) -> 0 , ( a , b ) -> a + b ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; ) . test ( ) ; pp . onNext ( 1 ) ; ts . assertResult ( 0 , 1 , 3 ) ; 
Flowable < Notification < Integer > > notifications = Flowable . just ( 1 , 2 ) . materialize ( ) ; Flowable < Integer > dematerialize = notifications . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; dematerialize . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable . just ( 1 , 2 ) . materialize ( ) . dematerialize ( new Function < Notification < Integer > , Notification < Object > > ( ) @ Override public Notification < Object > apply ( Notification < Integer > v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 , 2 ) . materialize ( ) . dematerialize ( new Function < Notification < Integer > , Notification < Object > > ( ) @ Override public Notification < Object > apply ( Notification < Integer > v ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable < Notification < Integer > > notifications = Flowable . just ( 1 , 2 ) . materialize ( ) ; Flowable < Integer > dematerialize = notifications . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; dematerialize . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Throwable exception = new Throwable ( "test" ) ; Flowable < Integer > flowable = Flowable . error ( exception ) ; Flowable < Integer > dematerialize = flowable . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; dematerialize . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onError ( exception ) ; verify ( subscriber , times ( 0 ) ) . onComplete ( ) ; verify ( subscriber , times ( 0 ) ) . onNext ( any ( Integer . class ) ) ; 
Exception exception = new Exception ( "test" ) ; Flowable < Integer > flowable = Flowable . error ( exception ) ; Flowable < Integer > dematerialize = flowable . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; dematerialize . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onError ( exception ) ; verify ( subscriber , times ( 0 ) ) . onComplete ( ) ; verify ( subscriber , times ( 0 ) ) . onNext ( any ( Integer . class ) ) ; 
Exception exception = new Exception ( "test" ) ; Flowable < Notification < Integer > > flowable = Flowable . error ( exception ) ; Flowable < Integer > dematerialize = flowable . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; dematerialize . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onError ( exception ) ; verify ( subscriber , times ( 0 ) ) . onComplete ( ) ; verify ( subscriber , times ( 0 ) ) . onNext ( any ( Integer . class ) ) ; 
Flowable < Notification < Integer > > flowable = Flowable . empty ( ) ; Flowable < Integer > dematerialize = flowable . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( subscriber ) ; dematerialize . subscribe ( ts ) ; System . out . println ( ts . errors ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 0 ) ) . onNext ( any ( Integer . class ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; Flowable < Integer > result = source . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onNext ( 1 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > source = Flowable . error ( new TestException ( ) ) ; Flowable < Integer > result = source . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( Notification . createOnComplete ( ) ) . dematerialize ( Functions . < Notification < Object > > identity ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Notification < Object > > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Notification < Object > > f ) throws Exception return f . dematerialize ( Functions . < Notification < Object > > identity ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Notification < Object > > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Notification < Object > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( Notification . createOnComplete ( ) ) ; subscriber . onNext ( Notification . < Object > createOnNext ( 1 ) ) ; subscriber . onNext ( Notification . createOnError ( new TestException ( "First" ) ) ) ; subscriber . onError ( new TestException ( "Second" ) ) ; . dematerialize ( Functions . < Notification < Object > > identity ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
new Flowable < Notification < Object > > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Notification < Object > > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( Notification . createOnComplete ( ) ) ; subscriber . onNext ( Notification . < Object > createOnNext ( 1 ) ) ; . dematerialize ( Functions . < Notification < Object > > identity ( ) ) . test ( ) . assertResult ( ) ; 
new Flowable < Object > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( Notification . createOnComplete ( ) ) ; subscriber . onNext ( 1 ) ; . dematerialize ( v -> ( Notification < Object > ) v ) . test ( ) . assertResult ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 5 ) . onBackpressureReduce ( TEST_INT_REDUCER ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Flowable . error ( new TestException ( ) ) ) . onBackpressureReduce ( TEST_INT_REDUCER ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertError ( TestException . class ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 2L ) ; Flowable . range ( 1 , 5 ) . onBackpressureReduce ( TEST_INT_REDUCER ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNotComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureReduce ( TEST_INT_REDUCER ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; source . onNext ( 1 ) ; ts . request ( 2 ) ; ts . assertValue ( 1 ) ; source . onNext ( 2 ) ; ts . assertValues ( 1 , 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 168 ) ; source . onNext ( 7 ) ; ts . assertValues ( 1 , 2 , 168 , 7 ) ; source . onNext ( 8 ) ; source . onNext ( 9 ) ; source . onComplete ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 168 , 7 , 67 ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; source . onBackpressureReduce ( Integer :: sum ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; ts . request ( 1 ) ; ts . assertValuesOnly ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; ts . assertValuesOnly ( 6 ) ; ts . request ( 1 ) ; ts . assertResult ( 6 , 4 ) ; 
return new TestSubscriberEx < T > ( 1L ) final Random rnd = new Random ( ) ; @ Override public void onNext ( T t ) super . onNext ( t ) ; if ( rnd . nextDouble ( ) < 0.001 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException ex ) ex . printStackTrace ( ) ; request ( 1 ) ; ; 
int previous = 0 ; for ( Integer current : ts . values ( ) ) Assert . assertTrue ( "The sequence must be increasing [current value=" + previous + ", previous value=" + current + "]" , previous <= current ) ; previous = current ; 
TestSubscriberEx < Integer > ts = createDelayedSubscriber ( ) ; int m = 100000 ; Flowable . range ( 1 , m ) . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureReduce ( ( previous , current ) -> return current ; ) . observeOn ( Schedulers . io ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts . assertTerminated ( ) ; assertValuesDropped ( ts , m ) ; assertIncreasingSequence ( ts ) ; 
TestSubscriberEx < Long > ts = createDelayedSubscriber ( ) ; int m = 100000 ; Flowable . rangeLong ( 1 , m ) . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureReduce ( Long :: sum ) . observeOn ( Schedulers . io ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts . assertTerminated ( ) ; assertValuesDropped ( ts , m ) ; long sum = 0 ; for ( Long i : ts . values ( ) ) sum += i ; Assert . assertEquals ( "Wrong sum: " + sum , 5000050000L , sum ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0 ) ; source . onBackpressureReduce ( ( l , r ) -> null ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( ts . errors ( ) , 0 , NullPointerException . class , "The reducer returned a null value" ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0 ) ; source . onBackpressureReduce ( ( l , r ) -> throw new TestException ( "Test exception" ) ; ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; TestHelper . assertError ( ts . errors ( ) , 0 , TestException . class , "Test exception" ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . onBackpressureReduce ( TEST_OBJECT_REDUCER ) ) ; 
Flowable . just ( 1 , 2 ) . onBackpressureReduce ( TEST_INT_REDUCER ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . onBackpressureReduce ( TEST_OBJECT_REDUCER ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . onBackpressureReduce ( TEST_OBJECT_REDUCER ) ) ; 
Flowable < String > obs = Flowable . just ( "one" ) ; Future < String > f = obs . toFuture ( ) ; assertEquals ( "one" , f . get ( ) ) ; 
Flowable < String > obs = Flowable . just ( "one" , "two" , "three" ) ; Future < List < String > > f = obs . toList ( ) . toFuture ( ) ; assertEquals ( "one" , f . get ( ) . get ( 0 ) ) ; assertEquals ( "two" , f . get ( ) . get ( 1 ) ) ; assertEquals ( "three" , f . get ( ) . get ( 2 ) ) ; 
Flowable < String > obs = Flowable . just ( "one" , "two" ) ; Future < String > f = obs . toFuture ( ) ; try f . get ( ) ; fail ( "Should have thrown!" ) ; catch ( ExecutionException e ) throw e . getCause ( ) ; 
Flowable < String > obs = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onError ( new TestException ( ) ) ; ) ; Future < String > f = obs . toFuture ( ) ; try f . get ( ) ; fail ( "expected exception" ) ; catch ( Throwable e ) assertEquals ( TestException . class , e . getCause ( ) . getClass ( ) ) ; 
Flowable < String > obs = Flowable . never ( ) ; Future < String > f = obs . toFuture ( ) ; boolean cancelled = f . cancel ( true ) ; assertTrue ( cancelled ) ; f . get ( ) ; 
Flowable < String > obs = Flowable . never ( ) ; Future < String > f = obs . toFuture ( ) ; boolean cancelled = f . cancel ( true ) ; assertTrue ( cancelled ) ; f . get ( Long . MAX_VALUE , TimeUnit . NANOSECONDS ) ; 
Flowable < String > obs = Flowable . empty ( ) ; Future < String > f = obs . toFuture ( ) ; try f . get ( ) ; catch ( ExecutionException e ) throw e . getCause ( ) ; 
performTestUsing ( false ) ; 
performTestUsing ( true ) ; 
performTestUsingWithSubscribingTwice ( false ) ; 
performTestUsingWithSubscribingTwice ( true ) ; 
$EMPTY$
performTestUsingWithResourceFactoryError ( false ) ; 
performTestUsingWithResourceFactoryError ( true ) ; 
performTestUsingWithFlowableFactoryError ( false ) ; 
performTestUsingWithFlowableFactoryError ( true ) ; 
final List < String > events = new ArrayList < > ( ) ; Supplier < Resource > resourceFactory = createResourceFactory ( events ) ; final Action completion = createOnCompletedAction ( events ) ; final Action unsub = createUnsubAction ( events ) ; Function < Resource , Flowable < String > > observableFactory = new Function < Resource , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Resource resource ) return Flowable . fromArray ( resource . getTextFromWeb ( ) . split ( " " ) ) ; ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > flowable = Flowable . using ( resourceFactory , observableFactory , new DisposeAction ( ) , true ) . doOnCancel ( unsub ) . doOnComplete ( completion ) ; flowable . safeSubscribe ( subscriber ) ; assertEquals ( Arrays . asList ( "disposed" , "completed" ) , events ) ; 
final List < String > events = new ArrayList < > ( ) ; Supplier < Resource > resourceFactory = createResourceFactory ( events ) ; final Action completion = createOnCompletedAction ( events ) ; final Action unsub = createUnsubAction ( events ) ; Function < Resource , Flowable < String > > observableFactory = new Function < Resource , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Resource resource ) return Flowable . fromArray ( resource . getTextFromWeb ( ) . split ( " " ) ) ; ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > flowable = Flowable . using ( resourceFactory , observableFactory , new DisposeAction ( ) , false ) . doOnCancel ( unsub ) . doOnComplete ( completion ) ; flowable . safeSubscribe ( subscriber ) ; assertEquals ( Arrays . asList ( "completed" , "disposed" ) , events ) ; 
final List < String > events = new ArrayList < > ( ) ; Supplier < Resource > resourceFactory = createResourceFactory ( events ) ; final Consumer < Throwable > onError = createOnErrorAction ( events ) ; final Action unsub = createUnsubAction ( events ) ; Function < Resource , Flowable < String > > observableFactory = new Function < Resource , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Resource resource ) return Flowable . fromArray ( resource . getTextFromWeb ( ) . split ( " " ) ) . concatWith ( Flowable . < String > error ( new RuntimeException ( ) ) ) ; ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > flowable = Flowable . using ( resourceFactory , observableFactory , new DisposeAction ( ) , true ) . doOnCancel ( unsub ) . doOnError ( onError ) ; flowable . safeSubscribe ( subscriber ) ; assertEquals ( Arrays . asList ( "disposed" , "error" ) , events ) ; 
final List < String > events = new ArrayList < > ( ) ; final Supplier < Resource > resourceFactory = createResourceFactory ( events ) ; final Consumer < Throwable > onError = createOnErrorAction ( events ) ; final Action unsub = createUnsubAction ( events ) ; Function < Resource , Flowable < String > > observableFactory = new Function < Resource , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Resource resource ) return Flowable . fromArray ( resource . getTextFromWeb ( ) . split ( " " ) ) . concatWith ( Flowable . < String > error ( new RuntimeException ( ) ) ) ; ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > flowable = Flowable . using ( resourceFactory , observableFactory , new DisposeAction ( ) , false ) . doOnCancel ( unsub ) . doOnError ( onError ) ; flowable . safeSubscribe ( subscriber ) ; assertEquals ( Arrays . asList ( "error" , "disposed" ) , events ) ; 
return new Action ( ) @ Override public void run ( ) events . add ( "unsub" ) ; ; 
return new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) events . add ( "error" ) ; ; 
return new Supplier < Resource > ( ) @ Override public Resource get ( ) return new Resource ( ) @ Override public String getTextFromWeb ( ) return "hello world" ; @ Override public void dispose ( ) events . add ( "disposed" ) ; ; ; 
return new Action ( ) @ Override public void run ( ) events . add ( "completed" ) ; ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . < Integer , Integer > using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throw new TestException ( "forced failure" ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer c ) count . incrementAndGet ( ) ; ) . subscribe ( ts ) ; ts . assertError ( TestException . class ) ; Assert . assertEquals ( 1 , count . get ( ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . < Integer , Integer > using ( new Supplier < Integer > ( ) @ Override public Integer get ( ) return 1 ; , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . just ( v ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer c ) count . incrementAndGet ( ) ; , false ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; Assert . assertEquals ( 1 , count . get ( ) ) ; 
TestSubscriberEx < Object > ts = Flowable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object v ) throws Exception throw new TestException ( "First" ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( "Second" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "First" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Second" ) ; 
throw new TestException ( "Second" ) ; 
TestSubscriberEx < Object > ts = Flowable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object v ) throws Exception return Flowable . error ( new TestException ( "First" ) ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( "Second" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "First" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Second" ) ; 
Flowable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object v ) throws Exception return Flowable . empty ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( "Second" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Second" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object v ) throws Exception return Flowable . empty ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( "Second" ) ; , false ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( ( Publisher < Object > ) null ) , Functions . emptyConsumer ( ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The sourceSupplier returned a null Publisher" ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return Flowable . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( f ) , Functions . emptyConsumer ( ) ) ; ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ts . cancel ( ) ; subscriber . onComplete ( ) ; ) , Functions . emptyConsumer ( ) , true ) . subscribe ( ts ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ts . cancel ( ) ; subscriber . onError ( new TestException ( ) ) ; ) , Functions . emptyConsumer ( ) , true ) . subscribe ( ts ) ; 
final StringBuilder sb = new StringBuilder ( ) ; Flowable . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) throws Throwable return Flowable . range ( 1 , 2 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Cancel" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , true ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; assertEquals ( "ResourceCancel" , sb . toString ( ) ) ; 
final StringBuilder sb = new StringBuilder ( ) ; Flowable . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) throws Throwable return Flowable . range ( 1 , 2 ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Cancel" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , false ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; assertEquals ( "CancelResource" , sb . toString ( ) ) ; 
stringSubscriber = TestHelper . mockSubscriber ( ) ; stringSubscriber2 = TestHelper . mockSubscriber ( ) ; 
Map < String , String > m1 = getMap ( "One" ) ; Map < String , String > m2 = getMap ( "Two" ) ; Flowable < Map < String , String > > flowable = Flowable . just ( m1 , m2 ) ; Flowable < String > m = flowable . map ( new Function < Map < String , String > , String > ( ) @ Override public String apply ( Map < String , String > map ) return map . get ( "firstName" ) ; ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "OneFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "TwoFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > ids = Flowable . just ( 1 , 2 ) ; Flowable < String > m = ids . flatMap ( new Function < Integer , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Integer id ) Flowable < Map < String , String > > subFlowable = null ; if ( id == 1 ) Map < String , String > m1 = getMap ( "One" ) ; Map < String , String > m2 = getMap ( "Two" ) ; subFlowable = Flowable . just ( m1 , m2 ) ; else Map < String , String > m3 = getMap ( "Three" ) ; Map < String , String > m4 = getMap ( "Four" ) ; subFlowable = Flowable . just ( m3 , m4 ) ; return subFlowable . map ( new Function < Map < String , String > , String > ( ) @ Override public String apply ( Map < String , String > map ) return map . get ( "firstName" ) ; ) ; ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "OneFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "TwoFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "ThreeFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "FourFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Map < String , String > m1 = getMap ( "One" ) ; Map < String , String > m2 = getMap ( "Two" ) ; Flowable < Map < String , String > > flowable1 = Flowable . just ( m1 , m2 ) ; Map < String , String > m3 = getMap ( "Three" ) ; Map < String , String > m4 = getMap ( "Four" ) ; Flowable < Map < String , String > > flowable2 = Flowable . just ( m3 , m4 ) ; Flowable < Flowable < Map < String , String > > > f = Flowable . just ( flowable1 , flowable2 ) ; Flowable < String > m = f . flatMap ( new Function < Flowable < Map < String , String > > , Flowable < String > > ( ) @ Override public Flowable < String > apply ( Flowable < Map < String , String > > f ) return f . map ( new Function < Map < String , String > , String > ( ) @ Override public String apply ( Map < String , String > map ) return map . get ( "firstName" ) ; ) ; ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "OneFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "TwoFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "ThreeFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "FourFirst" ) ; verify ( stringSubscriber , times ( 1 ) ) . onComplete ( ) ; 
final List < Throwable > errors = new ArrayList < > ( ) ; Flowable < String > w = Flowable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; Flowable < String > m = w . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new TestException ( "Forced Failure" ) ; return s ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) errors . add ( t1 ) ; ) ; m . subscribe ( stringSubscriber ) ; verify ( stringSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringSubscriber , never ( ) ) . onNext ( "two" ) ; verify ( stringSubscriber , never ( ) ) . onNext ( "three" ) ; verify ( stringSubscriber , never ( ) ) . onComplete ( ) ; verify ( stringSubscriber , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Forced Failure" ) ; 
Flowable . just ( 1 ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer arg0 ) throw new IllegalArgumentException ( "any error" ) ; ) . blockingSingle ( ) ; 
Flowable < String > m = Flowable . just ( "one" ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < String , String > ( ) @ Override public String apply ( String arg0 ) throw new IllegalArgumentException ( "any error" ) ; ) ; m . blockingLast ( ) ; 
assertNull ( Flowable . range ( 1 , 0 ) . lastElement ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i ; ) . blockingGet ( ) ) ; 
Flowable . error ( new IllegalStateException ( ) ) . map ( new Function < Object , Object > ( ) @ Override public Object apply ( Object i ) return i ; ) . blockingSingle ( ) ; 
Flowable . range ( 1 , 1 ) . lastElement ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i / 0 ; ) . blockingGet ( ) ; 
Map < String , String > m = new HashMap < > ( ) ; m . put ( "firstName" , prefix + "First" ) ; m . put ( "lastName" , prefix + "Last" ) ; return m ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; pp . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throw new TestException ( ) ; ) . subscribe ( ts ) ; Assert . assertTrue ( "Not subscribed?" , pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; Assert . assertFalse ( "Subscribed?" , pp . hasSubscribers ( ) ) ; ts . assertError ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . test ( ) . assertResult ( 2 , 3 ) ; 
Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 2 ) . hide ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . test ( ) . assertResult ( 2 , 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 2 , 3 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 2 ) . hide ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 2 , 3 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 2 ) . hide ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new IOException ( ) ) ; s . onComplete ( ) ; ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception return v + 1 ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . subscribe ( ts ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onComplete ( ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 2 , 3 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) ConditionalSubscriber < ? super Integer > cs = ( ConditionalSubscriber < ? super Integer > ) s ; cs . onSubscribe ( new BooleanSubscription ( ) ) ; cs . tryOnNext ( 1 ) ; cs . tryOnNext ( 2 ) ; cs . onError ( new IOException ( ) ) ; cs . onComplete ( ) ; ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . map ( Functions . identity ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . map ( Functions . identity ( ) ) ; ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 5 ) . map ( Functions . < Integer > identity ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . map ( Functions . < Integer > identity ( ) ) . subscribe ( ts ) ; TestHelper . emit ( up , 1 , 2 , 3 , 4 , 5 ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ; Flowable . range ( 1 , 5 ) . map ( Functions . < Integer > identity ( ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . map ( Functions . identity ( ) ) ; , false , 1 , 1 , 1 ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . empty ( ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . filter ( v -> true ) . map ( v -> v ) . filter ( v -> true ) . subscribe ( ts ) ; ts . assertResult ( ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Flowable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Action run = new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ; Flowable . fromCompletable ( Completable . fromAction ( run ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Flowable . fromCompletable ( Completable . fromAction ( run ) ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Flowable < Object > source = Flowable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception atomicInteger . incrementAndGet ( ) ; ) ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; source . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Flowable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception throw new UnsupportedOperationException ( ) ; ) ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestSubscriber < Object > ts = Flowable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception cdl1 . countDown ( ) ; cdl2 . await ( 5 , TimeUnit . SECONDS ) ; ) ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; ts . cancel ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , InterruptedException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Action run = mock ( Action . class ) ; Flowable . fromCompletable ( Completable . fromAction ( run ) ) . test ( 1L , true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . fromCompletable ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception ts . cancel ( ) ; ) ) . subscribeWith ( ts ) . assertEmpty ( ) ; assertTrue ( ts . isCancelled ( ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Action action = mock ( Action . class ) ; Flowable . fromCompletable ( Completable . fromAction ( action ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Action action = mock ( Action . class ) ; Flowable . fromCompletable ( Completable . fromAction ( action ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
Flowable < ? > f = Flowable . fromCompletable ( Completable . never ( ) ) ; assertTrue ( f instanceof HasUpstreamCompletableSource ) ; assertSame ( Completable . never ( ) , ( ( HasUpstreamCompletableSource ) f ) . source ( ) ) ; 
Flowable . range ( 1 , 5 ) . reduceWith ( Functions . justSupplier ( 1 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertResult ( 16 ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . reduceWith ( Functions . justSupplier ( 1 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
TestSubscriberEx < Integer > s = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 10 ) . takeLast ( 1 ) . subscribe ( s ) ; s . assertValue ( 10 ) ; s . assertNoErrors ( ) ; s . assertTerminated ( ) ; 
TestSubscriberEx < Object > s = new TestSubscriberEx < > ( ) ; Flowable . empty ( ) . takeLast ( 1 ) . subscribe ( s ) ; s . assertNoValues ( ) ; s . assertNoErrors ( ) ; s . assertTerminated ( ) ; 
TestSubscriberEx < Integer > s = new TestSubscriberEx < > ( ) ; Flowable . just ( 1 ) . takeLast ( 1 ) . subscribe ( s ) ; s . assertValue ( 1 ) ; s . assertNoErrors ( ) ; s . assertTerminated ( ) ; 
final AtomicBoolean unsubscribed = new AtomicBoolean ( false ) ; Action unsubscribeAction = new Action ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; ; Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) . doOnCancel ( unsubscribeAction ) . takeLast ( 1 ) . subscribe ( ) . dispose ( ) ; assertTrue ( unsubscribed . get ( ) ) ; 
MySubscriber < Integer > s = new MySubscriber < > ( 0 ) ; Flowable . just ( 1 ) . takeLast ( 1 ) . subscribe ( s ) ; assertEquals ( 0 , s . list . size ( ) ) ; s . requestMore ( 1 ) ; assertEquals ( 1 , s . list . size ( ) ) ; 
final AtomicInteger upstreamCount = new AtomicInteger ( ) ; final int num = 10 ; long count = Flowable . range ( 1 , num ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . takeLast ( 0 ) . count ( ) . blockingGet ( ) ; assertEquals ( num , upstreamCount . get ( ) ) ; assertEquals ( 0L , count ) ; 
if ( initialRequest > 0 ) request ( initialRequest ) ; 
$EMPTY$
$EMPTY$
TestHelper . checkDisposed ( Flowable . just ( 1 ) . takeLast ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . takeLast ( 1 ) ; ) ; 
Flowable . error ( new TestException ( ) ) . takeLast ( 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable < String > flowable = Flowable . fromIterable ( Arrays . < String > asList ( "one" , "two" , "three" ) ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Iterable < String > it = new Iterable < String > ( ) @ Override public Iterator < String > iterator ( ) return new Iterator < String > ( ) int i ; @ Override public boolean hasNext ( ) return i < 3 ; @ Override public String next ( ) return String . valueOf ( ++ i ) ; @ Override public void remove ( ) ; ; Flowable < String > flowable = Flowable . fromIterable ( it ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "1" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "2" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "3" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > flowable = Flowable . fromIterable ( Arrays . < String > asList ( "one" , "two" , "three" ) ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
ArrayList < Integer > list = new ArrayList < > ( Flowable . bufferSize ( ) ) ; for ( int i = 1 ; i <= Flowable . bufferSize ( ) + 1 ; i ++ ) list . add ( i ) ; Flowable < Integer > f = Flowable . fromIterable ( list ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; f . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . request ( 3 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 ) ; ts . request ( list . size ( ) ) ; ts . assertTerminated ( ) ; 
Flowable < Integer > f = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; ts . assertNoValues ( ) ; ts . request ( Long . MAX_VALUE ) ; f . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertTerminated ( ) ; 
Flowable < Integer > f = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; f . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable < Integer > f = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) ; final int expectedCount = 4 ; final CountDownLatch latch = new CountDownLatch ( expectedCount ) ; f . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 2 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new RuntimeException ( e ) ; @ Override public void onNext ( Integer t ) latch . countDown ( ) ; request ( Long . MAX_VALUE - 1 ) ; ) ; assertTrue ( latch . await ( 10 , TimeUnit . SECONDS ) ) ; 
final AtomicBoolean completed = new AtomicBoolean ( false ) ; Flowable . fromIterable ( Collections . emptyList ( ) ) . subscribe ( new DefaultSubscriber < Object > ( ) @ Override public void onStart ( ) @ Override public void onComplete ( ) completed . set ( true ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Object t ) ) ; assertTrue ( completed . get ( ) ) ; 
final AtomicBoolean called = new AtomicBoolean ( false ) ; Iterable < Integer > iterable = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count = 1 ; @ Override public void remove ( ) @ Override public boolean hasNext ( ) if ( count > 1 ) called . set ( true ) ; return false ; return true ; @ Override public Integer next ( ) return count ++ ; ; ; Flowable . fromIterable ( iterable ) . take ( 1 ) . subscribe ( ) ; assertFalse ( called . get ( ) ) ; 
final AtomicBoolean called = new AtomicBoolean ( false ) ; Iterable < Integer > iterable = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) int count = 1 ; @ Override public boolean hasNext ( ) if ( count > 1 ) called . set ( true ) ; return false ; return true ; @ Override public Integer next ( ) return count ++ ; ; ; Flowable . fromIterable ( iterable ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) cancel ( ) ; ) ; assertFalse ( called . get ( ) ) ; 
Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) throw new TestException ( "Forced failure" ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromIterable ( it ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) throw new TestException ( "Forced failure" ) ; @ Override public Integer next ( ) return null ; @ Override public void remove ( ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromIterable ( it ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count >= 2 ) throw new TestException ( "Forced failure" ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromIterable ( it ) . subscribe ( ts ) ; ts . assertValues ( 1 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count >= 2 ) throw new TestException ( "Forced failure" ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 5 ) ; Flowable . fromIterable ( it ) . subscribe ( ts ) ; ts . assertValues ( 1 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( "Forced failure" ) ; @ Override public void remove ( ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromIterable ( it ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( "Forced failure" ) ; @ Override public void remove ( ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 5 ) ; Flowable . fromIterable ( it ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Iterable < Integer > it = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new NoSuchElementException ( ) ; @ Override public void remove ( ) ; ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 5 ) ; ts . cancel ( ) ; Flowable . fromIterable ( it ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) . concatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . range ( v , 2 ) ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < Integer > qs = ( QueueSubscription < Integer > ) s ; assertFalse ( qs . isEmpty ( ) ) ; try assertEquals ( 1 , qs . poll ( ) . intValue ( ) ) ; catch ( Throwable ex ) throw new AssertionError ( ex ) ; assertFalse ( qs . isEmpty ( ) ) ; qs . clear ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try qs . request ( - 99 ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class , "n > 0 required but it was -99" ) ; finally RxJavaPlugins . reset ( ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( 5L ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) . filter ( Functions . alwaysTrue ( ) ) . to ( TestHelper . < Integer > testSubscriber ( 4L ) ) . assertSubscribed ( ) . assertValues ( 1 , 2 , 3 , 4 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) . filter ( Functions . alwaysFalse ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , null , 3 , 4 , 5 ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( NullPointerException . class , 1 ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , null , 3 , 4 , 5 ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( 5L ) . assertFailure ( NullPointerException . class , 1 ) ; 
Flowable . fromIterable ( new CrashingIterable ( 100 , 2 , 100 ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class , 0 ) ; 
Flowable . fromIterable ( new CrashingIterable ( 100 , 100 , 2 ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class , 0 ) ; 
Flowable . fromIterable ( new CrashingIterable ( 100 , 2 , 100 ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( 5L ) . assertFailure ( TestException . class , 0 ) ; 
Flowable . fromIterable ( new CrashingIterable ( 100 , 100 , 2 ) ) . filter ( Functions . alwaysTrue ( ) ) . test ( 5L ) . assertFailure ( TestException . class , 0 ) ; 
Flowable . fromIterable ( new CrashingIterable ( 100 , 10 * 1000 * 1000 , 10 * 1000 * 1000 ) ) . filter ( Functions . alwaysTrue ( ) ) . take ( 1000 * 1000 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Flowable . fromIterable ( new CrashingIterable ( 100 , 10 * 1000 * 1000 , 10 * 1000 * 1000 ) ) . filter ( Functions . alwaysTrue ( ) ) . rebatchRequests ( 128 ) . take ( 1000 * 1000 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( 1000 * 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) . filter ( Functions . alwaysFalse ( ) ) . subscribe ( ts ) ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( Long . MAX_VALUE ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) . subscribe ( ts ) ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( Long . MAX_VALUE ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) . subscribe ( ts ) ; TestHelper . race ( r1 , r2 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 ) ; 
Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < Integer > qs = ( QueueSubscription < Integer > ) s ; qs . requestFusion ( QueueFuseable . ANY ) ; try assertEquals ( 1 , qs . poll ( ) . intValue ( ) ) ; catch ( Throwable ex ) fail ( ex . toString ( ) ) ; qs . clear ( ) ; try assertNull ( qs . poll ( ) ) ; catch ( Throwable ex ) fail ( ex . toString ( ) ) ; @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
Flowable . fromIterable ( new CrashingIterable ( 1 , 100 , 100 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Flowable . fromIterable ( new CrashingIterable ( 100 , 2 , 100 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count == 2 ) ts . cancel ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( ts ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count == 2 ) ts . cancel ( ) ; return false ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( ts ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 10L ) ; Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count == 2 ) ts . cancel ( ) ; return false ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( ts ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count == 2 ) ts . cancel ( ) ; return false ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . filter ( v -> true ) . subscribe ( ts ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 10 ) ; Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count == 2 ) ts . cancel ( ) ; return false ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . filter ( v -> true ) . subscribe ( ts ) ; ts . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
AtomicReference < SimpleQueue < ? > > queue = new AtomicReference < > ( ) ; Flowable . fromIterable ( Arrays . asList ( 1 ) ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( @ NonNull Subscription s ) queue . set ( ( SimpleQueue < ? > ) s ) ; ( ( QueueSubscription < ? > ) s ) . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; SimpleQueue < ? > q = queue . get ( ) ; assertFalse ( q . isEmpty ( ) ) ; assertEquals ( 1 , q . poll ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; q . clear ( ) ; assertTrue ( q . isEmpty ( ) ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 10 ) ; Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) ts . cancel ( ) ; return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( 10 ) ; Flowable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) ts . cancel ( ) ; return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . filter ( v -> true ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
Subscription s = mock ( Subscription . class ) ; TestObservable f = new TestObservable ( s , "one" , "fail" , "two" , "three" ) ; Flowable < String > w = Flowable . unsafeCreate ( f ) ; Flowable < String > resume = Flowable . just ( "twoResume" , "threeResume" ) ; Flowable < String > flowable = w . onErrorResumeWith ( resume ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; try f . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "threeResume" ) ; 
Subscription sr = mock ( Subscription . class ) ; Flowable < String > w = Flowable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; TestObservable f = new TestObservable ( sr , "twoResume" , "threeResume" ) ; Flowable < String > resume = Flowable . unsafeCreate ( f ) ; w = w . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; System . out . println ( "BadMapper:" + s ) ; return s ; ) ; Flowable < String > flowable = w . onErrorResumeWith ( resume ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; try f . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( subscriber , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "threeResume" ) ; 
System . out . println ( "TestObservable subscribed to ..." ) ; subscriber . onSubscribe ( upstream ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestObservable thread" ) ; for ( String s : values ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; System . out . println ( "TestObservable onNext: " + s ) ; subscriber . onNext ( s ) ; System . out . println ( "TestObservable onComplete" ) ; subscriber . onComplete ( ) ; catch ( Throwable e ) System . out . println ( "TestObservable onError: " + e ) ; subscriber . onError ( e ) ; ) ; System . out . println ( "starting TestObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestObservable thread" ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , 100000 ) . onErrorResumeWith ( Flowable . just ( 1 ) ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t1 ) if ( c ++ <= 1 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; pp . onErrorResumeWith ( Flowable . range ( 3 , 2 ) ) . subscribe ( ts ) ; ts . request ( 2 ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onError ( new TestException ( "Forced failure" ) ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 3 , 4 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Long > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 100 ) ; infinite . take ( 500 ) . subscribe ( ts ) ; assertEquals ( 500 , ts . values ( ) . size ( ) ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 0 , Flowable . bufferSize ( ) * 10 ) . onBackpressureDrop ( ) . observeOn ( Schedulers . io ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; 
final CountDownLatch l1 = new CountDownLatch ( 100 ) ; final CountDownLatch l2 = new CountDownLatch ( 150 ) ; TestSubscriber < Long > ts = new TestSubscriber < > ( new DefaultSubscriber < Long > ( ) @ Override protected void onStart ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long t ) l1 . countDown ( ) ; l2 . countDown ( ) ; , 0L ) ; ts . request ( 100 ) ; infinite . subscribeOn ( Schedulers . computation ( ) ) . onBackpressureDrop ( ) . take ( 500 ) . subscribe ( ts ) ; l1 . await ( ) ; assertEquals ( 100 , ts . values ( ) . size ( ) ) ; ts . request ( 50 ) ; l2 . await ( ) ; assertEquals ( 150 , ts . values ( ) . size ( ) ) ; ts . request ( 350 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 500 , ts . values ( ) . size ( ) ) ; ts . assertNoErrors ( ) ; assertEquals ( 0 , ts . values ( ) . get ( 0 ) . intValue ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; int n = 10 ; range ( n ) . onBackpressureDrop ( ) . subscribe ( new DefaultSubscriber < Long > ( ) @ Override public void onStart ( ) request ( 10 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new RuntimeException ( e ) ; @ Override public void onNext ( Long t ) count . incrementAndGet ( ) ; request ( Long . MAX_VALUE - 1 ) ; ) ; assertEquals ( n , count . get ( ) ) ; 
final AtomicBoolean errorOccurred = new AtomicBoolean ( false ) ; TestSubscriber < Long > ts = TestSubscriber . create ( 0 ) ; range ( 2 ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) errorOccurred . set ( true ) ; ) . onBackpressureDrop ( THROW_NON_FATAL ) . subscribe ( ts ) ; assertFalse ( errorOccurred . get ( ) ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . onBackpressureDrop ( ) ; , false , 1 , 1 , 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . onBackpressureDrop ( ) ; ) ; 
TestHelper . assertBadRequestReported ( Flowable . just ( 1 ) . onBackpressureDrop ( ) ) ; 
Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; , true , Integer . MAX_VALUE ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 10 ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; , false , 3 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; , false , 1 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return null ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertFailure ( NullPointerException . class ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( ts . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 11 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; , false , 1 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; , false , 2 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 2 ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( ts , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . fromArray ( new String [ ] "1" , "a" , "2" ) . flatMapSingle ( new Function < String , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final String s ) throws NumberFormatException return Single . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws NumberFormatException return Integer . valueOf ( s ) ; ) ; ) . test ( ) . assertFailure ( NumberFormatException . class , 1 ) ; 
Flowable . range ( 1 , 1000 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 500 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . range ( 1 , 2 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) return pp . singleOrError ( ) ; return Single . error ( new TestException ( ) ) ; , true , Integer . MAX_VALUE ) . test ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class , 1 ) ; 
TestHelper . checkDisposed ( PublishProcessor . < Integer > create ( ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . < Integer > just ( 1 ) ; ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Object > f ) throws Exception return f . flatMapSingle ( Functions . justFunction ( Single . just ( 2 ) ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onError ( new TestException ( "Second" ) ) ; . flatMapSingle ( Functions . justFunction ( Single . just ( 2 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . flatMapSingle ( Functions . justFunction ( new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onError ( new TestException ( "Second" ) ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ; Flowable . just ( pp1 , pp2 ) . flatMapSingle ( new Function < PublishProcessor < Integer > , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( PublishProcessor < Integer > v ) throws Exception return v . singleOrError ( ) ; ) . subscribe ( ts ) ; pp1 . onNext ( 1 ) ; pp1 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Integer v ) throws Exception return new Single < Object > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ts . cancel ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( 1 ) . flatMapSingle ( Functions . justFunction ( pp . singleOrError ( ) ) ) . test ( ) ; pp . onNext ( 2 ) ; pp . onComplete ( ) ; ts . assertResult ( 2 ) ; 
TestSubscriber < Integer > ts = Flowable . just ( 1 ) . flatMapSingle ( Functions . justFunction ( Single . just ( 2 ) ) ) . test ( 0L ) . assertEmpty ( ) ; ts . request ( 1 ) ; ts . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . flatMapSingle ( Functions . justFunction ( Single . < Integer > error ( new TestException ( ) ) ) ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
Flowable . just ( 1 ) . flatMapSingle ( Functions . justFunction ( Single . < Integer > error ( new TestException ( ) ) ) , true , 16 ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) . flatMapSingle ( Functions . justFunction ( Single . just ( 2 ) ) ) . test ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Flowable . range ( 1 , 1000 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . < Integer > error ( new TestException ( ) ) . subscribeOn ( Schedulers . computation ( ) ) ; , true , 128 ) . take ( 500 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( CompositeException . class ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . flatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . flatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; , true , 2 ) ; ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . flatMapSingle ( v -> Single . never ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) SingleSubject < Integer > ss1 = SingleSubject . create ( ) ; SingleSubject < Integer > ss2 = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( ss1 , ss2 ) . flatMapSingle ( v -> v ) . test ( ) ; TestHelper . race ( ( ) -> ss1 . onSuccess ( 1 ) , ( ) -> ss2 . onSuccess ( 1 ) ) ; ts . assertResult ( 1 , 1 ) ; 
SingleSubject < Integer > ss1 = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( ss1 ) . hide ( ) . flatMapSingle ( v -> v ) . test ( ) ; ss1 . onSuccess ( 1 ) ; ts . assertResult ( 1 ) ; 
MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . subscribe ( mp ) ; TestSubscriber < Integer > ts1 = mp . test ( ) ; TestSubscriber < Integer > ts2 = mp . take ( 1 ) . test ( ) ; up . onNext ( 1 ) ; up . onNext ( 2 ) ; up . onComplete ( ) ; ts1 . assertResult ( 1 , 2 ) ; ts2 . assertResult ( 1 ) ; 
MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; mp . onSubscribe ( new QueueSubscription < Integer > ( ) @ Override public int requestFusion ( int mode ) return 0 ; @ Override public boolean offer ( Integer value ) return false ; @ Override public boolean offer ( Integer v1 , Integer v2 ) return false ; @ Override public Integer poll ( ) throws Exception return null ; @ Override public boolean isEmpty ( ) return false ; @ Override public void clear ( ) @ Override public void request ( long n ) @ Override public void cancel ( ) ) ; TestSubscriber < Integer > ts = mp . test ( ) ; mp . onNext ( 1 ) ; mp . onNext ( 2 ) ; mp . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; final MulticastSubscription < Integer > ms1 = new MulticastSubscription < > ( null , mp ) ; final MulticastSubscription < Integer > ms2 = new MulticastSubscription < > ( null , mp ) ; assertTrue ( mp . add ( ms1 ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) mp . remove ( ms1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) mp . add ( ms2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; MulticastSubscription < Integer > ms1 = new MulticastSubscription < > ( null , mp ) ; assertTrue ( mp . add ( ms1 ) ) ; mp . remove ( null ) ; 
MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; MulticastSubscription < Integer > ms1 = new MulticastSubscription < > ( null , mp ) ; assertTrue ( mp . add ( ms1 ) ) ; ms1 . set ( Long . MIN_VALUE ) ; mp . errorAll ( null ) ; 
MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; MulticastSubscription < Integer > ms1 = new MulticastSubscription < > ( null , mp ) ; assertTrue ( mp . add ( ms1 ) ) ; ms1 . set ( Long . MIN_VALUE ) ; mp . completeAll ( ) ; 
final MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; final MulticastSubscription < Integer > ms1 = new MulticastSubscription < > ( null , mp ) ; assertTrue ( mp . add ( ms1 ) ) ; mp . onSubscribe ( new BooleanSubscription ( ) ) ; ms1 . set ( Long . MIN_VALUE ) ; mp . drain ( ) ; 
final MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; final MulticastSubscription < Integer > ms1 = new MulticastSubscription < > ( null , mp ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ms1 . request ( - 1 ) ; TestHelper . assertError ( errors , 0 , IllegalArgumentException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . doubleOnSubscribe ( new OutputCanceller < > ( new TestSubscriber < > ( ) , null ) ) ; 
final MulticastProcessor < Integer > mp = new MulticastProcessor < > ( 128 , true ) ; mp . onSubscribe ( new BooleanSubscription ( ) ) ; mp . onNext ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final MulticastSubscription < Integer > ms1 = new MulticastSubscription < > ( ts , mp ) ; ts . onSubscribe ( ms1 ) ; assertTrue ( mp . add ( ms1 ) ) ; ms1 . set ( Long . MIN_VALUE ) ; mp . drain ( ) ; assertFalse ( mp . queue . isEmpty ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyInt ( ) ) ; other . onNext ( 1 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyInt ( ) ) ; source . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( ( 2 << 8 ) + 1 ) ; other . onNext ( 2 ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyInt ( ) ) ; other . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onNext ( ( 3 << 8 ) + 2 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( other . hasSubscribers ( ) ) ; other . onNext ( 1 ) ; source . onComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertNoValues ( ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( other . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( other . hasSubscribers ( ) ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertNoValues ( ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( other . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( other . hasSubscribers ( ) ) ; other . onNext ( 1 ) ; source . onNext ( 1 ) ; ts . cancel ( ) ; ts . assertValue ( ( 1 << 8 ) + 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( other . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( other . hasSubscribers ( ) ) ; other . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; ts . assertTerminated ( ) ; ts . assertValue ( ( 1 << 8 ) + 1 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( other . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( other . hasSubscribers ( ) ) ; other . onNext ( 1 ) ; source . onNext ( 1 ) ; other . onError ( new TestException ( ) ) ; ts . assertTerminated ( ) ; ts . assertValue ( ( 1 << 8 ) + 1 ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( other . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER_ERROR ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; result . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( other . hasSubscribers ( ) ) ; other . onNext ( 1 ) ; source . onNext ( 1 ) ; ts . assertTerminated ( ) ; ts . assertNotComplete ( ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( other . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; result . subscribe ( ts ) ; source . onComplete ( ) ; assertFalse ( ts . isCancelled ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; result . subscribe ( ts ) ; assertTrue ( "Other has no observers!" , other . hasSubscribers ( ) ) ; ts . request ( 1 ) ; source . onNext ( 1 ) ; assertTrue ( "Other has no observers!" , other . hasSubscribers ( ) ) ; ts . assertNoValues ( ) ; other . onNext ( 1 ) ; source . onNext ( 2 ) ; ts . assertValue ( ( 2 << 8 ) + 1 ) ; ts . request ( 5 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; source . onNext ( 7 ) ; ts . assertValues ( ( 2 << 8 ) + 1 , ( 3 << 8 ) + 1 , ( 4 << 8 ) + 1 , ( 5 << 8 ) + 1 , ( 6 << 8 ) + 1 , ( 7 << 8 ) + 1 ) ; ts . cancel ( ) ; assertFalse ( "Other has observers!" , other . hasSubscribers ( ) ) ; ts . assertNoErrors ( ) ; 
PublishProcessor < String > pp1 = PublishProcessor . create ( ) ; PublishProcessor < String > pp2 = PublishProcessor . create ( ) ; PublishProcessor < String > pp3 = PublishProcessor . create ( ) ; PublishProcessor < String > main = PublishProcessor . create ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; main . withLatestFrom ( new Flowable [ ] pp1 , pp2 , pp3 , toArray ) . subscribe ( ts ) ; main . onNext ( "1" ) ; ts . assertNoValues ( ) ; pp1 . onNext ( "a" ) ; ts . assertNoValues ( ) ; pp2 . onNext ( "A" ) ; ts . assertNoValues ( ) ; pp3 . onNext ( "=" ) ; ts . assertNoValues ( ) ; main . onNext ( "2" ) ; ts . assertValues ( "[2, a, A, =]" ) ; pp2 . onNext ( "B" ) ; ts . assertValues ( "[2, a, A, =]" ) ; pp3 . onComplete ( ) ; ts . assertValues ( "[2, a, A, =]" ) ; pp1 . onNext ( "b" ) ; main . onNext ( "3" ) ; ts . assertValues ( "[2, a, A, =]" , "[3, b, B, =]" ) ; main . onComplete ( ) ; ts . assertValues ( "[2, a, A, =]" , "[3, b, B, =]" ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; assertFalse ( "ps1 has subscribers?" , pp1 . hasSubscribers ( ) ) ; assertFalse ( "ps2 has subscribers?" , pp2 . hasSubscribers ( ) ) ; assertFalse ( "ps3 has subscribers?" , pp3 . hasSubscribers ( ) ) ; 
PublishProcessor < String > pp1 = PublishProcessor . create ( ) ; PublishProcessor < String > pp2 = PublishProcessor . create ( ) ; PublishProcessor < String > pp3 = PublishProcessor . create ( ) ; PublishProcessor < String > main = PublishProcessor . create ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; main . withLatestFrom ( Arrays . < Flowable < ? > > asList ( pp1 , pp2 , pp3 ) , toArray ) . subscribe ( ts ) ; main . onNext ( "1" ) ; ts . assertNoValues ( ) ; pp1 . onNext ( "a" ) ; ts . assertNoValues ( ) ; pp2 . onNext ( "A" ) ; ts . assertNoValues ( ) ; pp3 . onNext ( "=" ) ; ts . assertNoValues ( ) ; main . onNext ( "2" ) ; ts . assertValues ( "[2, a, A, =]" ) ; pp2 . onNext ( "B" ) ; ts . assertValues ( "[2, a, A, =]" ) ; pp3 . onComplete ( ) ; ts . assertValues ( "[2, a, A, =]" ) ; pp1 . onNext ( "b" ) ; main . onNext ( "3" ) ; ts . assertValues ( "[2, a, A, =]" , "[3, b, B, =]" ) ; main . onComplete ( ) ; ts . assertValues ( "[2, a, A, =]" , "[3, b, B, =]" ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; assertFalse ( "ps1 has subscribers?" , pp1 . hasSubscribers ( ) ) ; assertFalse ( "ps2 has subscribers?" , pp2 . hasSubscribers ( ) ) ; assertFalse ( "ps3 has subscribers?" , pp3 . hasSubscribers ( ) ) ; 
for ( String val : new String [ ] "1" ) int n = 35 ; for ( int i = 0 ; i < n ; i ++ ) List < Flowable < ? > > sources = new ArrayList < > ( ) ; List < String > expected = new ArrayList < > ( ) ; expected . add ( val ) ; for ( int j = 0 ; j < i ; j ++ ) sources . add ( Flowable . just ( val ) ) ; expected . add ( String . valueOf ( val ) ) ; TestSubscriber < String > ts = new TestSubscriber < > ( ) ; PublishProcessor < String > main = PublishProcessor . create ( ) ; main . withLatestFrom ( sources , toArray ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; main . onNext ( val ) ; main . onComplete ( ) ; ts . assertValue ( expected . toString ( ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
PublishProcessor < String > pp1 = PublishProcessor . create ( ) ; PublishProcessor < String > pp2 = PublishProcessor . create ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; Flowable . range ( 1 , 10 ) . withLatestFrom ( new Flowable < ? > [ ] pp1 , pp2 , toArray ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; assertFalse ( "ps1 has subscribers?" , pp1 . hasSubscribers ( ) ) ; assertFalse ( "ps2 has subscribers?" , pp2 . hasSubscribers ( ) ) ; 
PublishProcessor < String > pp1 = PublishProcessor . create ( ) ; PublishProcessor < String > pp2 = PublishProcessor . create ( ) ; TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; Flowable . range ( 1 , 3 ) . withLatestFrom ( new Flowable < ? > [ ] pp1 , pp2 , toArray ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; pp1 . onNext ( "1" ) ; pp2 . onNext ( "1" ) ; ts . request ( 1 ) ; ts . assertValue ( "[1, 1, 1]" ) ; ts . request ( 1 ) ; ts . assertValues ( "[1, 1, 1]" , "[2, 1, 1]" ) ; ts . request ( 1 ) ; ts . assertValues ( "[1, 1, 1]" , "[2, 1, 1]" , "[3, 1, 1]" ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; assertFalse ( "ps1 has subscribers?" , pp1 . hasSubscribers ( ) ) ; assertFalse ( "ps2 has subscribers?" , pp2 . hasSubscribers ( ) ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; Flowable . range ( 1 , 3 ) . withLatestFrom ( new Flowable < ? > [ ] Flowable . just ( 1 ) , Flowable . empty ( ) , toArray ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; Flowable . range ( 1 , 3 ) . withLatestFrom ( new Flowable < ? > [ ] Flowable . just ( 1 ) , Flowable . error ( new TestException ( ) ) , toArray ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < String > ts = new TestSubscriber < > ( 0 ) ; Flowable . error ( new TestException ( ) ) . withLatestFrom ( new Flowable < ? > [ ] Flowable . just ( 1 ) , Flowable . just ( 1 ) , toArray ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Flowable < Integer > just = Flowable . just ( 1 ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; just . withLatestFrom ( just , just , new Function3 < Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer a , Integer b , Integer c ) return Arrays . asList ( a , b , c ) ; ) . subscribe ( ts ) ; ts . assertValue ( Arrays . asList ( 1 , 1 , 1 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable < Integer > just = Flowable . just ( 1 ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; just . withLatestFrom ( just , just , just , new Function4 < Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer a , Integer b , Integer c , Integer d ) return Arrays . asList ( a , b , c , d ) ; ) . subscribe ( ts ) ; ts . assertValue ( Arrays . asList ( 1 , 1 , 1 , 1 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable < Integer > just = Flowable . just ( 1 ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( ) ; just . withLatestFrom ( just , just , just , just , new Function5 < Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer a , Integer b , Integer c , Integer d , Integer e ) return Arrays . asList ( a , b , c , d , e ) ; ) . subscribe ( ts ) ; ts . assertValue ( Arrays . asList ( 1 , 1 , 1 , 1 , 1 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . withLatestFrom ( Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a ; ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . withLatestFrom ( Flowable . just ( 2 ) , Flowable . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception return a ; ) ) ; 
Flowable . just ( 1 ) . withLatestFrom ( new CrashingMappedIterable < > ( 1 , 100 , 100 , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . just ( 2 ) ; ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return a ; ) . to ( TestHelper . testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Flowable . just ( 1 ) . withLatestFrom ( Flowable . just ( 2 ) , Flowable . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( "Second" ) ) ; subscriber . onComplete ( ) ; . withLatestFrom ( Flowable . just ( 2 ) , Flowable . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception return a ; ) . to ( TestHelper . testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . withLatestFrom ( new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( "First" ) ) ; s . onError ( new TestException ( "Second" ) ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . just ( 1 ) . withLatestFrom ( Flowable . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable . just ( 1 ) . withLatestFrom ( Arrays . asList ( Flowable . just ( 2 ) , Flowable . just ( 3 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] o ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Flowable . just ( 1 ) . withLatestFrom ( new Flowable [ 0 ] , Functions . justFunction ( null ) ) . to ( TestHelper . testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The combiner returned a null value" ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; Flowable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; result . subscribe ( ts ) ; ts . request ( 1 ) ; source . onNext ( 1 ) ; ts . assertNoValues ( ) ; other . onNext ( 1 ) ; ts . assertNoValues ( ) ; source . onNext ( 2 ) ; ts . assertValue ( ( 2 << 8 ) + 1 ) ; 
Flowable . range ( 1 , 10 ) . withLatestFrom ( Flowable . never ( ) , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer a , Object b ) throws Exception return a ; ) . test ( 1 ) . assertResult ( ) ; 
Flowable . range ( 1 , 10 ) . withLatestFrom ( Flowable . never ( ) , Flowable . never ( ) , Flowable . never ( ) , new Function4 < Integer , Object , Object , Object , Object > ( ) @ Override public Object apply ( Integer a , Object b , Object c , Object d ) throws Exception return a ; ) . test ( 1 ) . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp3 = PublishProcessor . create ( ) ; final Flowable < Object > source = pp0 . withLatestFrom ( pp1 , pp2 , pp3 , new Function4 < Object , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b , Integer c , Integer d ) throws Exception return a ; ) ; final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . subscribe ( ts ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertEmpty ( ) ; assertFalse ( pp0 . hasSubscribers ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; assertFalse ( pp3 . hasSubscribers ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp0 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp3 = PublishProcessor . create ( ) ; final Flowable < Object > source = pp0 . withLatestFrom ( pp1 , pp2 , pp3 , new Function4 < Object , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Object a , Integer b , Integer c , Integer d ) throws Exception return a ; ) ; final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) source . subscribe ( ts ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp1 . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( ) ; assertFalse ( pp0 . hasSubscribers ( ) ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; assertFalse ( pp3 . hasSubscribers ( ) ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; subscriber = TestHelper . mockSubscriber ( ) ; subscriber2 = TestHelper . mockSubscriber ( ) ; 
Flowable < Long > source = Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( final Subscriber < ? super Long > subscriber1 ) subscriber1 . onSubscribe ( new BooleanSubscription ( ) ) ; innerScheduler . schedule ( new Runnable ( ) @ Override public void run ( ) subscriber1 . onNext ( 1L ) ; , 1 , TimeUnit . SECONDS ) ; innerScheduler . schedule ( new Runnable ( ) @ Override public void run ( ) subscriber1 . onNext ( 2L ) ; , 2 , TimeUnit . SECONDS ) ; innerScheduler . schedule ( new Runnable ( ) @ Override public void run ( ) subscriber1 . onComplete ( ) ; , 3 , TimeUnit . SECONDS ) ; ) ; Flowable < Long > sampled = source . sample ( 400L , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 800L , TimeUnit . MILLISECONDS ) ; verify ( subscriber , never ( ) ) . onNext ( any ( Long . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 1200L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1L ) ; verify ( subscriber , never ( ) ) . onNext ( 2L ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 1600L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 1L ) ; verify ( subscriber , never ( ) ) . onNext ( 2L ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 1L ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2L ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 1L ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( 2L ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; Flowable < Integer > m = source . sample ( sampler ) ; m . subscribe ( subscriber2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; sampler . onNext ( 1 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; sampler . onNext ( 2 ) ; source . onComplete ( ) ; sampler . onNext ( 3 ) ; InOrder inOrder = inOrder ( subscriber2 ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; Flowable < Integer > m = source . sample ( sampler ) ; m . subscribe ( subscriber2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; sampler . onNext ( 1 ) ; sampler . onNext ( 1 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; sampler . onNext ( 2 ) ; sampler . onNext ( 2 ) ; source . onComplete ( ) ; sampler . onNext ( 3 ) ; InOrder inOrder = inOrder ( subscriber2 ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; Flowable < Integer > m = source . sample ( sampler ) ; m . subscribe ( subscriber2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; sampler . onNext ( 1 ) ; sampler . onComplete ( ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; InOrder inOrder = inOrder ( subscriber2 ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; Flowable < Integer > m = source . sample ( sampler ) ; m . subscribe ( subscriber2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; sampler . onNext ( 1 ) ; source . onNext ( 3 ) ; source . onComplete ( ) ; sampler . onNext ( 2 ) ; sampler . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber2 ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( subscriber2 , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; Flowable < Integer > m = source . sample ( sampler ) ; m . subscribe ( subscriber2 ) ; source . onComplete ( ) ; sampler . onNext ( 1 ) ; InOrder inOrder = inOrder ( subscriber2 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber2 , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; Flowable < Integer > m = source . sample ( sampler ) ; m . subscribe ( subscriber2 ) ; source . onNext ( 1 ) ; source . onError ( new RuntimeException ( "Forced failure!" ) ) ; sampler . onNext ( 1 ) ; InOrder inOrder = inOrder ( subscriber2 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber2 , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; Flowable < Integer > m = source . sample ( sampler ) ; m . subscribe ( subscriber2 ) ; source . onNext ( 1 ) ; sampler . onNext ( 1 ) ; sampler . onError ( new RuntimeException ( "Forced failure!" ) ) ; InOrder inOrder = inOrder ( subscriber2 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber2 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
final Subscription s = mock ( Subscription . class ) ; Flowable < Integer > f = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( s ) ; ) ; f . throttleLast ( 1 , TimeUnit . MILLISECONDS ) . subscribe ( ) . dispose ( ) ; verify ( s ) . cancel ( ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . sample ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . sample ( Flowable . never ( ) ) ) ; 
Flowable . error ( new TestException ( ) ) . sample ( 1 , TimeUnit . SECONDS ) . test ( ) . assertFailure ( TestException . class ) ; 
BehaviorProcessor . createDefault ( 1 ) . sample ( 1 , TimeUnit . MILLISECONDS ) . test ( 0L ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( MissingBackpressureException . class ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp1 . sample ( pp2 ) . test ( 0L ) ; pp1 . onNext ( 1 ) ; pp2 . onNext ( 2 ) ; ts . assertFailure ( MissingBackpressureException . class ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; 
Flowable . just ( 1 ) . sample ( 1 , TimeUnit . DAYS , true ) . test ( ) . assertResult ( 1 ) ; 
Flowable . empty ( ) . sample ( 1 , TimeUnit . DAYS , true ) . test ( ) . assertResult ( ) ; 
Flowable . just ( 1 ) . sample ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , true ) . test ( ) . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestScheduler scheduler = new TestScheduler ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . sample ( 1 , TimeUnit . SECONDS , scheduler , true ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . sample ( Flowable . timer ( 1 , TimeUnit . DAYS ) , true ) . test ( ) . assertResult ( 1 ) ; 
Flowable . empty ( ) . sample ( Flowable . timer ( 1 , TimeUnit . DAYS ) , true ) . test ( ) . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . sample ( sampler , true ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sampler . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final PublishProcessor < Integer > sampler = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . sample ( sampler , true ) . test ( ) ; pp . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sampler . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertResult ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . sample ( 1 , TimeUnit . SECONDS ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . sample ( PublishProcessor . create ( ) ) ; ) ; 
TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) . sample ( PublishProcessor . create ( ) ) ) ; 
TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) . sample ( 1 , TimeUnit . MINUTES ) ) ; 
assertEquals ( 1 , Flowable . range ( 1 , 10 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingFirst ( ) . intValue ( ) ) ; 
assertEquals ( 1 , Flowable . < Integer > empty ( ) . subscribeOn ( Schedulers . computation ( ) ) . blockingFirst ( 1 ) . intValue ( ) ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , 128 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Integer > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , 3 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , Functions . emptyConsumer ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , Functions . emptyConsumer ( ) , 128 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; , Functions . emptyConsumer ( ) , 3 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; TestException ex = new TestException ( ) ; Consumer < Object > cons = new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( v ) ; ; Flowable . range ( 1 , 5 ) . concatWith ( Flowable . < Integer > error ( ex ) ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( cons , cons ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , ex ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; TestException ex = new TestException ( ) ; Consumer < Object > cons = new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( v ) ; ; Flowable . range ( 1 , 5 ) . concatWith ( Flowable . < Integer > error ( ex ) ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( cons , cons , 128 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , ex ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Consumer < Object > cons = new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( v ) ; ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( cons , cons , new Action ( ) @ Override public void run ( ) throws Exception list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 100 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Consumer < Object > cons = new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( v ) ; ; Action action = new Action ( ) @ Override public void run ( ) throws Exception list . add ( 100 ) ; ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( cons , cons , action , 128 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 100 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Consumer < Object > cons = new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( v ) ; ; Action action = new Action ( ) @ Override public void run ( ) throws Exception list . add ( 100 ) ; ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( cons , cons , action , 3 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 100 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Consumer < Object > cons = new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( v ) ; ; Action action = new Action ( ) @ Override public void run ( ) throws Exception list . add ( 1000001 ) ; ; Flowable . range ( 1 , 1000000 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( cons , cons , action , 128 ) ; assertEquals ( 1000000 + 1 , list . size ( ) ) ; 
final List < Object > list = new ArrayList < > ( ) ; Flowable . range ( 1 , 5 ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) s . request ( Long . MAX_VALUE ) ; @ Override public void onNext ( Object value ) list . add ( value ) ; @ Override public void onError ( Throwable e ) list . add ( e ) ; @ Override public void onComplete ( ) list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 100 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; final TestException ex = new TestException ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Flowable . < Integer > error ( ex ) ) . subscribeOn ( Schedulers . computation ( ) ) . blockingSubscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) s . request ( Long . MAX_VALUE ) ; @ Override public void onNext ( Object value ) list . add ( value ) ; @ Override public void onError ( Throwable e ) list . add ( e ) ; @ Override public void onComplete ( ) list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , ex ) , list ) ; 
Flowable . just ( 1 ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer e ) throws Exception throw new TestException ( ) ; ) ; 
Flowable . empty ( ) . blockingFirst ( ) ; 
Flowable . empty ( ) . blockingLast ( ) ; 
assertEquals ( 1 , Flowable . just ( 1 , 2 ) . blockingFirst ( 3 ) . intValue ( ) ) ; 
assertEquals ( 2 , Flowable . just ( 1 , 2 ) . blockingLast ( 3 ) . intValue ( ) ) ; 
Flowable < Integer > source = Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; ) ; assertEquals ( 1 , source . blockingFirst ( ) . intValue ( ) ) ; 
List < Throwable > list = TestHelper . trackPluginErrors ( ) ; try Flowable < Integer > source = Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( ) ) ; ) ; assertEquals ( 1 , source . blockingFirst ( ) . intValue ( ) ) ; TestHelper . assertUndeliverable ( list , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < Integer > source = Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onError ( new TestException ( ) ) ; ) ; source . blockingFirst ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Thread . currentThread ( ) . interrupt ( ) ; try Flowable . just ( 1 ) . blockingSubscribe ( ts ) ; ts . assertFailure ( InterruptedException . class ) ; finally Thread . interrupted ( ) ; 
Flowable . empty ( ) . blockingSingle ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . empty ( ) . delay ( 100 , TimeUnit . MILLISECONDS ) . blockingSubscribe ( ts ) ; ts . assertResult ( ) ; 
TestHelper . checkUtilityClass ( FlowableBlockingSubscribe . class ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; ts . cancel ( ) ; Flowable . just ( 1 ) . blockingSubscribe ( ts ) ; ts . assertEmpty ( ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; final Subscriber [ ] s = null ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ SuppressWarnings ( "unchecked" ) @ Override public void run ( ) ts . cancel ( ) ; s [ 0 ] . onNext ( 1 ) ; , 200 , TimeUnit . MILLISECONDS ) ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; s [ 0 ] = subscriber ; . blockingSubscribe ( ts ) ; while ( ! ts . isCancelled ( ) ) Thread . sleep ( 100 ) ; ts . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; final Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp . onNext ( 1 ) ; ; final AtomicInteger c = new AtomicInteger ( 2 ) ; Schedulers . computation ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) c . decrementAndGet ( ) ; while ( c . get ( ) != 0 && ! pp . hasSubscribers ( ) ) TestHelper . race ( r1 , r2 ) ; ) ; c . decrementAndGet ( ) ; while ( c . get ( ) != 0 ) pp . blockingSubscribe ( ts ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) List < Flowable < String > > os = new ArrayList < > ( ) ; os . add ( Flowable . just ( "one" , "two" , "three" , "four" , "five" ) . subscribeOn ( Schedulers . newThread ( ) ) ) ; os . add ( Flowable . just ( "one" , "two" , "three" , "four" , "five" ) . subscribeOn ( Schedulers . newThread ( ) ) ) ; os . add ( Flowable . just ( "one" , "two" , "three" , "four" , "five" ) . subscribeOn ( Schedulers . newThread ( ) ) ) ; List < String > expected = Arrays . asList ( "one" , "two" , "three" , "four" , "five" , "one" , "two" , "three" , "four" , "five" , "one" , "two" , "three" , "four" , "five" ) ; Iterator < String > iter = Flowable . merge ( os , 1 ) . blockingIterable ( ) . iterator ( ) ; List < String > actual = new ArrayList < > ( ) ; while ( iter . hasNext ( ) ) actual . add ( iter . next ( ) ) ; assertEquals ( expected , actual ) ; 
for ( int times = 0 ; times < 100 ; times ++ ) int observableCount = 100 ; int maxConcurrent = 2 + ( times % 10 ) ; AtomicInteger subscriptionCount = new AtomicInteger ( 0 ) ; List < Flowable < String > > os = new ArrayList < > ( ) ; List < SubscriptionCheckObservable > scos = new ArrayList < > ( ) ; for ( int i = 0 ; i < observableCount ; i ++ ) SubscriptionCheckObservable sco = new SubscriptionCheckObservable ( subscriptionCount , maxConcurrent ) ; scos . add ( sco ) ; os . add ( Flowable . unsafeCreate ( sco ) ) ; Iterator < String > iter = Flowable . merge ( os , maxConcurrent ) . blockingIterable ( ) . iterator ( ) ; List < String > actual = new ArrayList < > ( ) ; while ( iter . hasNext ( ) ) actual . add ( iter . next ( ) ) ; assertEquals ( 5 * observableCount , actual . size ( ) ) ; for ( SubscriptionCheckObservable sco : scos ) assertFalse ( sco . failed ) ; 
t1 . onSubscribe ( new BooleanSubscription ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) if ( subscriptionCount . incrementAndGet ( ) > maxConcurrent ) failed = true ; t1 . onNext ( "one" ) ; t1 . onNext ( "two" ) ; t1 . onNext ( "three" ) ; t1 . onNext ( "four" ) ; t1 . onNext ( "five" ) ; subscriptionCount . decrementAndGet ( ) ; t1 . onComplete ( ) ; ) . start ( ) ; 
int n = 10000 ; List < Flowable < Integer > > sourceList = new ArrayList < > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) sourceList . add ( Flowable . just ( i ) ) ; Iterator < Integer > it = Flowable . merge ( Flowable . fromIterable ( sourceList ) , 1 ) . blockingIterable ( ) . iterator ( ) ; int j = 0 ; while ( it . hasNext ( ) ) assertEquals ( ( Integer ) j , it . next ( ) ) ; j ++ ; assertEquals ( j , n ) ; 
int n = 10000 ; List < Flowable < Integer > > sourceList = new ArrayList < > ( n ) ; for ( int i = 0 ; i < n ; i ++ ) sourceList . add ( Flowable . just ( i ) ) ; Iterator < Integer > it = Flowable . merge ( Flowable . fromIterable ( sourceList ) , 1 ) . take ( n / 2 ) . blockingIterable ( ) . iterator ( ) ; int j = 0 ; while ( it . hasNext ( ) ) assertEquals ( ( Integer ) j , it . next ( ) ) ; j ++ ; assertEquals ( j , n / 2 ) ; 
for ( int i = 1 ; i < 100 ; i ++ ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; List < Flowable < Integer > > sourceList = new ArrayList < > ( i ) ; List < Integer > result = new ArrayList < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) sourceList . add ( Flowable . just ( j ) ) ; result . add ( j ) ; Flowable . merge ( sourceList , i ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValueSequence ( result ) ; 
for ( int i = 2 ; i < 100 ; i ++ ) TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; List < Flowable < Integer > > sourceList = new ArrayList < > ( i ) ; List < Integer > result = new ArrayList < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) sourceList . add ( Flowable . just ( j ) ) ; result . add ( j ) ; Flowable . merge ( sourceList , i - 1 ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValueSequence ( result ) ; 
IoScheduler ios = ( IoScheduler ) Schedulers . io ( ) ; int c = ios . size ( ) ; for ( int i = 0 ; i < 200 ; i ++ ) simpleAsync ( ) ; int c1 = ios . size ( ) ; if ( c + 60 < c1 ) throw new AssertionError ( "Worker leak: " + c + " - " + c1 ) ; 
for ( int i = 1 ; i < 50 ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; List < Flowable < Integer > > sourceList = new ArrayList < > ( i ) ; Set < Integer > expected = new HashSet < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) sourceList . add ( Flowable . just ( j ) . subscribeOn ( Schedulers . io ( ) ) ) ; expected . add ( j ) ; Flowable . merge ( sourceList , i ) . subscribe ( ts ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; Set < Integer > actual = new HashSet < > ( ts . values ( ) ) ; assertEquals ( expected , actual ) ; 
for ( int i = 0 ; i < 200 ; i ++ ) simpleOneLessAsync ( ) ; 
long t = System . currentTimeMillis ( ) ; for ( int i = 2 ; i < 50 ; i ++ ) if ( System . currentTimeMillis ( ) - t > TimeUnit . SECONDS . toMillis ( 9 ) ) break ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; List < Flowable < Integer > > sourceList = new ArrayList < > ( i ) ; Set < Integer > expected = new HashSet < > ( i ) ; for ( int j = 1 ; j <= i ; j ++ ) sourceList . add ( Flowable . just ( j ) . subscribeOn ( Schedulers . io ( ) ) ) ; expected . add ( j ) ; Flowable . merge ( sourceList , i - 1 ) . subscribe ( ts ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; Set < Integer > actual = new HashSet < > ( ts . values ( ) ) ; assertEquals ( expected , actual ) ; 
List < Flowable < Integer > > sourceList = new ArrayList < > ( 3 ) ; sourceList . add ( Flowable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; sourceList . add ( Flowable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; sourceList . add ( Flowable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; final CountDownLatch cdl = new CountDownLatch ( 5 ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 0L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cdl . countDown ( ) ; ; Flowable . merge ( sourceList , 2 ) . subscribe ( ts ) ; ts . request ( 5 ) ; cdl . await ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 5 ) ; ts . assertNotComplete ( ) ; ts . cancel ( ) ; 
List < Flowable < Integer > > sourceList = new ArrayList < > ( 3 ) ; sourceList . add ( Flowable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; sourceList . add ( Flowable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; sourceList . add ( Flowable . range ( 0 , 100000 ) . subscribeOn ( Schedulers . io ( ) ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . merge ( sourceList , 2 ) . take ( 5 ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 5 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Flowable . < Integer > create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onComplete ( ) ; e . onError ( new TestException ( "first" ) ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( "second" ) ) ; e . onComplete ( ) ; , BackpressureStrategy . BUFFER ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "first" ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d1 = Disposable . empty ( ) ; final Disposable d2 = Disposable . empty ( ) ; Flowable . < Integer > create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e . setDisposable ( d1 ) ; e . setCancellable ( new Cancellable ( ) @ Override public void cancel ( ) throws Exception d2 . dispose ( ) ; ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onComplete ( ) ; e . onError ( new TestException ( "first" ) ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( "second" ) ) ; e . onComplete ( ) ; , BackpressureStrategy . BUFFER ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertTrue ( d1 . isDisposed ( ) ) ; assertTrue ( d2 . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "first" ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Flowable . < Integer > create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e . setDisposable ( d ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( "second" ) ) ; , BackpressureStrategy . BUFFER ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Flowable . < Integer > create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; e . setDisposable ( d ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onComplete ( ) ; e . onError ( new TestException ( "first" ) ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( "second" ) ) ; e . onComplete ( ) ; , BackpressureStrategy . BUFFER ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "first" ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable d = Disposable . empty ( ) ; Flowable . < Integer > create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; e . setDisposable ( d ) ; e . onNext ( 1 ) ; e . onNext ( 2 ) ; e . onNext ( 3 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; e . onNext ( 4 ) ; e . onError ( new TestException ( "second" ) ) ; , BackpressureStrategy . BUFFER ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; assertTrue ( d . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "second" ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . fromPublisher ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onNext ( 3 ) ; subscriber . onNext ( 4 ) ; subscriber . onNext ( 5 ) ; subscriber . onComplete ( ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onNext ( 3 ) ; subscriber . onNext ( 4 ) ; subscriber . onNext ( 5 ) ; subscriber . onComplete ( ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . unsafeCreate ( Flowable . just ( 1 ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . BUFFER ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . LATEST ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . ERROR ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . DROP ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . MISSING ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . BUFFER ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . LATEST ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . ERROR ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . DROP ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , BackpressureStrategy . MISSING ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable < Object > source = Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception final FlowableEmitter < Object > f = e . serialize ( ) ; final TestException ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) f . onError ( null ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) f . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; , m ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) source . test ( ) . assertFailure ( Throwable . class ) ; finally RxJavaPlugins . reset ( ) ; assertFalse ( errors . isEmpty ( ) ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable < Object > source = Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception final FlowableEmitter < Object > f = e . serialize ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) f . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) f . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; , m ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) source . test ( ) . assertResult ( ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception e . onNext ( null ) ; , m ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) System . out . println ( m ) ; Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception e . onError ( null ) ; , m ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception final FlowableEmitter < Object > f = e . serialize ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 1000 ; i ++ ) f . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 100 ; i ++ ) f . onNext ( 1 ) ; f . onError ( new TestException ( ) ) ; ; TestHelper . race ( r1 , r2 ) ; , m ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertSubscribed ( ) . assertNotComplete ( ) . assertError ( TestException . class ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception throw new TestException ( ) ; , m ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception e . serialize ( ) . onNext ( null ) ; , m ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , m ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onError ( new IOException ( ) ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; , m ) . subscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception Disposable d = Disposable . empty ( ) ; e . setDisposable ( d ) ; try e . onComplete ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) assertTrue ( d . isDisposed ( ) ) ; , m ) . subscribe ( new FlowableSubscriber < Object > ( ) @ Override public void onSubscribe ( Subscription s ) @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Throwable [ ] error = null ; Flowable . create ( new FlowableOnSubscribe < Integer > ( ) @ Override public void subscribe ( FlowableEmitter < Integer > e ) throws Exception e = e . serialize ( ) ; try e . onNext ( null ) ; e . onNext ( 1 ) ; e . onError ( new TestException ( ) ) ; e . onComplete ( ) ; catch ( Throwable ex ) error [ 0 ] = ex ; , m ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertNull ( error [ 0 ] ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception e . serialize ( ) . onError ( null ) ; , m ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception final FlowableEmitter < Object > f = e . serialize ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) f . onNext ( 1 ) ; ; TestHelper . race ( r1 , r1 ) ; , m ) . take ( TestHelper . RACE_DEFAULT_LOOPS ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertSubscribed ( ) . assertValueCount ( TestHelper . RACE_DEFAULT_LOOPS ) . assertComplete ( ) . assertNoErrors ( ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) TestSubscriberEx < Object > ts = Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception final FlowableEmitter < Object > f = e . serialize ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 1000 ; i ++ ) f . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < 100 ; i ++ ) f . onNext ( 1 ) ; f . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; , m ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertSubscribed ( ) . assertComplete ( ) . assertNoErrors ( ) ; int c = ts . values ( ) . size ( ) ; assertTrue ( "" + c , c >= 100 ) ; 
for ( BackpressureStrategy m : BackpressureStrategy . values ( ) ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception FlowableEmitter < Object > f = e . serialize ( ) ; assertSame ( f , f . serialize ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; final int [ ] calls = 0 ; f . setCancellable ( new Cancellable ( ) @ Override public void cancel ( ) throws Exception calls [ 0 ] ++ ; ) ; e . onComplete ( ) ; assertTrue ( f . isCancelled ( ) ) ; assertEquals ( 1 , calls [ 0 ] ) ; , m ) . test ( ) . assertResult ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
for ( BackpressureStrategy strategy : BackpressureStrategy . values ( ) ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Boolean [ ] response = null ; Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception e . onNext ( 1 ) ; response [ 0 ] = e . tryOnError ( new TestException ( ) ) ; , strategy ) . take ( 1 ) . test ( ) . withTag ( strategy . toString ( ) ) . assertResult ( 1 ) ; assertFalse ( response [ 0 ] ) ; assertTrue ( strategy + ": " + errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
for ( BackpressureStrategy strategy : BackpressureStrategy . values ( ) ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Boolean [ ] response = null ; Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > e ) throws Exception e = e . serialize ( ) ; e . onNext ( 1 ) ; response [ 0 ] = e . tryOnError ( new TestException ( ) ) ; , strategy ) . take ( 1 ) . test ( ) . withTag ( strategy . toString ( ) ) . assertResult ( 1 ) ; assertFalse ( response [ 0 ] ) ; assertTrue ( strategy + ": " + errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Map < BackpressureStrategy , Class < ? extends FlowableEmitter > > emitterMap = new HashMap < > ( ) ; emitterMap . put ( BackpressureStrategy . MISSING , FlowableCreate . MissingEmitter . class ) ; emitterMap . put ( BackpressureStrategy . ERROR , FlowableCreate . ErrorAsyncEmitter . class ) ; emitterMap . put ( BackpressureStrategy . DROP , FlowableCreate . DropAsyncEmitter . class ) ; emitterMap . put ( BackpressureStrategy . LATEST , FlowableCreate . LatestAsyncEmitter . class ) ; emitterMap . put ( BackpressureStrategy . BUFFER , FlowableCreate . BufferAsyncEmitter . class ) ; for ( final Map . Entry < BackpressureStrategy , Class < ? extends FlowableEmitter > > entry : emitterMap . entrySet ( ) ) Flowable . create ( new FlowableOnSubscribe < Object > ( ) @ Override public void subscribe ( FlowableEmitter < Object > emitter ) throws Exception assertTrue ( emitter . toString ( ) . contains ( entry . getValue ( ) . getSimpleName ( ) ) ) ; assertTrue ( emitter . serialize ( ) . toString ( ) . contains ( entry . getValue ( ) . getSimpleName ( ) ) ) ; , entry . getKey ( ) ) . test ( ) . assertEmpty ( ) ; 
AtomicReference < FlowableEmitter < Integer > > ref = new AtomicReference < > ( ) ; Flowable . < Integer > create ( emitter -> emitter = emitter . serialize ( ) ; ref . set ( emitter ) ; assertEquals ( Long . MAX_VALUE , emitter . requested ( ) ) ; emitter . onNext ( 1 ) ; , BackpressureStrategy . MISSING ) . doOnNext ( v -> if ( v == 1 ) ref . get ( ) . onNext ( 2 ) ; ref . get ( ) . onComplete ( ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; 
TestHelper . assertBadRequestReported ( Flowable . create ( e -> , BackpressureStrategy . BUFFER ) ) ; 
Flowable . create ( emitter -> emitter . tryOnError ( null ) , BackpressureStrategy . MISSING ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . < Integer > create ( emitter -> emitter = emitter . serialize ( ) ; emitter . onComplete ( ) ; emitter . onNext ( 1 ) ; , BackpressureStrategy . MISSING ) . subscribe ( ts ) ; ts . assertResult ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . < Integer > create ( emitter -> emitter = emitter . serialize ( ) ; ts . cancel ( ) ; emitter . onNext ( 1 ) ; , BackpressureStrategy . MISSING ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
subscriber = TestHelper . mockSubscriber ( ) ; subscriber2 = TestHelper . mockSubscriber ( ) ; scheduler = new TestScheduler ( ) ; 
Flowable < Long > source = Flowable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . take ( 3 ) ; Flowable < Long > delayed = source . delay ( 500L , TimeUnit . MILLISECONDS , scheduler ) ; delayed . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 1499L , TimeUnit . MILLISECONDS ) ; verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 1500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 0L ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2400L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1L ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3400L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2L ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Long > source = Flowable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . take ( 3 ) ; Flowable < Long > delayed = source . delay ( 5L , TimeUnit . SECONDS , scheduler ) ; delayed . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 5999L , TimeUnit . MILLISECONDS ) ; verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 6000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 0L ) ; scheduler . advanceTimeTo ( 6999L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; scheduler . advanceTimeTo ( 7000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1L ) ; scheduler . advanceTimeTo ( 7999L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; scheduler . advanceTimeTo ( 8000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2L ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Long > source = Flowable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long value ) if ( value == 1L ) throw new RuntimeException ( "error!" ) ; return value ; ) ; Flowable < Long > delayed = source . delay ( 1L , TimeUnit . SECONDS , scheduler ) ; delayed . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 1999L , TimeUnit . MILLISECONDS ) ; verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; scheduler . advanceTimeTo ( 5000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable < Long > source = Flowable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . take ( 3 ) ; Flowable < Long > delayed = source . delay ( 500L , TimeUnit . MILLISECONDS , scheduler ) ; delayed . subscribe ( subscriber ) ; delayed . subscribe ( subscriber2 ) ; InOrder inOrder = inOrder ( subscriber ) ; InOrder inOrder2 = inOrder ( subscriber2 ) ; scheduler . advanceTimeTo ( 1499L , TimeUnit . MILLISECONDS ) ; verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber2 , never ( ) ) . onNext ( anyLong ( ) ) ; scheduler . advanceTimeTo ( 1500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 0L ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 0L ) ; scheduler . advanceTimeTo ( 2499L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder2 . verify ( subscriber2 , never ( ) ) . onNext ( anyLong ( ) ) ; scheduler . advanceTimeTo ( 2500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1L ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 1L ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber2 , never ( ) ) . onComplete ( ) ; scheduler . advanceTimeTo ( 3500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2L ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onNext ( 2L ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder2 . verify ( subscriber2 , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder2 . verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > result = Flowable . just ( 1 , 2 , 3 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > result = Flowable . just ( 1 , 2 , 3 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( subscriber ) ; result . subscribe ( ts ) ; ts . cancel ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final List < PublishProcessor < Integer > > delays = new ArrayList < > ( ) ; final int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) PublishProcessor < Integer > delay = PublishProcessor . create ( ) ; delays . add ( delay ) ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return delays . get ( t1 ) ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( delayFunc ) . subscribe ( subscriber ) ; for ( int i = 0 ; i < n ; i ++ ) source . onNext ( i ) ; delays . get ( i ) . onNext ( i ) ; inOrder . verify ( subscriber ) . onNext ( i ) ; source . onComplete ( ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > delay = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return delay ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; delay . onNext ( 1 ) ; delay . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > delay = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return delay ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; delay . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > delay = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return delay ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; delay . onError ( new TestException ( ) ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > delay = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return delay ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( delay , delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; delay . onNext ( 1 ) ; source . onNext ( 2 ) ; delay . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > delay = PublishProcessor . create ( ) ; Supplier < Flowable < Integer > > subFunc = new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) throw new TestException ( ) ; ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return delay ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( Flowable . defer ( subFunc ) , delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; delay . onNext ( 1 ) ; source . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > delay = PublishProcessor . create ( ) ; Supplier < Flowable < Integer > > subFunc = new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) return delay ; ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return delay ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( Flowable . defer ( subFunc ) , delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; delay . onError ( new TestException ( ) ) ; source . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return Flowable . empty ( ) ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > sdelay = PublishProcessor . create ( ) ; final PublishProcessor < Integer > delay = PublishProcessor . create ( ) ; Supplier < Flowable < Integer > > subFunc = new Supplier < Flowable < Integer > > ( ) @ Override public Flowable < Integer > get ( ) return sdelay ; ; Function < Integer , Flowable < Integer > > delayFunc = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return delay ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . delay ( Flowable . defer ( subFunc ) , delayFunc ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; sdelay . onComplete ( ) ; source . onNext ( 2 ) ; delay . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable < Long > source = Flowable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . take ( 3 ) ; final Flowable < Long > delayer = Flowable . timer ( 500L , TimeUnit . MILLISECONDS , scheduler ) ; Function < Long , Flowable < Long > > delayFunc = new Function < Long , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Long t1 ) return delayer ; ; Flowable < Long > delayed = source . delay ( delayFunc ) ; delayed . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 1499L , TimeUnit . MILLISECONDS ) ; verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 1500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 0L ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2400L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1L ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3400L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2L ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
int n = 3 ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final List < PublishProcessor < Integer > > subjects = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) subjects . add ( PublishProcessor . < Integer > create ( ) ) ; Flowable < Integer > result = source . delay ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return subjects . get ( t1 ) ; ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; result . subscribe ( subscriber ) ; for ( int i = 0 ; i < n ; i ++ ) source . onNext ( i ) ; source . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onNext ( anyInt ( ) ) ; inOrder . verify ( subscriber , never ( ) ) . onComplete ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) subjects . get ( i ) . onComplete ( ) ; inOrder . verify ( subscriber ) . onNext ( i ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 5 ) ; Flowable < Integer > delayed = source . delay ( 500L , TimeUnit . MILLISECONDS , scheduler ) ; delayed = delayed . doOnEach ( new Consumer < Notification < Integer > > ( ) @ Override public void accept ( Notification < Integer > t1 ) System . out . println ( t1 ) ; ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; delayed . subscribe ( ts ) ; scheduler . advanceTimeBy ( 500L , TimeUnit . MILLISECONDS ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t ) if ( c ++ <= 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) return t ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS ) . delay ( 100 , TimeUnit . MILLISECONDS ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t ) if ( c ++ <= 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) return t ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . delay ( new Function < Integer , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Integer i ) return Flowable . timer ( 100 , TimeUnit . MILLISECONDS ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t ) if ( c ++ <= 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) return t ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . delay ( Flowable . defer ( new Supplier < Flowable < Long > > ( ) @ Override public Flowable < Long > get ( ) return Flowable . timer ( 500 , TimeUnit . MILLISECONDS ) ; ) , new Function < Integer , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Integer i ) return Flowable . timer ( 100 , TimeUnit . MILLISECONDS ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t ) if ( c ++ <= 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) return t ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , ts . values ( ) . size ( ) ) ; 
TestScheduler test = new TestScheduler ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; pp . delay ( 1 , TimeUnit . SECONDS , test ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; test . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; pp . onError ( new TestException ( ) ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 5 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . delaySubscription ( Flowable . defer ( new Supplier < Publisher < Integer > > ( ) @ Override public Publisher < Integer > get ( ) return pp ; ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; pp . onNext ( 1 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 5 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . delaySubscription ( Flowable . defer ( new Supplier < Publisher < Integer > > ( ) @ Override public Publisher < Integer > get ( ) return pp ; ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; pp . onComplete ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 5 ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . delaySubscription ( Flowable . defer ( new Supplier < Publisher < Integer > > ( ) @ Override public Publisher < Integer > get ( ) return pp ; ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; pp . onError ( new TestException ( ) ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
PublishProcessor < Integer > delayUntil = PublishProcessor . create ( ) ; PublishProcessor < Integer > interrupt = PublishProcessor . create ( ) ; final AtomicBoolean subscribed = new AtomicBoolean ( false ) ; Flowable . just ( 1 ) . doOnSubscribe ( new Consumer < Object > ( ) @ Override public void accept ( Object o ) subscribed . set ( true ) ; ) . delaySubscription ( delayUntil ) . takeUntil ( interrupt ) . subscribe ( ) ; interrupt . onNext ( 9000 ) ; delayUntil . onNext ( 1 ) ; Assert . assertFalse ( subscribed . get ( ) ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . delay ( 100 , TimeUnit . MILLISECONDS , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class , 1 ) ; 
Flowable < Integer > result = Flowable . just ( 1 , 2 , 3 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( subscriber ) ; result . subscribe ( ts ) ; ts . cancel ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Thread > thread = new AtomicReference < > ( ) ; Flowable . < String > error ( new Exception ( ) ) . delay ( 0 , TimeUnit . MILLISECONDS , Schedulers . newThread ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throws Exception thread . set ( Thread . currentThread ( ) ) ; latch . countDown ( ) ; ) . onErrorResumeWith ( Flowable . < String > empty ( ) ) . subscribe ( ) ; latch . await ( ) ; assertNotEquals ( Thread . currentThread ( ) , thread . get ( ) ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . delay ( 1 , TimeUnit . SECONDS ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . delay ( Functions . justFunction ( Flowable . never ( ) ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . delay ( 1 , TimeUnit . SECONDS ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . delay ( Functions . justFunction ( Flowable . never ( ) ) ) ; ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable . empty ( ) . delay ( 1 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( new DisposableSubscriber < Object > ( ) @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; try scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable . error ( new TestException ( ) ) . delay ( 1 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( new DisposableSubscriber < Object > ( ) @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) ) ; try scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) 
Flowable . just ( 1 ) . delay ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer t ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The itemDelay returned a null Publisher" ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Flowable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ; Flowable . fromRunnable ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Flowable . fromRunnable ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Flowable < Object > source = Flowable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; source . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Flowable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final int [ ] counter = 0 ; Flowable < Void > m = Flowable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter [ 0 ] ++ ; ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof Supplier ) ; assertNull ( ( ( Supplier < Void > ) m ) . get ( ) ) ; assertEquals ( 1 , counter [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestSubscriber < Object > ts = Flowable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) cdl1 . countDown ( ) ; try cdl2 . await ( 5 , TimeUnit . SECONDS ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; throw new TestException ( e ) ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; ts . cancel ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Runnable run = mock ( Runnable . class ) ; Flowable . fromRunnable ( run ) . test ( 1L , true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
final TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ) . subscribeWith ( ts ) . assertEmpty ( ) ; assertTrue ( ts . isCancelled ( ) ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Runnable action = mock ( Runnable . class ) ; Flowable . fromRunnable ( action ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Runnable action = mock ( Runnable . class ) ; Flowable . fromRunnable ( action ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
assertTrue ( Flowable . empty ( ) . ignoreElements ( ) . toFlowable ( ) . isEmpty ( ) . blockingGet ( ) ) ; 
assertTrue ( Flowable . just ( 1 , 2 , 3 ) . ignoreElements ( ) . toFlowable ( ) . isEmpty ( ) . blockingGet ( ) ) ; 
final int num = 10 ; final AtomicInteger upstreamCount = new AtomicInteger ( ) ; long count = Flowable . range ( 1 , num ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . ignoreElements ( ) . toFlowable ( ) . count ( ) . blockingGet ( ) ; assertEquals ( num , upstreamCount . get ( ) ) ; assertEquals ( 0 , count ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 1 , 10 ) . ignoreElements ( ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; ts . assertTerminated ( ) ; 
TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( ) ; TestException ex = new TestException ( "boo" ) ; Flowable . error ( ex ) . ignoreElements ( ) . toFlowable ( ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertTerminated ( ) ; ts . assertError ( TestException . class ) ; ts . assertErrorMessage ( "boo" ) ; 
final AtomicBoolean unsub = new AtomicBoolean ( ) ; Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > never ( ) ) . doOnCancel ( new Action ( ) @ Override public void run ( ) unsub . set ( true ) ; ) . ignoreElements ( ) . toFlowable ( ) . subscribe ( ) . dispose ( ) ; assertTrue ( unsub . get ( ) ) ; 
final AtomicInteger upstreamCount = new AtomicInteger ( ) ; final AtomicInteger count = new AtomicInteger ( 0 ) ; int num = 10 ; Flowable . range ( 1 , num ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . ignoreElements ( ) . < Integer > toFlowable ( ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 1 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) count . incrementAndGet ( ) ; ) ; assertEquals ( num , upstreamCount . get ( ) ) ; assertEquals ( 0 , count . get ( ) ) ; 
Flowable . empty ( ) . ignoreElements ( ) . blockingAwait ( ) ; 
Flowable . just ( 1 , 2 , 3 ) . ignoreElements ( ) . blockingAwait ( ) ; 
final int num = 10 ; final AtomicInteger upstreamCount = new AtomicInteger ( ) ; Flowable . range ( 1 , num ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . ignoreElements ( ) . blockingAwait ( ) ; assertEquals ( num , upstreamCount . get ( ) ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; Flowable . range ( 1 , 10 ) . ignoreElements ( ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; to . assertTerminated ( ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; TestException ex = new TestException ( "boo" ) ; Flowable . error ( ex ) . ignoreElements ( ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertTerminated ( ) ; to . assertError ( TestException . class ) ; to . assertErrorMessage ( "boo" ) ; 
final AtomicBoolean unsub = new AtomicBoolean ( ) ; Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > never ( ) ) . doOnCancel ( new Action ( ) @ Override public void run ( ) unsub . set ( true ) ; ) . ignoreElements ( ) . subscribe ( ) . dispose ( ) ; assertTrue ( unsub . get ( ) ) ; 
final AtomicInteger upstreamCount = new AtomicInteger ( ) ; final AtomicInteger count = new AtomicInteger ( 0 ) ; int num = 10 ; Flowable . range ( 1 , num ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . ignoreElements ( ) . subscribe ( new DisposableCompletableObserver ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) ) ; assertEquals ( num , upstreamCount . get ( ) ) ; assertEquals ( 0 , count . get ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . ignoreElements ( ) . < Integer > toFlowable ( ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp . hasSubscribers ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . just ( 1 ) . hide ( ) . ignoreElements ( ) . < Integer > toFlowable ( ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
Flowable . just ( 1 ) . hide ( ) . ignoreElements ( ) . < Integer > toFlowable ( ) . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < Integer > qs = ( QueueSubscription < Integer > ) s ; try assertNull ( qs . poll ( ) ) ; catch ( Throwable ex ) throw new AssertionError ( ex ) ; assertTrue ( qs . isEmpty ( ) ) ; qs . clear ( ) ; assertTrue ( qs . isEmpty ( ) ) ; try assertNull ( qs . poll ( ) ) ; catch ( Throwable ex ) throw new AssertionError ( ex ) ; try qs . offer ( 1 ) ; fail ( "Should have thrown!" ) ; catch ( UnsupportedOperationException ex ) try qs . offer ( 1 , 2 ) ; fail ( "Should have thrown!" ) ; catch ( UnsupportedOperationException ex ) @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . ignoreElements ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . ignoreElements ( ) . toFlowable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . ignoreElements ( ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToCompletable ( new Function < Flowable < Object > , Completable > ( ) @ Override public Completable apply ( Flowable < Object > f ) throws Exception return f . ignoreElements ( ) ; ) ; 
Assert . assertEquals ( 0 , Flowable . empty ( ) . count ( ) . toFlowable ( ) . blockingLast ( ) . intValue ( ) ) ; Assert . assertEquals ( 1 , Flowable . just ( 1 ) . count ( ) . toFlowable ( ) . blockingLast ( ) . intValue ( ) ) ; Assert . assertEquals ( 10 , Flowable . range ( 1 , 10 ) . count ( ) . toFlowable ( ) . blockingLast ( ) . intValue ( ) ) ; 
Assert . assertEquals ( 0 , Flowable . empty ( ) . count ( ) . blockingGet ( ) . intValue ( ) ) ; Assert . assertEquals ( 1 , Flowable . just ( 1 ) . count ( ) . blockingGet ( ) . intValue ( ) ) ; Assert . assertEquals ( 10 , Flowable . range ( 1 , 10 ) . count ( ) . blockingGet ( ) . intValue ( ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . count ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . count ( ) . toFlowable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Long > > ( ) @ Override public Flowable < Long > apply ( Flowable < Object > f ) throws Exception return f . count ( ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Object > , SingleSource < Long > > ( ) @ Override public SingleSource < Long > apply ( Flowable < Object > f ) throws Exception return f . count ( ) ; ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; subscriber = TestHelper . mockSubscriber ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 100 , "one" ) ; publishNext ( subscriber , 300 , "two" ) ; publishNext ( subscriber , 900 , "three" ) ; publishNext ( subscriber , 905 , "four" ) ; publishCompleted ( subscriber , 1000 ) ; ) ; Flowable < String > sampled = source . throttleFirst ( 400 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 1000 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( subscriber , times ( 0 ) ) . onNext ( "two" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( subscriber , times ( 0 ) ) . onNext ( "four" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; Exception error = new TestException ( ) ; publishNext ( subscriber , 100 , "one" ) ; publishNext ( subscriber , 200 , "two" ) ; publishError ( subscriber , 300 , error ) ; ) ; Flowable < String > sampled = source . throttleFirst ( 400 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; scheduler . advanceTimeTo ( 400 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber ) . onNext ( "one" ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; TestScheduler s = new TestScheduler ( ) ; PublishProcessor < Integer > o = PublishProcessor . create ( ) ; o . throttleFirst ( 500 , TimeUnit . MILLISECONDS , s ) . subscribe ( subscriber ) ; s . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; s . advanceTimeTo ( 501 , TimeUnit . MILLISECONDS ) ; o . onNext ( 3 ) ; s . advanceTimeTo ( 600 , TimeUnit . MILLISECONDS ) ; o . onNext ( 4 ) ; s . advanceTimeTo ( 700 , TimeUnit . MILLISECONDS ) ; o . onNext ( 5 ) ; o . onNext ( 6 ) ; s . advanceTimeTo ( 1001 , TimeUnit . MILLISECONDS ) ; o . onNext ( 7 ) ; s . advanceTimeTo ( 1501 , TimeUnit . MILLISECONDS ) ; o . onComplete ( ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onNext ( 7 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable . just ( 1 ) . throttleFirst ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . throttleFirst ( 1 , TimeUnit . DAYS ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 3 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . throttleFirst ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . range ( 1 , 3 ) . throttleFirst ( 1 , TimeUnit . MINUTES ) . test ( 0L ) . assertFailure ( MissingBackpressureException . class ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . throttleFirst ( 1 , TimeUnit . MINUTES ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . throttleFirst ( 1 , TimeUnit . MINUTES ) ) ; 
@ SuppressWarnings ( "unchecked" ) Future < Object > future = mock ( Future . class ) ; Object value = new Object ( ) ; when ( future . get ( ) ) . thenReturn ( value ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( subscriber ) ; Flowable . fromFuture ( future ) . subscribe ( ts ) ; ts . cancel ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( value ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( future , never ( ) ) . cancel ( anyBoolean ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Future < Object > future = mock ( Future . class ) ; Object value = new Object ( ) ; when ( future . get ( ) ) . thenReturn ( value ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( subscriber ) ; Flowable . fromFuture ( future ) . subscribeOn ( scheduler ) . subscribe ( ts ) ; verify ( subscriber , never ( ) ) . onNext ( value ) ; scheduler . triggerActions ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( value ) ; 
@ SuppressWarnings ( "unchecked" ) Future < Object > future = mock ( Future . class ) ; RuntimeException e = new RuntimeException ( ) ; when ( future . get ( ) ) . thenThrow ( e ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( subscriber ) ; Flowable . fromFuture ( future ) . subscribe ( ts ) ; ts . cancel ( ) ; verify ( subscriber , never ( ) ) . onNext ( null ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onError ( e ) ; verify ( future , never ( ) ) . cancel ( anyBoolean ( ) ) ; 
@ SuppressWarnings ( "unchecked" ) Future < Object > future = mock ( Future . class ) ; CancellationException e = new CancellationException ( "unit test synthetic cancellation" ) ; when ( future . get ( ) ) . thenThrow ( e ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( subscriber ) ; ts . cancel ( ) ; Flowable . fromFuture ( future ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
Future < Object > future = new Future < Object > ( ) private AtomicBoolean isCancelled = new AtomicBoolean ( false ) ; private AtomicBoolean isDone = new AtomicBoolean ( false ) ; @ Override public boolean cancel ( boolean mayInterruptIfRunning ) isCancelled . compareAndSet ( false , true ) ; return true ; @ Override public boolean isCancelled ( ) return isCancelled . get ( ) ; @ Override public boolean isDone ( ) return isCancelled ( ) || isDone . get ( ) ; @ Override public Object get ( ) throws InterruptedException , ExecutionException Thread . sleep ( 500 ) ; isDone . compareAndSet ( false , true ) ; return "foo" ; @ Override public Object get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException return get ( ) ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriber < Object > ts = new TestSubscriber < > ( subscriber ) ; Flowable < Object > futureObservable = Flowable . fromFuture ( future ) ; futureObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; Thread . sleep ( 100 ) ; ts . cancel ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0 ) ; FutureTask < Integer > f = new FutureTask < > ( new Runnable ( ) @ Override public void run ( ) , 1 ) ; f . run ( ) ; Flowable . fromFuture ( f ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
FutureTask < Integer > task = new FutureTask < > ( new Runnable ( ) @ Override public void run ( ) , 1 ) ; task . run ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . fromFuture ( task , 1 , TimeUnit . SECONDS ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
FutureTask < Integer > task = new FutureTask < > ( new Runnable ( ) @ Override public void run ( ) , 1 ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . fromFuture ( task , 10 , TimeUnit . MILLISECONDS ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TimeoutException . class ) ; ts . assertNotComplete ( ) ; 
FutureTask < Integer > task = new FutureTask < > ( new Runnable ( ) @ Override public void run ( ) , 1 ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . fromFuture ( task ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; task . run ( ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Single . just ( 100 ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
Flowable . range ( 1 , 5 ) . concatWith ( Single . just ( 100 ) ) . test ( 0 ) . assertEmpty ( ) . requestMore ( 3 ) . assertValues ( 1 , 2 , 3 ) . requestMore ( 2 ) . assertValues ( 1 , 2 , 3 , 4 , 5 ) . requestMore ( 1 ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . < Integer > error ( new TestException ( ) ) . concatWith ( Single . just ( 100 ) ) . subscribe ( ts ) ; ts . assertFailure ( TestException . class ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Single . < Integer > error ( new TestException ( ) ) ) . subscribe ( ts ) ; ts . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 5 ) . concatWith ( Single . just ( 100 ) ) . take ( 3 ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 ) ; 
SingleSubject < Object > other = SingleSubject . create ( ) ; TestSubscriber < Object > ts = Flowable . empty ( ) . concatWith ( other ) . test ( ) ; assertTrue ( other . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( other . hasObservers ( ) ) ; 
w = TestHelper . mockSubscriber ( ) ; wo = TestHelper . mockSingleObserver ( ) ; wm = TestHelper . mockMaybeObserver ( ) ; 
Flowable < String > src = Flowable . empty ( ) ; src . first ( "default" ) . toFlowable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyString ( ) ) ; verify ( w , times ( 1 ) ) . onNext ( "default" ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" ) ; src . first ( "default" ) . toFlowable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyString ( ) ) ; verify ( w , times ( 1 ) ) . onNext ( "a" ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" ) ; src . filter ( IS_D ) . first ( "default" ) . toFlowable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyString ( ) ) ; verify ( w , times ( 1 ) ) . onNext ( "default" ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" , "d" , "e" , "f" ) ; src . filter ( IS_D ) . first ( "default" ) . toFlowable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyString ( ) ) ; verify ( w , times ( 1 ) ) . onNext ( "d" ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 ) . firstElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 ) . firstElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . < Integer > empty ( ) . firstElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 ) . first ( 4 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 ) . first ( 2 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . < Integer > empty ( ) . first ( 1 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 8 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 4 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < Integer > flowable = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 2 ) . toFlowable ( ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < String > src = Flowable . empty ( ) ; src . first ( "default" ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyString ( ) ) ; verify ( wo , times ( 1 ) ) . onSuccess ( "default" ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" ) ; src . first ( "default" ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyString ( ) ) ; verify ( wo , times ( 1 ) ) . onSuccess ( "a" ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" ) ; src . filter ( IS_D ) . first ( "default" ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyString ( ) ) ; verify ( wo , times ( 1 ) ) . onSuccess ( "default" ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < String > src = Flowable . just ( "a" , "b" , "c" , "d" , "e" , "f" ) ; src . filter ( IS_D ) . first ( "default" ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyString ( ) ) ; verify ( wo , times ( 1 ) ) . onSuccess ( "d" ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 , 3 ) . firstElement ( ) ; maybe . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 ) . firstElement ( ) ; maybe . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . < Integer > empty ( ) . firstElement ( ) ; maybe . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm ) . onComplete ( ) ; inOrder . verify ( wm , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) ; maybe . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) ; maybe . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) ; maybe . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm ) . onComplete ( ) ; inOrder . verify ( wm , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 , 3 ) . first ( 4 ) ; single . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 ) . first ( 2 ) ; single . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . < Integer > empty ( ) . first ( 1 ) ; single . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 8 ) ; single . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 4 ) ; single . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 2 ) ; single . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable . empty ( ) . firstOrError ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Flowable . just ( 1 ) . firstOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Flowable . just ( 1 , 2 , 3 ) . firstOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Flowable . error ( new RuntimeException ( "error" ) ) . firstOrError ( ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
Flowable . empty ( ) . firstOrError ( ) . toFlowable ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Flowable . just ( 1 ) . firstOrError ( ) . toFlowable ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Flowable . just ( 1 , 2 , 3 ) . firstOrError ( ) . toFlowable ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Flowable . error ( new RuntimeException ( "error" ) ) . firstOrError ( ) . toFlowable ( ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; final List < Integer > list = Arrays . asList ( 1 , 2 , 3 ) ; Function < Integer , List < Integer > > func = new Function < Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 ) return list ; ; BiFunction < Integer , Integer , Integer > resFunc = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 | t2 ; ; List < Integer > source = Arrays . asList ( 16 , 32 , 64 ) ; Flowable . fromIterable ( source ) . flatMapIterable ( func , resFunc ) . subscribe ( subscriber ) ; for ( Integer s : source ) for ( Integer v : list ) verify ( subscriber ) . onNext ( s | v ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Function < Integer , List < Integer > > func = new Function < Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; BiFunction < Integer , Integer , Integer > resFunc = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 | t2 ; ; List < Integer > source = Arrays . asList ( 16 , 32 , 64 ) ; Flowable . fromIterable ( source ) . flatMapIterable ( func , resFunc ) . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; final List < Integer > list = Arrays . asList ( 1 , 2 , 3 ) ; Function < Integer , List < Integer > > func = new Function < Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 ) return list ; ; BiFunction < Integer , Integer , Integer > resFunc = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throw new TestException ( ) ; ; List < Integer > source = Arrays . asList ( 16 , 32 , 64 ) ; Flowable . fromIterable ( source ) . flatMapIterable ( func , resFunc ) . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; Function < Integer , Flowable < Integer > > func = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return Flowable . error ( new TestException ( ) ) ; ; BiFunction < Integer , Integer , Integer > resFunc = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 | t2 ; ; List < Integer > source = Arrays . asList ( 16 , 32 , 64 ) ; Flowable . fromIterable ( source ) . flatMap ( func , resFunc ) . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; 
return value ; 
Flowable < Integer > onNext = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; Flowable < Integer > onComplete = Flowable . fromIterable ( Arrays . asList ( 4 ) ) ; Flowable < Integer > onError = Flowable . fromIterable ( Arrays . asList ( 5 ) ) ; Flowable < Integer > source = Flowable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . flatMap ( just ( onNext ) , just ( onError ) , just0 ( onComplete ) ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 3 ) ; verify ( subscriber ) . onNext ( 4 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( 5 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > onNext = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; Flowable < Integer > onComplete = Flowable . fromIterable ( Arrays . asList ( 4 ) ) ; Flowable < Integer > onError = Flowable . fromIterable ( Arrays . asList ( 5 ) ) ; Flowable < Integer > source = Flowable . concat ( Flowable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) , Flowable . < Integer > error ( new RuntimeException ( "Forced failure!" ) ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . flatMap ( just ( onNext ) , just ( onError ) , just0 ( onComplete ) ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 3 ) ; verify ( subscriber ) . onNext ( 5 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( 4 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
throw new TestException ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable < Integer > onComplete = Flowable . fromIterable ( Arrays . asList ( 4 ) ) ; Flowable < Integer > onError = Flowable . fromIterable ( Arrays . asList ( 5 ) ) ; Flowable < Integer > source = Flowable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . flatMap ( funcThrow ( 1 , onError ) , just ( onError ) , just0 ( onComplete ) ) . subscribe ( subscriber ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < Integer > onNext = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; Flowable < Integer > onComplete = Flowable . fromIterable ( Arrays . asList ( 4 ) ) ; Flowable < Integer > onError = Flowable . fromIterable ( Arrays . asList ( 5 ) ) ; Flowable < Integer > source = Flowable . error ( new TestException ( ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . flatMap ( just ( onNext ) , funcThrow ( ( Throwable ) null , onError ) , just0 ( onComplete ) ) . subscribe ( subscriber ) ; verify ( subscriber ) . onError ( any ( CompositeException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable < Integer > onNext = Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; Flowable < Integer > onComplete = Flowable . fromIterable ( Arrays . asList ( 4 ) ) ; Flowable < Integer > onError = Flowable . fromIterable ( Arrays . asList ( 5 ) ) ; Flowable < Integer > source = Flowable . fromIterable ( Arrays . < Integer > asList ( ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . flatMap ( just ( onNext ) , just ( onError ) , funcThrow0 ( onComplete ) ) . subscribe ( subscriber ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable < Integer > onNext = Flowable . error ( new TestException ( ) ) ; Flowable < Integer > onComplete = Flowable . fromIterable ( Arrays . asList ( 4 ) ) ; Flowable < Integer > onError = Flowable . fromIterable ( Arrays . asList ( 5 ) ) ; Flowable < Integer > source = Flowable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; source . flatMap ( just ( onNext ) , just ( onError ) , funcThrow0 ( onComplete ) ) . subscribe ( subscriber ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
final int m = 4 ; final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 10 ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return composer ( Flowable . range ( t1 * 10 , 2 ) , subscriptionCount , m ) . subscribeOn ( Schedulers . computation ( ) ) ; , m ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; Set < Integer > expected = new HashSet < > ( Arrays . asList ( 10 , 11 , 20 , 21 , 30 , 31 , 40 , 41 , 50 , 51 , 60 , 61 , 70 , 71 , 80 , 81 , 90 , 91 , 100 , 101 ) ) ; Assert . assertEquals ( expected . size ( ) , ts . values ( ) . size ( ) ) ; Assert . assertTrue ( expected . containsAll ( ts . values ( ) ) ) ; 
final int m = 4 ; final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 10 ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return composer ( Flowable . range ( t1 * 10 , 2 ) , subscriptionCount , m ) . subscribeOn ( Schedulers . computation ( ) ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 * 1000 + t2 ; , m ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; Set < Integer > expected = new HashSet < > ( Arrays . asList ( 1010 , 1011 , 2020 , 2021 , 3030 , 3031 , 4040 , 4041 , 5050 , 5051 , 6060 , 6061 , 7070 , 7071 , 8080 , 8081 , 9090 , 9091 , 10100 , 10101 ) ) ; Assert . assertEquals ( expected . size ( ) , ts . values ( ) . size ( ) ) ; System . out . println ( "--> testFlatMapSelectorMaxConcurrent: " + ts . values ( ) ) ; Assert . assertTrue ( expected . containsAll ( ts . values ( ) ) ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) if ( i % 100 == 0 ) System . out . println ( "testFlatMapTransformsMaxConcurrentNormalLoop => " + i ) ; flatMapTransformsMaxConcurrentNormal ( ) ; 
final int m = 2 ; final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; Flowable < Integer > onNext = composer ( Flowable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . observeOn ( Schedulers . computation ( ) ) , subscriptionCount , m ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable < Integer > onComplete = composer ( Flowable . fromIterable ( Arrays . asList ( 4 ) ) , subscriptionCount , m ) . subscribeOn ( Schedulers . computation ( ) ) ; Flowable < Integer > onError = Flowable . fromIterable ( Arrays . asList ( 5 ) ) ; Flowable < Integer > source = Flowable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; TestSubscriberEx < Object > ts = new TestSubscriberEx < > ( subscriber ) ; Function < Integer , Flowable < Integer > > just = just ( onNext ) ; Function < Throwable , Flowable < Integer > > just2 = just ( onError ) ; Supplier < Flowable < Integer > > just0 = just0 ( onComplete ) ; source . flatMap ( just , just2 , just0 , m ) . subscribe ( ts ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 3 ) ) . onNext ( 3 ) ; verify ( subscriber ) . onNext ( 4 ) ; verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( 5 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
for ( int i = 0 ; i < 2000 ; i ++ ) if ( i % 10 == 0 ) System . out . println ( "flatMapRangeAsyncLoop > " + i ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . range ( 0 , 1000 ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) final Random rnd = new Random ( ) ; @ Override public Flowable < Integer > apply ( Integer t ) Flowable < Integer > r = Flowable . just ( t ) ; if ( rnd . nextBoolean ( ) ) r = r . hide ( ) ; return r ; ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; ts . awaitDone ( 2500 , TimeUnit . MILLISECONDS ) ; if ( ts . completions ( ) == 0 ) System . out . println ( ts . values ( ) . size ( ) ) ; ts . assertTerminated ( ) ; ts . assertNoErrors ( ) ; List < Integer > list = ts . values ( ) ; if ( list . size ( ) < 1000 ) Set < Integer > set = new HashSet < > ( list ) ; for ( int j = 0 ; j < 1000 ; j ++ ) if ( ! set . contains ( j ) ) System . out . println ( j + " missing" ) ; assertEquals ( 1000 , list . size ( ) ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 1000 ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return Flowable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; ts . assertValueCount ( 1000 ) ; 
for ( final int n : new int [ ] 1 , 1000 , 1000000 ) TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 , 2 ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return Flowable . range ( 1 , n ) ; ) . subscribe ( ts ) ; System . out . println ( "flatMapTwoNestedSync >> @ " + n ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; ts . assertValueCount ( n * 2 ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 0 , 4 * Flowable . bufferSize ( ) ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return ( v & 1 ) == 0 ? Flowable . < Integer > empty ( ) : Flowable . just ( v ) ; ) . subscribe ( ts ) ; ts . assertValueCount ( 2 * Flowable . bufferSize ( ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; int j = 1 ; for ( Integer v : ts . values ( ) ) Assert . assertEquals ( j , v . intValue ( ) ) ; j += 2 ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 0 , 4 * Flowable . bufferSize ( ) ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return ( v & 1 ) == 0 ? Flowable . < Integer > empty ( ) : Flowable . range ( v , 2 ) ; ) . subscribe ( ts ) ; ts . assertValueCount ( 4 * Flowable . bufferSize ( ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; int j = 1 ; List < Integer > list = ts . values ( ) ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) Assert . assertEquals ( j , list . get ( i ) . intValue ( ) ) ; Assert . assertEquals ( j + 1 , list . get ( i + 1 ) . intValue ( ) ) ; j += 2 ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 0 , 4 * Flowable . bufferSize ( ) ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return ( v & 1 ) == 0 ? Flowable . < Integer > empty ( ) : Flowable . just ( v ) ; , 16 ) . subscribe ( ts ) ; ts . assertValueCount ( 2 * Flowable . bufferSize ( ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; int j = 1 ; for ( Integer v : ts . values ( ) ) Assert . assertEquals ( j , v . intValue ( ) ) ; j += 2 ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 0 , 4 * Flowable . bufferSize ( ) ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return ( v & 1 ) == 0 ? Flowable . < Integer > empty ( ) : Flowable . range ( v , 2 ) ; , 16 ) . subscribe ( ts ) ; ts . assertValueCount ( 4 * Flowable . bufferSize ( ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; int j = 1 ; List < Integer > list = ts . values ( ) ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) Assert . assertEquals ( j , list . get ( i ) . intValue ( ) ) ; Assert . assertEquals ( j + 1 , list . get ( i + 1 ) . intValue ( ) ) ; j += 2 ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; pp . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) throw new TestException ( ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 ; ) . subscribe ( ts ) ; Assert . assertTrue ( "Not subscribed?" , pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; Assert . assertFalse ( "Subscribed?" , pp . hasSubscribers ( ) ) ; ts . assertError ( TestException . class ) ; 
Flowable . just ( 1 ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v * 10 ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true ) . test ( ) . assertResult ( 11 ) ; 
Flowable . just ( 1 ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v * 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true ) . test ( ) . assertFailure ( TestException . class , 11 ) ; 
Flowable . just ( 1 , 2 ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( v * 10 ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true , 1 ) . test ( ) . assertResult ( 11 , 22 ) ; 
assertSame ( Flowable . empty ( ) , Flowable . empty ( ) . flatMap ( new Function < Object , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Object v ) throws Exception return Flowable . just ( v ) ; ) ) ; 
Flowable . merge ( Flowable . just ( Flowable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . merge ( Flowable . just ( Flowable . just ( 1 ) ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . merge ( Flowable . just ( Flowable . empty ( ) ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . merge ( Flowable . just ( Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
final PublishProcessor < Flowable < Integer > > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onNext ( Flowable . just ( 2 ) ) ; ; Flowable . merge ( pp ) . subscribe ( ts ) ; pp . onNext ( Flowable . just ( 1 ) ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
final PublishProcessor < Flowable < Integer > > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onNext ( Flowable . just ( 2 ) ) ; ; Flowable . merge ( pp , 2 ) . subscribe ( ts ) ; pp . onNext ( Flowable . just ( 1 ) ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = Flowable . merge ( Flowable . just ( pp ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer v ) throws Exception return Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer w ) throws Exception throw new TestException ( ) ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestSubscriberEx < Integer > ts = Flowable . range ( 1 , 2 ) . hide ( ) . flatMap ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer w ) throws Exception throw new TestException ( ) ; ) ; , true ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . errorList ( ts ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , TestException . class ) ; 
Flowable . fromCallable ( Functions . justCallable ( 1 ) ) . flatMap ( Functions . justFunction ( Flowable . fromCallable ( Functions . justCallable ( 2 ) ) ) ) . test ( ) . assertResult ( 2 ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) TestSubscriber < Object > ts = Flowable . merge ( Flowable . just ( 1 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return Thread . currentThread ( ) . getName ( ) . substring ( 0 , 4 ) ; ) , Flowable . just ( 1 ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return Thread . currentThread ( ) . getName ( ) . substring ( 0 , 4 ) ; ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 2 ) ; List < Object > list = ts . values ( ) ; assertTrue ( list . toString ( ) , list . contains ( "RxSi" ) ) ; assertTrue ( list . toString ( ) , list . contains ( "RxCo" ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Flowable < Integer > > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) for ( int j = 1 ; j < 50 ; j += 5 ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Flowable < Integer > > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( 0 ) ; final PublishProcessor < Integer > just = PublishProcessor . create ( ) ; pp . onNext ( just ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts . request ( 1 ) ; ts . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) just . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . just ( 1 ) . flatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) throws Exception return null ; , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer v , Object w ) throws Exception return v ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The mapper returned a null Iterable" ) ; 
Flowable . just ( 1 ) . flatMap ( new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer v ) throws Exception return null ; , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer v , Object w ) throws Exception return v ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The mapper returned a null Publisher" ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception counter . getAndIncrement ( ) ; ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . < Integer > fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , counter . get ( ) ) ; 
final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp3 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp4 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( pp1 , pp2 , pp3 , pp4 ) . flatMap ( new Function < PublishProcessor < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( PublishProcessor < Integer > v ) throws Exception return v ; , 2 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( v == 1 ) pp1 . onComplete ( ) ; pp2 . onComplete ( ) ; ) . test ( ) ; pp1 . onNext ( 1 ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; assertTrue ( pp3 . hasSubscribers ( ) ) ; assertTrue ( pp4 . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp3 . hasSubscribers ( ) ) ; assertFalse ( pp4 . hasSubscribers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; , true ) ; ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; pp1 . flatMap ( v -> pp2 ) . test ( ) ; pp1 . onNext ( 1 ) ; assertTrue ( "No subscribers?" , pp2 . hasSubscribers ( ) ) ; pp1 . onError ( new TestException ( ) ) ; assertFalse ( "Has subscribers?" , pp2 . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; pp1 . flatMap ( v -> pp2 ) . test ( ) ; pp1 . onNext ( 1 ) ; assertTrue ( "No subscribers?" , pp2 . hasSubscribers ( ) ) ; pp2 . onError ( new TestException ( ) ) ; assertFalse ( "Has subscribers?" , pp1 . hasSubscribers ( ) ) ; 
FlowableFlatMap . InnerSubscriber < Integer , Integer > inner = new FlowableFlatMap . InnerSubscriber < > ( null , 10 , 0L ) ; assertFalse ( inner . isDisposed ( ) ) ; inner . dispose ( ) ; assertTrue ( inner . isDisposed ( ) ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . flatMap ( v -> Flowable . never ( ) ) ) ; 
TestHelper . withErrorTracking ( errors -> new Flowable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Subscriber < ? super @ NonNull Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onComplete ( ) ; s . onError ( new IOException ( ) ) ; . flatMap ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; ) ; 
s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onComplete ( ) ; s . onError ( new IOException ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; pp . flatMap ( v -> Flowable . just ( v ) ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; pp . onNext ( 3 ) ; ) . take ( 2 ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; pp . flatMap ( v -> Flowable . just ( v ) ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; TestHelper . raceOther ( ( ) -> pp . onComplete ( ) , cdl ) ; ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; cdl . await ( ) ; ts . assertResult ( 1 , 2 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( pp , up . map ( v -> if ( v == 10 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) ) . flatMap ( v -> v , true ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; up . onNext ( 10 ) ; ) . test ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class , 1 , 2 ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . just ( up . map ( v -> if ( v == 10 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . flowableStripBoundary ( ) ) , pp ) . flatMap ( v -> v , true ) . doOnNext ( v -> if ( v == 1 ) pp . onNext ( 2 ) ; up . onNext ( 10 ) ; ) . test ( ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; ts . assertFailure ( TestException . class , 1 , 2 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . flatMap ( v -> Flowable . never ( ) ) ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> Flowable . just ( 2 ) . hide ( ) , Integer . MAX_VALUE ) . test ( ) . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> Flowable . just ( 2 ) , Integer . MAX_VALUE ) . test ( ) . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> Flowable . empty ( ) , Integer . MAX_VALUE ) . test ( ) . assertResult ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> new ScalarEmptyCancel ( ts ) ) . subscribeWith ( ts ) . assertEmpty ( ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> Flowable . just ( 2 ) , Integer . MAX_VALUE ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 1 ) . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> Flowable . just ( 2 ) , 2 ) . takeUntil ( v -> true ) . test ( ) . assertResult ( 2 ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Subscriber < @ NonNull ? super @ NonNull Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onNext ( 3 ) ; . flatMap ( v -> Flowable . just ( v ) , 1 ) . test ( 0L ) . assertFailure ( MissingBackpressureException . class ) ; 
AtomicReference < Subscriber < ? super Integer > > ref = new AtomicReference < > ( ) ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Subscriber < @ NonNull ? super @ NonNull Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; ref . set ( subscriber ) ; subscriber . onNext ( 1 ) ; . flatMap ( v -> Flowable . just ( v ) , 1 ) . doOnNext ( v -> if ( v == 1 ) ref . get ( ) . onNext ( 2 ) ; ref . get ( ) . onNext ( 3 ) ; ) . test ( ) . assertFailure ( MissingBackpressureException . class , 1 ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> new Flowable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Subscriber < @ NonNull ? super @ NonNull Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onNext ( 3 ) ; , false , 1 , 1 ) . test ( 0L ) . assertFailure ( MissingBackpressureException . class ) ; 
Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> Flowable . just ( 2 ) , 2 ) . takeUntil ( v -> true ) . test ( 0L ) . requestMore ( 2 ) . assertResult ( 2 ) ; 
Flowable . just ( 1 ) . concatWith ( Flowable . never ( ) ) . hide ( ) . flatMap ( v -> Flowable . just ( 2 ) , 2 ) . test ( 0L ) . requestMore ( 2 ) . assertValuesOnly ( 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Flowable . just ( 1 ) . hide ( ) . flatMap ( v -> pp ) . doOnNext ( v -> if ( v == 1 ) pp . onComplete ( ) ; ts . cancel ( ) ; ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . requestMore ( 1 ) . assertValuesOnly ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) Flowable . range ( 0 , 20 ) . flatMap ( integer -> if ( integer % 5 != 0 ) return Flowable . just ( integer ) ; return Flowable . just ( - integer ) . observeOn ( Schedulers . computation ( ) ) ; , false , 1 ) . ignoreElements ( ) . blockingAwait ( ) ; 
FlowableCache < Integer > source = new FlowableCache < > ( Flowable . range ( 0 , 1000 ) , 16 ) ; assertFalse ( "Source is connected!" , source . isConnected ( ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . subscribe ( ts ) ; assertTrue ( "Source is not connected!" , source . isConnected ( ) ) ; assertFalse ( "Subscribers retained!" , source . hasSubscribers ( ) ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 1000 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; 
FlowableCache < Integer > source = new FlowableCache < > ( Flowable . range ( 0 , 1000 ) , 16 ) ; assertFalse ( "Source is connected!" , source . isConnected ( ) ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 10 ) ; source . subscribe ( ts ) ; assertTrue ( "Source is not connected!" , source . isConnected ( ) ) ; assertFalse ( "Subscribers retained!" , source . hasSubscribers ( ) ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 10 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; ts . cancel ( ) ; assertFalse ( "Subscribers retained!" , source . hasSubscribers ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < String > f = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; System . out . println ( "published observable being executed" ) ; subscriber . onNext ( "one" ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) . cache ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
Action unsubscribe = mock ( Action . class ) ; Flowable < Integer > f = Flowable . just ( 1 ) . doOnCancel ( unsubscribe ) . cache ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; verify ( unsubscribe , never ( ) ) . run ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; FlowableCache < Integer > cached = new FlowableCache < > ( Flowable . range ( 1 , 100 ) , 16 ) ; cached . take ( 10 ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertFalse ( cached . hasSubscribers ( ) ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 10000 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; FlowableCache < Integer > cached = new FlowableCache < > ( source , 16 ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts1 ) ; ts1 . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts1 . assertNoErrors ( ) ; ts1 . assertComplete ( ) ; assertEquals ( 10000 , ts1 . values ( ) . size ( ) ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts2 ) ; ts2 . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts2 . assertNoErrors ( ) ; ts2 . assertComplete ( ) ; assertEquals ( 10000 , ts2 . values ( ) . size ( ) ) ; 
Flowable < Long > source = Flowable . interval ( 1 , 1 , TimeUnit . MILLISECONDS ) . take ( 1000 ) . subscribeOn ( Schedulers . io ( ) ) ; FlowableCache < Long > cached = new FlowableCache < > ( source , 16 ) ; Flowable < Long > output = cached . observeOn ( Schedulers . computation ( ) ) ; List < TestSubscriber < Long > > list = new ArrayList < > ( 100 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestSubscriber < Long > ts = new TestSubscriber < > ( ) ; list . add ( ts ) ; output . skip ( i * 10 ) . take ( 10 ) . subscribe ( ts ) ; List < Long > expected = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) expected . add ( ( long ) ( i - 10 ) ) ; int j = 0 ; for ( TestSubscriber < Long > ts : list ) ts . awaitDone ( 3 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; for ( int i = j * 10 ; i < j * 10 + 10 ; i ++ ) expected . set ( i - j * 10 , ( long ) i ) ; ts . assertValueSequence ( expected ) ; j ++ ; 
final int m = 4 * 1000 * 1000 ; Flowable < Integer > firehose = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > t ) t . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) t . onNext ( i ) ; t . onComplete ( ) ; ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; firehose . cache ( ) . observeOn ( Schedulers . computation ( ) ) . takeLast ( 100 ) . subscribe ( ts ) ; ts . awaitDone ( 3 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; assertEquals ( 100 , ts . values ( ) . size ( ) ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . cache ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; source . subscribe ( ts2 ) ; ts2 . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts2 . assertNotComplete ( ) ; ts2 . assertError ( TestException . class ) ; 
Flowable < Integer > cache = Flowable . range ( 1 , 5 ) . cache ( ) ; cache . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; cache . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 5 ) . cache ( ) ) ; 
Flowable < Integer > f = PublishProcessor . < Integer > create ( ) . cache ( ) ; f . test ( ) ; f . test ( 0L , true ) . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . < Integer > create ( ) ; final Flowable < Integer > cache = pp . cache ( ) ; cache . test ( ) ; final TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cache . subscribe ( ts ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 500 ; j ++ ) pp . onNext ( j ) ; pp . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertComplete ( ) . assertNoErrors ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; FlowableCache < Integer > cache = ( FlowableCache < Integer > ) Flowable . range ( 1 , 5 ) . concatWith ( pp ) . cache ( ) ; assertFalse ( cache . hasSubscribers ( ) ) ; assertEquals ( 0 , cache . cachedEventCount ( ) ) ; TestSubscriber < Integer > ts = cache . test ( ) ; assertTrue ( cache . hasSubscribers ( ) ) ; assertEquals ( 5 , cache . cachedEventCount ( ) ) ; pp . onComplete ( ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . cache ( ) . test ( 0L , true ) . assertEmpty ( ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Object > , Object > ( ) @ Override public Object apply ( Flowable < Object > f ) throws Exception return f . cache ( ) ; , false , 1 , 1 , 1 ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . cache ( ) ) ; 
Flowable < Integer > cache = Flowable . just ( 1 , 2 ) . cache ( ) ; cache . test ( ) ; cache . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Flowable . empty ( ) . cache ( ) . test ( 0L ) . assertResult ( ) ; 
Flowable . error ( new TestException ( ) ) . cache ( ) . test ( 0L ) . assertFailure ( TestException . class ) ; 
final AtomicInteger call = new AtomicInteger ( ) ; Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return call . incrementAndGet ( ) ; ) . cache ( ) . test ( 1L , true ) . assertNoValues ( ) ; assertEquals ( 1 , call . get ( ) ) ; 
final AtomicInteger call = new AtomicInteger ( ) ; Flowable < Object > f = Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return call . incrementAndGet ( ) ; ) . concatWith ( Flowable . never ( ) ) . cache ( ) ; f . test ( ) . assertValuesOnly ( 1 ) ; f . test ( 1L , true ) . assertEmpty ( ) ; assertEquals ( 1 , call . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final Flowable < Integer > cache = Flowable . range ( 1 , 500 ) . cache ( ) ; final TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; final TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cache . subscribe ( ts1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cache . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; ts1 . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertComplete ( ) . assertNoErrors ( ) ; ts2 . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertComplete ( ) . assertNoErrors ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . < Integer > create ( ) ; final Flowable < Integer > cache = pp . cache ( ) ; cache . test ( ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cache . subscribe ( ts ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
Flowable . range ( 1 , 5 ) . cache ( ) . test ( 0 ) . assertEmpty ( ) . requestMore ( 2 ) . assertValuesOnly ( 1 , 2 ) . requestMore ( 3 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) Flowable < Object > f = Flowable . never ( ) . cache ( ) ; TestSubscriber < Object > ts = f . test ( ) ; TestHelper . race ( ( ) -> ts . cancel ( ) , ( ) -> f . test ( ) ) ; 
concat2Strings = new BiFunction < String , String , String > ( ) @ Override public String apply ( String t1 , String t2 ) return t1 + "-" + t2 ; ; s1 = PublishProcessor . create ( ) ; s2 = PublishProcessor . create ( ) ; zipped = Flowable . zip ( s1 , s2 , concat2Strings ) ; subscriber = TestHelper . mockSubscriber ( ) ; inOrder = inOrder ( subscriber ) ; zipped . subscribe ( subscriber ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" , "3" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onNext ( "three-" ) ; r1 . onComplete ( ) ; io . verify ( subscriber ) . onNext ( "one-1" ) ; io . verify ( subscriber ) . onNext ( "two-2" ) ; io . verify ( subscriber ) . onNext ( "three-3" ) ; io . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" , "3" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onComplete ( ) ; io . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = Arrays . asList ( ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onNext ( "three-" ) ; r1 . onComplete ( ) ; io . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" , "3" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onComplete ( ) ; io . verify ( subscriber ) . onNext ( "one-1" ) ; io . verify ( subscriber ) . onNext ( "two-2" ) ; io . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onNext ( "three-" ) ; r1 . onComplete ( ) ; io . verify ( subscriber ) . onNext ( "one-1" ) ; io . verify ( subscriber ) . onNext ( "two-2" ) ; io . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" , "3" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onError ( new TestException ( ) ) ; io . verify ( subscriber ) . onNext ( "one-1" ) ; io . verify ( subscriber ) . onNext ( "two-2" ) ; io . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = new Iterable < String > ( ) @ Override public Iterator < String > iterator ( ) throw new TestException ( ) ; ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onError ( new TestException ( ) ) ; io . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = new Iterable < String > ( ) @ Override public Iterator < String > iterator ( ) return new Iterator < String > ( ) int count ; @ Override public boolean hasNext ( ) if ( count == 0 ) return true ; throw new TestException ( ) ; @ Override public String next ( ) count ++ ; return "1" ; @ Override public void remove ( ) throw new UnsupportedOperationException ( "Not supported yet." ) ; ; ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onNext ( "one-" ) ; r1 . onError ( new TestException ( ) ) ; io . verify ( subscriber ) . onNext ( "one-1" ) ; io . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
PublishProcessor < String > r1 = PublishProcessor . create ( ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; InOrder io = inOrder ( subscriber ) ; Iterable < String > r2 = new Iterable < String > ( ) @ Override public Iterator < String > iterator ( ) return new Iterator < String > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public String next ( ) throw new TestException ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( "Not supported yet." ) ; ; ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( subscriber ) ; r1 . onError ( new TestException ( ) ) ; io . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
counter . incrementAndGet ( ) ; System . out . println ( "Omg I'm calculating so hard: " + t1 + "*" + t1 + "=" + ( t1 * t1 ) ) ; return " " + ( t1 * t1 ) ; 
Flowable < Integer > f = Flowable . just ( 1 , 2 , 3 , 4 , 5 ) ; Iterable < String > it = Arrays . asList ( "a" , "b" , "c" , "d" , "e" ) ; SquareStr squareStr = new SquareStr ( ) ; f . map ( squareStr ) . zipWith ( it , concat2Strings ) . take ( 2 ) . subscribe ( printer ) ; assertEquals ( 2 , squareStr . counter . get ( ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . zipWith ( Arrays . asList ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Integer > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Integer > f ) throws Exception return f . zipWith ( Arrays . asList ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) ; ) ; 
Flowable . just ( 1 ) . zipWith ( new CrashingIterable ( 100 , 1 , 100 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onComplete ( ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . zipWith ( Arrays . asList ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertResult ( 2 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishProcessor < Object > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Flowable . just ( 1 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( ts ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onNext ( 1 ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
PublishProcessor < Object > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Flowable . just ( 1 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( ts ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onNext ( 1 ) ; other . onNext ( 2 ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
PublishProcessor < Object > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Flowable . just ( 1 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( ts ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onComplete ( ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
PublishProcessor < Object > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Flowable . < Integer > error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( ts ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onComplete ( ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
PublishProcessor < Object > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Flowable . < Integer > error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( ts ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onError ( new TestException ( ) ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
PublishProcessor < Object > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; final AtomicInteger subscribed = new AtomicInteger ( ) ; Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribed . getAndIncrement ( ) ; ) . delaySubscription ( other ) . subscribe ( ts ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; Assert . assertEquals ( "Premature subscription" , 0 , subscribed . get ( ) ) ; other . onNext ( 1 ) ; Assert . assertEquals ( "No subscription" , 1 , subscribed . get ( ) ) ; Assert . assertFalse ( "Not unsubscribed from other" , other . hasSubscribers ( ) ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 10 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . delaySubscription ( other ) . subscribe ( ts ) ; Assert . assertFalse ( "source subscribed?" , source . hasSubscribers ( ) ) ; Assert . assertTrue ( "other not subscribed?" , other . hasSubscribers ( ) ) ; ts . cancel ( ) ; Assert . assertFalse ( "source subscribed?" , source . hasSubscribers ( ) ) ; Assert . assertFalse ( "other still subscribed?" , other . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . delaySubscription ( other ) . subscribe ( ts ) ; Assert . assertFalse ( "source subscribed?" , source . hasSubscribers ( ) ) ; Assert . assertTrue ( "other not subscribed?" , other . hasSubscribers ( ) ) ; other . onComplete ( ) ; Assert . assertTrue ( "source not subscribed?" , source . hasSubscribers ( ) ) ; Assert . assertFalse ( "other still subscribed?" , other . hasSubscribers ( ) ) ; ts . cancel ( ) ; Assert . assertFalse ( "source subscribed?" , source . hasSubscribers ( ) ) ; Assert . assertFalse ( "other still subscribed?" , other . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > delayUntil = PublishProcessor . create ( ) ; PublishProcessor < Integer > interrupt = PublishProcessor . create ( ) ; final AtomicBoolean subscribed = new AtomicBoolean ( false ) ; Flowable . just ( 1 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribed . set ( true ) ; ) . delaySubscription ( delayUntil ) . takeUntil ( interrupt ) . subscribe ( ) ; interrupt . onNext ( 9000 ) ; delayUntil . onNext ( 1 ) ; Assert . assertFalse ( subscribed . get ( ) ) ; 
TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return Flowable . just ( 1 ) . delaySubscription ( f ) ; , false , 1 , 1 , 1 ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try for ( Scheduler s : new Scheduler [ ] Schedulers . single ( ) , Schedulers . computation ( ) , Schedulers . newThread ( ) , Schedulers . io ( ) , Schedulers . from ( exec ) ) final TestSubscriber < Boolean > ts = TestSubscriber . create ( ) ; ts . withTag ( s . getClass ( ) . getSimpleName ( ) ) ; Flowable . < Boolean > create ( new FlowableOnSubscribe < Boolean > ( ) @ Override public void subscribe ( FlowableEmitter < Boolean > emitter ) throws Exception emitter . onNext ( Thread . interrupted ( ) ) ; emitter . onComplete ( ) ; , BackpressureStrategy . MISSING ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , s ) . subscribe ( ts ) ; ts . awaitDone ( 5 , TimeUnit . SECONDS ) ; ts . assertValue ( false ) ; finally exec . shutdown ( ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . delaySubscription ( Flowable . empty ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> PublishProcessor . create ( ) . delaySubscription ( f ) ) ; 
TestHelper . assertBadRequestReported ( PublishProcessor . create ( ) . delaySubscription ( Flowable . empty ( ) ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 3 , 2 , 5 , 4 ) ; Flowable < List < Integer > > flowable = w . toSortedList ( ) . toFlowable ( ) ; Subscriber < List < Integer > > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 3 , 2 , 5 , 4 ) ; Flowable < List < Integer > > flowable = w . toSortedList ( new Comparator < Integer > ( ) @ Override public int compare ( Integer t1 , Integer t2 ) return t2 - t1 ; ) . toFlowable ( ) ; Subscriber < List < Integer > > subscriber = TestHelper . mockSubscriber ( ) ; flowable . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) ; verify ( subscriber , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < Integer > f = Flowable . just ( 1 , 3 , 2 , 5 , 4 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , f . toSortedList ( ) . toFlowable ( ) . blockingFirst ( ) ) ; 
Flowable < List < Integer > > w = Flowable . just ( 1 , 3 , 2 , 5 , 4 ) . toSortedList ( ) . toFlowable ( ) ; TestSubscriber < List < Integer > > ts = new TestSubscriber < > ( 0L ) ; w . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . assertValue ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; ts . request ( 1 ) ; ts . assertValue ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . just ( 5 , 1 , 2 , 4 , 3 ) . sorted ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . just ( 5 , 1 , 2 , 4 , 3 ) . sorted ( new Comparator < Integer > ( ) @ Override public int compare ( Integer a , Integer b ) return b - a ; ) . test ( ) . assertResult ( 5 , 4 , 3 , 2 , 1 ) ; 
Flowable . just ( 5 , 1 , 2 , 4 , 3 ) . toSortedList ( 4 ) . toFlowable ( ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Flowable . just ( 5 , 1 , 2 , 4 , 3 ) . toSortedList ( new Comparator < Integer > ( ) @ Override public int compare ( Integer a , Integer b ) return b - a ; , 4 ) . toFlowable ( ) . test ( ) . assertResult ( Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 3 , 2 , 5 , 4 ) ; Single < List < Integer > > single = w . toSortedList ( ) ; SingleObserver < List < Integer > > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 3 , 2 , 5 , 4 ) ; Single < List < Integer > > single = w . toSortedList ( new Comparator < Integer > ( ) @ Override public int compare ( Integer t1 , Integer t2 ) return t2 - t1 ; ) ; SingleObserver < List < Integer > > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Flowable < Integer > f = Flowable . just ( 1 , 3 , 2 , 5 , 4 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , f . toSortedList ( ) . blockingGet ( ) ) ; 
try cb . await ( ) ; catch ( InterruptedException ex ) ex . printStackTrace ( ) ; catch ( BrokenBarrierException ex ) ex . printStackTrace ( ) ; 
Flowable . just ( 5 , 1 , 2 , 4 , 3 ) . toSortedList ( 4 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Flowable . just ( 5 , 1 , 2 , 4 , 3 ) . toSortedList ( new Comparator < Integer > ( ) @ Override public int compare ( Integer a , Integer b ) return b - a ; , 4 ) . test ( ) . assertResult ( Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; source . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . range ( v , 2 ) ; ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . assertValues ( 1 , 2 , 2 , 3 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; source . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . range ( v , 2 ) ; ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . assertValues ( 1 , 2 , 2 , 3 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
final Flowable < Integer > inner = Flowable . range ( 1 , 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return inner ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 1 , 2 , 1 , 2 ) ; ts . assertError ( CompositeException . class ) ; ts . assertNotComplete ( ) ; 
final Flowable < Integer > inner = Flowable . range ( 1 , 2 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return inner ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return null ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( NullPointerException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throw new TestException ( ) ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return v == 2 ? Flowable . < Integer > empty ( ) : Flowable . range ( 1 , 2 ) ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return v == 2 ? Flowable . just ( 3 ) : Flowable . range ( 1 , 2 ) ; ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( 0 ) ; Flowable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) return Flowable . range ( v , 2 ) ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 3 ) ; ts . assertValues ( 1 , 2 , 2 , 3 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 , 4 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
return source . concatWith ( Flowable . < T > error ( new TestException ( ) ) ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . concatDelayError ( Flowable . just ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . concatDelayError ( withError ( Flowable . just ( withError ( Flowable . just ( 1 ) ) , withError ( Flowable . just ( 2 ) ) ) ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertError ( CompositeException . class ) ; ts . assertNotComplete ( ) ; CompositeException ce = ( CompositeException ) ts . errors ( ) . get ( 0 ) ; List < Throwable > cex = ce . getExceptions ( ) ; assertEquals ( 3 , cex . size ( ) ) ; assertTrue ( cex . get ( 0 ) . toString ( ) , cex . get ( 0 ) instanceof TestException ) ; assertTrue ( cex . get ( 1 ) . toString ( ) , cex . get ( 1 ) instanceof TestException ) ; assertTrue ( cex . get ( 2 ) . toString ( ) , cex . get ( 2 ) instanceof TestException ) ; 
TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . concatDelayError ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable . concatDelayError ( Arrays . asList ( withError ( Flowable . just ( 1 ) ) , withError ( Flowable . just ( 2 ) ) ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 2 ) ; ts . assertError ( CompositeException . class ) ; ts . assertNotComplete ( ) ; assertEquals ( 2 , ( ( CompositeException ) ts . errors ( ) . get ( 0 ) ) . getExceptions ( ) . size ( ) ) ; 
assertEquals ( 2 , Flowable . fromArray ( 1 , 2 ) . elementAt ( 1 ) . toFlowable ( ) . blockingSingle ( ) . intValue ( ) ) ; 
Flowable . fromArray ( 1 , 2 ) . elementAt ( - 1 ) ; 
assertEquals ( - 100 , Flowable . fromArray ( 1 , 2 ) . elementAt ( 2 ) . toFlowable ( ) . blockingFirst ( - 100 ) . intValue ( ) ) ; 
assertEquals ( 2 , Flowable . fromArray ( 1 , 2 ) . elementAt ( 1 , 0 ) . toFlowable ( ) . blockingSingle ( ) . intValue ( ) ) ; 
assertEquals ( 0 , Flowable . fromArray ( 1 , 2 ) . elementAt ( 2 , 0 ) . toFlowable ( ) . blockingSingle ( ) . intValue ( ) ) ; 
Flowable . fromArray ( 1 , 2 ) . elementAt ( - 1 , 0 ) ; 
assertEquals ( 2 , Flowable . fromArray ( 1 , 2 ) . elementAt ( 1 ) . blockingGet ( ) . intValue ( ) ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable . fromArray ( 1 , 2 , 3 , 4 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) throws Throwable requests . add ( n ) ; ) . elementAt ( 2 ) . blockingGet ( ) . intValue ( ) ; assertEquals ( Arrays . asList ( 3L ) , requests ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable . fromArray ( 1 , 2 , 3 , 4 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) throws Throwable requests . add ( n ) ; ) . elementAt ( 2 , 100 ) . blockingGet ( ) . intValue ( ) ; assertEquals ( Arrays . asList ( 3L ) , requests ) ; 
Flowable . fromArray ( 1 , 2 ) . elementAt ( - 1 ) ; 
assertNull ( Flowable . fromArray ( 1 , 2 ) . elementAt ( 2 ) . blockingGet ( ) ) ; 
assertEquals ( 2 , Flowable . fromArray ( 1 , 2 ) . elementAt ( 1 , 0 ) . blockingGet ( ) . intValue ( ) ) ; 
assertEquals ( 0 , Flowable . fromArray ( 1 , 2 ) . elementAt ( 2 , 0 ) . blockingGet ( ) . intValue ( ) ) ; 
Flowable . fromArray ( 1 , 2 ) . elementAt ( - 1 , 0 ) ; 
Flowable . empty ( ) . elementAtOrError ( - 1 ) ; 
Flowable . empty ( ) . elementAtOrError ( 0 ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Flowable . just ( 1 ) . elementAtOrError ( 0 ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Flowable . just ( 1 , 2 , 3 ) . elementAtOrError ( 1 ) . test ( ) . assertNoErrors ( ) . assertValue ( 2 ) ; 
Flowable . just ( 1 , 2 , 3 ) . elementAtOrError ( 3 ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Flowable . error ( new RuntimeException ( "error" ) ) . elementAtOrError ( 0 ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
Flowable . empty ( ) . elementAt ( 0 ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . elementAt ( 0 , 5 ) . test ( ) . assertResult ( 5 ) ; 
Flowable . empty ( ) . elementAt ( 1 ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . elementAt ( 1 , 10 ) . test ( ) . assertResult ( 10 ) ; 
Flowable . empty ( ) . elementAtOrError ( 1 ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Object > f ) throws Exception return f . elementAt ( 0 ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToMaybe ( new Function < Flowable < Object > , Maybe < Object > > ( ) @ Override public Maybe < Object > apply ( Flowable < Object > f ) throws Exception return f . elementAt ( 0 ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Object > , Single < Object > > ( ) @ Override public Single < Object > apply ( Flowable < Object > f ) throws Exception return f . elementAt ( 0 , 1 ) ; ) ; 
Flowable . empty ( ) . elementAt ( 1 , 10 ) . toFlowable ( ) . test ( ) . assertResult ( 10 ) ; 
Flowable . error ( new TestException ( ) ) . elementAt ( 1 , 10 ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . elementAt ( 1 , 10 ) . test ( ) . assertFailure ( TestException . class ) ; Flowable . error ( new TestException ( ) ) . elementAt ( 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . elementAt ( 0 ) . toFlowable ( ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . elementAt ( 0 ) ; , false , null , 1 ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . elementAt ( 0 , 1 ) ; , false , null , 1 , 1 ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . elementAt ( 0 ) . toFlowable ( ) ; , false , null , 1 ) ; TestHelper . checkBadSourceFlowable ( new Function < Flowable < Integer > , Object > ( ) @ Override public Object apply ( Flowable < Integer > f ) throws Exception return f . elementAt ( 0 , 1 ) . toFlowable ( ) ; , false , null , 1 , 1 ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . elementAt ( 0 ) . toFlowable ( ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . elementAt ( 0 , 1 ) . toFlowable ( ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . elementAt ( 0 ) ) ; TestHelper . checkDisposed ( PublishProcessor . create ( ) . elementAt ( 0 , 1 ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . elementAt ( 0 ) . toFlowable ( ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( 1 ) ; subscriber . onNext ( 2 ) ; subscriber . onError ( new TestException ( ) ) ; subscriber . onComplete ( ) ; . elementAt ( 0 , 1 ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
source = new PublishAsyncEmitter ( ) ; sourceNoCancel = new PublishAsyncEmitterNoCancel ( ) ; ts = new TestSubscriberEx < > ( 0L ) ; 
Flowable . create ( source , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; Assert . assertEquals ( 0 , source . requested ( ) ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . DROP ) . subscribe ( ts ) ; source . onNext ( 1 ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . assertValues ( 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . LATEST ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValues ( 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . MISSING ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . MISSING ) . subscribe ( ts ) ; ts . request ( 2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . ERROR ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . assertNoValues ( ) ; ts . assertError ( MissingBackpressureException . class ) ; ts . assertNotComplete ( ) ; Assert . assertEquals ( "create: could not emit value due to lack of requests" , ts . errors ( ) . get ( 0 ) . getMessage ( ) ) ; 
Flowable . create ( source , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . LATEST ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; ts . assertValues ( 2 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . MISSING ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; ts . cancel ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . LATEST ) . subscribe ( ts ) ; ts . cancel ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . ERROR ) . subscribe ( ts ) ; ts . cancel ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . DROP ) . subscribe ( ts ) ; ts . cancel ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . MISSING ) . subscribe ( ts ) ; ts . cancel ( ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . create ( sourceNoCancel , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; ts . cancel ( ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; sourceNoCancel . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . create ( sourceNoCancel , BackpressureStrategy . LATEST ) . subscribe ( ts ) ; ts . cancel ( ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; sourceNoCancel . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . create ( sourceNoCancel , BackpressureStrategy . ERROR ) . subscribe ( ts ) ; ts . cancel ( ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; sourceNoCancel . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . create ( sourceNoCancel , BackpressureStrategy . DROP ) . subscribe ( ts ) ; ts . cancel ( ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; sourceNoCancel . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . create ( sourceNoCancel , BackpressureStrategy . MISSING ) . subscribe ( ts ) ; ts . cancel ( ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; sourceNoCancel . onError ( new TestException ( ) ) ; ts . request ( 1 ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . create ( source , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . BUFFER ) . take ( 2 ) . subscribe ( ts ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . BUFFER ) . take ( 1 ) . subscribe ( ts ) ; ts . request ( 2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( source , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; ts . request ( 2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( sourceNoCancel , BackpressureStrategy . BUFFER ) . take ( 2 ) . subscribe ( ts ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; sourceNoCancel . onComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( sourceNoCancel , BackpressureStrategy . BUFFER ) . take ( 1 ) . subscribe ( ts ) ; ts . request ( 2 ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; sourceNoCancel . onComplete ( ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( sourceNoCancel , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; ts . request ( 2 ) ; sourceNoCancel . onNext ( 1 ) ; ts . cancel ( ) ; sourceNoCancel . onNext ( 2 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; ; Flowable . create ( sourceNoCancel , BackpressureStrategy . BUFFER ) . subscribe ( ts1 ) ; sourceNoCancel . onNext ( 1 ) ; ts1 . assertValues ( 1 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; 
super . onNext ( t ) ; cancel ( ) ; 
Flowable . create ( sourceNoCancel , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( sourceNoCancel , BackpressureStrategy . BUFFER ) . subscribe ( ts ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onError ( new TestException ( ) ) ; ts . request ( 2 ) ; ts . assertValues ( 1 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; request ( 1 ) ; ; Flowable . create ( sourceNoCancel , BackpressureStrategy . BUFFER ) . subscribe ( ts1 ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; ts1 . assertValues ( 1 , 2 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; 
super . onNext ( t ) ; request ( 1 ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; ; Flowable . create ( sourceNoCancel , BackpressureStrategy . LATEST ) . subscribe ( ts1 ) ; sourceNoCancel . onNext ( 1 ) ; ts1 . assertValues ( 1 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; ; Flowable . create ( sourceNoCancel , BackpressureStrategy . LATEST ) . subscribe ( ts1 ) ; sourceNoCancel . onNext ( 1 ) ; ts1 . assertValues ( 1 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; 
Flowable . create ( sourceNoCancel , BackpressureStrategy . LATEST ) . subscribe ( ts ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onComplete ( ) ; ts . request ( 2 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( sourceNoCancel , BackpressureStrategy . LATEST ) . subscribe ( ts ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onComplete ( ) ; ts . request ( 1 ) ; ts . assertValues ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . create ( sourceNoCancel , BackpressureStrategy . LATEST ) . subscribe ( ts ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onError ( new TestException ( ) ) ; ts . request ( 2 ) ; ts . assertValues ( 1 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
TestSubscriber < Integer > ts1 = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; request ( 1 ) ; ; Flowable . create ( sourceNoCancel , BackpressureStrategy . LATEST ) . subscribe ( ts1 ) ; sourceNoCancel . onNext ( 1 ) ; sourceNoCancel . onNext ( 2 ) ; ts1 . assertValues ( 1 , 2 ) ; ts1 . assertNoErrors ( ) ; ts1 . assertNotComplete ( ) ; 
return current . requested ( ) ; 
this . current = t ; final ResourceSubscriber < Integer > as = new ResourceSubscriber < Integer > ( ) @ Override public void onComplete ( ) t . onComplete ( ) ; @ Override public void onError ( Throwable e ) t . onError ( e ) ; @ Override public void onNext ( Integer v ) t . onNext ( v ) ; ; processor . subscribe ( as ) ; t . setCancellable ( new Cancellable ( ) @ Override public void cancel ( ) throws Exception as . dispose ( ) ; ) ; ; 
t . onComplete ( ) ; 
t . onError ( e ) ; 
s . request ( Long . MAX_VALUE ) ; 
processor . onError ( e ) ; 
processor . onComplete ( ) ; 
processor . subscribe ( new FlowableSubscriber < Integer > ( ) @ Override public void onSubscribe ( Subscription s ) s . request ( Long . MAX_VALUE ) ; @ Override public void onComplete ( ) t . onComplete ( ) ; @ Override public void onError ( Throwable e ) t . onError ( e ) ; @ Override public void onNext ( Integer v ) t . onNext ( v ) ; ) ; 
s . request ( Long . MAX_VALUE ) ; 
Subscription sSource = mock ( Subscription . class ) ; Subscription sOther = mock ( Subscription . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Subscriber < String > result = TestHelper . mockSubscriber ( ) ; Flowable < String > stringObservable = Flowable . unsafeCreate ( source ) . takeUntil ( Flowable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; other . sendOnNext ( "three" ) ; source . sendOnNext ( "four" ) ; source . sendOnCompleted ( ) ; other . sendOnCompleted ( ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( result , times ( 0 ) ) . onNext ( "three" ) ; verify ( result , times ( 0 ) ) . onNext ( "four" ) ; verify ( sSource , times ( 1 ) ) . cancel ( ) ; verify ( sOther , times ( 1 ) ) . cancel ( ) ; 
Subscription sSource = mock ( Subscription . class ) ; Subscription sOther = mock ( Subscription . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Subscriber < String > result = TestHelper . mockSubscriber ( ) ; Flowable < String > stringObservable = Flowable . unsafeCreate ( source ) . takeUntil ( Flowable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; source . sendOnCompleted ( ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( sSource , never ( ) ) . cancel ( ) ; verify ( sOther , times ( 1 ) ) . cancel ( ) ; 
Subscription sSource = mock ( Subscription . class ) ; Subscription sOther = mock ( Subscription . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Throwable error = new Throwable ( ) ; Subscriber < String > result = TestHelper . mockSubscriber ( ) ; Flowable < String > stringObservable = Flowable . unsafeCreate ( source ) . takeUntil ( Flowable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; source . sendOnError ( error ) ; source . sendOnNext ( "three" ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( result , times ( 0 ) ) . onNext ( "three" ) ; verify ( result , times ( 1 ) ) . onError ( error ) ; verify ( sSource , never ( ) ) . cancel ( ) ; verify ( sOther , times ( 1 ) ) . cancel ( ) ; 
Subscription sSource = mock ( Subscription . class ) ; Subscription sOther = mock ( Subscription . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Throwable error = new Throwable ( ) ; Subscriber < String > result = TestHelper . mockSubscriber ( ) ; Flowable < String > stringObservable = Flowable . unsafeCreate ( source ) . takeUntil ( Flowable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; other . sendOnError ( error ) ; source . sendOnNext ( "three" ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( result , times ( 0 ) ) . onNext ( "three" ) ; verify ( result , times ( 1 ) ) . onError ( error ) ; verify ( result , times ( 0 ) ) . onComplete ( ) ; verify ( sSource , times ( 1 ) ) . cancel ( ) ; verify ( sOther , never ( ) ) . cancel ( ) ; 
Subscription sSource = mock ( Subscription . class ) ; Subscription sOther = mock ( Subscription . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Subscriber < String > result = TestHelper . mockSubscriber ( ) ; Flowable < String > stringObservable = Flowable . unsafeCreate ( source ) . takeUntil ( Flowable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; other . sendOnCompleted ( ) ; source . sendOnNext ( "three" ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( result , times ( 0 ) ) . onNext ( "three" ) ; verify ( result , times ( 1 ) ) . onComplete ( ) ; verify ( sSource , times ( 1 ) ) . cancel ( ) ; verify ( sOther , never ( ) ) . cancel ( ) ; 
subscriber . onComplete ( ) ; 
subscriber . onNext ( value ) ; 
subscriber . onError ( e ) ; 
this . subscriber = subscriber ; subscriber . onSubscribe ( upstream ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > until = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . takeUntil ( until ) . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( until . hasSubscribers ( ) ) ; source . onNext ( 1 ) ; ts . assertValue ( 1 ) ; until . onNext ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; assertFalse ( "Source still has observers" , source . hasSubscribers ( ) ) ; assertFalse ( "Until still has observers" , until . hasSubscribers ( ) ) ; assertFalse ( "TestSubscriber is unsubscribed" , ts . isCancelled ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > until = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . takeUntil ( until ) . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( until . hasSubscribers ( ) ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; assertFalse ( "Source still has observers" , source . hasSubscribers ( ) ) ; assertFalse ( "Until still has observers" , until . hasSubscribers ( ) ) ; assertFalse ( "TestSubscriber is unsubscribed" , ts . isCancelled ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > until = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . takeUntil ( until ) . take ( 1 ) . subscribe ( ts ) ; assertTrue ( source . hasSubscribers ( ) ) ; assertTrue ( until . hasSubscribers ( ) ) ; source . onNext ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; assertFalse ( "Source still has observers" , source . hasSubscribers ( ) ) ; assertFalse ( "Until still has observers" , until . hasSubscribers ( ) ) ; assertFalse ( "TestSubscriber is unsubscribed" , ts . isCancelled ( ) ) ; 
PublishProcessor < Integer > until = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Flowable . range ( 1 , 10 ) . takeUntil ( until ) . subscribe ( ts ) ; assertTrue ( until . hasSubscribers ( ) ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; until . onNext ( 5 ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; assertFalse ( "Until still has observers" , until . hasSubscribers ( ) ) ; assertFalse ( "TestSubscriber is unsubscribed" , ts . isCancelled ( ) ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . takeUntil ( Flowable . never ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > c ) throws Exception return c . takeUntil ( Flowable . never ( ) ) ; ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no subscribers?" , main . hasSubscribers ( ) ) ; assertTrue ( "Other no subscribers?" , other . hasSubscribers ( ) ) ; main . onNext ( 1 ) ; main . onNext ( 2 ) ; main . onComplete ( ) ; assertFalse ( "Main has subscribers?" , main . hasSubscribers ( ) ) ; assertFalse ( "Other has subscribers?" , other . hasSubscribers ( ) ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no subscribers?" , main . hasSubscribers ( ) ) ; assertTrue ( "Other no subscribers?" , other . hasSubscribers ( ) ) ; main . onComplete ( ) ; assertFalse ( "Main has subscribers?" , main . hasSubscribers ( ) ) ; assertFalse ( "Other has subscribers?" , other . hasSubscribers ( ) ) ; ts . assertResult ( ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no subscribers?" , main . hasSubscribers ( ) ) ; assertTrue ( "Other no subscribers?" , other . hasSubscribers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( "Main has subscribers?" , main . hasSubscribers ( ) ) ; assertFalse ( "Other has subscribers?" , other . hasSubscribers ( ) ) ; ts . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no subscribers?" , main . hasSubscribers ( ) ) ; assertTrue ( "Other no subscribers?" , other . hasSubscribers ( ) ) ; other . onNext ( 1 ) ; assertFalse ( "Main has subscribers?" , main . hasSubscribers ( ) ) ; assertFalse ( "Other has subscribers?" , other . hasSubscribers ( ) ) ; ts . assertResult ( ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no subscribers?" , main . hasSubscribers ( ) ) ; assertTrue ( "Other no subscribers?" , other . hasSubscribers ( ) ) ; other . onComplete ( ) ; assertFalse ( "Main has subscribers?" , main . hasSubscribers ( ) ) ; assertFalse ( "Other has subscribers?" , other . hasSubscribers ( ) ) ; ts . assertResult ( ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no subscribers?" , main . hasSubscribers ( ) ) ; assertTrue ( "Other no subscribers?" , other . hasSubscribers ( ) ) ; other . onError ( new TestException ( ) ) ; assertFalse ( "Main has subscribers?" , main . hasSubscribers ( ) ) ; assertFalse ( "Other has subscribers?" , other . hasSubscribers ( ) ) ; ts . assertFailure ( TestException . class ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; PublishProcessor < Integer > other = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no subscribers?" , main . hasSubscribers ( ) ) ; assertTrue ( "Other no subscribers?" , other . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( "Main has subscribers?" , main . hasSubscribers ( ) ) ; assertFalse ( "Other has subscribers?" , other . hasSubscribers ( ) ) ; ts . assertEmpty ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 3 , true ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 3 , 100 , TimeUnit . MILLISECONDS , scheduler , true ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 100 , TimeUnit . MILLISECONDS , scheduler , true ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Flowable < Integer > , Flowable < Integer > > selector = new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > t1 ) return t1 . map ( dbl ) ; ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > co = source . replay ( selector ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 8 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Flowable < Integer > , Flowable < Integer > > selector = new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > t1 ) return t1 . map ( dbl ) ; ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > co = source . replay ( selector , 3 , true ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 8 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Flowable < Integer > , Flowable < Integer > > selector = new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > t1 ) return t1 . map ( dbl ) ; ; TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > co = source . replay ( selector , 100 , TimeUnit . MILLISECONDS , scheduler , true ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 6 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 3 , true ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onComplete ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 100 , TimeUnit . MILLISECONDS , scheduler , true ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onComplete ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onComplete ( ) ; 
final AtomicInteger effectCounter = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 , 4 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) effectCounter . incrementAndGet ( ) ; System . out . println ( "Sideeffect #" + v ) ; ) ; Flowable < Integer > result = source . replay ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > f ) return f . take ( 2 ) ; ) ; for ( int i = 1 ; i < 3 ; i ++ ) effectCounter . set ( 0 ) ; System . out . printf ( "- %d -%n" , i ) ; result . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) System . out . println ( t1 ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) t1 . printStackTrace ( ) ; , new Action ( ) @ Override public void run ( ) System . out . println ( "Done" ) ; ) ; assertEquals ( 2 , effectCounter . get ( ) ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; Subscriber < Integer > spiedSubscriberBeforeConnect = TestHelper . mockSubscriber ( ) ; Subscriber < Integer > spiedSubscriberAfterConnect = TestHelper . mockSubscriber ( ) ; Flowable < Integer > source = Flowable . just ( 1 , 2 ) ; ConnectableFlowable < Integer > replay = source . doOnNext ( sourceNext ) . doOnCancel ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . replay ( ) ; replay . subscribe ( spiedSubscriberBeforeConnect ) ; replay . subscribe ( spiedSubscriberBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( spiedSubscriberAfterConnect ) ; replay . subscribe ( spiedSubscriberAfterConnect ) ; verify ( spiedSubscriberBeforeConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( spiedSubscriberAfterConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 2 ) ; verify ( sourceCompleted , times ( 1 ) ) . run ( ) ; verifyObserverMock ( spiedSubscriberBeforeConnect , 2 , 4 ) ; verifyObserverMock ( spiedSubscriberAfterConnect , 2 , 4 ) ; verify ( sourceUnsubscribed , never ( ) ) . run ( ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( spiedSubscriberBeforeConnect ) ; verifyNoMoreInteractions ( spiedSubscriberAfterConnect ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; final Scheduler mockScheduler = mock ( Scheduler . class ) ; final Disposable mockSubscription = mock ( Disposable . class ) ; Worker spiedWorker = workerSpy ( mockSubscription ) ; Subscriber < Integer > mockObserverBeforeConnect = TestHelper . mockSubscriber ( ) ; Subscriber < Integer > mockObserverAfterConnect = TestHelper . mockSubscriber ( ) ; when ( mockScheduler . createWorker ( ) ) . thenReturn ( spiedWorker ) ; ConnectableFlowable < Integer > replay = Flowable . just ( 1 , 2 , 3 ) . doOnNext ( sourceNext ) . doOnCancel ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . subscribeOn ( mockScheduler ) . replay ( ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( mockObserverAfterConnect ) ; replay . subscribe ( mockObserverAfterConnect ) ; verify ( mockObserverBeforeConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( mockObserverAfterConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 2 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 3 ) ; verify ( sourceCompleted , times ( 1 ) ) . run ( ) ; verify ( mockScheduler , times ( 1 ) ) . createWorker ( ) ; verify ( spiedWorker , times ( 1 ) ) . schedule ( ( Runnable ) notNull ( ) ) ; verifyObserverMock ( mockObserverBeforeConnect , 2 , 6 ) ; verifyObserverMock ( mockObserverAfterConnect , 2 , 6 ) ; verify ( spiedWorker , times ( 1 ) ) . dispose ( ) ; verify ( sourceUnsubscribed , never ( ) ) . run ( ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( spiedWorker ) ; verifyNoMoreInteractions ( mockSubscription ) ; verifyNoMoreInteractions ( mockScheduler ) ; verifyNoMoreInteractions ( mockObserverBeforeConnect ) ; verifyNoMoreInteractions ( mockObserverAfterConnect ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Consumer < Throwable > sourceError = mock ( Consumer . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; final Scheduler mockScheduler = mock ( Scheduler . class ) ; final Disposable mockSubscription = mock ( Disposable . class ) ; Worker spiedWorker = workerSpy ( mockSubscription ) ; Subscriber < Integer > mockObserverBeforeConnect = TestHelper . mockSubscriber ( ) ; Subscriber < Integer > mockObserverAfterConnect = TestHelper . mockSubscriber ( ) ; when ( mockScheduler . createWorker ( ) ) . thenReturn ( spiedWorker ) ; Function < Integer , Integer > mockFunc = mock ( Function . class ) ; IllegalArgumentException illegalArgumentException = new IllegalArgumentException ( ) ; when ( mockFunc . apply ( 1 ) ) . thenReturn ( 1 ) ; when ( mockFunc . apply ( 2 ) ) . thenThrow ( illegalArgumentException ) ; ConnectableFlowable < Integer > replay = Flowable . just ( 1 , 2 , 3 ) . map ( mockFunc ) . doOnNext ( sourceNext ) . doOnCancel ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . doOnError ( sourceError ) . subscribeOn ( mockScheduler ) . replay ( ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( mockObserverAfterConnect ) ; replay . subscribe ( mockObserverAfterConnect ) ; verify ( mockObserverBeforeConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( mockObserverAfterConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( mockScheduler , times ( 1 ) ) . createWorker ( ) ; verify ( spiedWorker , times ( 1 ) ) . schedule ( ( Runnable ) notNull ( ) ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceError , times ( 1 ) ) . accept ( illegalArgumentException ) ; verifyObserver ( mockObserverBeforeConnect , 2 , 2 , illegalArgumentException ) ; verifyObserver ( mockObserverAfterConnect , 2 , 2 , illegalArgumentException ) ; verify ( spiedWorker , times ( 1 ) ) . dispose ( ) ; verify ( sourceUnsubscribed , never ( ) ) . run ( ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceError ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( spiedWorker ) ; verifyNoMoreInteractions ( mockSubscription ) ; verifyNoMoreInteractions ( mockScheduler ) ; verifyNoMoreInteractions ( mockObserverBeforeConnect ) ; verifyNoMoreInteractions ( mockObserverAfterConnect ) ; 
return spy ( new InprocessWorker ( mockDisposable ) ) ; 
action . run ( ) ; return mockDisposable ; 
unsubscribed = true ; 
return unsubscribed ; 
BoundedReplayBuffer < Integer > buf = new BoundedReplayBuffer < Integer > ( true ) private static final long serialVersionUID = - 9081211580719235896L ; @ Override void truncate ( ) ; buf . addLast ( new Node ( 1 , 0 ) ) ; buf . addLast ( new Node ( 2 , 1 ) ) ; buf . addLast ( new Node ( 3 , 2 ) ) ; buf . addLast ( new Node ( 4 , 3 ) ) ; buf . addLast ( new Node ( 5 , 4 ) ) ; List < Integer > values = new ArrayList < > ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , values ) ; buf . removeSome ( 2 ) ; buf . removeFirst ( ) ; buf . removeSome ( 2 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; buf . addLast ( new Node ( 5 , 5 ) ) ; buf . addLast ( new Node ( 6 , 6 ) ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 , 6 ) , values ) ; 
TestScheduler test = new TestScheduler ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = new SizeAndTimeBoundReplayBuffer < > ( 2 , 2000 , TimeUnit . MILLISECONDS , test , true ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . next ( 2 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . complete ( ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; Assert . assertEquals ( 1 , buf . size ) ; Assert . assertTrue ( buf . hasCompleted ( ) ) ; 
final AtomicLong requested = new AtomicLong ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 1000 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long t ) requested . addAndGet ( t ) ; ) ; ConnectableFlowable < Integer > cf = source . replay ( ) ; TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( 10L ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( 90L ) ; cf . subscribe ( ts1 ) ; cf . subscribe ( ts2 ) ; ts2 . request ( 10 ) ; cf . connect ( ) ; ts1 . assertValueCount ( 10 ) ; ts1 . assertNotTerminated ( ) ; ts2 . assertValueCount ( 100 ) ; ts2 . assertNotTerminated ( ) ; Assert . assertEquals ( 100 , requested . get ( ) ) ; 
final AtomicLong requested = new AtomicLong ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 1000 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long t ) requested . addAndGet ( t ) ; ) ; ConnectableFlowable < Integer > cf = source . replay ( 50 , true ) ; TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( 10L ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( 90L ) ; cf . subscribe ( ts1 ) ; cf . subscribe ( ts2 ) ; ts2 . request ( 10 ) ; cf . connect ( ) ; ts1 . assertValueCount ( 10 ) ; ts1 . assertNotTerminated ( ) ; ts2 . assertValueCount ( 100 ) ; ts2 . assertNotTerminated ( ) ; Assert . assertEquals ( 100 , requested . get ( ) ) ; 
Flowable < Integer > source = Flowable . range ( 0 , 1000 ) . replay ( ) . autoConnect ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 1000 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; 
Flowable < Integer > source = Flowable . range ( 0 , 1000 ) . replay ( ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 10 ) ; source . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 10 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; ts . cancel ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < String > f = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; System . out . println ( "published observable being executed" ) ; subscriber . onNext ( "one" ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) . replay ( ) . autoConnect ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
Action unsubscribe = mock ( Action . class ) ; Flowable < Integer > f = Flowable . just ( 1 ) . doOnCancel ( unsubscribe ) . replay ( ) . autoConnect ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; verify ( unsubscribe , never ( ) ) . run ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable < Integer > cached = Flowable . range ( 1 , 100 ) . replay ( ) . autoConnect ( ) ; cached . take ( 10 ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 10000 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; Flowable < Integer > cached = source . replay ( ) . autoConnect ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts1 ) ; ts1 . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts1 . assertNoErrors ( ) ; ts1 . assertTerminated ( ) ; assertEquals ( 10000 , ts1 . values ( ) . size ( ) ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts2 ) ; ts2 . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts2 . assertNoErrors ( ) ; ts2 . assertTerminated ( ) ; assertEquals ( 10000 , ts2 . values ( ) . size ( ) ) ; 
Flowable < Long > source = Flowable . interval ( 1 , 1 , TimeUnit . MILLISECONDS ) . take ( 1000 ) . subscribeOn ( Schedulers . io ( ) ) ; Flowable < Long > cached = source . replay ( ) . autoConnect ( ) ; Flowable < Long > output = cached . observeOn ( Schedulers . computation ( ) , false , 1024 ) ; List < TestSubscriberEx < Long > > list = new ArrayList < > ( 100 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestSubscriberEx < Long > ts = new TestSubscriberEx < > ( ) ; list . add ( ts ) ; output . skip ( i * 10 ) . take ( 10 ) . subscribe ( ts ) ; List < Long > expected = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) expected . add ( ( long ) ( i - 10 ) ) ; int j = 0 ; for ( TestSubscriberEx < Long > ts : list ) ts . awaitDone ( 3 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; for ( int i = j * 10 ; i < j * 10 + 10 ; i ++ ) expected . set ( i - j * 10 , ( long ) i ) ; ts . assertValueSequence ( expected ) ; j ++ ; 
final int m = 4 * 1000 * 1000 ; Flowable < Integer > firehose = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > t ) t . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) t . onNext ( i ) ; t . onComplete ( ) ; ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; firehose . replay ( ) . autoConnect ( ) . observeOn ( Schedulers . computation ( ) ) . takeLast ( 100 ) . subscribe ( ts ) ; ts . awaitDone ( 3 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; assertEquals ( 100 , ts . values ( ) . size ( ) ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . replay ( ) . autoConnect ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts . assertNotComplete ( ) ; Assert . assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ) ; source . subscribe ( ts2 ) ; ts2 . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts2 . assertNotComplete ( ) ; Assert . assertEquals ( 1 , ts2 . errors ( ) . size ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 100 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . replay ( ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) throw new TestException ( ) ; ; source . subscribe ( ts ) ; Assert . assertEquals ( 100 , count . get ( ) ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final List < Long > requests = new ArrayList < > ( ) ; Flowable < Integer > out = source . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long t ) requests . add ( t ) ; ) . replay ( ) . autoConnect ( ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < > ( 5L ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 10L ) ; out . subscribe ( ts1 ) ; out . subscribe ( ts2 ) ; ts2 . cancel ( ) ; Assert . assertEquals ( Arrays . asList ( 5L , 5L ) , requests ) ; 
ConnectableFlowable < Integer > source = Flowable . range ( 1 , 10 ) . replay ( 1 , true ) ; source . connect ( ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < > ( 2L ) ; source . subscribe ( ts1 ) ; ts1 . assertValues ( 1 , 2 ) ; ts1 . assertNoErrors ( ) ; ts1 . cancel ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 2L ) ; source . subscribe ( ts2 ) ; ts2 . assertValues ( 2 , 3 ) ; ts2 . assertNoErrors ( ) ; ts2 . cancel ( ) ; TestSubscriber < Integer > ts21 = new TestSubscriber < > ( 1L ) ; source . subscribe ( ts21 ) ; ts21 . assertValues ( 3 ) ; ts21 . assertNoErrors ( ) ; ts21 . cancel ( ) ; TestSubscriber < Integer > ts22 = new TestSubscriber < > ( 1L ) ; source . subscribe ( ts22 ) ; ts22 . assertValues ( 3 ) ; ts22 . assertNoErrors ( ) ; ts22 . cancel ( ) ; TestSubscriber < Integer > ts3 = new TestSubscriber < > ( ) ; source . subscribe ( ts3 ) ; ts3 . assertNoErrors ( ) ; System . out . println ( ts3 . values ( ) ) ; ts3 . assertValues ( 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts3 . assertComplete ( ) ; 
ConnectableFlowable < Integer > source = Flowable . range ( 1 , 10 ) . replay ( 2 , true ) ; source . connect ( ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < > ( 2L ) ; source . subscribe ( ts1 ) ; ts1 . assertValues ( 1 , 2 ) ; ts1 . assertNoErrors ( ) ; ts1 . cancel ( ) ; TestSubscriber < Integer > ts11 = new TestSubscriber < > ( 2L ) ; source . subscribe ( ts11 ) ; ts11 . assertValues ( 1 , 2 ) ; ts11 . assertNoErrors ( ) ; ts11 . cancel ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 3L ) ; source . subscribe ( ts2 ) ; ts2 . assertValues ( 1 , 2 , 3 ) ; ts2 . assertNoErrors ( ) ; ts2 . cancel ( ) ; TestSubscriber < Integer > ts21 = new TestSubscriber < > ( 1L ) ; source . subscribe ( ts21 ) ; ts21 . assertValues ( 2 ) ; ts21 . assertNoErrors ( ) ; ts21 . cancel ( ) ; TestSubscriber < Integer > ts22 = new TestSubscriber < > ( 1L ) ; source . subscribe ( ts22 ) ; ts22 . assertValues ( 2 ) ; ts22 . assertNoErrors ( ) ; ts22 . cancel ( ) ; TestSubscriber < Integer > ts3 = new TestSubscriber < > ( ) ; source . subscribe ( ts3 ) ; ts3 . assertNoErrors ( ) ; System . out . println ( ts3 . values ( ) ) ; ts3 . assertValues ( 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts3 . assertComplete ( ) ; 
Flowable . just ( 1 ) . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) , true ) . autoConnect ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . replay ( 1 , 1 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . autoConnect ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . replay ( Functions . < Flowable < Integer > > identity ( ) , 1 , TimeUnit . MINUTES , Schedulers . computation ( ) , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 3 ) ; assertSame ( source , ( ( ( HasUpstreamPublisher < ? > ) source . replay ( ) ) ) . source ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 3 ) . replay ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cf . connect ( ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 3 ) . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 3 ) . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; cf . subscribe ( ts1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
Flowable . range ( 1 , 2 ) . replay ( Integer . MAX_VALUE , true ) . autoConnect ( ) . test ( Long . MAX_VALUE , true ) . assertEmpty ( ) ; 
ConnectableFlowable < Integer > cf = PublishProcessor . < Integer > create ( ) . replay ( Integer . MAX_VALUE , true ) ; cf . test ( ) ; cf . autoConnect ( ) . test ( Long . MAX_VALUE , true ) . assertEmpty ( ) ; 
ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 2 ) . replay ( ) ; try cf . connect ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable t ) throws Exception throw new TestException ( ) ; ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) cf . test ( ) . assertEmpty ( ) . cancel ( ) ; cf . connect ( ) ; cf . test ( ) . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( "Second" ) ) ; subscriber . onComplete ( ) ; . replay ( ) . autoConnect ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final ConnectableFlowable < Integer > cf = pp . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) pp . onNext ( j ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final ConnectableFlowable < Integer > cf = pp . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; cf . subscribe ( ts1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) pp . onNext ( j ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 1000 ) . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; cf . connect ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; super . onNext ( t ) ; ; pp . replay ( ) . autoConnect ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; super . onNext ( t ) ; ; pp . replay ( 10 , true ) . autoConnect ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) pp . onNext ( 2 ) ; cancel ( ) ; super . onNext ( t ) ; ; pp . replay ( ) . autoConnect ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValues ( 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) pp . onNext ( 2 ) ; cancel ( ) ; super . onNext ( t ) ; ; pp . replay ( 10 , true ) . autoConnect ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValues ( 1 ) ; 
Flowable . range ( 1 , 2 ) . replay ( Integer . MAX_VALUE , true ) . autoConnect ( ) . test ( ) . assertResult ( 1 , 2 ) ; 
TestScheduler test = new TestScheduler ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = new SizeAndTimeBoundReplayBuffer < > ( 2 , 2000 , TimeUnit . MILLISECONDS , test , true ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . next ( 2 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . error ( new TestException ( ) ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; Assert . assertEquals ( 1 , buf . size ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertTrue ( buf . hasError ( ) ) ; 
SizeBoundReplayBuffer < Integer > buf = new SizeBoundReplayBuffer < > ( 2 , true ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; buf . next ( 2 ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 4 , 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; buf . complete ( ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 4 , 5 ) , values ) ; Assert . assertEquals ( 3 , buf . size ) ; Assert . assertTrue ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; 
final Subscriber < ? > [ ] sub = null ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) sub [ 0 ] = s ; . replay ( ) . connect ( ) . dispose ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; sub [ 0 ] . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . replay ( 2 , TimeUnit . SECONDS , scheduler , true ) . autoConnect ( ) ; source . test ( ) . assertResult ( 1 ) ; source . test ( ) . assertResult ( 1 ) ; scheduler . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; source . test ( ) . assertResult ( ) ; 
FlowableReplay . multicastSelector ( new Supplier < ConnectableFlowable < Object > > ( ) @ Override public ConnectableFlowable < Object > get ( ) throws Exception throw new TestException ( ) ; , Functions . < Flowable < Object > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . replay ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , true ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , true ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , true ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; assertNull ( buf . get ( ) . value ) ; buf . trimHead ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) , true ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) , true ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , TimeUnit . MILLISECONDS , sch , true ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; sch . advanceTimeBy ( 2 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; assertNull ( buf . get ( ) . value ) ; buf . trimHead ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
FlowableReplay . create ( Flowable . just ( 1 ) , new Supplier < ReplayBuffer < Integer > > ( ) @ Override public ReplayBuffer < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . connect ( ) ; 
FlowableReplay . create ( Flowable . just ( 1 ) , new Supplier < ReplayBuffer < Integer > > ( ) @ Override public ReplayBuffer < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable < byte [ ] > source = Flowable . range ( 1 , 200 ) . map ( new Function < Integer , byte [ ] > ( ) @ Override public byte [ ] apply ( Integer v ) throws Exception return new byte [ 1024 * 1024 ] ; ) . replay ( new Function < Flowable < byte [ ] > , Publisher < byte [ ] > > ( ) @ Override public Publisher < byte [ ] > apply ( final Flowable < byte [ ] > f ) throws Exception return f . take ( 1 ) . concatMap ( new Function < byte [ ] , Publisher < byte [ ] > > ( ) @ Override public Publisher < byte [ ] > apply ( byte [ ] v ) throws Exception return f ; ) ; , 1 , true ) . takeLast ( 1 ) ; System . out . println ( "Bounded Replay Leak check: Wait before GC" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check: GC" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long initial = memHeap . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; final AtomicLong after = new AtomicLong ( ) ; source . subscribe ( new Consumer < byte [ ] > ( ) @ Override public void accept ( byte [ ] v ) throws Exception System . out . println ( "Bounded Replay Leak check: Wait before GC 2" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check:  GC 2" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; after . set ( memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ) ; ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after . get ( ) / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after . get ( ) ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after . get ( ) / 1024.0 / 1024.0 ) ; 
PublishProcessor < int [ ] > pp = PublishProcessor . create ( ) ; ConnectableFlowable < int [ ] > cf = pp . replay ( 1 , true ) ; TestSubscriber < int [ ] > ts = cf . test ( ) ; cf . connect ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; pp . onNext ( new int [ 100 * 1024 * 1024 ] ) ; ts . assertValueCount ( 1 ) ; ts . values ( ) . clear ( ) ; pp . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; ts . cancel ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishProcessor < int [ ] > pp = PublishProcessor . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; ConnectableFlowable < int [ ] > cf = pp . replay ( 1 , TimeUnit . SECONDS , scheduler , true ) ; TestSubscriber < int [ ] > ts = cf . test ( ) ; cf . connect ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; pp . onNext ( new int [ 100 * 1024 * 1024 ] ) ; ts . assertValueCount ( 1 ) ; ts . values ( ) . clear ( ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; pp . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; ts . cancel ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishProcessor < int [ ] > pp = PublishProcessor . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; ConnectableFlowable < int [ ] > cf = pp . replay ( 1 , 5 , TimeUnit . SECONDS , scheduler , true ) ; TestSubscriber < int [ ] > ts = cf . test ( ) ; cf . connect ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; pp . onNext ( new int [ 100 * 1024 * 1024 ] ) ; ts . assertValueCount ( 1 ) ; ts . values ( ) . clear ( ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; pp . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; ts . cancel ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishProcessor < int [ ] > pp = PublishProcessor . create ( ) ; Flowable < int [ ] > cf = pp . replay ( Functions . < Flowable < int [ ] > > identity ( ) , 1 , true ) ; TestSubscriber < int [ ] > ts = cf . test ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; pp . onNext ( new int [ 100 * 1024 * 1024 ] ) ; ts . assertValueCount ( 1 ) ; ts . values ( ) . clear ( ) ; pp . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; ts . cancel ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishProcessor < int [ ] > pp = PublishProcessor . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; Flowable < int [ ] > cf = pp . replay ( Functions . < Flowable < int [ ] > > identity ( ) , 1 , TimeUnit . SECONDS , scheduler , true ) ; TestSubscriber < int [ ] > ts = cf . test ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; pp . onNext ( new int [ 100 * 1024 * 1024 ] ) ; ts . assertValueCount ( 1 ) ; ts . values ( ) . clear ( ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; pp . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; ts . cancel ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishProcessor < int [ ] > pp = PublishProcessor . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; Flowable < int [ ] > cf = pp . replay ( Functions . < Flowable < int [ ] > > identity ( ) , 1 , 5 , TimeUnit . SECONDS , scheduler , true ) ; TestSubscriber < int [ ] > ts = cf . test ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; pp . onNext ( new int [ 100 * 1024 * 1024 ] ) ; ts . assertValueCount ( 1 ) ; ts . values ( ) . clear ( ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; pp . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; ts . cancel ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
Flowable . just ( 1 ) . replay ( 1 , 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , true ) . autoConnect ( ) . test ( ) . assertComplete ( ) . assertNoErrors ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . replay ( 10 , true ) ; TestSubscriber < Integer > ts = cf . test ( ) ; Disposable d = cf . connect ( ) ; pp . onNext ( 1 ) ; d . dispose ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . replay ( 10 , TimeUnit . MINUTES , Schedulers . single ( ) , true ) ; TestSubscriber < Integer > ts = cf . test ( ) ; Disposable d = cf . connect ( ) ; pp . onNext ( 1 ) ; d . dispose ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . replay ( 10 , 10 , TimeUnit . MINUTES , Schedulers . single ( ) , true ) ; TestSubscriber < Integer > ts = cf . test ( ) ; Disposable d = cf . connect ( ) ; pp . onNext ( 1 ) ; d . dispose ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 2 ) ; 
final AtomicBoolean subscribed = new AtomicBoolean ( false ) ; final Flowable < Integer > flowable = Flowable . just ( 4 ) . switchIfEmpty ( Flowable . just ( 2 ) . doOnSubscribe ( new Consumer < Subscription > ( ) @ Override public void accept ( Subscription s ) subscribed . set ( true ) ; ) ) ; assertEquals ( 4 , flowable . blockingSingle ( ) . intValue ( ) ) ; assertFalse ( subscribed . get ( ) ) ; 
final Flowable < Integer > flowable = Flowable . < Integer > empty ( ) . switchIfEmpty ( Flowable . fromIterable ( Arrays . asList ( 42 ) ) ) ; assertEquals ( 42 , flowable . blockingSingle ( ) . intValue ( ) ) ; 
final AtomicBoolean emitted = new AtomicBoolean ( false ) ; Flowable < Long > withProducer = Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( final Subscriber < ? super Long > subscriber ) subscriber . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) if ( n > 0 && emitted . compareAndSet ( false , true ) ) emitted . set ( true ) ; subscriber . onNext ( 42L ) ; subscriber . onComplete ( ) ; @ Override public void cancel ( ) ) ; ) ; final Flowable < Long > flowable = Flowable . < Long > empty ( ) . switchIfEmpty ( withProducer ) ; assertEquals ( 42 , flowable . blockingSingle ( ) . intValue ( ) ) ; 
final BooleanSubscription bs = new BooleanSubscription ( ) ; Flowable < Long > withProducer = Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( final Subscriber < ? super Long > subscriber ) subscriber . onSubscribe ( bs ) ; subscriber . onNext ( 42L ) ; ) ; Flowable . < Long > empty ( ) . switchIfEmpty ( withProducer ) . lift ( new FlowableOperator < Long , Long > ( ) @ Override public Subscriber < ? super Long > apply ( final Subscriber < ? super Long > child ) return new DefaultSubscriber < Long > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long aLong ) cancel ( ) ; ; ) . subscribe ( ) ; assertTrue ( bs . isCancelled ( ) ) ; 
final BooleanSubscription bs = new BooleanSubscription ( ) ; Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( final Subscriber < ? super Long > subscriber ) subscriber . onSubscribe ( bs ) ; subscriber . onComplete ( ) ; ) . switchIfEmpty ( Flowable . < Long > never ( ) ) . subscribe ( ) ; assertFalse ( bs . isCancelled ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 1L ) ; Flowable . < Integer > empty ( ) . switchIfEmpty ( Flowable . just ( 1 , 2 , 3 ) ) . subscribe ( ts ) ; assertEquals ( Arrays . asList ( 1 ) , ts . values ( ) ) ; ts . assertNoErrors ( ) ; ts . request ( 1 ) ; ts . assertValueCount ( 2 ) ; ts . request ( 1 ) ; ts . assertValueCount ( 3 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Flowable . < Integer > empty ( ) . switchIfEmpty ( Flowable . just ( 1 , 2 , 3 ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Flowable . just ( 1 , 2 , 3 ) . switchIfEmpty ( Flowable . just ( 4 , 5 , 6 ) ) . subscribe ( ts ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; 
final TestSubscriber < Long > ts = new TestSubscriber < > ( 0L ) ; Flowable . unsafeCreate ( new Publisher < Long > ( ) @ Override public void subscribe ( final Subscriber < ? super Long > subscriber ) subscriber . onSubscribe ( new Subscription ( ) final AtomicBoolean completed = new AtomicBoolean ( false ) ; @ Override public void request ( long n ) if ( n > 0 && completed . compareAndSet ( false , true ) ) Schedulers . io ( ) . createWorker ( ) . schedule ( new Runnable ( ) @ Override public void run ( ) subscriber . onComplete ( ) ; , 100 , TimeUnit . MILLISECONDS ) ; @ Override public void cancel ( ) ) ; ) . switchIfEmpty ( Flowable . fromIterable ( Arrays . asList ( 1L , 2L , 3L ) ) ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( ts ) ; Thread . sleep ( 50 ) ; ts . request ( 1 ) ; ts . request ( 1 ) ; Thread . sleep ( 500 ) ; ts . assertNotComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 2 ) ; ts . cancel ( ) ; 
Maybe < Integer > last = Flowable . just ( 1 , 2 , 3 ) . lastElement ( ) ; assertEquals ( 3 , last . blockingGet ( ) . intValue ( ) ) ; 
Maybe < ? > last = Flowable . empty ( ) . lastElement ( ) ; assertNull ( last . blockingGet ( ) ) ; 
Maybe < Integer > last = Flowable . just ( 1 , 2 , 3 ) . lastElement ( ) ; assertEquals ( 3 , last . blockingGet ( ) . intValue ( ) ) ; assertEquals ( 3 , last . blockingGet ( ) . intValue ( ) ) ; 
Flowable . just ( 1 , 2 , 3 ) . lastElement ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 , 3 ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 3 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . < Integer > empty ( ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 6 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > maybe = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; maybe . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 , 3 ) . last ( 4 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 3 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 ) . last ( 2 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . < Integer > empty ( ) . last ( 1 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . last ( 8 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 6 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . last ( 4 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > single = Flowable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . last ( 2 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable . empty ( ) . lastOrError ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Flowable . just ( 1 ) . lastOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Flowable . just ( 1 , 2 , 3 ) . lastOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 3 ) ; 
Flowable . error ( new RuntimeException ( "error" ) ) . lastOrError ( ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
TestHelper . checkDisposed ( Flowable . never ( ) . lastElement ( ) . toFlowable ( ) ) ; TestHelper . checkDisposed ( Flowable . never ( ) . lastElement ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . lastOrError ( ) . toFlowable ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . lastOrError ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . last ( 2 ) . toFlowable ( ) ) ; TestHelper . checkDisposed ( Flowable . just ( 1 ) . last ( 2 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToMaybe ( new Function < Flowable < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Flowable < Object > f ) throws Exception return f . lastElement ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . lastElement ( ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Flowable < Object > f ) throws Exception return f . lastOrError ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . lastOrError ( ) . toFlowable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowableToSingle ( new Function < Flowable < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Flowable < Object > f ) throws Exception return f . last ( 2 ) ; ) ; TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . last ( 2 ) . toFlowable ( ) ; ) ; 
Flowable . error ( new TestException ( ) ) . lastElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . error ( new TestException ( ) ) . lastOrError ( ) . toFlowable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . empty ( ) . lastOrError ( ) . toFlowable ( ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
concat2Strings = new BiFunction < String , String , String > ( ) @ Override public String apply ( String t1 , String t2 ) return t1 + "-" + t2 ; ; s1 = PublishProcessor . create ( ) ; s2 = PublishProcessor . create ( ) ; zipped = Flowable . zip ( s1 , s2 , concat2Strings ) ; subscriber = TestHelper . mockSubscriber ( ) ; inOrder = inOrder ( subscriber ) ; zipped . subscribe ( subscriber ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s1 . onComplete ( ) ; s2 . onNext ( "1" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a-1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b-2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; s1 . onNext ( "a" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a-1" ) ; s1 . onNext ( "b" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b-2" ) ; s1 . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; s2 . onComplete ( ) ; s1 . onNext ( "a" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a-1" ) ; s1 . onNext ( "b" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b-2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s2 . onNext ( "1" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "a-1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onNext ( "b-2" ) ; s2 . onComplete ( ) ; inOrder . verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final AtomicLong counter = new AtomicLong ( ) ; final Integer [ ] numbers = new Integer [ 5000 ] ; for ( int i = 0 ; i < numbers . length ; i ++ ) numbers [ i ] = i + 1 ; final int NITERS = 250 ; final CountDownLatch latch = new CountDownLatch ( NITERS ) ; for ( int iters = 0 ; iters < NITERS ; iters ++ ) final CountDownLatch innerLatch = new CountDownLatch ( 1 ) ; final PublishProcessor < Void > s = PublishProcessor . create ( ) ; final AtomicBoolean completed = new AtomicBoolean ( ) ; Flowable . fromArray ( numbers ) . takeUntil ( s ) . window ( 50 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Flowable < Integer > integerObservable ) return integerObservable . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer integer ) if ( integer >= 5 && completed . compareAndSet ( false , true ) ) s . onComplete ( ) ; Math . pow ( Math . random ( ) , Math . random ( ) ) ; return integer * 2 ; ) ; ) . toList ( ) . doOnSuccess ( new Consumer < List < Object > > ( ) @ Override public void accept ( List < Object > integers ) counter . incrementAndGet ( ) ; latch . countDown ( ) ; innerLatch . countDown ( ) ; ) . subscribe ( ) ; if ( ! innerLatch . await ( 30 , TimeUnit . SECONDS ) ) Assert . fail ( "Failed inner latch wait, iteration " + iters ) ; if ( ! latch . await ( 30 , TimeUnit . SECONDS ) ) Assert . fail ( "Incomplete! Went through " + latch . getCount ( ) + " iterations" ) ; else Assert . assertEquals ( NITERS , counter . get ( ) ) ; 
Flowable . range ( 1 , 10 ) . onErrorComplete ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . range ( 1 , 10 ) . onErrorComplete ( ) . test ( 0 ) . assertEmpty ( ) . requestMore ( 3 ) . assertValuesOnly ( 1 , 2 , 3 ) . requestMore ( 3 ) . assertValuesOnly ( 1 , 2 , 3 , 4 , 5 , 6 ) . requestMore ( 4 ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable . empty ( ) . onErrorComplete ( ) . test ( ) . assertResult ( ) ; 
TestHelper . withErrorTracking ( errors -> Flowable . error ( new TestException ( ) ) . onErrorComplete ( ) . test ( ) . assertResult ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Flowable . error ( new TestException ( ) ) . onErrorComplete ( error -> error instanceof TestException ) . test ( ) . assertResult ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Flowable . error ( new IOException ( ) ) . onErrorComplete ( error -> error instanceof TestException ) . test ( ) . assertFailure ( IOException . class ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> TestSubscriberEx < Object > ts = Flowable . error ( new IOException ( ) ) . onErrorComplete ( error -> throw new TestException ( ) ; ) . subscribeWith ( new TestSubscriberEx < > ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , IOException . class ) ; TestHelper . assertError ( ts , 1 , TestException . class ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Flowable . range ( 1 , 5 ) . map ( v -> 4 / ( 3 - v ) ) . onErrorComplete ( ) . test ( ) . assertResult ( 2 , 4 ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . onErrorComplete ( ) . test ( ) ; assertTrue ( "No subscribers?!" , pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( "Still subscribers?!" , pp . hasSubscribers ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( f -> f . onErrorComplete ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . take ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( 4 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . take ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onNext ( 4 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > result = source . take ( 1 , TimeUnit . SECONDS , scheduler ) ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; source . onError ( new TestException ( ) ) ; InOrder inOrder = inOrder ( subscriber ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 2 ) ; inOrder . verify ( subscriber ) . onNext ( 3 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber , never ( ) ) . onNext ( 4 ) ; verify ( subscriber , never ( ) ) . onError ( any ( TestException . class ) ) ; 
Flowable . range ( 1 , 5 ) . take ( 1 , TimeUnit . MINUTES ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . fromSingle ( Single . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . fromSingle ( Single . error ( new TestException ( ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestSubscriber < Integer > ts = Flowable . fromSingle ( ms ) . test ( ) ; ts . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; ts . cancel ( ) ; assertFalse ( ms . hasObservers ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . fromSingle ( Single . just ( 1 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; ts . setInitialFusionMode ( QueueFuseable . SYNC ) ; Flowable . fromSingle ( Single . just ( 1 ) ) . subscribe ( ts ) ; ts . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 ) ; 
requests . add ( CANCELLED ) ; 
Flowable . range ( 1 , 5 ) . doOnRequest ( this ) . take ( 6 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 6 , requests . get ( 0 ) . intValue ( ) ) ; 
Flowable . range ( 1 , 5 ) . doOnRequest ( this ) . doOnCancel ( this ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 2 , requests . size ( ) ) ; assertEquals ( 5 , requests . get ( 0 ) . intValue ( ) ) ; assertEquals ( CANCELLED , requests . get ( 1 ) ) ; 
Flowable . range ( 1 , 6 ) . doOnRequest ( this ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , requests . get ( 0 ) . intValue ( ) ) ; 
Flowable . error ( new TestException ( ) ) . take ( 5 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . range ( 1 , 5 ) . doOnCancel ( this ) . doOnRequest ( this ) . take ( 0 ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , requests . size ( ) ) ; assertEquals ( CANCELLED , requests . get ( 0 ) ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 6 ) . doOnRequest ( this ) . take ( 5 ) . test ( 0L ) ; assertEquals ( 0 , requests . size ( ) ) ; ts . request ( 1 ) ; ts . assertValue ( 1 ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . request ( 3 ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( 1L , 2L , 2L ) , requests ) ; 
Flowable . range ( 1 , 5 ) . doOnCancel ( this ) . doOnRequest ( this ) . take ( 6 ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( Arrays . asList ( 5L , CANCELLED ) , requests ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . doOnRequest ( this ) . take ( 5 ) . test ( 0L ) ; ts . request ( 5 ) ; ts . request ( 10 ) ; assertTrue ( pp . offer ( 1 ) ) ; pp . onComplete ( ) ; ts . assertResult ( 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) BooleanSubscription bs = new BooleanSubscription ( ) ; s . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; s . onNext ( 1 ) ; s . onComplete ( ) ; s . onError ( new TestException ( ) ) ; s . onSubscribe ( null ) ; . take ( 0 ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , NullPointerException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . assertBadRequestReported ( Flowable . range ( 1 , 5 ) . take ( 3 ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestSubscriber < Integer > ts = Flowable . range ( 1 , 10 ) . take ( 5 ) . test ( 0L ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) ts . request ( 3 ) ; ; TestHelper . race ( r , r ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . error ( new TestException ( ) ) . take ( 0 ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < Integer > w = Flowable . just ( 1 , 2 , 3 ) ; Flowable < Integer > take = w . takeWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer input ) return input < 3 ; ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; take . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onNext ( 3 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
FlowableProcessor < Integer > s = PublishProcessor . create ( ) ; Flowable < Integer > take = s . takeWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer input ) return input < 3 ; ) ; Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; take . subscribe ( subscriber ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onNext ( 3 ) ; s . onNext ( 4 ) ; s . onNext ( 5 ) ; s . onComplete ( ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , never ( ) ) . onNext ( 3 ) ; verify ( subscriber , never ( ) ) . onNext ( 4 ) ; verify ( subscriber , never ( ) ) . onNext ( 5 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . just ( "one" , "two" , "three" ) ; Flowable < String > take = w . takeWhile ( new Predicate < String > ( ) int index ; @ Override public boolean test ( String input ) return index ++ < 2 ; ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; take . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onError ( new TestException ( "test failed" ) ) ; ) ; source . takeWhile ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return false ; ) . blockingLast ( "" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "test failed" ) ; finally RxJavaPlugins . reset ( ) ; 
subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onNext ( "one" ) ; subscriber . onError ( new TestException ( "test failed" ) ) ; 
TestFlowable source = new TestFlowable ( mock ( Subscription . class ) , "one" ) ; final RuntimeException testException = new RuntimeException ( "test exception" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > take = Flowable . unsafeCreate ( source ) . takeWhile ( new Predicate < String > ( ) @ Override public boolean test ( String s ) throw testException ; ) ; take . subscribe ( subscriber ) ; try source . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , times ( 1 ) ) . onError ( testException ) ; 
Subscription s = mock ( Subscription . class ) ; TestFlowable w = new TestFlowable ( s , "one" , "two" , "three" ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; Flowable < String > take = Flowable . unsafeCreate ( w ) . takeWhile ( new Predicate < String > ( ) int index ; @ Override public boolean test ( String s ) return index ++ < 1 ; ) ; take . subscribe ( subscriber ) ; try w . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; System . out . println ( "TestFlowable thread finished" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onNext ( "two" ) ; verify ( subscriber , never ( ) ) . onNext ( "three" ) ; verify ( s , times ( 1 ) ) . cancel ( ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 1000 ) . takeWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 100 ; ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 5L ) ; source . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; ts . request ( 5 ) ; ts . assertNoErrors ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 1000 ) . takeWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; source . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValue ( 1 ) ; Assert . assertFalse ( "Unsubscribed!" , ts . isCancelled ( ) ) ; 
TestSubscriberEx < String > ts = new TestSubscriberEx < > ( ) ; Flowable . just ( "abc" ) . takeWhile ( new Predicate < String > ( ) @ Override public boolean test ( String t1 ) throw new TestException ( ) ; ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishProcessor . create ( ) . takeWhile ( Functions . alwaysTrue ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . takeWhile ( Functions . alwaysTrue ( ) ) ; ) ; 
new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onComplete ( ) ; subscriber . onComplete ( ) ; . takeWhile ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
final List < String > list = new ArrayList < > ( ) ; final List < List < String > > lists = new ArrayList < > ( ) ; Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , "one" , 10 ) ; push ( subscriber , "two" , 60 ) ; push ( subscriber , "three" , 110 ) ; push ( subscriber , "four" , 160 ) ; push ( subscriber , "five" , 210 ) ; complete ( subscriber , 500 ) ; ) ; Flowable < Object > openings = Flowable . unsafeCreate ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , new Object ( ) , 50 ) ; push ( subscriber , new Object ( ) , 200 ) ; complete ( subscriber , 250 ) ; ) ; Function < Object , Flowable < Object > > closer = new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object opening ) return Flowable . unsafeCreate ( new Publisher < Object > ( ) @ Override public void subscribe ( Subscriber < ? super Object > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; push ( subscriber , new Object ( ) , 100 ) ; complete ( subscriber , 101 ) ; ) ; ; Flowable < Flowable < String > > windowed = source . window ( openings , closer ) ; windowed . subscribe ( observeWindow ( list , lists ) ) ; scheduler . advanceTimeTo ( 500 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , lists . size ( ) ) ; assertEquals ( lists . get ( 0 ) , list ( "two" , "three" ) ) ; assertEquals ( lists . get ( 1 ) , list ( "five" ) ) ; 
return new Consumer < Flowable < String > > ( ) @ Override public void accept ( Flowable < String > stringFlowable ) stringFlowable . subscribe ( new DefaultSubscriber < String > ( ) @ Override public void onComplete ( ) lists . add ( new ArrayList < > ( list ) ) ; list . clear ( ) ; @ Override public void onError ( Throwable e ) fail ( e . getMessage ( ) ) ; @ Override public void onNext ( String args ) list . add ( args ) ; ) ; ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > open = PublishProcessor . create ( ) ; final PublishProcessor < Integer > close = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = new TestSubscriber < > ( ) ; source . window ( open , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return close ; ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . subscribe ( ts ) ; open . onNext ( 1 ) ; source . onNext ( 1 ) ; assertTrue ( open . hasSubscribers ( ) ) ; assertTrue ( close . hasSubscribers ( ) ) ; close . onNext ( 1 ) ; assertFalse ( close . hasSubscribers ( ) ) ; source . onComplete ( ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 1 ) ; assertFalse ( ts . isCancelled ( ) ) ; assertFalse ( open . hasSubscribers ( ) ) ; assertFalse ( close . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > open = PublishProcessor . create ( ) ; final PublishProcessor < Integer > close = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = new TestSubscriber < > ( ) ; source . window ( open , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return close ; ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . subscribe ( ts ) ; open . onNext ( 1 ) ; assertTrue ( open . hasSubscribers ( ) ) ; assertTrue ( close . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( open . hasSubscribers ( ) ) ; assertTrue ( close . hasSubscribers ( ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . window ( Flowable . just ( 2 ) , Functions . justFunction ( Flowable . never ( ) ) ) ) ; 
final FlowableProcessor < Integer > pp = PublishProcessor . < Integer > create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; ; pp . window ( BehaviorProcessor . createDefault ( 1 ) , Functions . justFunction ( Flowable . never ( ) ) ) . flatMap ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > v ) throws Exception return v ; ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > start = PublishProcessor . create ( ) ; final PublishProcessor < Integer > end = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = source . window ( start , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return end ; ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) ; start . onNext ( 0 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; start . onNext ( 1 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; end . onNext ( 1 ) ; start . onNext ( 2 ) ; TestHelper . emit ( source , 7 , 8 ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 , 5 , 6 , 6 , 7 , 8 ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > start = PublishProcessor . create ( ) ; final PublishProcessor < Integer > end = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = source . window ( start , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return end ; ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) ; start . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( "Source has observers!" , source . hasSubscribers ( ) ) ; assertFalse ( "Start has observers!" , start . hasSubscribers ( ) ) ; assertFalse ( "End has observers!" , end . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > start = PublishProcessor . create ( ) ; final PublishProcessor < Integer > end = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = source . window ( start , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return end ; ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) ; start . onNext ( 1 ) ; end . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( "Source has observers!" , source . hasSubscribers ( ) ) ; assertFalse ( "Start has observers!" , start . hasSubscribers ( ) ) ; assertFalse ( "End has observers!" , end . hasSubscribers ( ) ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . window ( Flowable . never ( ) , Functions . justFunction ( Flowable . just ( 1 ) ) ) . flatMap ( Functions . < Flowable < Integer > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try BehaviorProcessor . createDefault ( 1 ) . window ( BehaviorProcessor . createDefault ( 1 ) , new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer f ) throws Exception return new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new TestException ( ) ) ; ; ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . test ( ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
return Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) . doOnCancel ( new Action ( ) @ Override public void run ( ) throws Exception ref . set ( true ) ; ) ; 
AtomicBoolean mainDisposed = new AtomicBoolean ( ) ; AtomicBoolean openDisposed = new AtomicBoolean ( ) ; final AtomicBoolean closeDisposed = new AtomicBoolean ( ) ; flowableDisposed ( mainDisposed ) . window ( flowableDisposed ( openDisposed ) , new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return flowableDisposed ( closeDisposed ) ; ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > w ) throws Throwable w . subscribe ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) ) ; ) . to ( TestHelper . < Flowable < Integer > > testConsumer ( ) ) . assertSubscribed ( ) . assertNoErrors ( ) . assertNotComplete ( ) . cancel ( ) ; assertTrue ( mainDisposed . get ( ) ) ; assertTrue ( openDisposed . get ( ) ) ; assertTrue ( closeDisposed . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = source . window ( boundary , Functions . justFunction ( Flowable . never ( ) ) ) . test ( 0L ) ; ts . assertEmpty ( ) ; boundary . onNext ( 1 ) ; ts . assertFailure ( MissingBackpressureException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( boundary . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = pp . window ( Flowable . just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) ) . take ( 1 ) . flatMap ( new Function < Flowable < Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Flowable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final AtomicReference < Flowable < Integer > > inner = new AtomicReference < > ( ) ; TestSubscriber < Flowable < Integer > > ts = pp . window ( Flowable . < Integer > just ( 1 ) . concatWith ( Flowable . < Integer > never ( ) ) , Functions . justFunction ( Flowable . never ( ) ) ) . doOnNext ( new Consumer < Flowable < Integer > > ( ) @ Override public void accept ( Flowable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . assertValueCount ( 1 ) ; pp . onNext ( 1 ) ; assertTrue ( pp . hasSubscribers ( ) ) ; ts . cancel ( ) ; ts . assertValueCount ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; assertFalse ( "Processor still has subscribers!" , pp . hasSubscribers ( ) ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; PublishProcessor < Integer > boundary = PublishProcessor . create ( ) ; TestSubscriber < Flowable < Integer > > ts = source . window ( boundary , new Function < Integer , Publisher < Object > > ( ) @ Override public Publisher < Object > apply ( Integer end ) throws Throwable throw new TestException ( ) ; ) . test ( ) ; ts . assertEmpty ( ) ; boundary . onNext ( 1 ) ; ts . assertFailure ( TestException . class ) ; assertFalse ( source . hasSubscribers ( ) ) ; assertFalse ( boundary . hasSubscribers ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( o -> o . window ( Flowable . never ( ) , v -> Flowable . never ( ) ) ) ; 
TestHelper . withErrorTracking ( errors -> TestException ex1 = new TestException ( ) ; TestException ex2 = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) AtomicReference < Subscriber < ? super Integer > > ref1 = new AtomicReference < > ( ) ; AtomicReference < Subscriber < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Flowable < Integer > f1 = Flowable . < Integer > fromPublisher ( ref1 :: set ) ; Flowable < Integer > f2 = Flowable . < Integer > fromPublisher ( ref2 :: set ) ; TestSubscriber < Flowable < Integer > > ts = BehaviorProcessor . createDefault ( 1 ) . window ( f1 , v -> f2 ) . doOnNext ( w -> w . test ( ) ) . test ( ) ; ref1 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref2 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; TestHelper . race ( ( ) -> ref1 . get ( ) . onError ( ex1 ) , ( ) -> ref2 . get ( ) . onError ( ex2 ) ) ; ts . assertError ( RuntimeException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; errors . clear ( ) ; ) ; 
TestHelper . withErrorTracking ( errors -> AtomicReference < Subscriber < ? super Integer > > ref1 = new AtomicReference < > ( ) ; AtomicReference < Subscriber < ? super Integer > > ref2 = new AtomicReference < > ( ) ; Flowable < Integer > f1 = Flowable . < Integer > unsafeCreate ( ref1 :: set ) ; Flowable < Integer > f2 = Flowable . < Integer > unsafeCreate ( ref2 :: set ) ; TestSubscriber < Integer > ts = BehaviorProcessor . createDefault ( 1 ) . window ( f1 , v -> f2 ) . flatMap ( v -> v ) . test ( ) ; ref1 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref2 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; ref2 . get ( ) . onError ( new TestException ( ) ) ; ref2 . get ( ) . onError ( new TestException ( ) ) ; ts . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
Flowable . error ( new TestException ( ) ) . window ( Flowable . never ( ) , v -> Flowable . never ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
AtomicReference < Subscriber < ? super Integer > > ref1 = new AtomicReference < > ( ) ; PublishProcessor < Object > pp = PublishProcessor . create ( ) ; Flowable < Integer > f1 = Flowable . < Integer > unsafeCreate ( ref1 :: set ) ; AtomicInteger counter = new AtomicInteger ( ) ; TestSubscriber < Flowable < Object > > ts = pp . window ( f1 , v -> Flowable . never ( ) ) . doOnNext ( w -> if ( counter . getAndIncrement ( ) == 0 ) ref1 . get ( ) . onNext ( 2 ) ; pp . onNext ( 1 ) ; pp . onComplete ( ) ; w . test ( ) ; ) . test ( ) ; ref1 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ts . assertComplete ( ) ; 
AtomicReference < Subscriber < ? super Integer > > ref1 = new AtomicReference < > ( ) ; PublishProcessor < Object > pp = PublishProcessor . create ( ) ; Flowable < Integer > f1 = Flowable . < Integer > unsafeCreate ( ref1 :: set ) ; AtomicInteger counter = new AtomicInteger ( ) ; TestSubscriber < Flowable < Object > > ts = pp . window ( f1 , v -> Flowable . never ( ) ) . doOnNext ( w -> if ( counter . getAndIncrement ( ) == 0 ) ref1 . get ( ) . onNext ( 2 ) ; pp . onNext ( 1 ) ; pp . onError ( new TestException ( ) ) ; w . test ( ) ; ) . test ( ) ; ref1 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ts . assertError ( TestException . class ) ; 
AtomicReference < Subscriber < ? super Integer > > ref1 = new AtomicReference < > ( ) ; PublishProcessor < Object > pp = PublishProcessor . create ( ) ; Flowable < Integer > f1 = Flowable . < Integer > unsafeCreate ( ref1 :: set ) ; TestSubscriber < Flowable < Object > > ts = pp . window ( f1 , v -> Flowable . never ( ) ) . take ( 1 ) . doOnNext ( w -> w . test ( ) ; ) . test ( ) ; ref1 . get ( ) . onSubscribe ( new BooleanSubscription ( ) ) ; ref1 . get ( ) . onNext ( 1 ) ; ref1 . get ( ) . onNext ( 2 ) ; ts . assertValueCount ( 1 ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . window ( Flowable . never ( ) , v -> Flowable . never ( ) ) ) ; 
TestHelper . withErrorTracking ( errors -> Flowable . fromPublisher ( s -> s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new IOException ( ) ) ; ) . window ( BehaviorProcessor . createDefault ( 1 ) , v -> Flowable . error ( new TestException ( ) ) ) . doOnNext ( w -> w . test ( ) ) . test ( ) . assertError ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; ) ; 
Object n = NotificationLite . next ( "Hello" ) ; Object c = NotificationLite . complete ( ) ; assertTrue ( NotificationLite . isComplete ( c ) ) ; assertFalse ( NotificationLite . isComplete ( n ) ) ; assertEquals ( "Hello" , NotificationLite . getValue ( n ) ) ; 
assertSame ( 1 , NotificationLite . next ( 1 ) ) ; 
TestHelper . checkEnum ( NotificationLite . class ) ; 
Object o = NotificationLite . error ( new TestException ( ) ) ; assertEquals ( "NotificationLite.Error[io.reactivex.rxjava3.exceptions.TestException]" , o . toString ( ) ) ; assertTrue ( NotificationLite . isError ( o ) ) ; assertFalse ( NotificationLite . isComplete ( o ) ) ; assertFalse ( NotificationLite . isDisposable ( o ) ) ; assertFalse ( NotificationLite . isSubscription ( o ) ) ; assertTrue ( NotificationLite . getError ( o ) instanceof TestException ) ; 
Object o = NotificationLite . complete ( ) ; Object o2 = NotificationLite . complete ( ) ; assertSame ( o , o2 ) ; assertFalse ( NotificationLite . isError ( o ) ) ; assertTrue ( NotificationLite . isComplete ( o ) ) ; assertFalse ( NotificationLite . isDisposable ( o ) ) ; assertFalse ( NotificationLite . isSubscription ( o ) ) ; assertEquals ( "NotificationLite.Complete" , o . toString ( ) ) ; assertTrue ( NotificationLite . isComplete ( o ) ) ; 
Object o = NotificationLite . disposable ( Disposable . empty ( ) ) ; assertEquals ( "NotificationLite.Disposable[RunnableDisposable(disposed=false, EmptyRunnable)]" , o . toString ( ) ) ; assertFalse ( NotificationLite . isError ( o ) ) ; assertFalse ( NotificationLite . isComplete ( o ) ) ; assertTrue ( NotificationLite . isDisposable ( o ) ) ; assertFalse ( NotificationLite . isSubscription ( o ) ) ; assertNotNull ( NotificationLite . getDisposable ( o ) ) ; 
Object o = NotificationLite . subscription ( new BooleanSubscription ( ) ) ; assertEquals ( "NotificationLite.Subscription[BooleanSubscription(cancelled=false)]" , o . toString ( ) ) ; assertFalse ( NotificationLite . isError ( o ) ) ; assertFalse ( NotificationLite . isComplete ( o ) ) ; assertFalse ( NotificationLite . isDisposable ( o ) ) ; assertTrue ( NotificationLite . isSubscription ( o ) ) ; assertNotNull ( NotificationLite . getSubscription ( o ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 3 ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 3 , 100 , TimeUnit . MILLISECONDS , scheduler ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Flowable < Integer > , Flowable < Integer > > selector = new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > t1 ) return t1 . map ( dbl ) ; ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > co = source . replay ( selector ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 8 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Flowable < Integer > , Flowable < Integer > > selector = new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > t1 ) return t1 . map ( dbl ) ; ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > co = source . replay ( selector , 3 ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 8 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Flowable < Integer > , Flowable < Integer > > selector = new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > t1 ) return t1 . map ( dbl ) ; ; TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > co = source . replay ( selector , 100 , TimeUnit . MILLISECONDS , scheduler ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 6 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; co . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 3 ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onComplete ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = source . replay ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; cf . connect ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onComplete ( ) ; Subscriber < Object > subscriber1 = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber1 ) ; cf . subscribe ( subscriber1 ) ; inOrder . verify ( subscriber1 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( subscriber1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( subscriber1 , never ( ) ) . onComplete ( ) ; 
final AtomicInteger effectCounter = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 , 2 , 3 , 4 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) effectCounter . incrementAndGet ( ) ; System . out . println ( "Sideeffect #" + v ) ; ) ; Flowable < Integer > result = source . replay ( new Function < Flowable < Integer > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > f ) return f . take ( 2 ) ; ) ; for ( int i = 1 ; i < 3 ; i ++ ) effectCounter . set ( 0 ) ; System . out . printf ( "- %d -%n" , i ) ; result . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) System . out . println ( t1 ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) t1 . printStackTrace ( ) ; , new Action ( ) @ Override public void run ( ) System . out . println ( "Done" ) ; ) ; assertEquals ( 2 , effectCounter . get ( ) ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; Subscriber < Integer > spiedSubscriberBeforeConnect = TestHelper . mockSubscriber ( ) ; Subscriber < Integer > spiedSubscriberAfterConnect = TestHelper . mockSubscriber ( ) ; Flowable < Integer > source = Flowable . just ( 1 , 2 ) ; ConnectableFlowable < Integer > replay = source . doOnNext ( sourceNext ) . doOnCancel ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . replay ( ) ; replay . subscribe ( spiedSubscriberBeforeConnect ) ; replay . subscribe ( spiedSubscriberBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( spiedSubscriberAfterConnect ) ; replay . subscribe ( spiedSubscriberAfterConnect ) ; verify ( spiedSubscriberBeforeConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( spiedSubscriberAfterConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 2 ) ; verify ( sourceCompleted , times ( 1 ) ) . run ( ) ; verifyObserverMock ( spiedSubscriberBeforeConnect , 2 , 4 ) ; verifyObserverMock ( spiedSubscriberAfterConnect , 2 , 4 ) ; verify ( sourceUnsubscribed , never ( ) ) . run ( ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( spiedSubscriberBeforeConnect ) ; verifyNoMoreInteractions ( spiedSubscriberAfterConnect ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; final Scheduler mockScheduler = mock ( Scheduler . class ) ; final Disposable mockSubscription = mock ( Disposable . class ) ; Worker spiedWorker = workerSpy ( mockSubscription ) ; Subscriber < Integer > mockObserverBeforeConnect = TestHelper . mockSubscriber ( ) ; Subscriber < Integer > mockObserverAfterConnect = TestHelper . mockSubscriber ( ) ; when ( mockScheduler . createWorker ( ) ) . thenReturn ( spiedWorker ) ; ConnectableFlowable < Integer > replay = Flowable . just ( 1 , 2 , 3 ) . doOnNext ( sourceNext ) . doOnCancel ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . subscribeOn ( mockScheduler ) . replay ( ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( mockObserverAfterConnect ) ; replay . subscribe ( mockObserverAfterConnect ) ; verify ( mockObserverBeforeConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( mockObserverAfterConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 2 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 3 ) ; verify ( sourceCompleted , times ( 1 ) ) . run ( ) ; verify ( mockScheduler , times ( 1 ) ) . createWorker ( ) ; verify ( spiedWorker , times ( 1 ) ) . schedule ( ( Runnable ) notNull ( ) ) ; verifyObserverMock ( mockObserverBeforeConnect , 2 , 6 ) ; verifyObserverMock ( mockObserverAfterConnect , 2 , 6 ) ; verify ( spiedWorker , times ( 1 ) ) . dispose ( ) ; verify ( sourceUnsubscribed , never ( ) ) . run ( ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( spiedWorker ) ; verifyNoMoreInteractions ( mockSubscription ) ; verifyNoMoreInteractions ( mockScheduler ) ; verifyNoMoreInteractions ( mockObserverBeforeConnect ) ; verifyNoMoreInteractions ( mockObserverAfterConnect ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Consumer < Throwable > sourceError = mock ( Consumer . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; final Scheduler mockScheduler = mock ( Scheduler . class ) ; final Disposable mockSubscription = mock ( Disposable . class ) ; Worker spiedWorker = workerSpy ( mockSubscription ) ; Subscriber < Integer > mockObserverBeforeConnect = TestHelper . mockSubscriber ( ) ; Subscriber < Integer > mockObserverAfterConnect = TestHelper . mockSubscriber ( ) ; when ( mockScheduler . createWorker ( ) ) . thenReturn ( spiedWorker ) ; Function < Integer , Integer > mockFunc = mock ( Function . class ) ; IllegalArgumentException illegalArgumentException = new IllegalArgumentException ( ) ; when ( mockFunc . apply ( 1 ) ) . thenReturn ( 1 ) ; when ( mockFunc . apply ( 2 ) ) . thenThrow ( illegalArgumentException ) ; ConnectableFlowable < Integer > replay = Flowable . just ( 1 , 2 , 3 ) . map ( mockFunc ) . doOnNext ( sourceNext ) . doOnCancel ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . doOnError ( sourceError ) . subscribeOn ( mockScheduler ) . replay ( ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( mockObserverAfterConnect ) ; replay . subscribe ( mockObserverAfterConnect ) ; verify ( mockObserverBeforeConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( mockObserverAfterConnect , times ( 2 ) ) . onSubscribe ( ( Subscription ) any ( ) ) ; verify ( mockScheduler , times ( 1 ) ) . createWorker ( ) ; verify ( spiedWorker , times ( 1 ) ) . schedule ( ( Runnable ) notNull ( ) ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceError , times ( 1 ) ) . accept ( illegalArgumentException ) ; verifyObserver ( mockObserverBeforeConnect , 2 , 2 , illegalArgumentException ) ; verifyObserver ( mockObserverAfterConnect , 2 , 2 , illegalArgumentException ) ; verify ( spiedWorker , times ( 1 ) ) . dispose ( ) ; verify ( sourceUnsubscribed , never ( ) ) . run ( ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceError ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( spiedWorker ) ; verifyNoMoreInteractions ( mockSubscription ) ; verifyNoMoreInteractions ( mockScheduler ) ; verifyNoMoreInteractions ( mockObserverBeforeConnect ) ; verifyNoMoreInteractions ( mockObserverAfterConnect ) ; 
return spy ( new InprocessWorker ( mockDisposable ) ) ; 
action . run ( ) ; return mockDisposable ; 
unsubscribed = true ; 
return unsubscribed ; 
BoundedReplayBuffer < Integer > buf = new BoundedReplayBuffer < Integer > ( false ) private static final long serialVersionUID = - 9081211580719235896L ; @ Override void truncate ( ) ; buf . addLast ( new Node ( 1 , 0 ) ) ; buf . addLast ( new Node ( 2 , 1 ) ) ; buf . addLast ( new Node ( 3 , 2 ) ) ; buf . addLast ( new Node ( 4 , 3 ) ) ; buf . addLast ( new Node ( 5 , 4 ) ) ; List < Integer > values = new ArrayList < > ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , values ) ; buf . removeSome ( 2 ) ; buf . removeFirst ( ) ; buf . removeSome ( 2 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; buf . addLast ( new Node ( 5 , 5 ) ) ; buf . addLast ( new Node ( 6 , 6 ) ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 , 6 ) , values ) ; 
BoundedReplayBuffer < Integer > buf = new BoundedReplayBuffer < Integer > ( false ) private static final long serialVersionUID = - 9081211580719235896L ; @ Override void truncate ( ) ; buf . removeFirst ( ) ; 
TestScheduler test = new TestScheduler ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = new SizeAndTimeBoundReplayBuffer < > ( 2 , 2000 , TimeUnit . MILLISECONDS , test , false ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . next ( 2 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . complete ( ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; Assert . assertEquals ( 1 , buf . size ) ; Assert . assertTrue ( buf . hasCompleted ( ) ) ; 
final AtomicLong requested = new AtomicLong ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 1000 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long t ) requested . addAndGet ( t ) ; ) ; ConnectableFlowable < Integer > cf = source . replay ( ) ; TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( 10L ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( 90L ) ; cf . subscribe ( ts1 ) ; cf . subscribe ( ts2 ) ; ts2 . request ( 10 ) ; cf . connect ( ) ; ts1 . assertValueCount ( 10 ) ; ts1 . assertNotTerminated ( ) ; ts2 . assertValueCount ( 100 ) ; ts2 . assertNotTerminated ( ) ; Assert . assertEquals ( 100 , requested . get ( ) ) ; 
final AtomicLong requested = new AtomicLong ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 1000 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long t ) requested . addAndGet ( t ) ; ) ; ConnectableFlowable < Integer > cf = source . replay ( 50 ) ; TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( 10L ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( 90L ) ; cf . subscribe ( ts1 ) ; cf . subscribe ( ts2 ) ; ts2 . request ( 10 ) ; cf . connect ( ) ; ts1 . assertValueCount ( 10 ) ; ts1 . assertNotTerminated ( ) ; ts2 . assertValueCount ( 100 ) ; ts2 . assertNotTerminated ( ) ; Assert . assertEquals ( 100 , requested . get ( ) ) ; 
Flowable < Integer > source = Flowable . range ( 0 , 1000 ) . replay ( ) . autoConnect ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 1000 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; 
Flowable < Integer > source = Flowable . range ( 0 , 1000 ) . replay ( ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; ts . request ( 10 ) ; source . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; List < Integer > onNextEvents = ts . values ( ) ; assertEquals ( 10 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; ts . cancel ( ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Flowable < String > f = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( final Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; System . out . println ( "published observable being executed" ) ; subscriber . onNext ( "one" ) ; subscriber . onComplete ( ) ; ) . start ( ) ; ) . replay ( ) . autoConnect ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; f . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
Action unsubscribe = mock ( Action . class ) ; Flowable < Integer > f = Flowable . just ( 1 ) . doOnCancel ( unsubscribe ) . replay ( ) . autoConnect ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; f . subscribe ( ) ; verify ( unsubscribe , never ( ) ) . run ( ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; Flowable < Integer > cached = Flowable . range ( 1 , 100 ) . replay ( ) . autoConnect ( ) ; cached . take ( 10 ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 10000 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestSubscriberEx < Integer > ts1 = new TestSubscriberEx < > ( ) ; Flowable < Integer > cached = source . replay ( ) . autoConnect ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts1 ) ; ts1 . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts1 . assertNoErrors ( ) ; ts1 . assertTerminated ( ) ; assertEquals ( 10000 , ts1 . values ( ) . size ( ) ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( ts2 ) ; ts2 . awaitDone ( 2 , TimeUnit . SECONDS ) ; ts2 . assertNoErrors ( ) ; ts2 . assertTerminated ( ) ; assertEquals ( 10000 , ts2 . values ( ) . size ( ) ) ; 
Flowable < Long > source = Flowable . interval ( 1 , 1 , TimeUnit . MILLISECONDS ) . take ( 1000 ) . subscribeOn ( Schedulers . io ( ) ) ; Flowable < Long > cached = source . replay ( ) . autoConnect ( ) ; Flowable < Long > output = cached . observeOn ( Schedulers . computation ( ) , false , 1024 ) ; List < TestSubscriberEx < Long > > list = new ArrayList < > ( 100 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestSubscriberEx < Long > ts = new TestSubscriberEx < > ( ) ; list . add ( ts ) ; output . skip ( i * 10 ) . take ( 10 ) . subscribe ( ts ) ; List < Long > expected = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) expected . add ( ( long ) ( i - 10 ) ) ; int j = 0 ; for ( TestSubscriberEx < Long > ts : list ) ts . awaitDone ( 3 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; for ( int i = j * 10 ; i < j * 10 + 10 ; i ++ ) expected . set ( i - j * 10 , ( long ) i ) ; ts . assertValueSequence ( expected ) ; j ++ ; 
final int m = 4 * 1000 * 1000 ; Flowable < Integer > firehose = Flowable . unsafeCreate ( new Publisher < Integer > ( ) @ Override public void subscribe ( Subscriber < ? super Integer > t ) t . onSubscribe ( new BooleanSubscription ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) t . onNext ( i ) ; t . onComplete ( ) ; ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; firehose . replay ( ) . autoConnect ( ) . observeOn ( Schedulers . computation ( ) ) . takeLast ( 100 ) . subscribe ( ts ) ; ts . awaitDone ( 3 , TimeUnit . SECONDS ) ; ts . assertNoErrors ( ) ; ts . assertTerminated ( ) ; assertEquals ( 100 , ts . values ( ) . size ( ) ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 10 ) . concatWith ( Flowable . < Integer > error ( new TestException ( ) ) ) . replay ( ) . autoConnect ( ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( ) ; source . subscribe ( ts ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts . assertNotComplete ( ) ; Assert . assertEquals ( 1 , ts . errors ( ) . size ( ) ) ; TestSubscriberEx < Integer > ts2 = new TestSubscriberEx < > ( ) ; source . subscribe ( ts2 ) ; ts2 . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts2 . assertNotComplete ( ) ; Assert . assertEquals ( 1 , ts2 . errors ( ) . size ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 100 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . replay ( ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) throw new TestException ( ) ; ; source . subscribe ( ts ) ; Assert . assertEquals ( 100 , count . get ( ) ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Flowable < Integer > source = Flowable . < Integer > error ( new IOException ( ) ) . replay ( ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onError ( Throwable t ) super . onError ( t ) ; throw new TestException ( ) ; ; source . subscribe ( ts ) ; ts . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Flowable < Integer > source = Flowable . < Integer > empty ( ) . replay ( ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onComplete ( ) super . onComplete ( ) ; throw new TestException ( ) ; ; source . subscribe ( ts ) ; ts . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final List < Long > requests = new ArrayList < > ( ) ; Flowable < Integer > out = source . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long t ) requests . add ( t ) ; ) . replay ( ) . autoConnect ( ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < > ( 5L ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 10L ) ; out . subscribe ( ts1 ) ; out . subscribe ( ts2 ) ; ts2 . cancel ( ) ; Assert . assertEquals ( Arrays . asList ( 5L , 5L ) , requests ) ; 
ConnectableFlowable < Integer > source = Flowable . range ( 1 , 10 ) . replay ( 1 ) ; source . connect ( ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < > ( 2L ) ; source . subscribe ( ts1 ) ; ts1 . assertValues ( 1 , 2 ) ; ts1 . assertNoErrors ( ) ; ts1 . cancel ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 2L ) ; source . subscribe ( ts2 ) ; ts2 . assertValues ( 2 , 3 ) ; ts2 . assertNoErrors ( ) ; ts2 . cancel ( ) ; TestSubscriber < Integer > ts21 = new TestSubscriber < > ( 1L ) ; source . subscribe ( ts21 ) ; ts21 . assertValues ( 3 ) ; ts21 . assertNoErrors ( ) ; ts21 . cancel ( ) ; TestSubscriber < Integer > ts22 = new TestSubscriber < > ( 1L ) ; source . subscribe ( ts22 ) ; ts22 . assertValues ( 3 ) ; ts22 . assertNoErrors ( ) ; ts22 . cancel ( ) ; TestSubscriber < Integer > ts3 = new TestSubscriber < > ( ) ; source . subscribe ( ts3 ) ; ts3 . assertNoErrors ( ) ; System . out . println ( ts3 . values ( ) ) ; ts3 . assertValues ( 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts3 . assertComplete ( ) ; 
ConnectableFlowable < Integer > source = Flowable . range ( 1 , 10 ) . replay ( 2 ) ; source . connect ( ) ; TestSubscriber < Integer > ts1 = new TestSubscriber < > ( 2L ) ; source . subscribe ( ts1 ) ; ts1 . assertValues ( 1 , 2 ) ; ts1 . assertNoErrors ( ) ; ts1 . cancel ( ) ; TestSubscriber < Integer > ts11 = new TestSubscriber < > ( 2L ) ; source . subscribe ( ts11 ) ; ts11 . assertValues ( 1 , 2 ) ; ts11 . assertNoErrors ( ) ; ts11 . cancel ( ) ; TestSubscriber < Integer > ts2 = new TestSubscriber < > ( 3L ) ; source . subscribe ( ts2 ) ; ts2 . assertValues ( 1 , 2 , 3 ) ; ts2 . assertNoErrors ( ) ; ts2 . cancel ( ) ; TestSubscriber < Integer > ts21 = new TestSubscriber < > ( 1L ) ; source . subscribe ( ts21 ) ; ts21 . assertValues ( 2 ) ; ts21 . assertNoErrors ( ) ; ts21 . cancel ( ) ; TestSubscriber < Integer > ts22 = new TestSubscriber < > ( 1L ) ; source . subscribe ( ts22 ) ; ts22 . assertValues ( 2 ) ; ts22 . assertNoErrors ( ) ; ts22 . cancel ( ) ; TestSubscriber < Integer > ts3 = new TestSubscriber < > ( ) ; source . subscribe ( ts3 ) ; ts3 . assertNoErrors ( ) ; System . out . println ( ts3 . values ( ) ) ; ts3 . assertValues ( 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; ts3 . assertComplete ( ) ; 
Flowable . just ( 1 ) . replay ( 1 , TimeUnit . MINUTES ) . autoConnect ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . replay ( 1 , 1 , TimeUnit . MILLISECONDS ) . autoConnect ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . replay ( Functions . < Flowable < Integer > > identity ( ) , 1 , TimeUnit . MINUTES ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Flowable < Integer > source = Flowable . range ( 1 , 3 ) ; assertSame ( source , ( ( ( HasUpstreamPublisher < ? > ) source . replay ( ) ) ) . source ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 3 ) . replay ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) cf . connect ( ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 3 ) . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 3 ) . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; final TestSubscriber < Integer > ts2 = new TestSubscriber < > ( ) ; cf . subscribe ( ts1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
Flowable . range ( 1 , 2 ) . replay ( Integer . MAX_VALUE ) . autoConnect ( ) . test ( Long . MAX_VALUE , true ) . assertEmpty ( ) ; 
ConnectableFlowable < Integer > cf = PublishProcessor . < Integer > create ( ) . replay ( Integer . MAX_VALUE ) ; cf . test ( ) ; cf . autoConnect ( ) . test ( Long . MAX_VALUE , true ) . assertEmpty ( ) ; 
ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 2 ) . replay ( ) ; try cf . connect ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable t ) throws Exception throw new TestException ( ) ; ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) cf . test ( ) . assertEmpty ( ) . cancel ( ) ; cf . connect ( ) ; cf . test ( ) . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; subscriber . onError ( new TestException ( "First" ) ) ; subscriber . onNext ( 1 ) ; subscriber . onError ( new TestException ( "Second" ) ) ; subscriber . onComplete ( ) ; . replay ( ) . autoConnect ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final ConnectableFlowable < Integer > cf = pp . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) pp . onNext ( j ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final ConnectableFlowable < Integer > cf = pp . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; cf . subscribe ( ts1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) pp . onNext ( j ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableFlowable < Integer > cf = Flowable . range ( 1 , 1000 ) . replay ( ) ; final TestSubscriber < Integer > ts1 = new TestSubscriber < > ( ) ; cf . connect ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cf . subscribe ( ts1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts1 . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; super . onNext ( t ) ; ; pp . replay ( ) . autoConnect ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) pp . onNext ( 2 ) ; pp . onComplete ( ) ; super . onNext ( t ) ; ; pp . replay ( 10 ) . autoConnect ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertResult ( 1 , 2 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) pp . onNext ( 2 ) ; cancel ( ) ; super . onNext ( t ) ; ; pp . replay ( ) . autoConnect ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValues ( 1 ) ; 
final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) pp . onNext ( 2 ) ; cancel ( ) ; super . onNext ( t ) ; ; pp . replay ( 10 ) . autoConnect ( ) . subscribe ( ts ) ; pp . onNext ( 1 ) ; ts . assertValues ( 1 ) ; 
Flowable . range ( 1 , 2 ) . replay ( Integer . MAX_VALUE ) . autoConnect ( ) . test ( ) . assertResult ( 1 , 2 ) ; 
TestScheduler test = new TestScheduler ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = new SizeAndTimeBoundReplayBuffer < > ( 2 , 2000 , TimeUnit . MILLISECONDS , test , false ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . next ( 2 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . error ( new TestException ( ) ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; Assert . assertEquals ( 1 , buf . size ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertTrue ( buf . hasError ( ) ) ; 
SizeBoundReplayBuffer < Integer > buf = new SizeBoundReplayBuffer < > ( 2 , false ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; buf . next ( 2 ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 4 , 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; buf . complete ( ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 4 , 5 ) , values ) ; Assert . assertEquals ( 3 , buf . size ) ; Assert . assertTrue ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; 
final Subscriber < ? > [ ] sub = null ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) sub [ 0 ] = s ; . replay ( ) . connect ( ) . dispose ( ) ; BooleanSubscription bs = new BooleanSubscription ( ) ; sub [ 0 ] . onSubscribe ( bs ) ; assertTrue ( bs . isCancelled ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . replay ( 2 , TimeUnit . SECONDS , scheduler ) . autoConnect ( ) ; source . test ( ) . assertResult ( 1 ) ; source . test ( ) . assertResult ( 1 ) ; scheduler . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; source . test ( ) . assertResult ( ) ; 
FlowableReplay . multicastSelector ( new Supplier < ConnectableFlowable < Object > > ( ) @ Override public ConnectableFlowable < Object > get ( ) throws Exception throw new TestException ( ) ; , Functions . < Flowable < Object > > identity ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . replay ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; assertNotNull ( buf . get ( ) . value ) ; buf . trimHead ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; PublishProcessor < Integer > source = PublishProcessor . create ( ) ; FlowableReplay < Integer > co = ( FlowableReplay < Integer > ) source . replay ( 1 , TimeUnit . MILLISECONDS , sch ) ; co . test ( ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; sch . advanceTimeBy ( 2 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; assertNotNull ( buf . get ( ) . value ) ; buf . trimHead ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
FlowableReplay . create ( Flowable . just ( 1 ) , new Supplier < ReplayBuffer < Integer > > ( ) @ Override public ReplayBuffer < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . connect ( ) ; 
FlowableReplay . create ( Flowable . just ( 1 ) , new Supplier < ReplayBuffer < Integer > > ( ) @ Override public ReplayBuffer < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable < byte [ ] > source = Flowable . range ( 1 , 200 ) . map ( new Function < Integer , byte [ ] > ( ) @ Override public byte [ ] apply ( Integer v ) throws Exception return new byte [ 1024 * 1024 ] ; ) . replay ( new Function < Flowable < byte [ ] > , Publisher < byte [ ] > > ( ) @ Override public Publisher < byte [ ] > apply ( final Flowable < byte [ ] > f ) throws Exception return f . take ( 1 ) . concatMap ( new Function < byte [ ] , Publisher < byte [ ] > > ( ) @ Override public Publisher < byte [ ] > apply ( byte [ ] v ) throws Exception return f ; ) ; , 1 ) . takeLast ( 1 ) ; System . out . println ( "Bounded Replay Leak check: Wait before GC" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check: GC" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long initial = memHeap . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; final AtomicLong after = new AtomicLong ( ) ; source . subscribe ( new Consumer < byte [ ] > ( ) @ Override public void accept ( byte [ ] v ) throws Exception System . out . println ( "Bounded Replay Leak check: Wait before GC 2" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check:  GC 2" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; after . set ( memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ) ; ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after . get ( ) / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after . get ( ) ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after . get ( ) / 1024.0 / 1024.0 ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . range ( 1 , 100 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . replay ( 1000 ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) throw new TestException ( ) ; ; source . subscribe ( ts ) ; Assert . assertEquals ( 100 , count . get ( ) ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
TestHelper . withErrorTracking ( errors -> Flowable < Integer > source = Flowable . < Integer > error ( new IOException ( ) ) . replay ( 1000 ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onError ( Throwable t ) super . onError ( t ) ; throw new TestException ( ) ; ; source . subscribe ( ts ) ; ts . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Flowable < Integer > source = Flowable . < Integer > empty ( ) . replay ( 1000 ) . autoConnect ( ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onComplete ( ) super . onComplete ( ) ; throw new TestException ( ) ; ; source . subscribe ( ts ) ; ts . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
ConnectableFlowable < Object > cf = Flowable . never ( ) . replay ( ) ; cf . connect ( ) ; cf . connect ( d -> throw new TestException ( ) ; ) ; 
ConnectableFlowable < Object > cf = Flowable . never ( ) . replay ( ) ; cf . reset ( ) ; 
ConnectableFlowable < Object > cf = Flowable . never ( ) . replay ( ) ; cf . connect ( ) ; cf . reset ( ) ; 
AtomicReference < Subscriber < ? super Integer > > ref = new AtomicReference < > ( ) ; Flowable < Integer > f = Flowable . < Integer > unsafeCreate ( ref :: set ) ; TestSubscriber < Integer > ts = f . replay ( ) . autoConnect ( ) . test ( ) ; AtomicLong requested = new AtomicLong ( ) ; ref . get ( ) . onSubscribe ( new Subscription ( ) @ Override public void request ( long n ) BackpressureHelper . add ( requested , n ) ; @ Override public void cancel ( ) ) ; assertEquals ( Long . MAX_VALUE , requested . get ( ) ) ; ref . get ( ) . onComplete ( ) ; ts . assertResult ( ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . replay ( ) ; TestSubscriber < Integer > ts = cf . test ( ) ; Disposable d = cf . connect ( ) ; pp . onNext ( 1 ) ; d . dispose ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . replay ( 10 ) ; TestSubscriber < Integer > ts = cf . test ( ) ; Disposable d = cf . connect ( ) ; pp . onNext ( 1 ) ; d . dispose ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . replay ( 10 , TimeUnit . MINUTES ) ; TestSubscriber < Integer > ts = cf . test ( ) ; Disposable d = cf . connect ( ) ; pp . onNext ( 1 ) ; d . dispose ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 2 ) ; 
PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; ConnectableFlowable < Integer > cf = pp . replay ( 10 , 10 , TimeUnit . MINUTES ) ; TestSubscriber < Integer > ts = cf . test ( ) ; Disposable d = cf . connect ( ) ; pp . onNext ( 1 ) ; d . dispose ( ) ; ts = cf . test ( ) ; ts . assertEmpty ( ) ; cf . connect ( ) ; ts . assertEmpty ( ) ; pp . onNext ( 2 ) ; ts . assertValuesOnly ( 2 ) ; 
Supplier < Flowable < String > > factory = mock ( Supplier . class ) ; Flowable < String > firstObservable = Flowable . just ( "one" , "two" ) ; Flowable < String > secondObservable = Flowable . just ( "three" , "four" ) ; when ( factory . get ( ) ) . thenReturn ( firstObservable , secondObservable ) ; Flowable < String > deferred = Flowable . defer ( factory ) ; verifyNoInteractions ( factory ) ; Subscriber < String > firstSubscriber = TestHelper . mockSubscriber ( ) ; deferred . subscribe ( firstSubscriber ) ; verify ( factory , times ( 1 ) ) . get ( ) ; verify ( firstSubscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( firstSubscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( firstSubscriber , times ( 0 ) ) . onNext ( "three" ) ; verify ( firstSubscriber , times ( 0 ) ) . onNext ( "four" ) ; verify ( firstSubscriber , times ( 1 ) ) . onComplete ( ) ; Subscriber < String > secondSubscriber = TestHelper . mockSubscriber ( ) ; deferred . subscribe ( secondSubscriber ) ; verify ( factory , times ( 2 ) ) . get ( ) ; verify ( secondSubscriber , times ( 0 ) ) . onNext ( "one" ) ; verify ( secondSubscriber , times ( 0 ) ) . onNext ( "two" ) ; verify ( secondSubscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( secondSubscriber , times ( 1 ) ) . onNext ( "four" ) ; verify ( secondSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Supplier < Flowable < String > > factory = mock ( Supplier . class ) ; when ( factory . get ( ) ) . thenThrow ( new TestException ( ) ) ; Flowable < String > result = Flowable . defer ( factory ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; result . subscribe ( subscriber ) ; verify ( subscriber ) . onError ( any ( TestException . class ) ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" ) , Flowable . just ( "one" , "two" , "three" ) ) . toFlowable ( ) ; verifyResult ( flowable , true ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" ) , Flowable . just ( "one" , "two" , "three" , "four" ) ) . toFlowable ( ) ; verifyResult ( flowable , false ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . just ( "one" , "two" , "three" , "four" ) , Flowable . just ( "one" , "two" , "three" ) ) . toFlowable ( ) ; verifyResult ( flowable , false ) ; 
Flowable < Boolean > flowable = Flowable . sequenceEqual ( Flowable . concat ( Flowable . just ( "one" ) , Flowable . < String > error ( new TestException ( ) ) ) , Flowable . just ( "one" , "two" , "three" ) ) . toFlowable ( ) ; verifyError ( flowable ) ; 
