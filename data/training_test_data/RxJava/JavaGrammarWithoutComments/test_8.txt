return RxJavaPlugins . onAssembly ( new ObservableSingleMaybe < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableSingleSingle < > ( this , null ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSkipUntil < > ( this , other ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSkipWhile < > ( this , predicate ) ) ; 
return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( Functions . naturalComparator ( ) ) ) . flatMapIterable ( Functions . identity ( ) ) ; 
Objects . requireNonNull ( comparator , "comparator is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( comparator ) ) . flatMapIterable ( Functions . identity ( ) ) ; 
return concatArray ( fromIterable ( items ) , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Observable . concat ( Completable . wrap ( other ) . < T > toObservable ( ) , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Observable . concat ( Single . wrap ( other ) . toObservable ( ) , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Observable . concat ( Maybe . wrap ( other ) . toObservable ( ) , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return concatArray ( other , this ) ; 
return subscribe ( Functions . emptyConsumer ( ) , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
return subscribe ( onNext , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
return subscribe ( onNext , onError , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; LambdaObserver < T > ls = new LambdaObserver < > ( onNext , onError , onComplete , Functions . emptyConsumer ( ) ) ; subscribe ( ls ) ; return ls ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; Objects . requireNonNull ( container , "container is null" ) ; DisposableAutoReleaseObserver < T > observer = new DisposableAutoReleaseObserver < > ( container , onNext , onError , onComplete ) ; container . add ( observer ) ; subscribe ( observer ) ; return observer ; 
Objects . requireNonNull ( observer , "observer is null" ) ; try observer = RxJavaPlugins . onSubscribe ( this , observer ) ; Objects . requireNonNull ( observer , "The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins" ) ; subscribeActual ( observer ) ; catch ( NullPointerException e ) throw e ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; NullPointerException npe = new NullPointerException ( "Actually not, but can't throw other exceptions due to RS" ) ; npe . initCause ( e ) ; throw npe ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSubscribeOn < > ( this , scheduler ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchIfEmpty < > ( this , other ) ) ; 
return switchMap ( mapper , bufferSize ( ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMapCompletable < > ( this , mapper , false ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMapCompletable < > ( this , mapper , true ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMapMaybe < > ( this , mapper , false ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMapMaybe < > ( this , mapper , true ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMapSingle < > ( this , mapper , false ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSwitchMapSingle < > ( this , mapper , true ) ) ; 
return switchMapDelayError ( mapper , bufferSize ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableTakeUntil < > ( this , other ) ) ; 
Objects . requireNonNull ( stopPredicate , "stopPredicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableTakeUntilPredicate < > ( this , stopPredicate ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableTakeWhile < > ( this , predicate ) ) ; 
return timeInterval ( TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; 
return timeInterval ( TimeUnit . MILLISECONDS , scheduler ) ; 
return timeInterval ( unit , Schedulers . computation ( ) ) ; 
Objects . requireNonNull ( unit , "unit is null" ) ; Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableTimeInterval < > ( this , unit , scheduler ) ) ; 
return timeout0 ( null , itemTimeoutIndicator , null ) ; 
Objects . requireNonNull ( fallback , "fallback is null" ) ; return timeout0 ( null , itemTimeoutIndicator , fallback ) ; 
Objects . requireNonNull ( firstTimeoutIndicator , "firstTimeoutIndicator is null" ) ; return timeout0 ( firstTimeoutIndicator , itemTimeoutIndicator , null ) ; 
Objects . requireNonNull ( firstTimeoutIndicator , "firstTimeoutIndicator is null" ) ; Objects . requireNonNull ( fallback , "fallback is null" ) ; return timeout0 ( firstTimeoutIndicator , itemTimeoutIndicator , fallback ) ; 
Objects . requireNonNull ( itemTimeoutIndicator , "itemTimeoutIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableTimeout < > ( this , firstTimeoutIndicator , itemTimeoutIndicator , fallback ) ) ; 
return timestamp ( TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; 
return timestamp ( TimeUnit . MILLISECONDS , scheduler ) ; 
return timestamp ( unit , Schedulers . computation ( ) ) ; 
Objects . requireNonNull ( unit , "unit is null" ) ; Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return map ( Functions . timestampWith ( unit , scheduler ) ) ; 
return Objects . requireNonNull ( converter , "converter is null" ) . apply ( this ) ; 
return toList ( 16 ) ; 
Objects . requireNonNull ( collectionSupplier , "collectionSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableToListSingle < > ( this , collectionSupplier ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; return collect ( HashMapSupplier . asSupplier ( ) , Functions . toMapKeySelector ( keySelector ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; Objects . requireNonNull ( valueSelector , "valueSelector is null" ) ; return collect ( HashMapSupplier . asSupplier ( ) , Functions . toMapKeyValueSelector ( keySelector , valueSelector ) ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; Objects . requireNonNull ( valueSelector , "valueSelector is null" ) ; Objects . requireNonNull ( mapSupplier , "mapSupplier is null" ) ; return collect ( mapSupplier , Functions . toMapKeyValueSelector ( keySelector , valueSelector ) ) ; 
Function < ? super T , ? extends T > valueSelector = Functions . identity ( ) ; Supplier < Map < K , Collection < T > > > mapSupplier = HashMapSupplier . asSupplier ( ) ; Function < K , List < T > > collectionFactory = ArrayListSupplier . asFunction ( ) ; return toMultimap ( keySelector , valueSelector , mapSupplier , collectionFactory ) ; 
Supplier < Map < K , Collection < V > > > mapSupplier = HashMapSupplier . asSupplier ( ) ; Function < K , List < V > > collectionFactory = ArrayListSupplier . asFunction ( ) ; return toMultimap ( keySelector , valueSelector , mapSupplier , collectionFactory ) ; 
Objects . requireNonNull ( keySelector , "keySelector is null" ) ; Objects . requireNonNull ( valueSelector , "valueSelector is null" ) ; Objects . requireNonNull ( mapSupplier , "mapSupplier is null" ) ; Objects . requireNonNull ( collectionFactory , "collectionFactory is null" ) ; return collect ( mapSupplier , Functions . toMultimapKeyValueSelector ( keySelector , valueSelector , collectionFactory ) ) ; 
return toMultimap ( keySelector , valueSelector , mapSupplier , ArrayListSupplier . asFunction ( ) ) ; 
Objects . requireNonNull ( strategy , "strategy is null" ) ; Flowable < T > f = new FlowableFromObservable < > ( this ) ; switch ( strategy ) case DROP : return f . onBackpressureDrop ( ) ; case LATEST : return f . onBackpressureLatest ( ) ; case MISSING : return f ; case ERROR : return RxJavaPlugins . onAssembly ( new FlowableOnBackpressureError < > ( f ) ) ; default : return f . onBackpressureBuffer ( ) ; 
return toSortedList ( Functions . naturalComparator ( ) ) ; 
Objects . requireNonNull ( comparator , "comparator is null" ) ; return toList ( ) . map ( Functions . listSorter ( comparator ) ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableUnsubscribeOn < > ( this , scheduler ) ) ; 
return window ( boundaryIndicator , bufferSize ( ) ) ; 
return window ( openingIndicator , closingIndicator , bufferSize ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableWithLatestFrom < T , U , R > ( this , combiner , other ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; Function < Object [ ] , R > f = Functions . toFunction ( combiner ) ; return withLatestFrom ( new ObservableSource [ ] source1 , source2 , f ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; Function < Object [ ] , R > f = Functions . toFunction ( combiner ) ; return withLatestFrom ( new ObservableSource [ ] source1 , source2 , source3 , f ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; Function < Object [ ] , R > f = Functions . toFunction ( combiner ) ; return withLatestFrom ( new ObservableSource [ ] source1 , source2 , source3 , source4 , f ) ; 
Objects . requireNonNull ( others , "others is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableWithLatestFromMany < > ( this , others , combiner ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableZipIterable < > ( this , other , zipper ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return zip ( this , other , zipper ) ; 
TestObserver < T > to = new TestObserver < > ( ) ; subscribe ( to ) ; return to ; 
Objects . requireNonNull ( optional , "optional is null" ) ; return optional . map ( Observable :: just ) . orElseGet ( Observable :: empty ) ; 
Objects . requireNonNull ( stage , "stage is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromCompletionStage < > ( stage ) ) ; 
Objects . requireNonNull ( stream , "stream is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFromStream < > ( stream ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableMapOptional < > ( this , mapper ) ) ; 
Objects . requireNonNull ( collector , "collector is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableCollectWithCollectorSingle < > ( this , collector ) ) ; 
return subscribeWith ( new ObservableFirstStageObserver < > ( false , null ) ) ; 
return subscribeWith ( new ObservableSingleStageObserver < > ( false , null ) ) ; 
return subscribeWith ( new ObservableLastStageObserver < > ( false , null ) ) ; 
return blockingStream ( bufferSize ( ) ) ; 
return flatMapStream ( mapper ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableFlatMapStream < > ( this , mapper ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeAmb < > ( null , sources ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeConcatIterable < > ( sources ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return concatArray ( source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return concatArray ( source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return concatArray ( source1 , source2 , source3 , source4 ) ; 
return concat ( sources , 2 ) ; 
return Flowable . fromIterable ( sources ) . concatMapMaybeDelayError ( Functions . identity ( ) ) ; 
return Flowable . fromPublisher ( sources ) . concatMapMaybeDelayError ( Functions . identity ( ) ) ; 
return Flowable . fromIterable ( sources ) . concatMapEagerDelayError ( ( Function ) MaybeToPublisher . instance ( ) , false ) ; 
return Flowable . fromPublisher ( sources ) . concatMapEager ( ( Function ) MaybeToPublisher . instance ( ) ) ; 
return Flowable . fromIterable ( sources ) . concatMapEagerDelayError ( ( Function ) MaybeToPublisher . instance ( ) , true ) ; 
return Flowable . fromPublisher ( sources ) . concatMapEagerDelayError ( ( Function ) MaybeToPublisher . instance ( ) , true ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeCreate < > ( onSubscribe ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDefer < > ( supplier ) ) ; 
return RxJavaPlugins . onAssembly ( ( Maybe < T > ) MaybeEmpty . INSTANCE ) ; 
Objects . requireNonNull ( throwable , "throwable is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeError < > ( throwable ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeErrorCallable < > ( supplier ) ) ; 
Objects . requireNonNull ( action , "action is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromAction < > ( action ) ) ; 
Objects . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < > ( completableSource ) ) ; 
Objects . requireNonNull ( single , "single is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < > ( single ) ) ; 
Objects . requireNonNull ( callable , "callable is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCallable < > ( callable ) ) ; 
Objects . requireNonNull ( future , "future is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromFuture < > ( future , 0L , null ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableElementAtMaybe < > ( source , 0L ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableElementAtMaybePublisher < > ( source , 0L ) ) ; 
Objects . requireNonNull ( run , "run is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromRunnable < > ( run ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSupplier < > ( supplier ) ) ; 
return Flowable . fromIterable ( sources ) . flatMapMaybe ( Functions . identity ( ) , false , Integer . MAX_VALUE ) ; 
return merge ( sources , Integer . MAX_VALUE ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatten ( source , Functions . identity ( ) ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return mergeArray ( source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return mergeArray ( source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return mergeArray ( source1 , source2 , source3 , source4 ) ; 
return Flowable . fromIterable ( sources ) . flatMapMaybe ( Functions . identity ( ) , true , Integer . MAX_VALUE ) ; 
return mergeDelayError ( sources , Integer . MAX_VALUE ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return mergeArrayDelayError ( source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return mergeArrayDelayError ( source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return mergeArrayDelayError ( source1 , source2 , source3 , source4 ) ; 
return RxJavaPlugins . onAssembly ( ( Maybe < T > ) MaybeNever . INSTANCE ) ; 
return sequenceEqual ( source1 , source2 , ObjectHelper . equalsPredicate ( ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( isEqual , "isEqual is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeEqualSingle < > ( source1 , source2 , isEqual ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapMaybePublisher < > ( sources , Functions . identity ( ) , false ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapMaybePublisher < > ( sources , Functions . identity ( ) , true ) ) ; 
if ( onSubscribe instanceof Maybe ) throw new IllegalArgumentException ( "unsafeCreate(Maybe) should be upgraded" ) ; Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeUnsafeCreate < > ( onSubscribe ) ) ; 
return using ( resourceSupplier , sourceSupplier , resourceCleanup , true ) ; 
if ( source instanceof Maybe ) return RxJavaPlugins . onAssembly ( ( Maybe < T > ) source ) ; Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeUnsafeCreate < > ( source ) ) ; 
Objects . requireNonNull ( zipper , "zipper is null" ) ; Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeZipIterable < > ( sources , zipper ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 , source6 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( source9 , "source9 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 , source9 ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; 
BlockingMultiObserver < T > observer = new BlockingMultiObserver < > ( ) ; subscribe ( observer ) ; return observer . blockingGet ( ) ; 
blockingSubscribe ( Functions . emptyConsumer ( ) , Functions . ERROR_CONSUMER , Functions . EMPTY_ACTION ) ; 
blockingSubscribe ( onSuccess , Functions . ERROR_CONSUMER , Functions . EMPTY_ACTION ) ; 
blockingSubscribe ( onSuccess , onError , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onSuccess , "onSuccess is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; BlockingMultiObserver < T > observer = new BlockingMultiObserver < > ( ) ; subscribe ( observer ) ; observer . blockingConsume ( onSuccess , onError , onComplete ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; BlockingDisposableMultiObserver < T > blockingObserver = new BlockingDisposableMultiObserver < > ( ) ; observer . onSubscribe ( blockingObserver ) ; subscribe ( blockingObserver ) ; blockingObserver . blockingConsume ( observer ) ; 
return RxJavaPlugins . onAssembly ( new MaybeCache < > ( this ) ) ; 
Objects . requireNonNull ( clazz , "clazz is null" ) ; return map ( Functions . castFunction ( clazz ) ) ; 
return wrap ( ( ( MaybeTransformer < T , R > ) Objects . requireNonNull ( transformer , "transformer is null" ) ) . apply ( this ) ) ; 
return flatMap ( mapper ) ; 
return flatMapCompletable ( mapper ) ; 
return flatMapSingle ( mapper ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return concat ( this , other ) ; 
Objects . requireNonNull ( item , "item is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeContains < > ( this , item ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybeCount < > ( this ) ) ; 
Objects . requireNonNull ( selector , "selector is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDematerialize < > ( this , selector ) ) ; 
Objects . requireNonNull ( delayIndicator , "delayIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDelayOtherPublisher < > ( this , delayIndicator ) ) ; 
Objects . requireNonNull ( subscriptionIndicator , "subscriptionIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDelaySubscriptionOtherPublisher < > ( this , subscriptionIndicator ) ) ; 
Objects . requireNonNull ( onAfterSuccess , "onAfterSuccess is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDoAfterSuccess < > ( this , onAfterSuccess ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybePeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Objects . requireNonNull ( onAfterTerminate , "onAfterTerminate is null" ) , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onFinally , "onFinally is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDoFinally < > ( this , onFinally ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybePeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Objects . requireNonNull ( onDispose , "onDispose is null" ) ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybePeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Objects . requireNonNull ( onComplete , "onComplete is null" ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybePeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Objects . requireNonNull ( onError , "onError is null" ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onEvent , "onEvent is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDoOnEvent < > ( this , onEvent ) ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; Objects . requireNonNull ( onDispose , "onDispose is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDoOnLifecycle < > ( this , onSubscribe , onDispose ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybePeek < > ( this , Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onTerminate , "onTerminate is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDoOnTerminate < > ( this , onTerminate ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybePeek < > ( this , Functions . emptyConsumer ( ) , Objects . requireNonNull ( onSuccess , "onSuccess is null" ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFilter < > ( this , predicate ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatten < > ( this , mapper ) ) ; 
Objects . requireNonNull ( onSuccessMapper , "onSuccessMapper is null" ) ; Objects . requireNonNull ( onErrorMapper , "onErrorMapper is null" ) ; Objects . requireNonNull ( onCompleteSupplier , "onCompleteSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatMapNotification < > ( this , onSuccessMapper , onErrorMapper , onCompleteSupplier ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatMapBiSelector < > ( this , mapper , combiner ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatMapIterableFlowable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatMapIterableObservable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatMapObservable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatMapPublisher < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatMapSingle < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlatMapCompletable < > ( this , mapper ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybeHide < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybeIgnoreElementCompletable < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybeIsEmptySingle < > ( this ) ) ; 
Objects . requireNonNull ( lift , "lift is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeLift < > ( this , lift ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeMap < > ( this , mapper ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybeMaterialize < > ( this ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return merge ( this , other ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeObserveOn < > ( this , scheduler ) ) ; 
Objects . requireNonNull ( clazz , "clazz is null" ) ; return filter ( Functions . isInstanceOf ( clazz ) ) . cast ( clazz ) ; 
return Objects . requireNonNull ( converter , "converter is null" ) . apply ( this ) ; 
if ( this instanceof FuseToFlowable ) return ( ( FuseToFlowable < T > ) this ) . fuseToFlowable ( ) ; return RxJavaPlugins . onAssembly ( new MaybeToFlowable < > ( this ) ) ; 
return subscribeWith ( new FutureMultiObserver < > ( ) ) ; 
if ( this instanceof FuseToObservable ) return ( ( FuseToObservable < T > ) this ) . fuseToObservable ( ) ; return RxJavaPlugins . onAssembly ( new MaybeToObservable < > ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybeToSingle < > ( this , null ) ) ; 
return onErrorComplete ( Functions . alwaysTrue ( ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeOnErrorComplete < > ( this , predicate ) ) ; 
Objects . requireNonNull ( fallback , "fallback is null" ) ; return onErrorResumeNext ( Functions . justFunction ( fallback ) ) ; 
Objects . requireNonNull ( fallbackSupplier , "fallbackSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeOnErrorNext < > ( this , fallbackSupplier ) ) ; 
Objects . requireNonNull ( itemSupplier , "itemSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeOnErrorReturn < > ( this , itemSupplier ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybeDetach < > ( this ) ) ; 
return repeat ( Long . MAX_VALUE ) ; 
return toFlowable ( ) . repeatUntil ( stop ) ; 
return toFlowable ( ) . repeatWhen ( handler ) ; 
return retry ( Long . MAX_VALUE , Functions . alwaysTrue ( ) ) ; 
return toFlowable ( ) . retry ( predicate ) . singleElement ( ) ; 
return retry ( Long . MAX_VALUE , predicate ) ; 
Objects . requireNonNull ( stop , "stop is null" ) ; return retry ( Long . MAX_VALUE , Functions . predicateReverseFor ( stop ) ) ; 
return toFlowable ( ) . retryWhen ( handler ) . singleElement ( ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; subscribe ( new SafeMaybeObserver < > ( observer ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Completable . wrap ( other ) . < T > toFlowable ( ) , toFlowable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Single . wrap ( other ) . toFlowable ( ) , toFlowable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Maybe . wrap ( other ) . toFlowable ( ) , toFlowable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Observable . wrap ( other ) . concatWith ( this . toObservable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return toFlowable ( ) . startWith ( other ) ; 
return subscribe ( Functions . emptyConsumer ( ) , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
return subscribe ( onSuccess , Functions . ON_ERROR_MISSING , Functions . EMPTY_ACTION ) ; 
return subscribe ( onSuccess , onError , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onSuccess , "onSuccess is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; return subscribeWith ( new MaybeCallbackObserver < > ( onSuccess , onError , onComplete ) ) ; 
Objects . requireNonNull ( onSuccess , "onSuccess is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; Objects . requireNonNull ( container , "container is null" ) ; DisposableAutoReleaseMultiObserver < T > observer = new DisposableAutoReleaseMultiObserver < > ( container , onSuccess , onError , onComplete ) ; container . add ( observer ) ; subscribe ( observer ) ; return observer ; 
Objects . requireNonNull ( observer , "observer is null" ) ; observer = RxJavaPlugins . onSubscribe ( this , observer ) ; Objects . requireNonNull ( observer , "The RxJavaPlugins.onSubscribe hook returned a null MaybeObserver. Please check the handler provided to RxJavaPlugins.setOnMaybeSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins" ) ; try subscribeActual ( observer ) ; catch ( NullPointerException ex ) throw ex ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; NullPointerException npe = new NullPointerException ( "subscribeActual failed" ) ; npe . initCause ( ex ) ; throw npe ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeSubscribeOn < > ( this , scheduler ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeSwitchIfEmpty < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeSwitchIfEmptySingle < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeTakeUntilMaybe < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeTakeUntilPublisher < > ( this , other ) ) ; 
return timeInterval ( TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; 
return timeInterval ( TimeUnit . MILLISECONDS , scheduler ) ; 
return timeInterval ( unit , Schedulers . computation ( ) ) ; 
Objects . requireNonNull ( unit , "unit is null" ) ; Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeTimeInterval < > ( this , unit , scheduler , true ) ) ; 
return timestamp ( TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; 
return timestamp ( TimeUnit . MILLISECONDS , scheduler ) ; 
return timestamp ( unit , Schedulers . computation ( ) ) ; 
Objects . requireNonNull ( unit , "unit is null" ) ; Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeTimeInterval < > ( this , unit , scheduler , false ) ) ; 
Objects . requireNonNull ( timeoutIndicator , "timeoutIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeTimeoutMaybe < > ( this , timeoutIndicator , null ) ) ; 
Objects . requireNonNull ( timeoutIndicator , "timeoutIndicator is null" ) ; Objects . requireNonNull ( fallback , "fallback is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeTimeoutMaybe < > ( this , timeoutIndicator , fallback ) ) ; 
Objects . requireNonNull ( timeoutIndicator , "timeoutIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeTimeoutPublisher < > ( this , timeoutIndicator , null ) ) ; 
Objects . requireNonNull ( timeoutIndicator , "timeoutIndicator is null" ) ; Objects . requireNonNull ( fallback , "fallback is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeTimeoutPublisher < > ( this , timeoutIndicator , fallback ) ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeUnsubscribeOn < > ( this , scheduler ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return zip ( this , other , zipper ) ; 
TestObserver < T > to = new TestObserver < > ( ) ; subscribe ( to ) ; return to ; 
Objects . requireNonNull ( optional , "optional is null" ) ; return optional . map ( Maybe :: just ) . orElseGet ( Maybe :: empty ) ; 
Objects . requireNonNull ( stage , "stage is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletionStage < > ( stage ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeMapOptional < > ( this , mapper ) ) ; 
return subscribeWith ( new CompletionStageConsumer < > ( false , null ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlattenStreamAsFlowable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFlattenStreamAsObservable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableAmb ( null , sources ) ) ; 
return RxJavaPlugins . onAssembly ( CompletableEmpty . INSTANCE ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableConcatIterable ( sources ) ) ; 
return concat ( sources , 2 ) ; 
return Flowable . fromIterable ( sources ) . concatMapCompletableDelayError ( Functions . identity ( ) ) ; 
return concatDelayError ( sources , 2 ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableCreate ( source ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return mergeArrayDelayError ( source1 , source2 ) . andThen ( Single . just ( true ) ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; if ( onSubscribe instanceof Completable ) throw new IllegalArgumentException ( "Use of unsafeCreate(Completable)!" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromUnsafeSource ( onSubscribe ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableDefer ( supplier ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableErrorSupplier ( supplier ) ) ; 
Objects . requireNonNull ( throwable , "throwable is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableError ( throwable ) ) ; 
Objects . requireNonNull ( action , "action is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromAction ( action ) ) ; 
Objects . requireNonNull ( callable , "callable is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromCallable ( callable ) ) ; 
Objects . requireNonNull ( future , "future is null" ) ; return fromAction ( Functions . futureAction ( future ) ) ; 
Objects . requireNonNull ( maybe , "maybe is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeIgnoreElementCompletable < > ( maybe ) ) ; 
Objects . requireNonNull ( run , "run is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromRunnable ( run ) ) ; 
Objects . requireNonNull ( observable , "observable is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromObservable < > ( observable ) ) ; 
Objects . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromPublisher < > ( publisher ) ) ; 
Objects . requireNonNull ( single , "single is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromSingle < > ( single ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromSupplier ( supplier ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableMergeIterable ( sources ) ) ; 
return merge0 ( sources , Integer . MAX_VALUE , false ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableMergeDelayErrorIterable ( sources ) ) ; 
return merge0 ( sources , Integer . MAX_VALUE , true ) ; 
return RxJavaPlugins . onAssembly ( CompletableNever . INSTANCE ) ; 
NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapCompletablePublisher < > ( sources , Functions . identity ( ) , false ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapCompletablePublisher < > ( sources , Functions . identity ( ) , true ) ) ; 
return using ( resourceSupplier , sourceSupplier , resourceCleanup , true ) ; 
Objects . requireNonNull ( source , "source is null" ) ; if ( source instanceof Completable ) return RxJavaPlugins . onAssembly ( ( Completable ) source ) ; return RxJavaPlugins . onAssembly ( new CompletableFromUnsafeSource ( source ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; 
Objects . requireNonNull ( next , "next is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableAndThenObservable < > ( this , next ) ) ; 
Objects . requireNonNull ( next , "next is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableAndThenPublisher < > ( this , next ) ) ; 
Objects . requireNonNull ( next , "next is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDelayWithCompletable < > ( next , this ) ) ; 
Objects . requireNonNull ( next , "next is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeDelayWithCompletable < > ( next , this ) ) ; 
Objects . requireNonNull ( next , "next is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableAndThenCompletable ( this , next ) ) ; 
BlockingMultiObserver < Void > observer = new BlockingMultiObserver < > ( ) ; subscribe ( observer ) ; observer . blockingGet ( ) ; 
blockingSubscribe ( Functions . EMPTY_ACTION , Functions . ERROR_CONSUMER ) ; 
blockingSubscribe ( onComplete , Functions . ERROR_CONSUMER ) ; 
Objects . requireNonNull ( onComplete , "onComplete is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; BlockingMultiObserver < Void > observer = new BlockingMultiObserver < > ( ) ; subscribe ( observer ) ; observer . blockingConsume ( Functions . emptyConsumer ( ) , onError , onComplete ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; BlockingDisposableMultiObserver < Void > blockingObserver = new BlockingDisposableMultiObserver < > ( ) ; observer . onSubscribe ( blockingObserver ) ; subscribe ( blockingObserver ) ; blockingObserver . blockingConsume ( observer ) ; 
return RxJavaPlugins . onAssembly ( new CompletableCache ( this ) ) ; 
return wrap ( Objects . requireNonNull ( transformer , "transformer is null" ) . apply ( this ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableAndThenCompletable ( this , other ) ) ; 
return doOnLifecycle ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , onComplete , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; 
return doOnLifecycle ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , onDispose ) ; 
return doOnLifecycle ( Functions . emptyConsumer ( ) , onError , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onEvent , "onEvent is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableDoOnEvent ( this , onEvent ) ) ; 
return doOnLifecycle ( onSubscribe , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , onDispose ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; Objects . requireNonNull ( onTerminate , "onTerminate is null" ) ; Objects . requireNonNull ( onAfterTerminate , "onAfterTerminate is null" ) ; Objects . requireNonNull ( onDispose , "onDispose is null" ) ; return RxJavaPlugins . onAssembly ( new CompletablePeek ( this , onSubscribe , onError , onComplete , onTerminate , onAfterTerminate , onDispose ) ) ; 
return doOnLifecycle ( onSubscribe , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; 
return doOnLifecycle ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , onTerminate , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION ) ; 
return doOnLifecycle ( Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , onAfterTerminate , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( onFinally , "onFinally is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableDoFinally ( this , onFinally ) ) ; 
Objects . requireNonNull ( onLift , "onLift is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableLift ( this , onLift ) ) ; 
return RxJavaPlugins . onAssembly ( new CompletableMaterialize < > ( this ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return mergeArray ( this , other ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableObserveOn ( this , scheduler ) ) ; 
return onErrorComplete ( Functions . alwaysTrue ( ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableOnErrorComplete ( this , predicate ) ) ; 
Objects . requireNonNull ( fallbackSupplier , "fallbackSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableResumeNext ( this , fallbackSupplier ) ) ; 
Objects . requireNonNull ( fallback , "fallback is null" ) ; return onErrorResumeNext ( Functions . justFunction ( fallback ) ) ; 
Objects . requireNonNull ( itemSupplier , "itemSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableOnErrorReturn < > ( this , itemSupplier ) ) ; 
return RxJavaPlugins . onAssembly ( new CompletableDetach ( this ) ) ; 
return fromPublisher ( toFlowable ( ) . repeat ( ) ) ; 
return fromPublisher ( toFlowable ( ) . repeatUntil ( stop ) ) ; 
return fromPublisher ( toFlowable ( ) . repeatWhen ( handler ) ) ; 
return fromPublisher ( toFlowable ( ) . retry ( ) ) ; 
return fromPublisher ( toFlowable ( ) . retry ( predicate ) ) ; 
return fromPublisher ( toFlowable ( ) . retry ( predicate ) ) ; 
Objects . requireNonNull ( stop , "stop is null" ) ; return retry ( Long . MAX_VALUE , Functions . predicateReverseFor ( stop ) ) ; 
return fromPublisher ( toFlowable ( ) . retryWhen ( handler ) ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; subscribe ( new SafeCompletableObserver ( observer ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return concatArray ( other , this ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Single . wrap ( other ) . toFlowable ( ) , toFlowable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Maybe . wrap ( other ) . toFlowable ( ) , toFlowable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Observable . wrap ( other ) . concatWith ( this . toObservable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return this . < T > toFlowable ( ) . startWith ( other ) ; 
return RxJavaPlugins . onAssembly ( new CompletableHide ( this ) ) ; 
EmptyCompletableObserver observer = new EmptyCompletableObserver ( ) ; subscribe ( observer ) ; return observer ; 
Objects . requireNonNull ( observer , "observer is null" ) ; try observer = RxJavaPlugins . onSubscribe ( this , observer ) ; Objects . requireNonNull ( observer , "The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins" ) ; subscribeActual ( observer ) ; catch ( NullPointerException ex ) throw ex ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; throw toNpe ( ex ) ; 
Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; CallbackCompletableObserver observer = new CallbackCompletableObserver ( onError , onComplete ) ; subscribe ( observer ) ; return observer ; 
Objects . requireNonNull ( onComplete , "onComplete is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( container , "container is null" ) ; DisposableAutoReleaseMultiObserver < Void > observer = new DisposableAutoReleaseMultiObserver < > ( container , Functions . emptyConsumer ( ) , onError , onComplete ) ; container . add ( observer ) ; subscribe ( observer ) ; return observer ; 
return subscribe ( onComplete , Functions . ON_ERROR_MISSING ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableSubscribeOn ( this , scheduler ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableTakeUntilCompletable ( this , other ) ) ; 
return Objects . requireNonNull ( converter , "converter is null" ) . apply ( this ) ; 
if ( this instanceof FuseToFlowable ) return ( ( FuseToFlowable < T > ) this ) . fuseToFlowable ( ) ; return RxJavaPlugins . onAssembly ( new CompletableToFlowable < > ( this ) ) ; 
return subscribeWith ( new FutureMultiObserver < > ( ) ) ; 
if ( this instanceof FuseToMaybe ) return ( ( FuseToMaybe < T > ) this ) . fuseToMaybe ( ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < > ( this ) ) ; 
if ( this instanceof FuseToObservable ) return ( ( FuseToObservable < T > ) this ) . fuseToObservable ( ) ; return RxJavaPlugins . onAssembly ( new CompletableToObservable < > ( this ) ) ; 
Objects . requireNonNull ( completionValueSupplier , "completionValueSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableToSingle < > ( this , completionValueSupplier , null ) ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableDisposeOn ( this , scheduler ) ) ; 
TestObserver < Void > to = new TestObserver < > ( ) ; subscribe ( to ) ; return to ; 
Objects . requireNonNull ( stage , "stage is null" ) ; return RxJavaPlugins . onAssembly ( new CompletableFromCompletionStage < > ( stage ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new SingleAmb < > ( null , sources ) ) ; 
return Flowable . fromIterable ( sources ) . concatMapSingleDelayError ( Functions . identity ( ) , false ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < > ( sources , Functions . identity ( ) , ErrorMode . IMMEDIATE , 2 ) ) ; 
return concat ( sources , 2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return Flowable . fromArray ( source1 , source2 ) . concatMapSingleDelayError ( Functions . identity ( ) , false ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return Flowable . fromArray ( source1 , source2 , source3 ) . concatMapSingleDelayError ( Functions . identity ( ) , false ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return Flowable . fromArray ( source1 , source2 , source3 , source4 ) . concatMapSingleDelayError ( Functions . identity ( ) , false ) ; 
return Flowable . fromIterable ( sources ) . concatMapSingleDelayError ( Functions . identity ( ) ) ; 
return Flowable . fromPublisher ( sources ) . concatMapSingleDelayError ( Functions . identity ( ) ) ; 
return Flowable . fromIterable ( sources ) . concatMapEagerDelayError ( SingleInternalHelper . toFlowable ( ) , false ) ; 
return Flowable . fromPublisher ( sources ) . concatMapEager ( SingleInternalHelper . toFlowable ( ) ) ; 
return Flowable . fromIterable ( sources ) . concatMapEagerDelayError ( SingleInternalHelper . toFlowable ( ) , true ) ; 
return Flowable . fromPublisher ( sources ) . concatMapEagerDelayError ( SingleInternalHelper . toFlowable ( ) , true ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new SingleCreate < > ( source ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDefer < > ( supplier ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new SingleError < > ( supplier ) ) ; 
Objects . requireNonNull ( throwable , "throwable is null" ) ; return error ( Functions . justSupplier ( throwable ) ) ; 
Objects . requireNonNull ( callable , "callable is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFromCallable < > ( callable ) ) ; 
return toSingle ( Flowable . fromFuture ( future ) ) ; 
Objects . requireNonNull ( maybe , "maybe is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeToSingle < > ( maybe , null ) ) ; 
Objects . requireNonNull ( publisher , "publisher is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFromPublisher < > ( publisher ) ) ; 
Objects . requireNonNull ( observable , "observable is null" ) ; return RxJavaPlugins . onAssembly ( new ObservableSingleSingle < > ( observable , null ) ) ; 
Objects . requireNonNull ( supplier , "supplier is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFromSupplier < > ( supplier ) ) ; 
return Flowable . fromIterable ( sources ) . flatMapSingle ( Functions . identity ( ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFlatMapSinglePublisher < > ( sources , Functions . identity ( ) , false , Integer . MAX_VALUE ) ) ; 
Objects . requireNonNull ( source , "source is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMap < SingleSource < ? extends T > , T > ( source , Functions . identity ( ) ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return Flowable . fromArray ( source1 , source2 ) . flatMapSingle ( Functions . identity ( ) , false , Integer . MAX_VALUE ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return Flowable . fromArray ( source1 , source2 , source3 ) . flatMapSingle ( Functions . identity ( ) , false , Integer . MAX_VALUE ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return Flowable . fromArray ( source1 , source2 , source3 , source4 ) . flatMapSingle ( Functions . identity ( ) , false , Integer . MAX_VALUE ) ; 
return Flowable . fromIterable ( sources ) . flatMapSingle ( Functions . identity ( ) , true , Integer . MAX_VALUE ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableFlatMapSinglePublisher < > ( sources , Functions . identity ( ) , true , Integer . MAX_VALUE ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return Flowable . fromArray ( source1 , source2 ) . flatMapSingle ( Functions . identity ( ) , true , Integer . MAX_VALUE ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; return Flowable . fromArray ( source1 , source2 , source3 ) . flatMapSingle ( Functions . identity ( ) , true , Integer . MAX_VALUE ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; return Flowable . fromArray ( source1 , source2 , source3 , source4 ) . flatMapSingle ( Functions . identity ( ) , true , Integer . MAX_VALUE ) ; 
return RxJavaPlugins . onAssembly ( ( Single < T > ) SingleNever . INSTANCE ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; return RxJavaPlugins . onAssembly ( new SingleEquals < > ( source1 , source2 ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapSinglePublisher < > ( sources , Functions . identity ( ) , false ) ) ; 
Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new FlowableSwitchMapSinglePublisher < > ( sources , Functions . identity ( ) , true ) ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; if ( onSubscribe instanceof Single ) throw new IllegalArgumentException ( "unsafeCreate(Single) should be upgraded" ) ; return RxJavaPlugins . onAssembly ( new SingleFromUnsafeSource < > ( onSubscribe ) ) ; 
return using ( resourceSupplier , sourceSupplier , resourceCleanup , true ) ; 
Objects . requireNonNull ( source , "source is null" ) ; if ( source instanceof Single ) return RxJavaPlugins . onAssembly ( ( Single < T > ) source ) ; return RxJavaPlugins . onAssembly ( new SingleFromUnsafeSource < > ( source ) ) ; 
Objects . requireNonNull ( zipper , "zipper is null" ) ; Objects . requireNonNull ( sources , "sources is null" ) ; return RxJavaPlugins . onAssembly ( new SingleZipIterable < > ( sources , zipper ) ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 , source6 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 ) ; 
Objects . requireNonNull ( source1 , "source1 is null" ) ; Objects . requireNonNull ( source2 , "source2 is null" ) ; Objects . requireNonNull ( source3 , "source3 is null" ) ; Objects . requireNonNull ( source4 , "source4 is null" ) ; Objects . requireNonNull ( source5 , "source5 is null" ) ; Objects . requireNonNull ( source6 , "source6 is null" ) ; Objects . requireNonNull ( source7 , "source7 is null" ) ; Objects . requireNonNull ( source8 , "source8 is null" ) ; Objects . requireNonNull ( source9 , "source9 is null" ) ; Objects . requireNonNull ( zipper , "zipper is null" ) ; return zipArray ( Functions . toFunction ( zipper ) , source1 , source2 , source3 , source4 , source5 , source6 , source7 , source8 , source9 ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return ambArray ( this , other ) ; 
return RxJavaPlugins . onAssembly ( new SingleHide < > ( this ) ) ; 
return wrap ( ( ( SingleTransformer < T , R > ) Objects . requireNonNull ( transformer , "transformer is null" ) ) . apply ( this ) ) ; 
return RxJavaPlugins . onAssembly ( new SingleCache < > ( this ) ) ; 
Objects . requireNonNull ( clazz , "clazz is null" ) ; return map ( Functions . castFunction ( clazz ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMap < > ( this , mapper ) ) ; 
return flatMapCompletable ( mapper ) ; 
return flatMapMaybe ( mapper ) ; 
return concat ( this , other ) ; 
Objects . requireNonNull ( subscriptionIndicator , "subscriptionIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDelayWithCompletable < > ( this , subscriptionIndicator ) ) ; 
Objects . requireNonNull ( subscriptionIndicator , "subscriptionIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDelayWithSingle < > ( this , subscriptionIndicator ) ) ; 
Objects . requireNonNull ( subscriptionIndicator , "subscriptionIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDelayWithObservable < > ( this , subscriptionIndicator ) ) ; 
Objects . requireNonNull ( subscriptionIndicator , "subscriptionIndicator is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDelayWithPublisher < > ( this , subscriptionIndicator ) ) ; 
Objects . requireNonNull ( selector , "selector is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDematerialize < > ( this , selector ) ) ; 
Objects . requireNonNull ( onAfterSuccess , "onAfterSuccess is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoAfterSuccess < > ( this , onAfterSuccess ) ) ; 
Objects . requireNonNull ( onAfterTerminate , "onAfterTerminate is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoAfterTerminate < > ( this , onAfterTerminate ) ) ; 
Objects . requireNonNull ( onFinally , "onFinally is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoFinally < > ( this , onFinally ) ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; Objects . requireNonNull ( onDispose , "onDispose is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoOnLifecycle < > ( this , onSubscribe , onDispose ) ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoOnSubscribe < > ( this , onSubscribe ) ) ; 
Objects . requireNonNull ( onTerminate , "onTerminate is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoOnTerminate < > ( this , onTerminate ) ) ; 
Objects . requireNonNull ( onSuccess , "onSuccess is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoOnSuccess < > ( this , onSuccess ) ) ; 
Objects . requireNonNull ( onEvent , "onEvent is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoOnEvent < > ( this , onEvent ) ) ; 
Objects . requireNonNull ( onError , "onError is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoOnError < > ( this , onError ) ) ; 
Objects . requireNonNull ( onDispose , "onDispose is null" ) ; return RxJavaPlugins . onAssembly ( new SingleDoOnDispose < > ( this , onDispose ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFilterSingle < > ( this , predicate ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMap < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; Objects . requireNonNull ( combiner , "combiner is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMapBiSelector < > ( this , mapper , combiner ) ) ; 
Objects . requireNonNull ( onSuccessMapper , "onSuccessMapper is null" ) ; Objects . requireNonNull ( onErrorMapper , "onErrorMapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMapNotification < > ( this , onSuccessMapper , onErrorMapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMapMaybe < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMapPublisher < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMapIterableFlowable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMapIterableObservable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMapObservable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlatMapCompletable < > ( this , mapper ) ) ; 
BlockingMultiObserver < T > observer = new BlockingMultiObserver < > ( ) ; subscribe ( observer ) ; return observer . blockingGet ( ) ; 
blockingSubscribe ( Functions . emptyConsumer ( ) , Functions . ERROR_CONSUMER ) ; 
blockingSubscribe ( onSuccess , Functions . ERROR_CONSUMER ) ; 
Objects . requireNonNull ( onSuccess , "onSuccess is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; BlockingMultiObserver < T > observer = new BlockingMultiObserver < > ( ) ; subscribe ( observer ) ; observer . blockingConsume ( onSuccess , onError , Functions . EMPTY_ACTION ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; BlockingDisposableMultiObserver < T > blockingObserver = new BlockingDisposableMultiObserver < > ( ) ; observer . onSubscribe ( blockingObserver ) ; subscribe ( blockingObserver ) ; blockingObserver . blockingConsume ( observer ) ; 
Objects . requireNonNull ( lift , "lift is null" ) ; return RxJavaPlugins . onAssembly ( new SingleLift < > ( this , lift ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleMap < > ( this , mapper ) ) ; 
return RxJavaPlugins . onAssembly ( new SingleMaterialize < > ( this ) ) ; 
return contains ( item , ObjectHelper . equalsPredicate ( ) ) ; 
Objects . requireNonNull ( item , "item is null" ) ; Objects . requireNonNull ( comparer , "comparer is null" ) ; return RxJavaPlugins . onAssembly ( new SingleContains < > ( this , item , comparer ) ) ; 
return merge ( this , other ) ; 
Objects . requireNonNull ( clazz , "clazz is null" ) ; return filter ( Functions . isInstanceOf ( clazz ) ) . cast ( clazz ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new SingleObserveOn < > ( this , scheduler ) ) ; 
Objects . requireNonNull ( itemSupplier , "itemSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new SingleOnErrorReturn < > ( this , itemSupplier , null ) ) ; 
Objects . requireNonNull ( fallback , "fallback is null" ) ; return onErrorResumeNext ( Functions . justFunction ( fallback ) ) ; 
return onErrorComplete ( Functions . alwaysTrue ( ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new SingleOnErrorComplete < > ( this , predicate ) ) ; 
Objects . requireNonNull ( fallbackSupplier , "fallbackSupplier is null" ) ; return RxJavaPlugins . onAssembly ( new SingleResumeNext < > ( this , fallbackSupplier ) ) ; 
return RxJavaPlugins . onAssembly ( new SingleDetach < > ( this ) ) ; 
return toFlowable ( ) . repeat ( ) ; 
return toFlowable ( ) . repeatWhen ( handler ) ; 
return toFlowable ( ) . repeatUntil ( stop ) ; 
return toSingle ( toFlowable ( ) . retry ( ) ) ; 
return toSingle ( toFlowable ( ) . retry ( predicate ) ) ; 
return toSingle ( toFlowable ( ) . retry ( predicate ) ) ; 
Objects . requireNonNull ( stop , "stop is null" ) ; return retry ( Long . MAX_VALUE , Functions . predicateReverseFor ( stop ) ) ; 
return toSingle ( toFlowable ( ) . retryWhen ( handler ) ) ; 
Objects . requireNonNull ( observer , "observer is null" ) ; subscribe ( new SafeSingleObserver < > ( observer ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Completable . wrap ( other ) . < T > toFlowable ( ) , toFlowable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Single . wrap ( other ) . toFlowable ( ) , toFlowable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Flowable . concat ( Maybe . wrap ( other ) . toFlowable ( ) , toFlowable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return Observable . wrap ( other ) . concatWith ( this . toObservable ( ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return toFlowable ( ) . startWith ( other ) ; 
return subscribe ( Functions . emptyConsumer ( ) , Functions . ON_ERROR_MISSING ) ; 
Objects . requireNonNull ( onCallback , "onCallback is null" ) ; BiConsumerSingleObserver < T > observer = new BiConsumerSingleObserver < > ( onCallback ) ; subscribe ( observer ) ; return observer ; 
return subscribe ( onSuccess , Functions . ON_ERROR_MISSING ) ; 
Objects . requireNonNull ( onSuccess , "onSuccess is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; ConsumerSingleObserver < T > observer = new ConsumerSingleObserver < > ( onSuccess , onError ) ; subscribe ( observer ) ; return observer ; 
Objects . requireNonNull ( onSuccess , "onSuccess is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( container , "container is null" ) ; DisposableAutoReleaseMultiObserver < T > observer = new DisposableAutoReleaseMultiObserver < > ( container , onSuccess , onError , Functions . EMPTY_ACTION ) ; container . add ( observer ) ; subscribe ( observer ) ; return observer ; 
Objects . requireNonNull ( observer , "observer is null" ) ; observer = RxJavaPlugins . onSubscribe ( this , observer ) ; Objects . requireNonNull ( observer , "The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins" ) ; try subscribeActual ( observer ) ; catch ( NullPointerException ex ) throw ex ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; NullPointerException npe = new NullPointerException ( "subscribeActual failed" ) ; npe . initCause ( ex ) ; throw npe ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new SingleSubscribeOn < > ( this , scheduler ) ) ; 
return timeInterval ( TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; 
return timeInterval ( TimeUnit . MILLISECONDS , scheduler ) ; 
return timeInterval ( unit , Schedulers . computation ( ) ) ; 
Objects . requireNonNull ( unit , "unit is null" ) ; Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new SingleTimeInterval < > ( this , unit , scheduler , true ) ) ; 
return timestamp ( TimeUnit . MILLISECONDS , Schedulers . computation ( ) ) ; 
return timestamp ( TimeUnit . MILLISECONDS , scheduler ) ; 
return timestamp ( unit , Schedulers . computation ( ) ) ; 
Objects . requireNonNull ( unit , "unit is null" ) ; Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new SingleTimeInterval < > ( this , unit , scheduler , false ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return takeUntil ( new CompletableToFlowable < T > ( other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return RxJavaPlugins . onAssembly ( new SingleTakeUntil < > ( this , other ) ) ; 
Objects . requireNonNull ( other , "other is null" ) ; return takeUntil ( new SingleToFlowable < E > ( other ) ) ; 
return Objects . requireNonNull ( converter , "converter is null" ) . apply ( this ) ; 
return RxJavaPlugins . onAssembly ( new CompletableFromSingle < > ( this ) ) ; 
if ( this instanceof FuseToFlowable ) return ( ( FuseToFlowable < T > ) this ) . fuseToFlowable ( ) ; return RxJavaPlugins . onAssembly ( new SingleToFlowable < > ( this ) ) ; 
return subscribeWith ( new FutureMultiObserver < > ( ) ) ; 
if ( this instanceof FuseToMaybe ) return ( ( FuseToMaybe < T > ) this ) . fuseToMaybe ( ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < > ( this ) ) ; 
if ( this instanceof FuseToObservable ) return ( ( FuseToObservable < T > ) this ) . fuseToObservable ( ) ; return RxJavaPlugins . onAssembly ( new SingleToObservable < > ( this ) ) ; 
Objects . requireNonNull ( scheduler , "scheduler is null" ) ; return RxJavaPlugins . onAssembly ( new SingleUnsubscribeOn < > ( this , scheduler ) ) ; 
return zip ( this , other , zipper ) ; 
TestObserver < T > to = new TestObserver < > ( ) ; subscribe ( to ) ; return to ; 
return RxJavaPlugins . onAssembly ( new FlowableSingleSingle < > ( source , null ) ) ; 
Objects . requireNonNull ( stage , "stage is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFromCompletionStage < > ( stage ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleMapOptional < > ( this , mapper ) ) ; 
return subscribeWith ( new CompletionStageConsumer < > ( false , null ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlattenStreamAsFlowable < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new SingleFlattenStreamAsObservable < > ( this , mapper ) ) ; 
return value == null ; 
return NotificationLite . isError ( value ) ; 
Object o = value ; return o != null && ! NotificationLite . isError ( o ) ; 
Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) return ( T ) value ; return null ; 
Object o = value ; if ( NotificationLite . isError ( o ) ) return NotificationLite . getError ( o ) ; return null ; 
if ( obj instanceof Notification ) Notification < ? > n = ( Notification < ? > ) obj ; return Objects . equals ( value , n . value ) ; return false ; 
Object o = value ; return o != null ? o . hashCode ( ) : 0 ; 
Object o = value ; if ( o == null ) return "OnCompleteNotification" ; if ( NotificationLite . isError ( o ) ) return "OnErrorNotification[" + NotificationLite . getError ( o ) + "]" ; return "OnNextNotification[" + value + "]" ; 
Objects . requireNonNull ( error , "error is null" ) ; return new Notification < > ( NotificationLite . error ( error ) ) ; 
return ( Notification < T > ) COMPLETE ; 
return new TestSubscriber < > ( ) ; 
return new TestSubscriber < > ( delegate ) ; 
lastThread = Thread . currentThread ( ) ; if ( s == null ) errors . add ( new NullPointerException ( "onSubscribe received a null Subscription" ) ) ; return ; if ( ! upstream . compareAndSet ( null , s ) ) s . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) errors . add ( new IllegalStateException ( "onSubscribe received multiple subscriptions: " + s ) ) ; return ; downstream . onSubscribe ( s ) ; long mr = missedRequested . getAndSet ( 0L ) ; if ( mr != 0L ) s . request ( mr ) ; onStart ( ) ; 
$EMPTY$
if ( ! checkSubscriptionOnce ) checkSubscriptionOnce = true ; if ( upstream . get ( ) == null ) errors . add ( new IllegalStateException ( "onSubscribe not called in proper order" ) ) ; try lastThread = Thread . currentThread ( ) ; if ( t == null ) errors . add ( new NullPointerException ( "onError received a null Throwable" ) ) ; else errors . add ( t ) ; downstream . onError ( t ) ; finally done . countDown ( ) ; 
if ( ! checkSubscriptionOnce ) checkSubscriptionOnce = true ; if ( upstream . get ( ) == null ) errors . add ( new IllegalStateException ( "onSubscribe not called in proper order" ) ) ; try lastThread = Thread . currentThread ( ) ; completions ++ ; downstream . onComplete ( ) ; finally done . countDown ( ) ; 
if ( ! cancelled ) cancelled = true ; SubscriptionHelper . cancel ( upstream ) ; 
return cancelled ; 
cancel ( ) ; 
return cancelled ; 
return upstream . get ( ) != null ; 
if ( upstream . get ( ) == null ) throw fail ( "Not subscribed!" ) ; return this ; 
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
if ( EndConsumerHelper . validate ( this . upstream , s , getClass ( ) ) ) this . upstream = s ; onStart ( ) ; 
Subscription s = this . upstream ; this . upstream = SubscriptionHelper . CANCELLED ; s . cancel ( ) ; 
request ( Long . MAX_VALUE ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; try downstream . onSubscribe ( this ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; done = true ; try s . cancel ( ) ; catch ( Throwable e1 ) Exceptions . throwIfFatal ( e1 ) ; RxJavaPlugins . onError ( new CompositeException ( e , e1 ) ) ; return ; RxJavaPlugins . onError ( e ) ; 
done = true ; Throwable ex = new NullPointerException ( "Subscription not set!" ) ; try downstream . onSubscribe ( EmptySubscription . INSTANCE ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( ex , e ) ) ; return ; try downstream . onError ( ex ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( ex , e ) ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; if ( upstream == null ) Throwable npe = new NullPointerException ( "Subscription not set!" ) ; try downstream . onSubscribe ( EmptySubscription . INSTANCE ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , npe , e ) ) ; return ; try downstream . onError ( new CompositeException ( t , npe ) ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , npe , e ) ) ; return ; if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; try downstream . onError ( t ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( t , ex ) ) ; 
if ( done ) return ; done = true ; if ( upstream == null ) onCompleteNoSubscription ( ) ; return ; try downstream . onComplete ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
Throwable ex = new NullPointerException ( "Subscription not set!" ) ; try downstream . onSubscribe ( EmptySubscription . INSTANCE ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( ex , e ) ) ; return ; try downstream . onError ( ex ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( ex , e ) ) ; 
try upstream . cancel ( ) ; catch ( Throwable e1 ) Exceptions . throwIfFatal ( e1 ) ; RxJavaPlugins . onError ( e1 ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; boolean reportError ; synchronized ( this ) if ( done ) reportError = true ; else if ( emitting ) done = true ; AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( QUEUE_LINK_SIZE ) ; queue = q ; Object err = NotificationLite . error ( t ) ; if ( delayError ) q . add ( err ) ; else q . setFirst ( err ) ; return ; else done = true ; emitting = true ; reportError = false ; if ( reportError ) RxJavaPlugins . onError ( t ) ; return ; downstream . onError ( t ) ; 
if ( done ) return ; synchronized ( this ) if ( done ) return ; if ( emitting ) AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( QUEUE_LINK_SIZE ) ; queue = q ; q . add ( NotificationLite . complete ( ) ) ; return ; done = true ; emitting = true ; downstream . onComplete ( ) ; 
for ( ; ; ) AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) q = queue ; if ( q == null ) emitting = false ; return ; queue = null ; if ( q . accept ( downstream ) ) return ; 
upstream . cancel ( ) ; 
Objects . requireNonNull ( resource , "resource is null" ) ; resources . add ( resource ) ; 
if ( EndConsumerHelper . setOnce ( this . upstream , s , getClass ( ) ) ) long r = missedRequested . getAndSet ( 0L ) ; if ( r != 0L ) s . request ( r ) ; onStart ( ) ; 
request ( Long . MAX_VALUE ) ; 
if ( SubscriptionHelper . cancel ( upstream ) ) resources . dispose ( ) ; 
return upstream . get ( ) == SubscriptionHelper . CANCELLED ; 
if ( EndConsumerHelper . setOnce ( this . upstream , s , getClass ( ) ) ) onStart ( ) ; 
upstream . get ( ) . request ( Long . MAX_VALUE ) ; 
dispose ( ) ; 
return upstream . get ( ) == SubscriptionHelper . CANCELLED ; 
SubscriptionHelper . cancel ( upstream ) ; 
soElement ( curr , calcDirectOffset ( curr . length ( ) - 1 ) , next ) ; 
final AtomicReferenceArray < Object > buffer = consumerBuffer ; final long index = lpConsumerIndex ( ) ; final int mask = consumerMask ; final int offset = calcWrappedOffset ( index , mask ) ; final Object e = lvElement ( buffer , offset ) ; boolean isNextBuffer = e == HAS_NEXT ; if ( null != e && ! isNextBuffer ) soElement ( buffer , offset , null ) ; soConsumerIndex ( index + 1 ) ; return ( T ) e ; else if ( isNextBuffer ) return newBufferPoll ( lvNextBufferAndUnlink ( buffer , mask + 1 ) , index , mask ) ; return null ; 
final AtomicReferenceArray < Object > buffer = consumerBuffer ; final long index = lpConsumerIndex ( ) ; final int mask = consumerMask ; final int offset = calcWrappedOffset ( index , mask ) ; final Object e = lvElement ( buffer , offset ) ; if ( e == HAS_NEXT ) return newBufferPeek ( lvNextBufferAndUnlink ( buffer , mask + 1 ) , index , mask ) ; return ( T ) e ; 
while ( poll ( ) != null || ! isEmpty ( ) ) 
long after = lvConsumerIndex ( ) ; while ( true ) final long before = after ; final long currentProducerIndex = lvProducerIndex ( ) ; after = lvConsumerIndex ( ) ; if ( before == after ) return ( int ) ( currentProducerIndex - after ) ; 
return lvProducerIndex ( ) == lvConsumerIndex ( ) ; 
return producerIndex . get ( ) ; 
return consumerIndex . get ( ) ; 
return producerIndex . get ( ) ; 
return consumerIndex . get ( ) ; 
final long index = consumerIndex . get ( ) ; final int offset = calcElementOffset ( index ) ; final E e = lvElement ( offset ) ; if ( null == e ) return null ; soConsumerIndex ( index + 1 ) ; soElement ( offset , null ) ; return e ; 
return producerIndex . get ( ) == consumerIndex . get ( ) ; 
while ( poll ( ) != null || ! isEmpty ( ) ) 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
done = true ; upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; boolean reportError ; synchronized ( this ) if ( done ) reportError = true ; else if ( emitting ) done = true ; AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( QUEUE_LINK_SIZE ) ; queue = q ; Object err = NotificationLite . error ( t ) ; if ( delayError ) q . add ( err ) ; else q . setFirst ( err ) ; return ; else done = true ; emitting = true ; reportError = false ; if ( reportError ) RxJavaPlugins . onError ( t ) ; return ; downstream . onError ( t ) ; 
if ( done ) return ; synchronized ( this ) if ( done ) return ; if ( emitting ) AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( QUEUE_LINK_SIZE ) ; queue = q ; q . add ( NotificationLite . complete ( ) ) ; return ; done = true ; emitting = true ; downstream . onComplete ( ) ; 
for ( ; ; ) AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) q = queue ; if ( q == null ) emitting = false ; return ; queue = null ; if ( q . accept ( downstream ) ) return ; 
Objects . requireNonNull ( resource , "resource is null" ) ; resources . add ( resource ) ; 
if ( EndConsumerHelper . setOnce ( this . upstream , d , getClass ( ) ) ) onStart ( ) ; 
$EMPTY$
if ( DisposableHelper . dispose ( upstream ) ) resources . dispose ( ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
if ( EndConsumerHelper . setOnce ( this . upstream , d , getClass ( ) ) ) onStart ( ) ; 
$EMPTY$
return upstream . get ( ) == DisposableHelper . DISPOSED ; 
DisposableHelper . dispose ( upstream ) ; 
Objects . requireNonNull ( resource , "resource is null" ) ; resources . add ( resource ) ; 
if ( EndConsumerHelper . setOnce ( this . upstream , d , getClass ( ) ) ) onStart ( ) ; 
$EMPTY$
if ( DisposableHelper . dispose ( upstream ) ) resources . dispose ( ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
if ( EndConsumerHelper . setOnce ( this . upstream , d , getClass ( ) ) ) onStart ( ) ; 
$EMPTY$
return upstream . get ( ) == DisposableHelper . DISPOSED ; 
DisposableHelper . dispose ( upstream ) ; 
if ( EndConsumerHelper . validate ( this . upstream , d , getClass ( ) ) ) this . upstream = d ; onStart ( ) ; 
Disposable upstream = this . upstream ; this . upstream = DisposableHelper . DISPOSED ; upstream . dispose ( ) ; 
$EMPTY$
if ( EndConsumerHelper . setOnce ( this . upstream , d , getClass ( ) ) ) onStart ( ) ; 
$EMPTY$
return upstream . get ( ) == DisposableHelper . DISPOSED ; 
DisposableHelper . dispose ( upstream ) ; 
Objects . requireNonNull ( resource , "resource is null" ) ; resources . add ( resource ) ; 
if ( EndConsumerHelper . setOnce ( this . upstream , d , getClass ( ) ) ) onStart ( ) ; 
$EMPTY$
if ( DisposableHelper . dispose ( upstream ) ) resources . dispose ( ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
return new TestObserver < > ( ) ; 
return new TestObserver < > ( delegate ) ; 
lastThread = Thread . currentThread ( ) ; if ( d == null ) errors . add ( new NullPointerException ( "onSubscribe received a null Subscription" ) ) ; return ; if ( ! upstream . compareAndSet ( null , d ) ) d . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) errors . add ( new IllegalStateException ( "onSubscribe received multiple subscriptions: " + d ) ) ; return ; downstream . onSubscribe ( d ) ; 
if ( ! checkSubscriptionOnce ) checkSubscriptionOnce = true ; if ( upstream . get ( ) == null ) errors . add ( new IllegalStateException ( "onSubscribe not called in proper order" ) ) ; try lastThread = Thread . currentThread ( ) ; if ( t == null ) errors . add ( new NullPointerException ( "onError received a null Throwable" ) ) ; else errors . add ( t ) ; downstream . onError ( t ) ; finally done . countDown ( ) ; 
if ( ! checkSubscriptionOnce ) checkSubscriptionOnce = true ; if ( upstream . get ( ) == null ) errors . add ( new IllegalStateException ( "onSubscribe not called in proper order" ) ) ; try lastThread = Thread . currentThread ( ) ; completions ++ ; downstream . onComplete ( ) ; finally done . countDown ( ) ; 
DisposableHelper . dispose ( upstream ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
return upstream . get ( ) != null ; 
if ( upstream . get ( ) == null ) throw fail ( "Not subscribed!" ) ; return this ; 
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
if ( EndConsumerHelper . setOnce ( this . upstream , d , getClass ( ) ) ) onStart ( ) ; 
$EMPTY$
return upstream . get ( ) == DisposableHelper . DISPOSED ; 
DisposableHelper . dispose ( upstream ) ; 
Objects . requireNonNull ( resource , "resource is null" ) ; resources . add ( resource ) ; 
if ( EndConsumerHelper . setOnce ( this . upstream , d , getClass ( ) ) ) onStart ( ) ; 
$EMPTY$
if ( DisposableHelper . dispose ( upstream ) ) resources . dispose ( ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; try downstream . onSubscribe ( this ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; done = true ; try d . dispose ( ) ; catch ( Throwable e1 ) Exceptions . throwIfFatal ( e1 ) ; RxJavaPlugins . onError ( new CompositeException ( e , e1 ) ) ; return ; RxJavaPlugins . onError ( e ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
done = true ; Throwable ex = new NullPointerException ( "Subscription not set!" ) ; try downstream . onSubscribe ( EmptyDisposable . INSTANCE ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( ex , e ) ) ; return ; try downstream . onError ( ex ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( ex , e ) ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; if ( upstream == null ) Throwable npe = new NullPointerException ( "Subscription not set!" ) ; try downstream . onSubscribe ( EmptyDisposable . INSTANCE ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , npe , e ) ) ; return ; try downstream . onError ( new CompositeException ( t , npe ) ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , npe , e ) ) ; return ; if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; try downstream . onError ( t ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( t , ex ) ) ; 
if ( done ) return ; done = true ; if ( upstream == null ) onCompleteNoSubscription ( ) ; return ; try downstream . onComplete ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
Throwable ex = new NullPointerException ( "Subscription not set!" ) ; try downstream . onSubscribe ( EmptyDisposable . INSTANCE ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( ex , e ) ) ; return ; try downstream . onError ( ex ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( ex , e ) ) ; 
return values ; 
StringBuilder b = new StringBuilder ( 64 + message . length ( ) ) ; b . append ( message ) ; b . append ( " (" ) . append ( "latch = " ) . append ( done . getCount ( ) ) . append ( ", " ) . append ( "values = " ) . append ( values . size ( ) ) . append ( ", " ) . append ( "errors = " ) . append ( errors . size ( ) ) . append ( ", " ) . append ( "completions = " ) . append ( completions ) ; if ( timeout ) b . append ( ", timeout!" ) ; if ( isDisposed ( ) ) b . append ( ", disposed!" ) ; CharSequence tag = this . tag ; if ( tag != null ) b . append ( ", tag = " ) . append ( tag ) ; b . append ( ')' ) ; AssertionError ae = new AssertionError ( b . toString ( ) ) ; if ( ! errors . isEmpty ( ) ) if ( errors . size ( ) == 1 ) ae . initCause ( errors . get ( 0 ) ) ; else CompositeException ce = new CompositeException ( errors ) ; ae . initCause ( ce ) ; return ae ; 
if ( done . getCount ( ) == 0 ) return ( U ) this ; done . await ( ) ; return ( U ) this ; 
long c = completions ; if ( c == 0 ) throw fail ( "Not completed" ) ; else if ( c > 1 ) throw fail ( "Multiple completions: " + c ) ; return ( U ) this ; 
long c = completions ; if ( c == 1 ) throw fail ( "Completed!" ) ; else if ( c > 1 ) throw fail ( "Multiple completions: " + c ) ; return ( U ) this ; 
int s = errors . size ( ) ; if ( s != 0 ) throw fail ( "Error(s) present: " + errors ) ; return ( U ) this ; 
return assertError ( Functions . equalsWith ( error ) , true ) ; 
return ( U ) assertError ( ( Predicate ) Functions . isInstanceOf ( errorClass ) , true ) ; 
return assertError ( errorPredicate , false ) ; 
assertValueAt ( 0 , valuePredicate ) ; if ( values . size ( ) > 1 ) throw fail ( "The first value passed the predicate but this consumer received more than one value" ) ; return ( U ) this ; 
if ( o != null ) return o + " (class: " + o . getClass ( ) . getSimpleName ( ) + ")" ; return "null" ; 
return assertValueCount ( 0 ) ; 
int i = 0 ; Iterator < T > actualIterator = values . iterator ( ) ; Iterator < ? extends T > expectedIterator = sequence . iterator ( ) ; boolean actualNext ; boolean expectedNext ; for ( ; ; ) expectedNext = expectedIterator . hasNext ( ) ; actualNext = actualIterator . hasNext ( ) ; if ( ! actualNext || ! expectedNext ) break ; T u = expectedIterator . next ( ) ; T v = actualIterator . next ( ) ; if ( ! Objects . equals ( u , v ) ) throw fail ( "\nexpected: " + valueAndClass ( u ) + "\ngot: " + valueAndClass ( v ) + "; Value at position " + i + " differ" ) ; i ++ ; if ( actualNext ) throw fail ( "More values received than expected (" + i + ")" ) ; if ( expectedNext ) throw fail ( "Fewer values received than expected (" + i + ")" ) ; return ( U ) this ; 
return assertSubscribed ( ) . assertNoValues ( ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
this . tag = tag ; return ( U ) this ; 
return key ; 
ConnectConsumer cc = new ConnectConsumer ( ) ; connect ( cc ) ; return cc . disposable ; 
return RxJavaPlugins . onAssembly ( new FlowableRefCount < > ( this ) ) ; 
return autoConnect ( 1 ) ; 
return exceptions ; 
return message ; 
if ( cause == null ) String separator = System . getProperty ( "line.separator" ) ; if ( exceptions . size ( ) > 1 ) Map < Throwable , Boolean > seenCauses = new IdentityHashMap < > ( ) ; StringBuilder aggregateMessage = new StringBuilder ( ) ; aggregateMessage . append ( "Multiple exceptions (" ) . append ( exceptions . size ( ) ) . append ( ")" ) . append ( separator ) ; for ( Throwable inner : exceptions ) int depth = 0 ; while ( inner != null ) for ( int i = 0 ; i < depth ; i ++ ) aggregateMessage . append ( "  " ) ; aggregateMessage . append ( "|-- " ) ; aggregateMessage . append ( inner . getClass ( ) . getCanonicalName ( ) ) . append ( ": " ) ; String innerMessage = inner . getMessage ( ) ; if ( innerMessage != null && innerMessage . contains ( separator ) ) aggregateMessage . append ( separator ) ; for ( String line : innerMessage . split ( separator ) ) for ( int i = 0 ; i < depth + 2 ; i ++ ) aggregateMessage . append ( "  " ) ; aggregateMessage . append ( line ) . append ( separator ) ; else aggregateMessage . append ( innerMessage ) ; aggregateMessage . append ( separator ) ; for ( int i = 0 ; i < depth + 2 ; i ++ ) aggregateMessage . append ( "  " ) ; StackTraceElement [ ] st = inner . getStackTrace ( ) ; if ( st . length > 0 ) aggregateMessage . append ( "at " ) . append ( st [ 0 ] ) . append ( separator ) ; if ( ! seenCauses . containsKey ( inner ) ) seenCauses . put ( inner , true ) ; inner = inner . getCause ( ) ; depth ++ ; else inner = inner . getCause ( ) ; if ( inner != null ) for ( int i = 0 ; i < depth + 2 ; i ++ ) aggregateMessage . append ( "  " ) ; aggregateMessage . append ( "|-- " ) ; aggregateMessage . append ( "(cause not expanded again) " ) ; aggregateMessage . append ( inner . getClass ( ) . getCanonicalName ( ) ) . append ( ": " ) ; aggregateMessage . append ( inner . getMessage ( ) ) ; aggregateMessage . append ( separator ) ; break ; cause = new ExceptionOverview ( aggregateMessage . toString ( ) . trim ( ) ) ; else cause = exceptions . get ( 0 ) ; return cause ; 
printStackTrace ( System . err ) ; 
printStackTrace ( new WrappedPrintStream ( s ) ) ; 
printStackTrace ( new WrappedPrintWriter ( s ) ) ; 
printStream . print ( o ) ; return this ; 
printWriter . print ( o ) ; return this ; 
return this ; 
return exceptions . size ( ) ; 
throw ExceptionHelper . wrapOrThrow ( t ) ; 
if ( t instanceof VirtualMachineError ) throw ( VirtualMachineError ) t ; else if ( t instanceof ThreadDeath ) throw ( ThreadDeath ) t ; else if ( t instanceof LinkageError ) throw ( LinkageError ) t ; 
return false ; 
return false ; 
return null ; 
disposable . dispose ( ) ; 
return disposable . isDisposed ( ) ; 
final Worker actualWorker = actualScheduler . createWorker ( ) ; final FlowableProcessor < ScheduledAction > actionProcessor = UnicastProcessor . < ScheduledAction > create ( ) . toSerialized ( ) ; Flowable < Completable > actions = actionProcessor . map ( new CreateWorkerFunction ( actualWorker ) ) ; Worker worker = new QueueWorker ( actionProcessor , actualWorker ) ; workerProcessor . onNext ( actions ) ; return worker ; 
return get ( ) . isDisposed ( ) ; 
getAndSet ( DISPOSED ) . dispose ( ) ; 
try action . run ( ) ; finally actionCompletable . onComplete ( ) ; 
actionCompletable . onSubscribe ( action ) ; action . call ( actualWorker , actionCompletable ) ; 
if ( unsubscribed . compareAndSet ( false , true ) ) actionProcessor . onComplete ( ) ; actualWorker . dispose ( ) ; 
return unsubscribed . get ( ) ; 
ImmediateAction immediateAction = new ImmediateAction ( action ) ; actionProcessor . onNext ( immediateAction ) ; return immediateAction ; 
$EMPTY$
return false ; 
return schedule ( run , 0 , null ) ; 
if ( ! disposed ) disposed = true ; executor . shutdownNow ( ) ; 
if ( ! disposed ) disposed = true ; executor . shutdown ( ) ; 
return disposed ; 
run ( ) ; return null ; 
lazySet ( THREAD_INDEX , Thread . currentThread ( ) ) ; try try actual . run ( ) ; catch ( Throwable e ) RxJavaPlugins . onError ( e ) ; throw e ; finally Object o = get ( PARENT_INDEX ) ; if ( o != PARENT_DISPOSED && compareAndSet ( PARENT_INDEX , o , DONE ) && o != null ) ( ( DisposableContainer ) o ) . delete ( this ) ; for ( ; ; ) o = get ( FUTURE_INDEX ) ; if ( o == SYNC_DISPOSED || o == ASYNC_DISPOSED || compareAndSet ( FUTURE_INDEX , o , DONE ) ) break ; lazySet ( THREAD_INDEX , null ) ; 
for ( ; ; ) Object o = get ( FUTURE_INDEX ) ; if ( o == DONE ) return ; if ( o == SYNC_DISPOSED ) f . cancel ( false ) ; return ; if ( o == ASYNC_DISPOSED ) f . cancel ( true ) ; return ; if ( compareAndSet ( FUTURE_INDEX , o , f ) ) return ; 
for ( ; ; ) Object o = get ( FUTURE_INDEX ) ; if ( o == DONE || o == SYNC_DISPOSED || o == ASYNC_DISPOSED ) break ; boolean async = get ( THREAD_INDEX ) != Thread . currentThread ( ) ; if ( compareAndSet ( FUTURE_INDEX , o , async ? ASYNC_DISPOSED : SYNC_DISPOSED ) ) if ( o != null ) ( ( Future < ? > ) o ) . cancel ( async ) ; break ; for ( ; ; ) Object o = get ( PARENT_INDEX ) ; if ( o == DONE || o == PARENT_DISPOSED || o == null ) return ; if ( compareAndSet ( PARENT_INDEX , o , PARENT_DISPOSED ) ) ( ( DisposableContainer ) o ) . delete ( this ) ; return ; 
Object o = get ( PARENT_INDEX ) ; return o == PARENT_DISPOSED || o == DONE ; 
String state ; Object o = get ( FUTURE_INDEX ) ; if ( o == DONE ) state = "Finished" ; else if ( o == SYNC_DISPOSED ) state = "Disposed(Sync)" ; else if ( o == ASYNC_DISPOSED ) state = "Disposed(Async)" ; else o = get ( THREAD_INDEX ) ; if ( o == null ) state = "Waiting" ; else state = "Running on " + o ; return getClass ( ) . getSimpleName ( ) + "[" + state + "]" ; 
runner = Thread . currentThread ( ) ; try task . run ( ) ; runner = null ; setRest ( executor . submit ( this ) ) ; catch ( Throwable ex ) runner = null ; RxJavaPlugins . onError ( ex ) ; throw ex ; return null ; 
Future < ? > current = first . getAndSet ( CANCELLED ) ; if ( current != null && current != CANCELLED ) current . cancel ( runner != Thread . currentThread ( ) ) ; current = rest . getAndSet ( CANCELLED ) ; if ( current != null && current != CANCELLED ) current . cancel ( runner != Thread . currentThread ( ) ) ; 
return first . get ( ) == CANCELLED ; 
for ( ; ; ) Future < ? > current = first . get ( ) ; if ( current == CANCELLED ) f . cancel ( runner != Thread . currentThread ( ) ) ; return ; if ( first . compareAndSet ( current , f ) ) return ; 
for ( ; ; ) Future < ? > current = rest . get ( ) ; if ( current == CANCELLED ) f . cancel ( runner != Thread . currentThread ( ) ) ; return ; if ( rest . compareAndSet ( current , f ) ) return ; 
runner = Thread . currentThread ( ) ; try runnable . run ( ) ; runner = null ; catch ( Throwable ex ) dispose ( ) ; runner = null ; RxJavaPlugins . onError ( ex ) ; throw ex ; 
evictExpiredWorkers ( expiringWorkerQueue , allWorkers ) ; 
if ( allWorkers . isDisposed ( ) ) return SHUTDOWN_THREAD_WORKER ; while ( ! expiringWorkerQueue . isEmpty ( ) ) ThreadWorker threadWorker = expiringWorkerQueue . poll ( ) ; if ( threadWorker != null ) return threadWorker ; ThreadWorker w = new ThreadWorker ( threadFactory ) ; allWorkers . add ( w ) ; return w ; 
if ( ! expiringWorkerQueue . isEmpty ( ) ) long currentTimestamp = now ( ) ; for ( ThreadWorker threadWorker : expiringWorkerQueue ) if ( threadWorker . getExpirationTime ( ) <= currentTimestamp ) if ( expiringWorkerQueue . remove ( threadWorker ) ) allWorkers . remove ( threadWorker ) ; else break ; 
return System . nanoTime ( ) ; 
allWorkers . dispose ( ) ; if ( evictorTask != null ) evictorTask . cancel ( true ) ; if ( evictorService != null ) evictorService . shutdownNow ( ) ; 
CachedWorkerPool update = new CachedWorkerPool ( KEEP_ALIVE_TIME , KEEP_ALIVE_UNIT , threadFactory ) ; if ( ! pool . compareAndSet ( NONE , update ) ) update . shutdown ( ) ; 
CachedWorkerPool curr = pool . getAndSet ( NONE ) ; if ( curr != NONE ) curr . shutdown ( ) ; 
return new EventLoopWorker ( pool . get ( ) ) ; 
return pool . get ( ) . allWorkers . size ( ) ; 
if ( once . compareAndSet ( false , true ) ) tasks . dispose ( ) ; if ( USE_SCHEDULED_RELEASE ) threadWorker . scheduleActual ( this , 0 , TimeUnit . NANOSECONDS , null ) ; else pool . release ( threadWorker ) ; 
pool . release ( threadWorker ) ; 
return once . get ( ) ; 
return expirationTime ; 
runner = Thread . currentThread ( ) ; try try runnable . run ( ) ; finally lazySet ( FINISHED ) ; runner = null ; catch ( Throwable ex ) RxJavaPlugins . onError ( ex ) ; throw ex ; return null ; 
Future < ? > f = get ( ) ; if ( f != FINISHED && f != DISPOSED ) if ( compareAndSet ( f , DISPOSED ) ) if ( f != null ) cancelFuture ( f ) ; 
Future < ? > f = get ( ) ; return f == FINISHED || f == DISPOSED ; 
for ( ; ; ) Future < ? > f = get ( ) ; if ( f == FINISHED ) break ; if ( f == DISPOSED ) cancelFuture ( future ) ; break ; if ( compareAndSet ( f , future ) ) break ; 
if ( runner == Thread . currentThread ( ) ) future . cancel ( false ) ; else future . cancel ( interruptOnCancel ) ; 
return runnable ; 
String status ; Future < ? > f = get ( ) ; if ( f == FINISHED ) status = "Finished" ; else if ( f == DISPOSED ) status = "Disposed" ; else Thread r = runner ; if ( r != null ) status = "Running on " + runner ; else status = "Waiting" ; return getClass ( ) . getSimpleName ( ) + "[" + status + "]" ; 
return new NewThreadWorker ( threadFactory ) ; 
return INSTANCE ; 
return new TrampolineWorker ( ) ; 
RxJavaPlugins . onSchedule ( run ) . run ( ) ; return EmptyDisposable . INSTANCE ; 
return enqueue ( action , now ( TimeUnit . MILLISECONDS ) ) ; 
disposed = true ; 
return disposed ; 
timedRunnable . disposed = true ; queue . remove ( timedRunnable ) ; 
if ( ! worker . disposed ) long t = worker . now ( TimeUnit . MILLISECONDS ) ; if ( execTime > t ) long delay = execTime - t ; try Thread . sleep ( delay ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; RxJavaPlugins . onError ( e ) ; return ; if ( ! worker . disposed ) run . run ( ) ; 
return SchedulerPoolFactory . create ( threadFactory ) ; 
ScheduledExecutorService next = null ; for ( ; ; ) ScheduledExecutorService current = executor . get ( ) ; if ( current != SHUTDOWN ) if ( next != null ) next . shutdown ( ) ; return ; if ( next == null ) next = createExecutor ( threadFactory ) ; if ( executor . compareAndSet ( current , next ) ) return ; 
ScheduledExecutorService current = executor . getAndSet ( SHUTDOWN ) ; if ( current != SHUTDOWN ) current . shutdownNow ( ) ; 
return new ScheduledWorker ( executor . get ( ) ) ; 
if ( ! disposed ) disposed = true ; tasks . dispose ( ) ; 
return disposed ; 
int c = cores ; if ( c == 0 ) return SHUTDOWN_WORKER ; return eventLoops [ ( int ) ( n ++ % c ) ] ; 
for ( PoolWorker w : eventLoops ) w . dispose ( ) ; 
return new EventLoopWorker ( pool . get ( ) . getEventLoop ( ) ) ; 
FixedSchedulerPool update = new FixedSchedulerPool ( MAX_THREADS , threadFactory ) ; if ( ! pool . compareAndSet ( NONE , update ) ) update . shutdown ( ) ; 
FixedSchedulerPool curr = pool . getAndSet ( NONE ) ; if ( curr != NONE ) curr . shutdown ( ) ; 
if ( ! disposed ) disposed = true ; both . dispose ( ) ; 
return disposed ; 
if ( disposed ) return EmptyDisposable . INSTANCE ; return poolWorker . scheduleActual ( action , 0 , TimeUnit . MILLISECONDS , serial ) ; 
return System . getProperty ( t ) ; 
final ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor ( 1 , factory ) ; exec . setRemoveOnCancelPolicy ( PURGE_ENABLED ) ; return exec ; 
run . run ( ) ; return DISPOSED ; 
return WORKER ; 
$EMPTY$
return false ; 
run . run ( ) ; return DISPOSED ; 
StringBuilder nameBuilder = new StringBuilder ( prefix ) . append ( '-' ) . append ( incrementAndGet ( ) ) ; String name = nameBuilder . toString ( ) ; Thread t = nonBlocking ? new RxCustomThread ( r , name ) : new Thread ( r , name ) ; t . setPriority ( priority ) ; t . setDaemon ( true ) ; return t ; 
return "RxThreadFactory[" + prefix + "]" ; 
return new ExecutorWorker ( executor , interruptibleWorker , fair ) ; 
Runnable decoratedRun = RxJavaPlugins . onSchedule ( run ) ; try if ( executor instanceof ExecutorService ) ScheduledDirectTask task = new ScheduledDirectTask ( decoratedRun , interruptibleWorker ) ; Future < ? > f = ( ( ExecutorService ) executor ) . submit ( task ) ; task . setFuture ( f ) ; return task ; if ( interruptibleWorker ) InterruptibleRunnable interruptibleTask = new InterruptibleRunnable ( decoratedRun , null ) ; executor . execute ( interruptibleTask ) ; return interruptibleTask ; else BooleanRunnable br = new BooleanRunnable ( decoratedRun ) ; executor . execute ( br ) ; return br ; catch ( RejectedExecutionException ex ) RxJavaPlugins . onError ( ex ) ; return EmptyDisposable . INSTANCE ; 
if ( disposed ) return EmptyDisposable . INSTANCE ; Runnable decoratedRun = RxJavaPlugins . onSchedule ( run ) ; Runnable task ; Disposable disposable ; if ( interruptibleWorker ) InterruptibleRunnable interruptibleTask = new InterruptibleRunnable ( decoratedRun , tasks ) ; tasks . add ( interruptibleTask ) ; task = interruptibleTask ; disposable = interruptibleTask ; else BooleanRunnable runnableTask = new BooleanRunnable ( decoratedRun ) ; task = runnableTask ; disposable = runnableTask ; queue . offer ( task ) ; if ( wip . getAndIncrement ( ) == 0 ) try executor . execute ( this ) ; catch ( RejectedExecutionException ex ) disposed = true ; queue . clear ( ) ; RxJavaPlugins . onError ( ex ) ; return EmptyDisposable . INSTANCE ; return disposable ; 
if ( ! disposed ) disposed = true ; tasks . dispose ( ) ; if ( wip . getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
return disposed ; 
if ( fair ) runFair ( ) ; else runEager ( ) ; 
final MpscLinkedQueue < Runnable > q = queue ; if ( disposed ) q . clear ( ) ; return ; Runnable run = q . poll ( ) ; run . run ( ) ; if ( disposed ) q . clear ( ) ; return ; if ( wip . decrementAndGet ( ) != 0 ) executor . execute ( this ) ; 
int missed = 1 ; final MpscLinkedQueue < Runnable > q = queue ; for ( ; ; ) if ( disposed ) q . clear ( ) ; return ; for ( ; ; ) Runnable run = q . poll ( ) ; if ( run == null ) break ; run . run ( ) ; if ( disposed ) q . clear ( ) ; return ; if ( disposed ) q . clear ( ) ; return ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( get ( ) ) return ; try actual . run ( ) ; catch ( Throwable ex ) RxJavaPlugins . onError ( ex ) ; throw ex ; finally lazySet ( true ) ; 
lazySet ( true ) ; 
return get ( ) ; 
mar . replace ( schedule ( decoratedRun ) ) ; 
if ( get ( ) == READY ) thread = Thread . currentThread ( ) ; if ( compareAndSet ( READY , RUNNING ) ) try try run . run ( ) ; catch ( Throwable ex ) RxJavaPlugins . onError ( ex ) ; throw ex ; finally thread = null ; if ( compareAndSet ( RUNNING , FINISHED ) ) cleanup ( ) ; else while ( get ( ) == INTERRUPTING ) Thread . yield ( ) ; Thread . interrupted ( ) ; else thread = null ; 
for ( ; ; ) int state = get ( ) ; if ( state >= FINISHED ) break ; else if ( state == READY ) if ( compareAndSet ( READY , INTERRUPTED ) ) cleanup ( ) ; break ; else if ( compareAndSet ( RUNNING , INTERRUPTING ) ) Thread t = thread ; if ( t != null ) t . interrupt ( ) ; thread = null ; set ( INTERRUPTED ) ; cleanup ( ) ; break ; 
if ( tasks != null ) tasks . delete ( this ) ; 
return get ( ) >= FINISHED ; 
Runnable r = get ( ) ; if ( r != null ) try try r . run ( ) ; finally lazySet ( null ) ; timed . lazySet ( DisposableHelper . DISPOSED ) ; direct . lazySet ( DisposableHelper . DISPOSED ) ; catch ( Throwable ex ) RxJavaPlugins . onError ( ex ) ; throw ex ; 
return get ( ) == null ; 
if ( getAndSet ( null ) != null ) timed . dispose ( ) ; direct . dispose ( ) ; 
Runnable r = get ( ) ; return r != null ? r : Functions . EMPTY_RUNNABLE ; 
dr . direct . replace ( scheduleDirect ( dr ) ) ; 
if ( value == null ) error = t ; else RxJavaPlugins . onError ( t ) ; countDown ( ) ; 
if ( ! done ) SubscriptionHelper . cancel ( upstream ) ; 
if ( once . compareAndSet ( false , true ) ) downstream . onSubscribe ( this ) ; SubscriptionHelper . deferredSetOnce ( this . upstream , requested , s ) ; else s . cancel ( ) ; cancel ( ) ; onError ( new IllegalStateException ( "2.12 violated: onSubscribe must be called at most once" ) ) ; 
done = true ; HalfSerializer . onError ( downstream , t , this , error ) ; 
done = true ; HalfSerializer . onComplete ( downstream , this , error ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) this . qs = ( QueueSubscription < T > ) s ; if ( beforeDownstream ( ) ) downstream . onSubscribe ( this ) ; afterDownstream ( ) ; 
return true ; 
$EMPTY$
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
Exceptions . throwIfFatal ( t ) ; upstream . cancel ( ) ; onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
return qs . isEmpty ( ) ; 
qs . clear ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) this . qs = ( QueueSubscription < T > ) s ; if ( beforeDownstream ( ) ) downstream . onSubscribe ( this ) ; afterDownstream ( ) ; 
return true ; 
$EMPTY$
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
Exceptions . throwIfFatal ( t ) ; upstream . cancel ( ) ; onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
return qs . isEmpty ( ) ; 
qs . clear ( ) ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) queue . offer ( NotificationLite . subscription ( this ) ) ; 
queue . offer ( NotificationLite . error ( t ) ) ; 
queue . offer ( NotificationLite . complete ( ) ) ; 
if ( SubscriptionHelper . cancel ( this ) ) queue . offer ( TERMINATED ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
value = null ; error = t ; countDown ( ) ; 
if ( SubscriptionHelper . setOnce ( upstream , s ) ) downstream . onSubscribe ( this ) ; 
DisposableHelper . dispose ( this ) ; downstream . onError ( t ) ; 
DisposableHelper . dispose ( this ) ; downstream . onComplete ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; DisposableHelper . dispose ( this ) ; 
return upstream . get ( ) == SubscriptionHelper . CANCELLED ; 
dispose ( ) ; 
DisposableHelper . set ( this , resource ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; try onError . accept ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , e ) ) ; else RxJavaPlugins . onError ( t ) ; removeSelf ( ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; try onComplete . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; removeSelf ( ) ; 
SubscriptionHelper . cancel ( this ) ; removeSelf ( ) ; 
DisposableContainer c = composite . getAndSet ( null ) ; if ( c != null ) c . delete ( this ) ; 
return SubscriptionHelper . CANCELLED == get ( ) ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) s . request ( Long . MAX_VALUE ) ; 
return onError != Functions . ON_ERROR_MISSING ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
value = null ; downstream . onError ( t ) ; 
if ( hasValue ) complete ( value ) ; else downstream . onComplete ( ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
return cancelled ; 
return done ; 
return wip . getAndIncrement ( ) == 0 ; 
return wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ; 
return error ; 
return requested . get ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( ! cancelled ) s . request ( Long . MAX_VALUE ) ; if ( cancelled ) this . upstream = SubscriptionHelper . CANCELLED ; s . cancel ( ) ; 
countDown ( ) ; 
if ( getCount ( ) != 0 ) try BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; catch ( InterruptedException ex ) Subscription s = this . upstream ; this . upstream = SubscriptionHelper . CANCELLED ; if ( s != null ) s . cancel ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; Throwable e = error ; if ( e != null ) throw ExceptionHelper . wrapOrThrow ( e ) ; return value ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) try onSubscribe . accept ( this ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; s . cancel ( ) ; onError ( e ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; try onError . accept ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , e ) ) ; else RxJavaPlugins . onError ( t ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; try onComplete . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
cancel ( ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
SubscriptionHelper . cancel ( this ) ; 
return onError != Functions . ON_ERROR_MISSING ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; try onError . accept ( t ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( t , ex ) ) ; 
if ( done ) return ; done = true ; try onComplete . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
SubscriptionHelper . cancel ( this ) ; 
return this . get ( ) == SubscriptionHelper . CANCELLED ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY ) ; if ( m == QueueSubscription . SYNC ) fusionMode = m ; queue = qs ; done = true ; parent . innerComplete ( this ) ; return ; if ( m == QueueSubscription . ASYNC ) fusionMode = m ; queue = qs ; QueueDrainHelper . request ( s , prefetch ) ; return ; queue = QueueDrainHelper . createQueue ( prefetch ) ; QueueDrainHelper . request ( s , prefetch ) ; 
parent . innerError ( this , t ) ; 
parent . innerComplete ( this ) ; 
SubscriptionHelper . cancel ( this ) ; 
return done ; 
this . done = true ; 
return queue ; 
return upstream . get ( ) == SubscriptionHelper . CANCELLED ; 
return getCount ( ) == 0 ; 
if ( getCount ( ) != 0 ) BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; if ( isCancelled ( ) ) throw new CancellationException ( ) ; Throwable ex = error ; if ( ex != null ) throw new ExecutionException ( ex ) ; return value ; 
SubscriptionHelper . setOnce ( this . upstream , s , Long . MAX_VALUE ) ; 
if ( error == null ) Subscription a = upstream . get ( ) ; if ( a != this && a != SubscriptionHelper . CANCELLED && upstream . compareAndSet ( a , this ) ) error = t ; countDown ( ) ; return ; RxJavaPlugins . onError ( t ) ; 
if ( value == null ) onError ( new NoSuchElementException ( "The source is empty" ) ) ; return ; Subscription a = upstream . get ( ) ; if ( a == this || a == SubscriptionHelper . CANCELLED ) return ; if ( upstream . compareAndSet ( a , this ) ) countDown ( ) ; 
$EMPTY$
if ( SubscriptionHelper . setOnce ( this , s ) ) try onSubscribe . accept ( this ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; s . cancel ( ) ; onError ( ex ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; try onError . accept ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , e ) ) ; else RxJavaPlugins . onError ( t ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; try onComplete . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
cancel ( ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
SubscriptionHelper . cancel ( this ) ; 
return onError != Functions . ON_ERROR_MISSING ; 
LinkedQueueNode < T > currConsumerNode = lpConsumerNode ( ) ; LinkedQueueNode < T > nextNode = currConsumerNode . lvNext ( ) ; if ( nextNode != null ) final T nextValue = nextNode . getAndNullValue ( ) ; spConsumerNode ( nextNode ) ; return nextValue ; else if ( currConsumerNode != lvProducerNode ( ) ) while ( ( nextNode = currConsumerNode . lvNext ( ) ) == null ) final T nextValue = nextNode . getAndNullValue ( ) ; spConsumerNode ( nextNode ) ; return nextValue ; return null ; 
while ( poll ( ) != null && ! isEmpty ( ) ) 
return producerNode . get ( ) ; 
return consumerNode . get ( ) ; 
return consumerNode . get ( ) ; 
return lvConsumerNode ( ) == lvProducerNode ( ) ; 
E temp = lpValue ( ) ; spValue ( null ) ; return temp ; 
return value ; 
return get ( ) ; 
if ( get ( 0 ) != SubscriptionHelper . CANCELLED ) int s = length ( ) ; for ( int i = 0 ; i < s ; i ++ ) Subscription o = get ( i ) ; if ( o != SubscriptionHelper . CANCELLED ) o = getAndSet ( i , SubscriptionHelper . CANCELLED ) ; if ( o != SubscriptionHelper . CANCELLED && o != null ) o . cancel ( ) ; 
return get ( 0 ) == SubscriptionHelper . CANCELLED ; 
lazySet ( true ) ; 
return get ( ) ; 
return "BooleanSubscription(cancelled=" + get ( ) + ")" ; 
dispose ( ) ; 
SubscriptionHelper . cancel ( actual ) ; DisposableHelper . dispose ( resource ) ; 
return actual . get ( ) == SubscriptionHelper . CANCELLED ; 
return DisposableHelper . set ( resource , r ) ; 
return DisposableHelper . replace ( resource , r ) ; 
SubscriptionHelper . deferredSetOnce ( actual , this , s ) ; 
lazySet ( CANCELLED ) ; 
return get ( ) == CANCELLED ; 
if ( get ( ) == NO_REQUEST ) lazySet ( REQUESTED ) ; return value ; return null ; 
return get ( ) != NO_REQUEST ; 
lazySet ( 1 ) ; 
$EMPTY$
return "EmptySubscription" ; 
s . onSubscribe ( INSTANCE ) ; s . onError ( e ) ; 
s . onSubscribe ( INSTANCE ) ; s . onComplete ( ) ; 
return null ; 
return true ; 
$EMPTY$
throw new UnsupportedOperationException ( "Should not be called!" ) ; 
throw new UnsupportedOperationException ( "Should not be called!" ) ; 
if ( cancelled ) s . cancel ( ) ; return ; Objects . requireNonNull ( s , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) Subscription a = actual ; if ( a != null && cancelOnReplace ) a . cancel ( ) ; actual = s ; long r = requested ; if ( decrementAndGet ( ) != 0 ) drainLoop ( ) ; if ( r != 0L ) s . request ( r ) ; return ; Subscription a = missedSubscription . getAndSet ( s ) ; if ( a != null && cancelOnReplace ) a . cancel ( ) ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; drainLoop ( ) ; 
int missed = 1 ; long requestAmount = 0L ; Subscription requestTarget = null ; for ( ; ; ) Subscription ms = missedSubscription . get ( ) ; if ( ms != null ) ms = missedSubscription . getAndSet ( null ) ; long mr = missedRequested . get ( ) ; if ( mr != 0L ) mr = missedRequested . getAndSet ( 0L ) ; long mp = missedProduced . get ( ) ; if ( mp != 0L ) mp = missedProduced . getAndSet ( 0L ) ; Subscription a = actual ; if ( cancelled ) if ( a != null ) a . cancel ( ) ; actual = null ; if ( ms != null ) ms . cancel ( ) ; else long r = requested ; if ( r != Long . MAX_VALUE ) long u = BackpressureHelper . addCap ( r , mr ) ; if ( u != Long . MAX_VALUE ) long v = u - mp ; if ( v < 0L ) SubscriptionHelper . reportMoreProduced ( v ) ; v = 0 ; r = v ; else r = u ; requested = r ; if ( ms != null ) if ( a != null && cancelOnReplace ) a . cancel ( ) ; actual = ms ; if ( r != 0L ) requestAmount = BackpressureHelper . addCap ( requestAmount , r ) ; requestTarget = ms ; else if ( a != null && mr != 0L ) requestAmount = BackpressureHelper . addCap ( requestAmount , mr ) ; requestTarget = a ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) if ( requestAmount != 0L ) requestTarget . request ( requestAmount ) ; return ; 
return unbounded ; 
return cancelled ; 
$EMPTY$
if ( next == null ) RxJavaPlugins . onError ( new NullPointerException ( "next is null" ) ) ; return false ; if ( current != null ) next . cancel ( ) ; reportSubscriptionSet ( ) ; return false ; return true ; 
RxJavaPlugins . onError ( new ProtocolViolationException ( "Subscription already set!" ) ) ; 
for ( ; ; ) Subscription current = field . get ( ) ; if ( current == CANCELLED ) if ( s != null ) s . cancel ( ) ; return false ; if ( field . compareAndSet ( current , s ) ) if ( current != null ) current . cancel ( ) ; return true ; 
Objects . requireNonNull ( s , "s is null" ) ; if ( ! field . compareAndSet ( null , s ) ) s . cancel ( ) ; if ( field . get ( ) != CANCELLED ) reportSubscriptionSet ( ) ; return false ; return true ; 
for ( ; ; ) Subscription current = field . get ( ) ; if ( current == CANCELLED ) if ( s != null ) s . cancel ( ) ; return false ; if ( field . compareAndSet ( current , s ) ) return true ; 
Subscription current = field . get ( ) ; if ( current != CANCELLED ) current = field . getAndSet ( CANCELLED ) ; if ( current != CANCELLED ) if ( current != null ) current . cancel ( ) ; return true ; return false ; 
if ( SubscriptionHelper . setOnce ( field , s ) ) long r = requested . getAndSet ( 0L ) ; if ( r != 0L ) s . request ( r ) ; return true ; return false ; 
if ( get ( ) == FUSED_READY ) lazySet ( FUSED_CONSUMED ) ; T v = value ; value = null ; return v ; return null ; 
return get ( ) != FUSED_READY ; 
lazySet ( FUSED_CONSUMED ) ; value = null ; 
set ( CANCELLED ) ; value = null ; 
return get ( ) == CANCELLED ; 
return getAndSet ( CANCELLED ) != CANCELLED ; 
if ( DisposableHelper . validate ( upstream , d ) ) upstream = d ; if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < T > qd = ( QueueDisposable < T > ) d ; int mode = qd . requestFusion ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ; if ( mode == QueueFuseable . SYNC ) queue = qd ; done = true ; onSubscribeDownstream ( ) ; drain ( ) ; return ; else if ( mode == QueueFuseable . ASYNC ) queue = qd ; onSubscribeDownstream ( ) ; return ; queue = new SpscLinkedArrayQueue < > ( prefetch ) ; onSubscribeDownstream ( ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) if ( errorMode == ErrorMode . IMMEDIATE ) disposeInner ( ) ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
disposed = true ; upstream . dispose ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; clearValue ( ) ; 
return disposed ; 
$EMPTY$
source . subscribe ( new ConcatMapMaybeSubscriber < > ( s , mapper , prefetch , errorMode ) ) ; 
source . subscribe ( new ConcatMapMaybeSubscriber < > ( s , mapper , prefetch , errorMode ) ) ; 
downstream . onSubscribe ( this ) ; 
stop ( ) ; 
this . state = STATE_INACTIVE ; drain ( ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) if ( errorMode != ErrorMode . END ) upstream . cancel ( ) ; this . state = STATE_INACTIVE ; drain ( ) ; 
item = null ; 
inner . dispose ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super R > downstream = this . downstream ; ErrorMode errorMode = this . errorMode ; SimpleQueue < T > queue = this . queue ; AtomicThrowable errors = this . errors ; AtomicLong requested = this . requested ; int limit = prefetch - ( prefetch > > 1 ) ; boolean syncFused = this . syncFused ; for ( ; ; ) for ( ; ; ) if ( cancelled ) queue . clear ( ) ; item = null ; break ; int s = state ; if ( errors . get ( ) != null ) if ( errorMode == ErrorMode . IMMEDIATE || ( errorMode == ErrorMode . BOUNDARY && s == STATE_INACTIVE ) ) queue . clear ( ) ; item = null ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( s == STATE_INACTIVE ) boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty ) break ; if ( ! syncFused ) int c = consumed + 1 ; if ( c == limit ) consumed = 0 ; upstream . request ( limit ) ; else consumed = c ; MaybeSource < ? extends R > ms ; try ms = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; queue . clear ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; state = STATE_ACTIVE ; ms . subscribe ( inner ) ; break ; else if ( s == STATE_RESULT_VALUE ) long e = emitted ; if ( e != requested . get ( ) ) R w = item ; item = null ; downstream . onNext ( w ) ; emitted = e + 1 ; state = STATE_INACTIVE ; else break ; else break ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . replace ( this , d ) ; 
parent . innerError ( e ) ; 
parent . innerComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new ConcatMapCompletableObserver < > ( observer , mapper , errorMode , prefetch ) ) ; 
downstream . onSubscribe ( this ) ; 
inner . dispose ( ) ; 
stop ( ) ; 
return cancelled ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) if ( errorMode == ErrorMode . IMMEDIATE ) upstream . cancel ( ) ; errors . tryTerminateConsumer ( downstream ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; else active = false ; drain ( ) ; 
active = false ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; ErrorMode errorMode = this . errorMode ; SimpleQueue < T > queue = this . queue ; AtomicThrowable errors = this . errors ; boolean syncFused = this . syncFused ; do if ( cancelled ) queue . clear ( ) ; return ; if ( errors . get ( ) != null ) if ( errorMode == ErrorMode . IMMEDIATE || ( errorMode == ErrorMode . BOUNDARY && ! active ) ) queue . clear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( ! active ) boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( ! empty ) int limit = prefetch - ( prefetch > > 1 ) ; if ( ! syncFused ) int c = consumed + 1 ; if ( c == limit ) consumed = 0 ; upstream . request ( limit ) ; else consumed = c ; CompletableSource cs ; try cs = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null CompletableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; queue . clear ( ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; active = true ; cs . subscribe ( inner ) ; while ( decrementAndGet ( ) != 0 ) ; 
DisposableHelper . replace ( this , d ) ; 
parent . innerError ( e ) ; 
parent . innerComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new AndThenPublisherSubscriber < R > ( s , other ) ) ; 
downstream . onError ( t ) ; 
Publisher < ? extends R > p = other ; if ( p == null ) downstream . onComplete ( ) ; else other = null ; p . subscribe ( this ) ; 
upstream . dispose ( ) ; SubscriptionHelper . cancel ( this ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
SubscriptionHelper . deferredSetOnce ( this , requested , s ) ; 
if ( source instanceof Supplier ) @ SuppressWarnings ( "unchecked" ) Supplier < T > supplier = ( Supplier < T > ) source ; CompletableSource cs = null ; try T item = supplier . get ( ) ; if ( item != null ) cs = Objects . requireNonNull ( mapper . apply ( item ) , "The mapper returned a null CompletableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; if ( cs == null ) EmptyDisposable . complete ( observer ) ; else cs . subscribe ( observer ) ; return true ; return false ; 
if ( source instanceof Supplier ) @ SuppressWarnings ( "unchecked" ) Supplier < T > supplier = ( Supplier < T > ) source ; MaybeSource < ? extends R > cs = null ; try T item = supplier . get ( ) ; if ( item != null ) cs = Objects . requireNonNull ( mapper . apply ( item ) , "The mapper returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; if ( cs == null ) EmptyDisposable . complete ( observer ) ; else cs . subscribe ( MaybeToObservable . create ( observer ) ) ; return true ; return false ; 
if ( source instanceof Supplier ) @ SuppressWarnings ( "unchecked" ) Supplier < T > supplier = ( Supplier < T > ) source ; SingleSource < ? extends R > cs = null ; try T item = supplier . get ( ) ; if ( item != null ) cs = Objects . requireNonNull ( mapper . apply ( item ) , "The mapper returned a null SingleSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; if ( cs == null ) EmptyDisposable . complete ( observer ) ; else cs . subscribe ( SingleToObservable . create ( observer ) ) ; return true ; return false ; 
if ( DisposableHelper . validate ( upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onSuccess ( Notification . createOnComplete ( ) ) ; 
downstream . onSuccess ( Notification . createOnError ( e ) ) ; 
return upstream . isDisposed ( ) ; 
upstream . dispose ( ) ; 
FlatMapObserver < T , R > parent = new FlatMapObserver < > ( observer , mapper ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( this , d ) ; 
source . subscribe ( new SwitchMapMaybeSubscriber < > ( s , mapper , delayErrors ) ) ; 
if ( SubscriptionHelper . validate ( upstream , s ) ) upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) if ( ! delayErrors ) disposeInner ( ) ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
SwitchMapMaybeObserver < R > current = inner . getAndSet ( ( SwitchMapMaybeObserver ) INNER_DISPOSED ) ; if ( current != null && current != INNER_DISPOSED ) current . dispose ( ) ; 
cancelled = true ; upstream . cancel ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super R > downstream = this . downstream ; AtomicThrowable errors = this . errors ; AtomicReference < SwitchMapMaybeObserver < R > > inner = this . inner ; AtomicLong requested = this . requested ; long emitted = this . emitted ; for ( ; ; ) for ( ; ; ) if ( cancelled ) return ; if ( errors . get ( ) != null ) if ( ! delayErrors ) errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = done ; SwitchMapMaybeObserver < R > current = inner . get ( ) ; boolean empty = current == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty || current . item == null || emitted == requested . get ( ) ) break ; inner . compareAndSet ( current , null ) ; downstream . onNext ( current . item ) ; emitted ++ ; this . emitted = emitted ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( this , e ) ; 
parent . innerComplete ( this ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new SwitchMapCompletableObserver < > ( observer , mapper , delayErrors ) ) ; 
if ( SubscriptionHelper . validate ( upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) if ( delayErrors ) onComplete ( ) ; else disposeInner ( ) ; errors . tryTerminateConsumer ( downstream ) ; 
done = true ; if ( inner . get ( ) == null ) errors . tryTerminateConsumer ( downstream ) ; 
SwitchMapInnerObserver o = inner . getAndSet ( INNER_DISPOSED ) ; if ( o != null && o != INNER_DISPOSED ) o . dispose ( ) ; 
upstream . cancel ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; 
return inner . get ( ) == INNER_DISPOSED ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( this , e ) ; 
parent . innerComplete ( this ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new ConcatMapSingleSubscriber < > ( s , mapper , prefetch , errorMode ) ) ; 
downstream . onSubscribe ( this ) ; 
stop ( ) ; 
item = null ; 
inner . dispose ( ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) if ( errorMode != ErrorMode . END ) upstream . cancel ( ) ; this . state = STATE_INACTIVE ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super R > downstream = this . downstream ; ErrorMode errorMode = this . errorMode ; SimpleQueue < T > queue = this . queue ; AtomicThrowable errors = this . errors ; AtomicLong requested = this . requested ; int limit = prefetch - ( prefetch > > 1 ) ; boolean syncFused = this . syncFused ; for ( ; ; ) for ( ; ; ) if ( cancelled ) queue . clear ( ) ; item = null ; break ; int s = state ; if ( errors . get ( ) != null ) if ( errorMode == ErrorMode . IMMEDIATE || ( errorMode == ErrorMode . BOUNDARY && s == STATE_INACTIVE ) ) queue . clear ( ) ; item = null ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( s == STATE_INACTIVE ) boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty ) break ; if ( ! syncFused ) int c = consumed + 1 ; if ( c == limit ) consumed = 0 ; upstream . request ( limit ) ; else consumed = c ; SingleSource < ? extends R > ss ; try ss = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null SingleSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; queue . clear ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; state = STATE_ACTIVE ; ss . subscribe ( inner ) ; break ; else if ( s == STATE_RESULT_VALUE ) long e = emitted ; if ( e != requested . get ( ) ) R w = item ; item = null ; downstream . onNext ( w ) ; emitted = e + 1 ; state = STATE_INACTIVE ; else break ; else break ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . replace ( this , d ) ; 
parent . innerError ( e ) ; 
DisposableHelper . dispose ( this ) ; 
FlatMapObserver < T , R > parent = new FlatMapObserver < > ( observer , mapper ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( this , d ) ; 
source . subscribe ( new SwitchMapSingleSubscriber < > ( s , mapper , delayErrors ) ) ; 
if ( SubscriptionHelper . validate ( upstream , s ) ) upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) if ( ! delayErrors ) disposeInner ( ) ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
SwitchMapSingleObserver < R > current = inner . getAndSet ( ( SwitchMapSingleObserver ) INNER_DISPOSED ) ; if ( current != null && current != INNER_DISPOSED ) current . dispose ( ) ; 
cancelled = true ; upstream . cancel ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super R > downstream = this . downstream ; AtomicThrowable errors = this . errors ; AtomicReference < SwitchMapSingleObserver < R > > inner = this . inner ; AtomicLong requested = this . requested ; long emitted = this . emitted ; for ( ; ; ) for ( ; ; ) if ( cancelled ) return ; if ( errors . get ( ) != null ) if ( ! delayErrors ) errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = done ; SwitchMapSingleObserver < R > current = inner . get ( ) ; boolean empty = current == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty || current . item == null || emitted == requested . get ( ) ) break ; inner . compareAndSet ( current , null ) ; downstream . onNext ( current . item ) ; emitted ++ ; this . emitted = emitted ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( this , e ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new FlowableSwitchMapSingle . SwitchMapSingleSubscriber < > ( s , mapper , delayErrors ) ) ; 
source . subscribe ( new FlowableSwitchMapCompletable . SwitchMapCompletableObserver < > ( observer , mapper , delayErrors ) ) ; 
source . subscribe ( new FlowableSwitchMapMaybe . SwitchMapMaybeSubscriber < > ( s , mapper , delayErrors ) ) ; 
if ( ! ScalarXMapZHelper . tryAsMaybe ( source , mapper , observer ) ) source . subscribe ( new SwitchMapMaybeMainObserver < > ( observer , mapper , delayErrors ) ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) upstream = d ; downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) if ( ! delayErrors ) disposeInner ( ) ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
SwitchMapMaybeObserver < R > current = inner . getAndSet ( ( SwitchMapMaybeObserver ) INNER_DISPOSED ) ; if ( current != null && current != INNER_DISPOSED ) current . dispose ( ) ; 
cancelled = true ; upstream . dispose ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; 
return cancelled ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Observer < ? super R > downstream = this . downstream ; AtomicThrowable errors = this . errors ; AtomicReference < SwitchMapMaybeObserver < R > > inner = this . inner ; for ( ; ; ) for ( ; ; ) if ( cancelled ) return ; if ( errors . get ( ) != null ) if ( ! delayErrors ) errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = done ; SwitchMapMaybeObserver < R > current = inner . get ( ) ; boolean empty = current == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty || current . item == null ) break ; inner . compareAndSet ( current , null ) ; downstream . onNext ( current . item ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( this , e ) ; 
parent . innerComplete ( this ) ; 
DisposableHelper . dispose ( this ) ; 
if ( ! ScalarXMapZHelper . tryAsCompletable ( source , mapper , observer ) ) source . subscribe ( new ConcatMapCompletableObserver < > ( observer , mapper , errorMode , prefetch ) ) ; 
downstream . onSubscribe ( this ) ; 
inner . dispose ( ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) if ( errorMode != ErrorMode . END ) upstream . dispose ( ) ; active = false ; drain ( ) ; 
active = false ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; AtomicThrowable errors = this . errors ; ErrorMode errorMode = this . errorMode ; SimpleQueue < T > queue = this . queue ; do if ( disposed ) queue . clear ( ) ; return ; if ( errors . get ( ) != null ) if ( errorMode == ErrorMode . IMMEDIATE || ( errorMode == ErrorMode . BOUNDARY && ! active ) ) disposed = true ; queue . clear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( ! active ) boolean d = done ; boolean empty = true ; CompletableSource cs = null ; try T v = queue . poll ( ) ; if ( v != null ) cs = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null CompletableSource" ) ; empty = false ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; disposed = true ; queue . clear ( ) ; upstream . dispose ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( d && empty ) disposed = true ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( ! empty ) active = true ; cs . subscribe ( inner ) ; while ( decrementAndGet ( ) != 0 ) ; 
DisposableHelper . replace ( this , d ) ; 
parent . innerError ( e ) ; 
parent . innerComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new FlatMapPublisherSubscriber < > ( s , mapper ) ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
upstream . dispose ( ) ; SubscriptionHelper . cancel ( this ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
SubscriptionHelper . deferredSetOnce ( this , requested , s ) ; 
source . subscribe ( new ConcatMapSingleSubscriber < > ( s , mapper , prefetch , errorMode ) ) ; 
if ( ! ScalarXMapZHelper . tryAsMaybe ( source , mapper , observer ) ) source . subscribe ( new ConcatMapMaybeMainObserver < > ( observer , mapper , prefetch , errorMode ) ) ; 
downstream . onSubscribe ( this ) ; 
item = null ; 
this . state = STATE_INACTIVE ; drain ( ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) if ( errorMode != ErrorMode . END ) upstream . dispose ( ) ; this . state = STATE_INACTIVE ; drain ( ) ; 
inner . dispose ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Observer < ? super R > downstream = this . downstream ; ErrorMode errorMode = this . errorMode ; SimpleQueue < T > queue = this . queue ; AtomicThrowable errors = this . errors ; for ( ; ; ) for ( ; ; ) if ( disposed ) queue . clear ( ) ; item = null ; break ; int s = state ; if ( errors . get ( ) != null ) if ( errorMode == ErrorMode . IMMEDIATE || ( errorMode == ErrorMode . BOUNDARY && s == STATE_INACTIVE ) ) queue . clear ( ) ; item = null ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( s == STATE_INACTIVE ) boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; disposed = true ; upstream . dispose ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty ) break ; MaybeSource < ? extends R > ms ; try ms = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . dispose ( ) ; queue . clear ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; state = STATE_ACTIVE ; ms . subscribe ( inner ) ; break ; else if ( s == STATE_RESULT_VALUE ) R w = item ; item = null ; downstream . onNext ( w ) ; state = STATE_INACTIVE ; else break ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . replace ( this , d ) ; 
parent . innerError ( e ) ; 
parent . innerComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
AndThenObservableObserver < R > parent = new AndThenObservableObserver < > ( observer , other ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
downstream . onError ( t ) ; 
ObservableSource < ? extends R > o = other ; if ( o == null ) downstream . onComplete ( ) ; else other = null ; o . subscribe ( this ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( this , d ) ; 
if ( ! ScalarXMapZHelper . tryAsSingle ( source , mapper , observer ) ) source . subscribe ( new SwitchMapSingleMainObserver < > ( observer , mapper , delayErrors ) ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) upstream = d ; downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) if ( ! delayErrors ) disposeInner ( ) ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
SwitchMapSingleObserver < R > current = inner . getAndSet ( ( SwitchMapSingleObserver ) INNER_DISPOSED ) ; if ( current != null && current != INNER_DISPOSED ) current . dispose ( ) ; 
cancelled = true ; upstream . dispose ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; 
return cancelled ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Observer < ? super R > downstream = this . downstream ; AtomicThrowable errors = this . errors ; AtomicReference < SwitchMapSingleObserver < R > > inner = this . inner ; for ( ; ; ) for ( ; ; ) if ( cancelled ) return ; if ( errors . get ( ) != null ) if ( ! delayErrors ) errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = done ; SwitchMapSingleObserver < R > current = inner . get ( ) ; boolean empty = current == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty || current . item == null ) break ; inner . compareAndSet ( current , null ) ; downstream . onNext ( current . item ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( this , e ) ; 
DisposableHelper . dispose ( this ) ; 
if ( ! ScalarXMapZHelper . tryAsCompletable ( source , mapper , observer ) ) source . subscribe ( new SwitchMapCompletableObserver < > ( observer , mapper , delayErrors ) ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) if ( delayErrors ) onComplete ( ) ; else disposeInner ( ) ; errors . tryTerminateConsumer ( downstream ) ; 
done = true ; if ( inner . get ( ) == null ) errors . tryTerminateConsumer ( downstream ) ; 
SwitchMapInnerObserver o = inner . getAndSet ( INNER_DISPOSED ) ; if ( o != null && o != INNER_DISPOSED ) o . dispose ( ) ; 
upstream . dispose ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; 
return inner . get ( ) == INNER_DISPOSED ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( this , e ) ; 
parent . innerComplete ( this ) ; 
DisposableHelper . dispose ( this ) ; 
if ( ! ScalarXMapZHelper . tryAsSingle ( source , mapper , observer ) ) source . subscribe ( new ConcatMapSingleMainObserver < > ( observer , mapper , prefetch , errorMode ) ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) if ( errorMode != ErrorMode . END ) upstream . dispose ( ) ; this . state = STATE_INACTIVE ; drain ( ) ; 
inner . dispose ( ) ; 
downstream . onSubscribe ( this ) ; 
item = null ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Observer < ? super R > downstream = this . downstream ; ErrorMode errorMode = this . errorMode ; SimpleQueue < T > queue = this . queue ; AtomicThrowable errors = this . errors ; for ( ; ; ) for ( ; ; ) if ( disposed ) queue . clear ( ) ; item = null ; break ; int s = state ; if ( errors . get ( ) != null ) if ( errorMode == ErrorMode . IMMEDIATE || ( errorMode == ErrorMode . BOUNDARY && s == STATE_INACTIVE ) ) queue . clear ( ) ; item = null ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( s == STATE_INACTIVE ) boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; disposed = true ; upstream . dispose ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty ) break ; SingleSource < ? extends R > ss ; try ss = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null SingleSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . dispose ( ) ; queue . clear ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; state = STATE_ACTIVE ; ss . subscribe ( inner ) ; break ; else if ( s == STATE_RESULT_VALUE ) R w = item ; item = null ; downstream . onNext ( w ) ; state = STATE_INACTIVE ; else break ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . replace ( this , d ) ; 
parent . innerError ( e ) ; 
DisposableHelper . dispose ( this ) ; 
if ( SubscriptionHelper . validate ( upstream , s ) ) upstream = s ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int mode = qs . requestFusion ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ; if ( mode == QueueFuseable . SYNC ) queue = qs ; syncFused = true ; done = true ; onSubscribeDownstream ( ) ; drain ( ) ; return ; else if ( mode == QueueFuseable . ASYNC ) queue = qs ; onSubscribeDownstream ( ) ; upstream . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; onSubscribeDownstream ( ) ; upstream . request ( prefetch ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) if ( errorMode == ErrorMode . IMMEDIATE ) disposeInner ( ) ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
cancelled = true ; upstream . cancel ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; clearValue ( ) ; 
$EMPTY$
source . subscribe ( new DoFinallyObserver < > ( observer , onFinally ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; runFinally ( ) ; 
upstream . dispose ( ) ; runFinally ( ) ; 
return upstream . isDisposed ( ) ; 
if ( compareAndSet ( 0 , 1 ) ) try onFinally . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
publisher . subscribe ( new ToSingleObserver < T > ( observer ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; this . value = null ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; T v = this . value ; this . value = null ; if ( v == null ) downstream . onError ( new NoSuchElementException ( "The source Publisher is empty" ) ) ; else downstream . onSuccess ( v ) ; 
return disposed ; 
disposed = true ; upstream . cancel ( ) ; 
source . subscribe ( new DoAfterObserver < > ( observer , onAfterSuccess ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
observer . onSubscribe ( Disposable . disposed ( ) ) ; observer . onSuccess ( value ) ; 
other . subscribe ( new OtherSubscriber < > ( observer , source ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( e ) ; return ; done = true ; downstream . onError ( e ) ; 
if ( done ) return ; done = true ; source . subscribe ( new ResumeSingleObserver < > ( this , downstream ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
source . subscribe ( new SingleLifecycleObserver < > ( observer , onSubscribe , onDispose ) ) ; 
try onSubscribe . accept ( d ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; d . dispose ( ) ; this . upstream = DisposableHelper . DISPOSED ; EmptyDisposable . error ( e , downstream ) ; return ; if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( upstream != DisposableHelper . DISPOSED ) upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
try onDispose . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new DoOnError ( observer ) ) ; 
downstream . onSubscribe ( d ) ; 
try onError . accept ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; downstream . onError ( e ) ; 
source . subscribe ( create ( observer ) ) ; 
return new SingleToObservableObserver < > ( downstream ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
error ( e ) ; 
super . dispose ( ) ; upstream . dispose ( ) ; 
TakeUntilMainObserver < T > parent = new TakeUntilMainObserver < > ( observer ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; source . subscribe ( parent ) ; 
DisposableHelper . dispose ( this ) ; other . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
other . dispose ( ) ; Disposable a = get ( ) ; if ( a != DisposableHelper . DISPOSED ) a = getAndSet ( DisposableHelper . DISPOSED ) ; if ( a != DisposableHelper . DISPOSED ) downstream . onError ( e ) ; return ; RxJavaPlugins . onError ( e ) ; 
Disposable a = get ( ) ; if ( a != DisposableHelper . DISPOSED ) a = getAndSet ( DisposableHelper . DISPOSED ) ; if ( a != DisposableHelper . DISPOSED ) if ( a != null ) a . dispose ( ) ; downstream . onError ( e ) ; return ; RxJavaPlugins . onError ( e ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
if ( SubscriptionHelper . cancel ( this ) ) parent . otherError ( new CancellationException ( ) ) ; 
parent . otherError ( t ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; parent . otherError ( new CancellationException ( ) ) ; 
SubscriptionHelper . cancel ( this ) ; 
other . subscribe ( new OtherObserver < > ( observer , source ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new ResumeSingleObserver < > ( this , downstream ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( d . isDisposed ( ) ) return ; T value ; try value = Objects . requireNonNull ( supplier . get ( ) , "The supplier returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! d . isDisposed ( ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! d . isDisposed ( ) ) observer . onSuccess ( value ) ; 
CacheDisposable < T > d = new CacheDisposable < > ( observer , this ) ; observer . onSubscribe ( d ) ; if ( add ( d ) ) if ( d . isDisposed ( ) ) remove ( d ) ; else Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else observer . onSuccess ( value ) ; return ; if ( wip . getAndIncrement ( ) == 0 ) source . subscribe ( this ) ; 
$EMPTY$
this . error = e ; for ( CacheDisposable < T > d : observers . getAndSet ( TERMINATED ) ) if ( ! d . isDisposed ( ) ) d . downstream . onError ( e ) ; 
return get ( ) ; 
if ( compareAndSet ( false , true ) ) parent . remove ( this ) ; 
SingleSource < ? extends T > [ ] sources = this . sources ; int n = sources . length ; if ( n == 1 ) sources [ 0 ] . subscribe ( new SingleMap . MapSingleObserver < > ( observer , new SingletonArrayFunc ( ) ) ) ; return ; ZipCoordinator < T , R > parent = new ZipCoordinator < > ( observer , n , zipper ) ; observer . onSubscribe ( parent ) ; for ( int i = 0 ; i < n ; i ++ ) if ( parent . isDisposed ( ) ) return ; SingleSource < ? extends T > source = sources [ i ] ; if ( source == null ) parent . innerError ( new NullPointerException ( "One of the sources is null" ) , i ) ; return ; source . subscribe ( parent . observers [ i ] ) ; 
return get ( ) <= 0 ; 
if ( getAndSet ( 0 ) > 0 ) for ( ZipSingleObserver < ? > d : observers ) d . dispose ( ) ; values = null ; 
DisposableHelper . dispose ( this ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( e , index ) ; 
source . subscribe ( new FlatMapIterableObserver < > ( observer , mapper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
cancelled = true ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return cancelled ; 
it = null ; 
return it == null ; 
Iterator < ? extends R > iterator = it ; if ( iterator != null ) R v = Objects . requireNonNull ( iterator . next ( ) , "The iterator returned a null value" ) ; if ( ! iterator . hasNext ( ) ) it = null ; return v ; return null ; 
source . subscribe ( new SingleFlatMapCallback < T , R > ( downstream , mapper ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
DisposableHelper . replace ( parent , d ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new TimeIntervalSingleObserver < > ( observer , unit , scheduler , start ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new DoOnSuccess ( observer ) ) ; 
downstream . onSubscribe ( d ) ; 
downstream . onError ( e ) ; 
other . subscribe ( new OtherObserver < > ( observer , source ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
source . subscribe ( new DoAfterTerminateObserver < > ( observer , onAfterTerminate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; onAfterTerminate ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
try onAfterTerminate . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
source . subscribe ( new DoOnDisposeObserver < > ( observer , onDispose ) ) ; 
Action a = getAndSet ( null ) ; if ( a != null ) try a . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
SingleSource < ? extends T > next ; try next = Objects . requireNonNull ( singleSupplier . get ( ) , "The singleSupplier returned a null SingleSource" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; next . subscribe ( observer ) ; 
source . subscribe ( new DoOnTerminate ( observer ) ) ; 
downstream . onSubscribe ( d ) ; 
try onTerminate . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; downstream . onError ( e ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( d . isDisposed ( ) ) return ; T value ; try value = Objects . requireNonNull ( callable . call ( ) , "The callable returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! d . isDisposed ( ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! d . isDisposed ( ) ) observer . onSuccess ( value ) ; 
source . subscribe ( new HideSingleObserver < T > ( observer ) ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new ObserveOnSingleObserver < > ( observer , scheduler ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
this . error = e ; Disposable d = scheduler . scheduleDirect ( this ) ; DisposableHelper . replace ( this , d ) ; 
Throwable ex = error ; if ( ex != null ) downstream . onError ( ex ) ; else downstream . onSuccess ( value ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
TimerDisposable parent = new TimerDisposable ( observer ) ; observer . onSubscribe ( parent ) ; parent . setFuture ( scheduler . scheduleDirect ( parent , delay , unit ) ) ; 
downstream . onSuccess ( 0L ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( this , d ) ; 
source . subscribe ( new DematerializeObserver < > ( observer , selector ) ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
return new NoSuchElementException ( ) ; 
return NoSuchElementSupplier . INSTANCE ; 
return new SingleToFlowable ( v ) ; 
return ( Function ) ToFlowable . INSTANCE ; 
return sit . hasNext ( ) ; 
return new SingleToFlowable < > ( sit . next ( ) ) ; 
throw new UnsupportedOperationException ( ) ; 
return new ToFlowableIterator < > ( sources . iterator ( ) ) ; 
return new ToFlowableIterable < > ( sources ) ; 
source . subscribe ( new FlatMapSingleObserver < T , R > ( downstream , mapper ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
DisposableHelper . replace ( parent , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
TimeoutMainObserver < T > parent = new TimeoutMainObserver < > ( observer , other , timeout , unit ) ; observer . onSubscribe ( parent ) ; DisposableHelper . replace ( parent . task , scheduler . scheduleDirect ( parent , timeout , unit ) ) ; source . subscribe ( parent ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
Disposable d = get ( ) ; if ( d != DisposableHelper . DISPOSED && compareAndSet ( d , DisposableHelper . DISPOSED ) ) if ( d != null ) d . dispose ( ) ; SingleSource < ? extends T > other = this . other ; if ( other == null ) downstream . onError ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; else this . other = null ; other . subscribe ( fallback ) ; 
DisposableHelper . setOnce ( this , d ) ; 
Disposable d = get ( ) ; if ( d != DisposableHelper . DISPOSED && compareAndSet ( d , DisposableHelper . DISPOSED ) ) DisposableHelper . dispose ( task ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
DisposableHelper . dispose ( this ) ; DisposableHelper . dispose ( task ) ; if ( fallback != null ) DisposableHelper . dispose ( fallback ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
final SubscribeOnObserver < T > parent = new SubscribeOnObserver < > ( observer , source ) ; observer . onSubscribe ( parent ) ; Disposable f = scheduler . scheduleDirect ( parent ) ; parent . task . replace ( f ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
DisposableHelper . dispose ( this ) ; task . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
source . subscribe ( this ) ; 
final SequentialDisposable sd = new SequentialDisposable ( ) ; observer . onSubscribe ( sd ) ; source . subscribe ( new Delay ( sd , observer ) ) ; 
sd . replace ( d ) ; 
sd . replace ( scheduler . scheduleDirect ( new OnError ( e ) , delayError ? time : 0 , unit ) ) ; 
downstream . onSuccess ( value ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new FlatMapBiMainObserver < T , U , R > ( observer , mapper , resultSelector ) ) ; 
DisposableHelper . dispose ( inner ) ; 
return DisposableHelper . isDisposed ( inner . get ( ) ) ; 
if ( DisposableHelper . setOnce ( inner , d ) ) inner . downstream . onSubscribe ( this ) ; 
inner . downstream . onError ( e ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new MaybeOnErrorComplete . OnErrorCompleteMultiObserver < T > ( observer , predicate ) ) ; 
@ SuppressWarnings ( "unchecked" ) SingleSource < ? extends T > [ ] a = new SingleSource [ 8 ] ; int n = 0 ; try for ( SingleSource < ? extends T > source : sources ) if ( source == null ) EmptyDisposable . error ( new NullPointerException ( "One of the sources is null" ) , observer ) ; return ; if ( n == a . length ) a = Arrays . copyOf ( a , n + ( n > > 2 ) ) ; a [ n ++ ] = source ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; if ( n == 0 ) EmptyDisposable . error ( new NoSuchElementException ( ) , observer ) ; return ; if ( n == 1 ) a [ 0 ] . subscribe ( new SingleMap . MapSingleObserver < > ( observer , new SingletonArrayFunc ( ) ) ) ; return ; ZipCoordinator < T , R > parent = new ZipCoordinator < > ( observer , n , zipper ) ; observer . onSubscribe ( parent ) ; for ( int i = 0 ; i < n ; i ++ ) if ( parent . isDisposed ( ) ) return ; a [ i ] . subscribe ( parent . observers [ i ] ) ; 
source . subscribe ( new DoOnEvent ( observer ) ) ; 
downstream . onSubscribe ( d ) ; 
try onEvent . accept ( null , e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; downstream . onError ( e ) ; 
SingleObserver < ? super T > sr ; try sr = Objects . requireNonNull ( onLift . apply ( observer ) , "The onLift returned a null SingleObserver" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( sr ) ; 
final U resource ; try resource = resourceSupplier . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; SingleSource < ? extends T > source ; try source = Objects . requireNonNull ( singleFunction . apply ( resource ) , "The singleFunction returned a null SingleSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( eager ) try disposer . accept ( resource ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; ex = new CompositeException ( ex , exc ) ; EmptyDisposable . error ( ex , observer ) ; if ( ! eager ) try disposer . accept ( resource ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; RxJavaPlugins . onError ( exc ) ; return ; source . subscribe ( new UsingSingleObserver < T , U > ( observer , resource , eager , disposer ) ) ; 
if ( eager ) disposeResource ( ) ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; else upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; disposeResource ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; if ( eager ) Object u = getAndSet ( this ) ; if ( u != this ) try disposer . accept ( ( U ) u ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; else return ; downstream . onError ( e ) ; if ( ! eager ) disposeResource ( ) ; 
Object u = getAndSet ( this ) ; if ( u != this ) try disposer . accept ( ( U ) u ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
source . subscribe ( new UnsubscribeOnSingleObserver < > ( observer , scheduler ) ) ; 
Disposable d = getAndSet ( DisposableHelper . DISPOSED ) ; if ( d != DisposableHelper . DISPOSED ) this . ds = d ; scheduler . scheduleDirect ( this ) ; 
ds . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
source . subscribe ( observer ) ; 
source . subscribe ( new SingleToFlowableObserver < T > ( s ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
super . cancel ( ) ; upstream . dispose ( ) ; 
FlatMapCompletableObserver < T > parent = new FlatMapCompletableObserver < > ( observer , mapper ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final Object [ ] values = null , null ; final CompositeDisposable set = new CompositeDisposable ( ) ; observer . onSubscribe ( set ) ; first . subscribe ( new InnerObserver < T > ( 0 , set , values , observer , count ) ) ; second . subscribe ( new InnerObserver < T > ( 1 , set , values , observer , count ) ) ; 
set . add ( d ) ; 
int state = count . getAndSet ( - 1 ) ; if ( state == 0 || state == 1 ) set . dispose ( ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
SingleSource < ? extends T > [ ] sources = this . sources ; int count = 0 ; if ( sources == null ) sources = new SingleSource [ 8 ] ; try for ( SingleSource < ? extends T > element : sourcesIterable ) if ( element == null ) EmptyDisposable . error ( new NullPointerException ( "One of the sources is null" ) , observer ) ; return ; if ( count == sources . length ) SingleSource < ? extends T > [ ] b = new SingleSource [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = element ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; else count = sources . length ; final AtomicBoolean winner = new AtomicBoolean ( ) ; final CompositeDisposable set = new CompositeDisposable ( ) ; observer . onSubscribe ( set ) ; for ( int i = 0 ; i < count ; i ++ ) SingleSource < ? extends T > s1 = sources [ i ] ; if ( set . isDisposed ( ) ) return ; if ( s1 == null ) set . dispose ( ) ; Throwable e = new NullPointerException ( "One of the sources is null" ) ; if ( winner . compareAndSet ( false , true ) ) observer . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; return ; s1 . subscribe ( new AmbSingleObserver < T > ( observer , set , winner ) ) ; 
this . upstream = d ; set . add ( d ) ; 
if ( winner . compareAndSet ( false , true ) ) set . delete ( upstream ) ; set . dispose ( ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
source . subscribe ( new DetachSingleObserver < > ( observer ) ) ; 
downstream = null ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; SingleObserver < ? super T > a = downstream ; if ( a != null ) downstream = null ; a . onError ( e ) ; 
source . subscribe ( new OnErrorReturn ( observer ) ) ; 
T v ; if ( valueSupplier != null ) try v = valueSupplier . apply ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; observer . onError ( new CompositeException ( e , ex ) ) ; return ; else v = value ; if ( v == null ) NullPointerException npe = new NullPointerException ( "Value supplied was null" ) ; npe . initCause ( e ) ; observer . onError ( npe ) ; return ; observer . onSuccess ( v ) ; 
observer . onSubscribe ( d ) ; 
source . subscribe ( new SingleFlatMapPublisherObserver < > ( downstream , mapper ) ) ; 
this . disposable = d ; downstream . onSubscribe ( this ) ; 
SubscriptionHelper . deferredSetOnce ( parent , this , s ) ; 
downstream . onComplete ( ) ; 
downstream . onError ( e ) ; 
disposable . dispose ( ) ; SubscriptionHelper . cancel ( parent ) ; 
source . subscribe ( new FlatMapIterableObserver < > ( s , mapper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
cancelled = true ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
if ( getAndIncrement ( ) != 0 ) return ; Subscriber < ? super R > a = downstream ; Iterator < ? extends R > iterator = this . it ; if ( outputFused && iterator != null ) a . onNext ( null ) ; a . onComplete ( ) ; return ; int missed = 1 ; for ( ; ; ) if ( iterator != null ) long r = requested . get ( ) ; long e = 0L ; if ( r == Long . MAX_VALUE ) fastPath ( a , iterator ) ; return ; while ( e != r ) if ( cancelled ) return ; R v ; try v = Objects . requireNonNull ( iterator . next ( ) , "The iterator returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; a . onNext ( v ) ; if ( cancelled ) return ; e ++ ; boolean b ; try b = iterator . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( ! b ) a . onComplete ( ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; if ( iterator == null ) iterator = it ; 
for ( ; ; ) if ( cancelled ) return ; R v ; try v = iterator . next ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; a . onNext ( v ) ; if ( cancelled ) return ; boolean b ; try b = iterator . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( ! b ) a . onComplete ( ) ; return ; 
it = null ; 
return it == null ; 
Iterator < ? extends R > iterator = it ; if ( iterator != null ) R v = Objects . requireNonNull ( iterator . next ( ) , "The iterator returned a null value" ) ; if ( ! iterator . hasNext ( ) ) it = null ; return v ; return null ; 
source . subscribe ( new ContainsSingleObserver ( observer ) ) ; 
downstream . onSubscribe ( d ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new FlatMapSingleObserver < > ( observer , onSuccessMapper , onErrorMapper ) ) ; 
DisposableHelper . dispose ( this ) ; upstream . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
SingleSource < ? extends R > source ; try source = Objects . requireNonNull ( onErrorMapper . apply ( e ) , "The onErrorMapper returned a null SingleSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; if ( ! isDisposed ( ) ) source . subscribe ( new InnerObserver ( ) ) ; 
DisposableHelper . setOnce ( FlatMapSingleObserver . this , d ) ; 
downstream . onError ( e ) ; 
observer . onSubscribe ( EmptyDisposable . NEVER ) ; 
Emitter < T > parent = new Emitter < > ( observer ) ; observer . onSubscribe ( parent ) ; try source . subscribe ( parent ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; parent . onError ( ex ) ; 
if ( ! tryOnError ( t ) ) RxJavaPlugins . onError ( t ) ; 
if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; if ( get ( ) != DisposableHelper . DISPOSED ) Disposable d = getAndSet ( DisposableHelper . DISPOSED ) ; if ( d != DisposableHelper . DISPOSED ) try downstream . onError ( t ) ; finally if ( d != null ) d . dispose ( ) ; return true ; return false ; 
DisposableHelper . set ( this , d ) ; 
setDisposable ( new CancellableDisposable ( c ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
return String . format ( "%s{%s}" , getClass ( ) . getSimpleName ( ) , super . toString ( ) ) ; 
source . subscribe ( new MapSingleObserver < T , R > ( t , mapper ) ) ; 
t . onSubscribe ( d ) ; 
t . onError ( e ) ; 
other . subscribe ( new OtherSubscriber < > ( observer , source ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( e ) ; return ; done = true ; downstream . onError ( e ) ; 
if ( done ) return ; done = true ; source . subscribe ( new ResumeSingleObserver < > ( this , downstream ) ) ; 
upstream . cancel ( ) ; DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
source . subscribe ( new ResumeMainSingleObserver < > ( observer , nextFunction ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
SingleSource < ? extends T > source ; try source = Objects . requireNonNull ( nextFunction . apply ( e ) , "The nextFunction returned a null SingleSource." ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; source . subscribe ( new ResumeSingleObserver < T > ( this , downstream ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
Throwable error ; try error = ExceptionHelper . nullCheck ( errorSupplier . get ( ) , "Supplier returned a null Throwable." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; error = e ; EmptyDisposable . error ( error , observer ) ; 
source . subscribe ( new DoOnSubscribeSingleObserver < > ( observer , onSubscribe ) ) ; 
try onSubscribe . accept ( d ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; done = true ; d . dispose ( ) ; EmptyDisposable . error ( ex , downstream ) ; return ; downstream . onSubscribe ( d ) ; 
if ( done ) RxJavaPlugins . onError ( e ) ; return ; downstream . onError ( e ) ; 
source . subscribe ( new MaterializeSingleObserver < > ( observer ) ) ; 
CompletableSource [ ] sources = this . sources ; int count = 0 ; if ( sources == null ) sources = new CompletableSource [ 8 ] ; try for ( CompletableSource element : sourcesIterable ) if ( element == null ) EmptyDisposable . error ( new NullPointerException ( "One of the sources is null" ) , observer ) ; return ; if ( count == sources . length ) CompletableSource [ ] b = new CompletableSource [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = element ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; else count = sources . length ; final CompositeDisposable set = new CompositeDisposable ( ) ; observer . onSubscribe ( set ) ; final AtomicBoolean once = new AtomicBoolean ( ) ; for ( int i = 0 ; i < count ; i ++ ) CompletableSource c = sources [ i ] ; if ( set . isDisposed ( ) ) return ; if ( c == null ) NullPointerException npe = new NullPointerException ( "One of the sources is null" ) ; if ( once . compareAndSet ( false , true ) ) set . dispose ( ) ; observer . onError ( npe ) ; else RxJavaPlugins . onError ( npe ) ; return ; c . subscribe ( new Amb ( once , set , observer ) ) ; if ( count == 0 ) observer . onComplete ( ) ; 
if ( once . compareAndSet ( false , true ) ) set . delete ( upstream ) ; set . dispose ( ) ; downstream . onComplete ( ) ; 
if ( once . compareAndSet ( false , true ) ) set . delete ( upstream ) ; set . dispose ( ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
upstream = d ; set . add ( d ) ; 
Emitter parent = new Emitter ( observer ) ; observer . onSubscribe ( parent ) ; try source . subscribe ( parent ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; parent . onError ( ex ) ; 
if ( get ( ) != DisposableHelper . DISPOSED ) Disposable d = getAndSet ( DisposableHelper . DISPOSED ) ; if ( d != DisposableHelper . DISPOSED ) try downstream . onComplete ( ) ; finally if ( d != null ) d . dispose ( ) ; 
if ( ! tryOnError ( t ) ) RxJavaPlugins . onError ( t ) ; 
if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; if ( get ( ) != DisposableHelper . DISPOSED ) Disposable d = getAndSet ( DisposableHelper . DISPOSED ) ; if ( d != DisposableHelper . DISPOSED ) try downstream . onError ( t ) ; finally if ( d != null ) d . dispose ( ) ; return true ; return false ; 
DisposableHelper . set ( this , d ) ; 
setDisposable ( new CancellableDisposable ( c ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
return String . format ( "%s{%s}" , getClass ( ) . getSimpleName ( ) , super . toString ( ) ) ; 
InnerCompletableCache inner = new InnerCompletableCache ( observer ) ; observer . onSubscribe ( inner ) ; if ( add ( inner ) ) if ( inner . isDisposed ( ) ) remove ( inner ) ; if ( once . compareAndSet ( false , true ) ) source . subscribe ( this ) ; else Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else observer . onComplete ( ) ; 
$EMPTY$
error = e ; for ( InnerCompletableCache inner : observers . getAndSet ( TERMINATED ) ) if ( ! inner . get ( ) ) inner . downstream . onError ( e ) ; 
for ( InnerCompletableCache inner : observers . getAndSet ( TERMINATED ) ) if ( ! inner . get ( ) ) inner . downstream . onComplete ( ) ; 
return get ( ) ; 
if ( compareAndSet ( false , true ) ) remove ( this ) ; 
ResumeNextObserver parent = new ResumeNextObserver ( observer , errorMapper ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
DisposableHelper . replace ( this , d ) ; 
downstream . onComplete ( ) ; 
if ( once ) downstream . onError ( e ) ; return ; once = true ; CompletableSource c ; try c = Objects . requireNonNull ( errorMapper . apply ( e ) , "The errorMapper returned a null CompletableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; c . subscribe ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . dispose ( this ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; try supplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; if ( ! d . isDisposed ( ) ) observer . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; return ; if ( ! d . isDisposed ( ) ) observer . onComplete ( ) ; 
source . subscribe ( new DetachCompletableObserver ( observer ) ) ; 
downstream = null ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; CompletableObserver a = downstream ; if ( a != null ) downstream = null ; a . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; CompletableObserver a = downstream ; if ( a != null ) downstream = null ; a . onComplete ( ) ; 
observer . onSubscribe ( EmptyDisposable . NEVER ) ; 
source . subscribe ( new HideCompletableObserver ( observer ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
CompletableMergeSubscriber parent = new CompletableMergeSubscriber ( observer , maxConcurrency , delayErrors ) ; source . subscribe ( parent ) ; 
upstream . cancel ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
return set . isDisposed ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; if ( maxConcurrency == Integer . MAX_VALUE ) s . request ( Long . MAX_VALUE ) ; else s . request ( maxConcurrency ) ; 
getAndIncrement ( ) ; MergeInnerObserver inner = new MergeInnerObserver ( ) ; set . add ( inner ) ; t . subscribe ( inner ) ; 
if ( ! delayErrors ) set . dispose ( ) ; if ( errors . tryAddThrowableOrReport ( t ) ) if ( getAndSet ( 0 ) > 0 ) errors . tryTerminateConsumer ( downstream ) ; else if ( errors . tryAddThrowableOrReport ( t ) ) if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; 
if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; 
DisposableHelper . setOnce ( this , d ) ; 
innerError ( this , e ) ; 
innerComplete ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . dispose ( this ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( ! d . isDisposed ( ) ) try runnable . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; if ( ! d . isDisposed ( ) ) observer . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; return ; if ( ! d . isDisposed ( ) ) observer . onComplete ( ) ; 
source . subscribe ( new FlowableFromCompletable . FromCompletableObserver < > ( s ) ) ; 
CompletableSource c ; try c = Objects . requireNonNull ( completableSupplier . get ( ) , "The completableSupplier returned a null CompletableSource" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; c . subscribe ( observer ) ; 
single . subscribe ( new CompletableFromSingleObserver < > ( observer ) ) ; 
co . onError ( e ) ; 
co . onSubscribe ( d ) ; 
source . subscribe ( new ObservableFromCompletable . FromCompletableObserver < > ( observer ) ) ; 
ConcatInnerObserver inner = new ConcatInnerObserver ( observer , sources ) ; observer . onSubscribe ( inner . sd ) ; inner . next ( ) ; 
sd . replace ( d ) ; 
downstream . onError ( e ) ; 
next ( ) ; 
if ( sd . isDisposed ( ) ) return ; if ( getAndIncrement ( ) != 0 ) return ; CompletableSource [ ] a = sources ; do if ( sd . isDisposed ( ) ) return ; int idx = index ++ ; if ( idx == a . length ) downstream . onComplete ( ) ; return ; a [ idx ] . subscribe ( this ) ; while ( decrementAndGet ( ) != 0 ) ; 
Iterator < ? extends CompletableSource > it ; try it = Objects . requireNonNull ( sources . iterator ( ) , "The iterator returned is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; ConcatInnerObserver inner = new ConcatInnerObserver ( observer , it ) ; observer . onSubscribe ( inner . sd ) ; inner . next ( ) ; 
sd . replace ( d ) ; 
downstream . onError ( e ) ; 
next ( ) ; 
if ( sd . isDisposed ( ) ) return ; if ( getAndIncrement ( ) != 0 ) return ; Iterator < ? extends CompletableSource > a = sources ; do if ( sd . isDisposed ( ) ) return ; boolean b ; try b = a . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; if ( ! b ) downstream . onComplete ( ) ; return ; CompletableSource c ; try c = Objects . requireNonNull ( a . next ( ) , "The CompletableSource returned is null" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; c . subscribe ( this ) ; while ( decrementAndGet ( ) != 0 ) ; 
source . subscribe ( new CompletableObserverImplementation ( observer ) ) ; 
try onSubscribe . accept ( d ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; d . dispose ( ) ; this . upstream = DisposableHelper . DISPOSED ; EmptyDisposable . error ( ex , downstream ) ; return ; if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( upstream == DisposableHelper . DISPOSED ) RxJavaPlugins . onError ( e ) ; return ; try onError . accept ( e ) ; onTerminate . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; downstream . onError ( e ) ; doAfter ( ) ; 
if ( upstream == DisposableHelper . DISPOSED ) return ; try onComplete . run ( ) ; onTerminate . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; downstream . onComplete ( ) ; doAfter ( ) ; 
try onAfterTerminate . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
try onDispose . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
final CompositeDisposable set = new CompositeDisposable ( ) ; final AtomicInteger wip = new AtomicInteger ( 1 ) ; MergeCompletableObserver shared = new MergeCompletableObserver ( observer , set , wip ) ; observer . onSubscribe ( shared ) ; Iterator < ? extends CompletableSource > iterator ; try iterator = Objects . requireNonNull ( sources . iterator ( ) , "The source iterator returned is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; observer . onError ( e ) ; return ; for ( ; ; ) if ( set . isDisposed ( ) ) return ; boolean b ; try b = iterator . hasNext ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; set . dispose ( ) ; shared . onError ( e ) ; return ; if ( ! b ) break ; if ( set . isDisposed ( ) ) return ; CompletableSource c ; try c = Objects . requireNonNull ( iterator . next ( ) , "The iterator returned a null CompletableSource" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; set . dispose ( ) ; shared . onError ( e ) ; return ; if ( set . isDisposed ( ) ) return ; wip . getAndIncrement ( ) ; c . subscribe ( shared ) ; shared . onComplete ( ) ; 
set . add ( d ) ; 
set . dispose ( ) ; if ( compareAndSet ( false , true ) ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( wip . decrementAndGet ( ) == 0 ) downstream . onComplete ( ) ; 
set . dispose ( ) ; set ( true ) ; 
return set . isDisposed ( ) ; 
final SubscribeOnObserver parent = new SubscribeOnObserver ( observer , source ) ; observer . onSubscribe ( parent ) ; Disposable f = scheduler . scheduleDirect ( parent ) ; parent . task . replace ( f ) ; 
source . subscribe ( this ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
DisposableHelper . dispose ( this ) ; task . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
source . subscribe ( new OnErrorReturnMaybeObserver < > ( observer , valueSupplier ) ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
T v ; try v = Objects . requireNonNull ( itemSupplier . apply ( e ) , "The itemSupplier returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; downstream . onSuccess ( v ) ; 
downstream . onComplete ( ) ; 
R resource ; try resource = resourceSupplier . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; CompletableSource source ; try source = Objects . requireNonNull ( completableFunction . apply ( resource ) , "The completableFunction returned a null CompletableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( eager ) try disposer . accept ( resource ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; EmptyDisposable . error ( new CompositeException ( ex , exc ) , observer ) ; return ; EmptyDisposable . error ( ex , observer ) ; if ( ! eager ) try disposer . accept ( resource ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; RxJavaPlugins . onError ( exc ) ; return ; source . subscribe ( new UsingObserver < > ( observer , resource , disposer , eager ) ) ; 
if ( eager ) disposeResource ( ) ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; else upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; disposeResource ( ) ; 
Object resource = getAndSet ( this ) ; if ( resource != this ) try disposer . accept ( ( R ) resource ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; if ( eager ) Object resource = getAndSet ( this ) ; if ( resource != this ) try disposer . accept ( ( R ) resource ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; else return ; downstream . onError ( e ) ; if ( ! eager ) disposeResource ( ) ; 
upstream = DisposableHelper . DISPOSED ; if ( eager ) Object resource = getAndSet ( this ) ; if ( resource != this ) try disposer . accept ( ( R ) resource ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; else return ; downstream . onComplete ( ) ; if ( ! eager ) disposeResource ( ) ; 
observable . subscribe ( new CompletableFromObservableObserver < > ( observer ) ) ; 
co . onSubscribe ( d ) ; 
co . onError ( e ) ; 
co . onComplete ( ) ; 
source . subscribe ( new DoFinallyObserver ( observer , onFinally ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; runFinally ( ) ; 
downstream . onComplete ( ) ; runFinally ( ) ; 
upstream . dispose ( ) ; runFinally ( ) ; 
return upstream . isDisposed ( ) ; 
if ( compareAndSet ( 0 , 1 ) ) try onFinally . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( ! d . isDisposed ( ) ) try run . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; if ( ! d . isDisposed ( ) ) observer . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; return ; if ( ! d . isDisposed ( ) ) observer . onComplete ( ) ; 
source . subscribe ( new MaterializeSingleObserver < > ( observer ) ) ; 
TakeUntilMainObserver parent = new TakeUntilMainObserver ( observer ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; source . subscribe ( parent ) ; 
if ( once . compareAndSet ( false , true ) ) DisposableHelper . dispose ( this ) ; DisposableHelper . dispose ( other ) ; 
return once . get ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
if ( once . compareAndSet ( false , true ) ) DisposableHelper . dispose ( other ) ; downstream . onComplete ( ) ; 
if ( once . compareAndSet ( false , true ) ) DisposableHelper . dispose ( other ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( once . compareAndSet ( false , true ) ) DisposableHelper . dispose ( this ) ; downstream . onComplete ( ) ; 
if ( once . compareAndSet ( false , true ) ) DisposableHelper . dispose ( this ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerComplete ( ) ; 
parent . innerError ( e ) ; 
final CompositeDisposable set = new CompositeDisposable ( ) ; observer . onSubscribe ( set ) ; Iterator < ? extends CompletableSource > iterator ; try iterator = Objects . requireNonNull ( sources . iterator ( ) , "The source iterator returned is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; observer . onError ( e ) ; return ; final AtomicInteger wip = new AtomicInteger ( 1 ) ; final AtomicThrowable errors = new AtomicThrowable ( ) ; set . add ( new TryTerminateAndReportDisposable ( errors ) ) ; for ( ; ; ) if ( set . isDisposed ( ) ) return ; boolean b ; try b = iterator . hasNext ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; errors . tryAddThrowableOrReport ( e ) ; break ; if ( ! b ) break ; if ( set . isDisposed ( ) ) return ; CompletableSource c ; try c = Objects . requireNonNull ( iterator . next ( ) , "The iterator returned a null CompletableSource" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; errors . tryAddThrowableOrReport ( e ) ; break ; if ( set . isDisposed ( ) ) return ; wip . getAndIncrement ( ) ; c . subscribe ( new MergeInnerCompletableObserver ( observer , set , errors , wip ) ) ; if ( wip . decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( observer ) ; 
EmptyDisposable . complete ( observer ) ; 
source . subscribe ( new SourceObserver ( observer , next ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) actualObserver . onSubscribe ( this ) ; 
actualObserver . onError ( e ) ; 
next . subscribe ( new NextObserver ( this , actualObserver ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( parent , d ) ; 
downstream . onComplete ( ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new OnError ( observer ) ) ; 
downstream . onComplete ( ) ; 
boolean b ; try b = predicate . test ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; if ( b ) downstream . onComplete ( ) ; else downstream . onError ( e ) ; 
downstream . onSubscribe ( d ) ; 
final CompositeDisposable set = new CompositeDisposable ( ) ; final AtomicInteger wip = new AtomicInteger ( sources . length + 1 ) ; final AtomicThrowable errors = new AtomicThrowable ( ) ; set . add ( new TryTerminateAndReportDisposable ( errors ) ) ; observer . onSubscribe ( set ) ; for ( CompletableSource c : sources ) if ( set . isDisposed ( ) ) return ; if ( c == null ) Throwable ex = new NullPointerException ( "A completable source is null" ) ; errors . tryAddThrowableOrReport ( ex ) ; wip . decrementAndGet ( ) ; continue ; c . subscribe ( new MergeInnerCompletableObserver ( observer , set , errors , wip ) ) ; if ( wip . decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( observer ) ; 
errors . tryTerminateAndReport ( ) ; 
return errors . isTerminated ( ) ; 
set . add ( d ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) tryTerminate ( ) ; 
tryTerminate ( ) ; 
if ( wip . decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; 
source . subscribe ( new DisposeOnObserver ( observer , scheduler ) ) ; 
if ( disposed ) return ; downstream . onComplete ( ) ; 
if ( disposed ) RxJavaPlugins . onError ( e ) ; return ; downstream . onError ( e ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
disposed = true ; scheduler . scheduleDirect ( this ) ; 
return disposed ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
source . subscribe ( new Delay ( observer , delay , unit , scheduler , delayError ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
DisposableHelper . replace ( this , scheduler . scheduleDirect ( this , delay , unit ) ) ; 
error = e ; DisposableHelper . replace ( this , scheduler . scheduleDirect ( this , delayError ? delay : 0 , unit ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
Throwable e = error ; error = null ; if ( e != null ) downstream . onError ( e ) ; else downstream . onComplete ( ) ; 
Throwable error ; try error = Objects . requireNonNull ( errorSupplier . get ( ) , "The error returned is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; error = e ; EmptyDisposable . error ( error , observer ) ; 
final CompositeDisposable set = new CompositeDisposable ( ) ; observer . onSubscribe ( set ) ; final AtomicBoolean once = new AtomicBoolean ( ) ; Disposable timer = scheduler . scheduleDirect ( new DisposeTask ( once , set , observer ) , timeout , unit ) ; set . add ( timer ) ; source . subscribe ( new TimeOutObserver ( set , once , observer ) ) ; 
set . add ( d ) ; 
if ( once . compareAndSet ( false , true ) ) set . dispose ( ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( once . compareAndSet ( false , true ) ) set . dispose ( ) ; downstream . onComplete ( ) ; 
if ( once . compareAndSet ( false , true ) ) set . clear ( ) ; if ( other == null ) downstream . onError ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; else other . subscribe ( new DisposeObserver ( ) ) ; 
set . add ( d ) ; 
set . dispose ( ) ; downstream . onError ( e ) ; 
set . dispose ( ) ; downstream . onComplete ( ) ; 
sources . subscribe ( new CompletableConcatSubscriber ( observer , prefetch ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; long r = prefetch == Integer . MAX_VALUE ? Long . MAX_VALUE : prefetch ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < CompletableSource > qs = ( QueueSubscription < CompletableSource > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY ) ; if ( m == QueueSubscription . SYNC ) sourceFused = m ; queue = qs ; done = true ; downstream . onSubscribe ( this ) ; drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) sourceFused = m ; queue = qs ; downstream . onSubscribe ( this ) ; s . request ( r ) ; return ; if ( prefetch == Integer . MAX_VALUE ) queue = new SpscLinkedArrayQueue < > ( Flowable . bufferSize ( ) ) ; else queue = new SpscArrayQueue < > ( prefetch ) ; downstream . onSubscribe ( this ) ; s . request ( r ) ; 
if ( sourceFused == QueueSubscription . NONE ) if ( ! queue . offer ( t ) ) onError ( new MissingBackpressureException ( ) ) ; return ; drain ( ) ; 
if ( once . compareAndSet ( false , true ) ) DisposableHelper . dispose ( inner ) ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
done = true ; drain ( ) ; 
upstream . cancel ( ) ; DisposableHelper . dispose ( inner ) ; 
return DisposableHelper . isDisposed ( inner . get ( ) ) ; 
if ( getAndIncrement ( ) != 0 ) return ; for ( ; ; ) if ( isDisposed ( ) ) return ; if ( ! active ) boolean d = done ; CompletableSource cs ; try cs = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; innerError ( ex ) ; return ; boolean empty = cs == null ; if ( d && empty ) downstream . onComplete ( ) ; return ; if ( ! empty ) active = true ; cs . subscribe ( inner ) ; request ( ) ; if ( decrementAndGet ( ) == 0 ) break ; 
if ( sourceFused != QueueSubscription . SYNC ) int p = consumed + 1 ; if ( p == limit ) consumed = 0 ; upstream . request ( p ) ; else consumed = p ; 
if ( once . compareAndSet ( false , true ) ) upstream . cancel ( ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
active = false ; drain ( ) ; 
DisposableHelper . replace ( this , d ) ; 
parent . innerError ( e ) ; 
parent . innerComplete ( ) ; 
source . subscribe ( new DoOnEvent ( observer ) ) ; 
try onEvent . accept ( null ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; observer . onError ( e ) ; return ; observer . onComplete ( ) ; 
try onEvent . accept ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; observer . onError ( e ) ; 
observer . onSubscribe ( d ) ; 
source . subscribe ( observer ) ; 
TimerDisposable parent = new TimerDisposable ( observer ) ; observer . onSubscribe ( parent ) ; parent . setFuture ( scheduler . scheduleDirect ( parent , delay , unit ) ) ; 
downstream . onComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( this , d ) ; 
try CompletableObserver sw = onLift . apply ( observer ) ; source . subscribe ( sw ) ; catch ( NullPointerException ex ) throw ex ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; try callable . call ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; if ( ! d . isDisposed ( ) ) observer . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; return ; if ( ! d . isDisposed ( ) ) observer . onComplete ( ) ; 
source . subscribe ( new ToSingle ( observer ) ) ; 
T v ; if ( completionValueSupplier != null ) try v = completionValueSupplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; observer . onError ( e ) ; return ; else v = completionValue ; if ( v == null ) observer . onError ( new NullPointerException ( "The value supplied is null" ) ) ; else observer . onSuccess ( v ) ; 
observer . onError ( e ) ; 
observer . onSubscribe ( d ) ; 
source . subscribe ( new ObserveOnCompletableObserver ( observer , scheduler ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
this . error = e ; DisposableHelper . replace ( this , scheduler . scheduleDirect ( this ) ) ; 
DisposableHelper . replace ( this , scheduler . scheduleDirect ( this ) ) ; 
Throwable ex = error ; if ( ex != null ) error = null ; downstream . onError ( ex ) ; else downstream . onComplete ( ) ; 
flowable . subscribe ( new FromPublisherSubscriber < > ( downstream ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
EmptyDisposable . error ( error , observer ) ; 
final CompositeDisposable set = new CompositeDisposable ( ) ; final AtomicBoolean once = new AtomicBoolean ( ) ; InnerCompletableObserver shared = new InnerCompletableObserver ( observer , once , set , sources . length + 1 ) ; observer . onSubscribe ( shared ) ; for ( CompletableSource c : sources ) if ( set . isDisposed ( ) ) return ; if ( c == null ) set . dispose ( ) ; NullPointerException npe = new NullPointerException ( "A completable source is null" ) ; shared . onError ( npe ) ; return ; c . subscribe ( shared ) ; shared . onComplete ( ) ; 
set . add ( d ) ; 
set . dispose ( ) ; if ( once . compareAndSet ( false , true ) ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( decrementAndGet ( ) == 0 ) downstream . onComplete ( ) ; 
set . dispose ( ) ; once . set ( true ) ; 
return set . isDisposed ( ) ; 
FromArrayDisposable < T > d = new FromArrayDisposable < > ( observer , array ) ; observer . onSubscribe ( d ) ; if ( d . fusionMode ) return ; d . run ( ) ; 
int i = index ; T [ ] a = array ; if ( i != a . length ) index = i + 1 ; return Objects . requireNonNull ( a [ i ] , "The array element is null" ) ; return null ; 
return index == array . length ; 
index = array . length ; 
disposed = true ; 
return disposed ; 
T [ ] a = array ; int n = a . length ; for ( int i = 0 ; i < n && ! isDisposed ( ) ; i ++ ) T value = a [ i ] ; if ( value == null ) downstream . onError ( new NullPointerException ( "The element at index " + i + " is null" ) ) ; return ; downstream . onNext ( value ) ; if ( ! isDisposed ( ) ) downstream . onComplete ( ) ; 
if ( source instanceof Supplier ) T t ; try t = ( ( Supplier < T > ) source ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; if ( t == null ) EmptyDisposable . complete ( observer ) ; return true ; ObservableSource < ? extends R > r ; try r = Objects . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; if ( r instanceof Supplier ) R u ; try u = ( ( Supplier < R > ) r ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; if ( u == null ) EmptyDisposable . complete ( observer ) ; return true ; ScalarDisposable < R > sd = new ScalarDisposable < > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; else r . subscribe ( observer ) ; return true ; return false ; 
ObservableSource < ? extends R > other ; try other = Objects . requireNonNull ( mapper . apply ( value ) , "The mapper returned a null ObservableSource" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; if ( other instanceof Supplier ) R u ; try u = ( ( Supplier < R > ) other ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; if ( u == null ) EmptyDisposable . complete ( observer ) ; return ; ScalarDisposable < R > sd = new ScalarDisposable < > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; else other . subscribe ( observer ) ; 
if ( get ( ) == FUSED ) lazySet ( ON_COMPLETE ) ; return value ; return null ; 
return get ( ) != FUSED ; 
lazySet ( ON_COMPLETE ) ; 
set ( ON_COMPLETE ) ; 
return get ( ) == ON_COMPLETE ; 
if ( get ( ) == START && compareAndSet ( START , ON_NEXT ) ) observer . onNext ( value ) ; if ( get ( ) == ON_NEXT ) lazySet ( ON_COMPLETE ) ; observer . onComplete ( ) ; 
source . subscribe ( new ScanObserver < > ( t , accumulator ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
RefConnection conn ; boolean connect = false ; synchronized ( this ) conn = connection ; if ( conn == null ) conn = new RefConnection ( this ) ; connection = conn ; long c = conn . subscriberCount ; if ( c == 0L && conn . timer != null ) conn . timer . dispose ( ) ; conn . subscriberCount = c + 1 ; if ( ! conn . connected && c + 1 == n ) connect = true ; conn . connected = true ; source . subscribe ( new RefCountObserver < > ( observer , this , conn ) ) ; if ( connect ) source . connect ( conn ) ; 
parent . timeout ( this ) ; 
DisposableHelper . replace ( this , t ) ; synchronized ( parent ) if ( disconnectedEarly ) parent . source . reset ( ) ; 
if ( compareAndSet ( false , true ) ) parent . terminated ( connection ) ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( compareAndSet ( false , true ) ) parent . terminated ( connection ) ; downstream . onComplete ( ) ; 
upstream . dispose ( ) ; if ( compareAndSet ( false , true ) ) parent . cancel ( connection ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
source . subscribe ( new DetachObserver < > ( observer ) ) ; 
Disposable d = this . upstream ; this . upstream = EmptyComponent . INSTANCE ; this . downstream = EmptyComponent . asObserver ( ) ; d . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
Observer < ? super T > a = downstream ; this . upstream = EmptyComponent . INSTANCE ; this . downstream = EmptyComponent . asObserver ( ) ; a . onError ( t ) ; 
Observer < ? super T > a = downstream ; this . upstream = EmptyComponent . INSTANCE ; this . downstream = EmptyComponent . asObserver ( ) ; a . onComplete ( ) ; 
if ( DisposableHelper . setOnce ( upstream , d ) ) downstream . onSubscribe ( this ) ; 
dispose ( ) ; downstream . onError ( t ) ; 
dispose ( ) ; downstream . onComplete ( ) ; 
DisposableHelper . dispose ( upstream ) ; DisposableHelper . dispose ( this ) ; 
return upstream . get ( ) == DisposableHelper . DISPOSED ; 
DisposableHelper . set ( this , resource ) ; 
U coll ; try coll = ExceptionHelper . nullCheck ( collectionSupplier . get ( ) , "The collectionSupplier returned a null Collection." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , t ) ; return ; source . subscribe ( new ToListObserver < > ( t , coll ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableToList < > ( source , collectionSupplier ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
collection = null ; downstream . onError ( t ) ; 
U c = collection ; collection = null ; downstream . onSuccess ( c ) ; 
MergeWithObserver < T > parent = new MergeWithObserver < > ( observer ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; other . subscribe ( parent . otherObserver ) ; 
DisposableHelper . setOnce ( mainDisposable , d ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) DisposableHelper . dispose ( otherObserver ) ; drain ( ) ; 
mainDone = true ; drain ( ) ; 
return DisposableHelper . isDisposed ( mainDisposable . get ( ) ) ; 
disposed = true ; DisposableHelper . dispose ( mainDisposable ) ; DisposableHelper . dispose ( otherObserver ) ; errors . tryTerminateAndReport ( ) ; if ( getAndIncrement ( ) == 0 ) queue = null ; singleItem = null ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) DisposableHelper . dispose ( mainDisposable ) ; drain ( ) ; 
otherState = OTHER_STATE_CONSUMED_OR_EMPTY ; drain ( ) ; 
SimplePlainQueue < T > q = queue ; if ( q == null ) q = new SpscLinkedArrayQueue < > ( bufferSize ( ) ) ; queue = q ; return q ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
Observer < ? super T > actual = this . downstream ; int missed = 1 ; for ( ; ; ) for ( ; ; ) if ( disposed ) singleItem = null ; queue = null ; return ; if ( errors . get ( ) != null ) singleItem = null ; queue = null ; errors . tryTerminateConsumer ( actual ) ; return ; int os = otherState ; if ( os == OTHER_STATE_HAS_VALUE ) T v = singleItem ; singleItem = null ; otherState = OTHER_STATE_CONSUMED_OR_EMPTY ; os = OTHER_STATE_CONSUMED_OR_EMPTY ; actual . onNext ( v ) ; boolean d = mainDone ; SimplePlainQueue < T > q = queue ; T v = q != null ? q . poll ( ) : null ; boolean empty = v == null ; if ( d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY ) queue = null ; actual . onComplete ( ) ; return ; if ( empty ) break ; actual . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . otherError ( e ) ; 
parent . otherComplete ( ) ; 
ObservableSource < ? extends T > [ ] sources = this . sources ; int count = 0 ; if ( sources == null ) sources = new ObservableSource [ 8 ] ; try for ( ObservableSource < ? extends T > p : sourcesIterable ) if ( count == sources . length ) ObservableSource < ? extends T > [ ] b = new ObservableSource [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = Objects . requireNonNull ( p , "The Iterator returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; else count = sources . length ; if ( count == 0 ) EmptyDisposable . complete ( observer ) ; return ; LatestCoordinator < T , R > lc = new LatestCoordinator < > ( observer , combiner , count , bufferSize , delayError ) ; lc . subscribe ( sources ) ; 
if ( ! cancelled ) cancelled = true ; cancelSources ( ) ; drain ( ) ; 
return cancelled ; 
for ( CombinerObserver < T , R > observer : observers ) observer . dispose ( ) ; 
synchronized ( this ) latest = null ; q . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; final SpscLinkedArrayQueue < Object [ ] > q = queue ; final Observer < ? super R > a = downstream ; final boolean delayError = this . delayError ; int missed = 1 ; for ( ; ; ) for ( ; ; ) if ( cancelled ) clear ( q ) ; errors . tryTerminateAndReport ( ) ; return ; if ( ! delayError && errors . get ( ) != null ) cancelSources ( ) ; clear ( q ) ; errors . tryTerminateConsumer ( a ) ; return ; boolean d = done ; Object [ ] s = q . poll ( ) ; boolean empty = s == null ; if ( d && empty ) clear ( q ) ; errors . tryTerminateConsumer ( a ) ; return ; if ( empty ) break ; R v ; try v = Objects . requireNonNull ( combiner . apply ( s ) , "The combiner returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; errors . tryAddThrowableOrReport ( ex ) ; cancelSources ( ) ; clear ( q ) ; errors . tryTerminateConsumer ( a ) ; return ; a . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( index , t ) ; 
parent . innerComplete ( index ) ; 
DisposableHelper . dispose ( this ) ; 
final SubscribeOnObserver < T > parent = new SubscribeOnObserver < > ( observer ) ; observer . onSubscribe ( parent ) ; parent . setDisposable ( scheduler . scheduleDirect ( new SubscribeTask ( parent ) ) ) ; 
DisposableHelper . setOnce ( this . upstream , d ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
DisposableHelper . dispose ( upstream ) ; DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
source . subscribe ( parent ) ; 
R r ; try r = Objects . requireNonNull ( seedSupplier . get ( ) , "The seed supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , t ) ; return ; source . subscribe ( new ScanSeedObserver < > ( t , accumulator , r ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; downstream . onNext ( value ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
source . subscribe ( new HideDisposable < > ( o ) ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new MapObserver < T , U > ( t , function ) ) ; 
T t = qd . poll ( ) ; return t != null ? Objects . requireNonNull ( mapper . apply ( t ) , "The mapper function returned a null value." ) : null ; 
MostRecentObserver < T > mostRecentObserver = new MostRecentObserver < > ( initialValue ) ; source . subscribe ( mostRecentObserver ) ; return mostRecentObserver . getIterable ( ) ; 
value = NotificationLite . complete ( ) ; 
value = NotificationLite . error ( e ) ; 
return new MostRecentIterator ( ) ; 
buf = value ; return ! NotificationLite . isComplete ( buf ) ; 
try if ( buf == null ) buf = value ; if ( NotificationLite . isComplete ( buf ) ) throw new NoSuchElementException ( ) ; if ( NotificationLite . isError ( buf ) ) throw ExceptionHelper . wrapOrThrow ( NotificationLite . getError ( buf ) ) ; return NotificationLite . getValue ( buf ) ; finally buf = null ; 
throw new UnsupportedOperationException ( "Read only iterator" ) ; 
BlockingObservableLatestIterator < T > lio = new BlockingObservableLatestIterator < > ( ) ; Observable < Notification < T > > materialized = Observable . wrap ( source ) . materialize ( ) ; materialized . subscribe ( lio ) ; return lio ; 
boolean wasNotAvailable = value . getAndSet ( args ) == null ; if ( wasNotAvailable ) notify . release ( ) ; 
RxJavaPlugins . onError ( e ) ; 
$EMPTY$
if ( iteratorNotification != null && iteratorNotification . isOnError ( ) ) throw ExceptionHelper . wrapOrThrow ( iteratorNotification . getError ( ) ) ; if ( iteratorNotification == null ) try BlockingHelper . verifyNonBlocking ( ) ; notify . acquire ( ) ; catch ( InterruptedException ex ) dispose ( ) ; iteratorNotification = Notification . createOnError ( ex ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; Notification < T > n = value . getAndSet ( null ) ; iteratorNotification = n ; if ( n . isOnError ( ) ) throw ExceptionHelper . wrapOrThrow ( n . getError ( ) ) ; return iteratorNotification . isOnNext ( ) ; 
if ( hasNext ( ) ) T v = iteratorNotification . getValue ( ) ; iteratorNotification = null ; return v ; throw new NoSuchElementException ( ) ; 
throw new UnsupportedOperationException ( "Read-only iterator." ) ; 
source . subscribe ( new FilterObserver < > ( observer , predicate ) ) ; 
for ( ; ; ) T v = qd . poll ( ) ; if ( v == null || filter . test ( v ) ) return v ; 
NextObserver < T > nextObserver = new NextObserver < > ( ) ; return new NextIterator < > ( source , nextObserver ) ; 
if ( error != null ) throw ExceptionHelper . wrapOrThrow ( error ) ; if ( ! hasNext ) return false ; return ! isNextConsumed || moveToNext ( ) ; 
if ( ! started ) started = true ; observer . setWaiting ( ) ; new ObservableMaterialize < > ( items ) . subscribe ( observer ) ; Notification < T > nextNotification ; try nextNotification = observer . takeNext ( ) ; catch ( InterruptedException e ) observer . dispose ( ) ; error = e ; throw ExceptionHelper . wrapOrThrow ( e ) ; if ( nextNotification . isOnNext ( ) ) isNextConsumed = false ; next = nextNotification . getValue ( ) ; return true ; hasNext = false ; if ( nextNotification . isOnComplete ( ) ) return false ; error = nextNotification . getError ( ) ; throw ExceptionHelper . wrapOrThrow ( error ) ; 
if ( error != null ) throw ExceptionHelper . wrapOrThrow ( error ) ; if ( hasNext ( ) ) isNextConsumed = true ; return next ; else throw new NoSuchElementException ( "No more elements" ) ; 
throw new UnsupportedOperationException ( "Read only iterator" ) ; 
$EMPTY$
RxJavaPlugins . onError ( e ) ; 
if ( waiting . getAndSet ( 0 ) == 1 || ! args . isOnNext ( ) ) Notification < T > toOffer = args ; while ( ! buf . offer ( toOffer ) ) Notification < T > concurrentItem = buf . poll ( ) ; if ( concurrentItem != null && ! concurrentItem . isOnNext ( ) ) toOffer = concurrentItem ; 
setWaiting ( ) ; BlockingHelper . verifyNonBlocking ( ) ; return buf . take ( ) ; 
waiting . set ( 1 ) ; 
ObservableSource < ? > [ ] others = otherArray ; int n = 0 ; if ( others == null ) others = new ObservableSource [ 8 ] ; try for ( ObservableSource < ? > p : otherIterable ) if ( n == others . length ) others = Arrays . copyOf ( others , n + ( n > > 1 ) ) ; others [ n ++ ] = p ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; else n = others . length ; if ( n == 0 ) new ObservableMap < > ( source , new SingletonArrayFunc ( ) ) . subscribeActual ( observer ) ; return ; WithLatestFromObserver < T , R > parent = new WithLatestFromObserver < > ( observer , combiner , n ) ; observer . onSubscribe ( parent ) ; parent . subscribe ( others , n ) ; source . subscribe ( parent ) ; 
DisposableHelper . setOnce ( this . upstream , d ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; cancelAllBut ( - 1 ) ; HalfSerializer . onError ( downstream , t , this , error ) ; 
if ( ! done ) done = true ; cancelAllBut ( - 1 ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
DisposableHelper . dispose ( upstream ) ; for ( WithLatestInnerObserver observer : observers ) observer . dispose ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
if ( ! hasValue ) hasValue = true ; parent . innerNext ( index , t ) ; 
parent . innerError ( index , t ) ; 
parent . innerComplete ( index , hasValue ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new ReduceSeedObserver < > ( observer , reducer , seed ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
R v = value ; if ( v != null ) value = null ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
R v = value ; if ( v != null ) value = null ; downstream . onSuccess ( v ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
Throwable error ; try error = ExceptionHelper . nullCheck ( errorSupplier . get ( ) , "Supplier returned a null Throwable." ) ; catch ( Throwable t ) Exceptions . throwIfFatal ( t ) ; error = t ; EmptyDisposable . error ( error , observer ) ; 
source . subscribe ( new SingleElementObserver < > ( t , defaultValue ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; T v = value ; value = null ; if ( v == null ) v = defaultValue ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onError ( new NoSuchElementException ( ) ) ; 
source . subscribe ( new AllObserver < > ( t , predicate ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableAll < > ( source , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onSuccess ( true ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new MapNotificationObserver < > ( t , onNextMapper , onErrorMapper , onCompleteSupplier ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
ObservableSource < ? extends R > p ; try p = Objects . requireNonNull ( onErrorMapper . apply ( t ) , "The onError ObservableSource returned is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; downstream . onNext ( p ) ; downstream . onComplete ( ) ; 
ObservableSource < ? extends R > p ; try p = Objects . requireNonNull ( onCompleteSupplier . get ( ) , "The onComplete ObservableSource returned is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; downstream . onNext ( p ) ; downstream . onComplete ( ) ; 
source . subscribe ( new TakeLastObserver < > ( t , count ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; 
Observer < ? super T > a = downstream ; for ( ; ; ) if ( cancelled ) return ; T v = poll ( ) ; if ( v == null ) a . onComplete ( ) ; return ; a . onNext ( v ) ; 
if ( ! cancelled ) cancelled = true ; upstream . dispose ( ) ; 
return cancelled ; 
source . subscribe ( new OnErrorCompleteObserver < > ( observer , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
boolean b ; try b = predicate . test ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; if ( b ) downstream . onComplete ( ) ; else downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new ElementAtObserver < > ( t , index ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableElementAt < > ( source , index , null , false ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onComplete ( ) ; 
source . subscribe ( new GroupByObserver < > ( t , keySelector , valueSelector , bufferSize , delayError ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
List < GroupedUnicast < K , V > > list = new ArrayList < > ( groups . values ( ) ) ; groups . clear ( ) ; for ( GroupedUnicast < K , V > e : list ) e . onError ( t ) ; downstream . onError ( t ) ; 
List < GroupedUnicast < K , V > > list = new ArrayList < > ( groups . values ( ) ) ; groups . clear ( ) ; for ( GroupedUnicast < K , V > e : list ) e . onComplete ( ) ; downstream . onComplete ( ) ; 
if ( cancelled . compareAndSet ( false , true ) ) if ( decrementAndGet ( ) == 0 ) upstream . dispose ( ) ; 
return cancelled . get ( ) ; 
state . subscribe ( observer ) ; 
state . onError ( e ) ; 
state . onComplete ( ) ; 
if ( cancelled . compareAndSet ( false , true ) ) if ( getAndIncrement ( ) == 0 ) actual . lazySet ( null ) ; cancelParent ( ) ; 
return cancelled . get ( ) ; 
for ( ; ; ) int s = once . get ( ) ; if ( ( s & HAS_SUBSCRIBER ) != 0 ) break ; int u = s | HAS_SUBSCRIBER ; if ( once . compareAndSet ( s , u ) ) observer . onSubscribe ( this ) ; actual . lazySet ( observer ) ; if ( cancelled . get ( ) ) actual . lazySet ( null ) ; else drain ( ) ; return ; EmptyDisposable . error ( new IllegalStateException ( "Only one Observer allowed!" ) , observer ) ; 
error = e ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final SpscLinkedArrayQueue < T > q = queue ; final boolean delayError = this . delayError ; Observer < ? super T > a = actual . get ( ) ; for ( ; ; ) if ( a != null ) for ( ; ; ) boolean d = done ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError ) ) return ; if ( empty ) break ; a . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; if ( a == null ) a = actual . get ( ) ; 
if ( ( once . get ( ) & ABANDONED ) == 0 ) parent . cancel ( key ) ; 
return once . get ( ) == FRESH && once . compareAndSet ( FRESH , ABANDONED ) ; 
WindowBoundaryMainObserver < T , B > parent = new WindowBoundaryMainObserver < > ( observer , capacityHint ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . boundaryObserver ) ; source . subscribe ( parent ) ; 
if ( DisposableHelper . setOnce ( upstream , d ) ) innerNext ( ) ; 
boundaryObserver . dispose ( ) ; if ( errors . tryAddThrowableOrReport ( e ) ) done = true ; drain ( ) ; 
boundaryObserver . dispose ( ) ; done = true ; drain ( ) ; 
if ( stopWindows . compareAndSet ( false , true ) ) boundaryObserver . dispose ( ) ; if ( windows . decrementAndGet ( ) == 0 ) DisposableHelper . dispose ( upstream ) ; 
return stopWindows . get ( ) ; 
if ( windows . decrementAndGet ( ) == 0 ) DisposableHelper . dispose ( upstream ) ; 
queue . offer ( NEXT_WINDOW ) ; drain ( ) ; 
DisposableHelper . dispose ( upstream ) ; if ( errors . tryAddThrowableOrReport ( e ) ) done = true ; drain ( ) ; 
DisposableHelper . dispose ( upstream ) ; done = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Observer < ? super Observable < T > > downstream = this . downstream ; MpscLinkedQueue < Object > queue = this . queue ; AtomicThrowable errors = this . errors ; for ( ; ; ) for ( ; ; ) if ( windows . get ( ) == 0 ) queue . clear ( ) ; window = null ; return ; UnicastSubject < T > w = window ; boolean d = done ; if ( d && errors . get ( ) != null ) queue . clear ( ) ; Throwable ex = errors . terminate ( ) ; if ( w != null ) window = null ; w . onError ( ex ) ; downstream . onError ( ex ) ; return ; Object v = queue . poll ( ) ; boolean empty = v == null ; if ( d && empty ) Throwable ex = errors . terminate ( ) ; if ( ex == null ) if ( w != null ) window = null ; w . onComplete ( ) ; downstream . onComplete ( ) ; else if ( w != null ) window = null ; w . onError ( ex ) ; downstream . onError ( ex ) ; return ; if ( empty ) break ; if ( v != NEXT_WINDOW ) w . onNext ( ( T ) v ) ; continue ; if ( w != null ) window = null ; w . onComplete ( ) ; if ( ! stopWindows . get ( ) ) w = UnicastSubject . create ( capacityHint , this ) ; window = w ; windows . getAndIncrement ( ) ; ObservableWindowSubscribeIntercept < T > intercept = new ObservableWindowSubscribeIntercept < > ( w ) ; downstream . onNext ( intercept ) ; if ( intercept . tryAbandon ( ) ) w . onComplete ( ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; parent . innerError ( t ) ; 
if ( done ) return ; done = true ; parent . innerComplete ( ) ; 
source . subscribe ( observer ) ; 
source . subscribe ( new OnErrorReturnObserver < > ( t , valueSupplier ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
T v ; try v = valueSupplier . apply ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; if ( v == null ) NullPointerException e = new NullPointerException ( "The supplied value is null" ) ; e . initCause ( t ) ; downstream . onError ( e ) ; return ; downstream . onNext ( v ) ; downstream . onComplete ( ) ; 
downstream . onComplete ( ) ; 
Subject < Object > signaller = PublishSubject . create ( ) . toSerialized ( ) ; ObservableSource < ? > other ; try other = Objects . requireNonNull ( handler . apply ( signaller ) , "The handler returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; RepeatWhenObserver < T > parent = new RepeatWhenObserver < > ( observer , signaller , source ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . inner ) ; parent . subscribeNext ( ) ; 
DisposableHelper . setOnce ( this . upstream , d ) ; 
DisposableHelper . dispose ( inner ) ; HalfSerializer . onError ( downstream , e , this , error ) ; 
DisposableHelper . replace ( upstream , null ) ; active = false ; signaller . onNext ( 0 ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
DisposableHelper . dispose ( upstream ) ; DisposableHelper . dispose ( inner ) ; 
subscribeNext ( ) ; 
DisposableHelper . dispose ( upstream ) ; HalfSerializer . onError ( downstream , ex , this , error ) ; 
DisposableHelper . dispose ( upstream ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
if ( wip . getAndIncrement ( ) == 0 ) do if ( isDisposed ( ) ) return ; if ( ! active ) active = true ; source . subscribe ( this ) ; while ( wip . decrementAndGet ( ) != 0 ) ; 
DisposableHelper . setOnce ( this , d ) ; 
innerNext ( ) ; 
innerError ( e ) ; 
innerComplete ( ) ; 
SequentialDisposable sa = new SequentialDisposable ( ) ; observer . onSubscribe ( sa ) ; RetryBiObserver < T > rs = new RetryBiObserver < > ( observer , predicate , sa , source ) ; rs . subscribeNext ( ) ; 
upstream . replace ( d ) ; 
boolean b ; try b = predicate . test ( ++ retries , t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; if ( ! b ) downstream . onError ( t ) ; return ; subscribeNext ( ) ; 
downstream . onComplete ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; for ( ; ; ) if ( upstream . isDisposed ( ) ) return ; source . subscribe ( this ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
EqualCoordinator < T > ec = new EqualCoordinator < > ( observer , bufferSize , first , second , comparer ) ; observer . onSubscribe ( ec ) ; ec . subscribe ( ) ; 
return RxJavaPlugins . onAssembly ( new ObservableSequenceEqual < > ( first , second , comparer , bufferSize ) ) ; 
EqualObserver < T > [ ] as = observers ; first . subscribe ( as [ 0 ] ) ; second . subscribe ( as [ 1 ] ) ; 
if ( ! cancelled ) cancelled = true ; resources . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) EqualObserver < T > [ ] as = observers ; as [ 0 ] . queue . clear ( ) ; as [ 1 ] . queue . clear ( ) ; 
return cancelled ; 
cancelled = true ; q1 . clear ( ) ; q2 . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; EqualObserver < T > [ ] as = observers ; final EqualObserver < T > observer1 = as [ 0 ] ; final SpscLinkedArrayQueue < T > q1 = observer1 . queue ; final EqualObserver < T > observer2 = as [ 1 ] ; final SpscLinkedArrayQueue < T > q2 = observer2 . queue ; for ( ; ; ) for ( ; ; ) if ( cancelled ) q1 . clear ( ) ; q2 . clear ( ) ; return ; boolean d1 = observer1 . done ; if ( d1 ) Throwable e = observer1 . error ; if ( e != null ) cancel ( q1 , q2 ) ; downstream . onError ( e ) ; return ; boolean d2 = observer2 . done ; if ( d2 ) Throwable e = observer2 . error ; if ( e != null ) cancel ( q1 , q2 ) ; downstream . onError ( e ) ; return ; if ( v1 == null ) v1 = q1 . poll ( ) ; boolean e1 = v1 == null ; if ( v2 == null ) v2 = q2 . poll ( ) ; boolean e2 = v2 == null ; if ( d1 && d2 && e1 && e2 ) downstream . onSuccess ( true ) ; return ; if ( ( d1 && d2 ) && ( e1 != e2 ) ) cancel ( q1 , q2 ) ; downstream . onSuccess ( false ) ; return ; if ( ! e1 && ! e2 ) boolean c ; try c = comparer . test ( v1 , v2 ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancel ( q1 , q2 ) ; downstream . onError ( ex ) ; return ; if ( ! c ) cancel ( q1 , q2 ) ; downstream . onSuccess ( false ) ; return ; v1 = null ; v2 = null ; if ( e1 || e2 ) break ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
parent . setDisposable ( d , index ) ; 
error = t ; done = true ; parent . drain ( ) ; 
done = true ; parent . drain ( ) ; 
source . subscribe ( new SkipWhileObserver < > ( observer , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
TakeUntilMainObserver < T , U > parent = new TakeUntilMainObserver < > ( child ) ; child . onSubscribe ( parent ) ; other . subscribe ( parent . otherObserver ) ; source . subscribe ( parent ) ; 
DisposableHelper . dispose ( upstream ) ; DisposableHelper . dispose ( otherObserver ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
DisposableHelper . setOnce ( upstream , d ) ; 
DisposableHelper . dispose ( otherObserver ) ; HalfSerializer . onError ( downstream , e , this , error ) ; 
DisposableHelper . dispose ( otherObserver ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
DisposableHelper . dispose ( upstream ) ; HalfSerializer . onError ( downstream , e , this , error ) ; 
DisposableHelper . dispose ( upstream ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
DisposableHelper . setOnce ( this , d ) ; 
otherError ( e ) ; 
otherComplete ( ) ; 
source . subscribe ( new DoAfterObserver < > ( observer , onAfterNext ) ) ; 
T v = qd . poll ( ) ; if ( v != null ) onAfterNext . accept ( v ) ; return v ; 
return source ; 
source . subscribe ( new FromCompletableObserver < T > ( observer ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
ObservableSource < ? extends T > [ ] sources = this . sources ; int count = 0 ; if ( sources == null ) sources = new ObservableSource [ 8 ] ; try for ( ObservableSource < ? extends T > p : sourcesIterable ) if ( p == null ) EmptyDisposable . error ( new NullPointerException ( "One of the sources is null" ) , observer ) ; return ; if ( count == sources . length ) ObservableSource < ? extends T > [ ] b = new ObservableSource [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = p ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; else count = sources . length ; if ( count == 0 ) EmptyDisposable . complete ( observer ) ; return ; else if ( count == 1 ) sources [ 0 ] . subscribe ( observer ) ; return ; AmbCoordinator < T > ac = new AmbCoordinator < > ( observer , count ) ; ac . subscribe ( sources ) ; 
if ( winner . get ( ) != - 1 ) winner . lazySet ( - 1 ) ; for ( AmbInnerObserver < T > a : observers ) a . dispose ( ) ; 
return winner . get ( ) == - 1 ; 
DisposableHelper . setOnce ( this , d ) ; 
if ( won ) downstream . onError ( t ) ; else if ( parent . win ( index ) ) won = true ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( won ) downstream . onComplete ( ) ; else if ( parent . win ( index ) ) won = true ; downstream . onComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
Subject < Throwable > signaller = PublishSubject . < Throwable > create ( ) . toSerialized ( ) ; ObservableSource < ? > other ; try other = Objects . requireNonNull ( handler . apply ( signaller ) , "The handler returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; RepeatWhenObserver < T > parent = new RepeatWhenObserver < > ( observer , signaller , source ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . inner ) ; parent . subscribeNext ( ) ; 
DisposableHelper . replace ( this . upstream , d ) ; 
DisposableHelper . replace ( upstream , null ) ; active = false ; signaller . onNext ( e ) ; 
DisposableHelper . dispose ( inner ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
DisposableHelper . dispose ( upstream ) ; DisposableHelper . dispose ( inner ) ; 
subscribeNext ( ) ; 
DisposableHelper . dispose ( upstream ) ; HalfSerializer . onError ( downstream , ex , this , error ) ; 
DisposableHelper . dispose ( upstream ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
if ( wip . getAndIncrement ( ) == 0 ) do if ( isDisposed ( ) ) return ; if ( ! active ) active = true ; source . subscribe ( this ) ; while ( wip . decrementAndGet ( ) != 0 ) ; 
DisposableHelper . setOnce ( this , d ) ; 
innerNext ( ) ; 
innerError ( e ) ; 
innerComplete ( ) ; 
SequentialDisposable sd = new SequentialDisposable ( ) ; observer . onSubscribe ( sd ) ; RepeatUntilObserver < T > rs = new RepeatUntilObserver < > ( observer , until , sd , source ) ; rs . subscribeNext ( ) ; 
upstream . replace ( d ) ; 
downstream . onError ( t ) ; 
boolean b ; try b = stop . getAsBoolean ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; if ( b ) downstream . onComplete ( ) ; else subscribeNext ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; for ( ; ; ) source . subscribe ( this ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
source . subscribe ( new AllObserver < > ( t , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onNext ( true ) ; downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( count == skip ) source . subscribe ( new WindowExactObserver < > ( t , count , capacityHint ) ) ; else source . subscribe ( new WindowSkipObserver < > ( t , count , skip , capacityHint ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
UnicastSubject < T > w = window ; if ( w != null ) window = null ; w . onError ( t ) ; downstream . onError ( t ) ; 
UnicastSubject < T > w = window ; if ( w != null ) window = null ; w . onComplete ( ) ; downstream . onComplete ( ) ; 
if ( cancelled . compareAndSet ( false , true ) ) run ( ) ; 
return cancelled . get ( ) ; 
if ( decrementAndGet ( ) == 0 ) upstream . dispose ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
final ArrayDeque < UnicastSubject < T > > ws = windows ; while ( ! ws . isEmpty ( ) ) ws . poll ( ) . onError ( t ) ; downstream . onError ( t ) ; 
final ArrayDeque < UnicastSubject < T > > ws = windows ; while ( ! ws . isEmpty ( ) ) ws . poll ( ) . onComplete ( ) ; downstream . onComplete ( ) ; 
if ( cancelled . compareAndSet ( false , true ) ) run ( ) ; 
return cancelled . get ( ) ; 
if ( decrementAndGet ( ) == 0 ) upstream . dispose ( ) ; 
if ( scheduler instanceof TrampolineScheduler ) source . subscribe ( observer ) ; else Scheduler . Worker w = scheduler . createWorker ( ) ; source . subscribe ( new ObserveOnObserver < > ( observer , w , delayError , bufferSize ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < T > qd = ( QueueDisposable < T > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY | QueueDisposable . BOUNDARY ) ; if ( m == QueueDisposable . SYNC ) sourceMode = m ; queue = qd ; done = true ; downstream . onSubscribe ( this ) ; schedule ( ) ; return ; if ( m == QueueDisposable . ASYNC ) sourceMode = m ; queue = qd ; downstream . onSubscribe ( this ) ; return ; queue = new SpscLinkedArrayQueue < > ( bufferSize ) ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; schedule ( ) ; 
if ( done ) return ; done = true ; schedule ( ) ; 
if ( ! disposed ) disposed = true ; upstream . dispose ( ) ; worker . dispose ( ) ; if ( ! outputFused && getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
return disposed ; 
if ( getAndIncrement ( ) == 0 ) worker . schedule ( this ) ; 
int missed = 1 ; final SimpleQueue < T > q = queue ; final Observer < ? super T > a = downstream ; for ( ; ; ) if ( checkTerminated ( done , q . isEmpty ( ) , a ) ) return ; for ( ; ; ) boolean d = done ; T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; disposed = true ; upstream . dispose ( ) ; q . clear ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a ) ) return ; if ( empty ) break ; a . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
int missed = 1 ; for ( ; ; ) if ( disposed ) return ; boolean d = done ; Throwable ex = error ; if ( ! delayError && d && ex != null ) disposed = true ; downstream . onError ( error ) ; worker . dispose ( ) ; return ; downstream . onNext ( null ) ; if ( d ) disposed = true ; ex = error ; if ( ex != null ) downstream . onError ( ex ) ; else downstream . onComplete ( ) ; worker . dispose ( ) ; return ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( outputFused ) drainFused ( ) ; else drainNormal ( ) ; 
return queue . poll ( ) ; 
queue . clear ( ) ; 
return queue . isEmpty ( ) ; 
if ( other == null ) TimeoutObserver < T > parent = new TimeoutObserver < > ( observer , timeout , unit , scheduler . createWorker ( ) ) ; observer . onSubscribe ( parent ) ; parent . startTimeout ( 0L ) ; source . subscribe ( parent ) ; else TimeoutFallbackObserver < T > parent = new TimeoutFallbackObserver < > ( observer , timeout , unit , scheduler . createWorker ( ) , other ) ; observer . onSubscribe ( parent ) ; parent . startTimeout ( 0L ) ; source . subscribe ( parent ) ; 
DisposableHelper . setOnce ( upstream , d ) ; 
if ( getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onError ( t ) ; worker . dispose ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onComplete ( ) ; worker . dispose ( ) ; 
DisposableHelper . dispose ( upstream ) ; worker . dispose ( ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
parent . onTimeout ( idx ) ; 
DisposableHelper . setOnce ( upstream , d ) ; 
if ( index . getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onError ( t ) ; worker . dispose ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( index . getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onComplete ( ) ; worker . dispose ( ) ; 
DisposableHelper . dispose ( upstream ) ; DisposableHelper . dispose ( this ) ; worker . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( arbiter , d ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new DoOnEachObserver < > ( t , onNext , onError , onComplete , onAfterTerminate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; try onError . accept ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; t = new CompositeException ( t , e ) ; downstream . onError ( t ) ; try onAfterTerminate . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
if ( done ) return ; try onComplete . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; onError ( e ) ; return ; done = true ; downstream . onComplete ( ) ; try onAfterTerminate . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
SequentialDisposable sd = new SequentialDisposable ( ) ; observer . onSubscribe ( sd ) ; RepeatObserver < T > rs = new RepeatObserver < > ( observer , count != Long . MAX_VALUE ? count - 1 : Long . MAX_VALUE , sd , source ) ; rs . subscribeNext ( ) ; 
sd . replace ( d ) ; 
downstream . onError ( t ) ; 
long r = remaining ; if ( r != Long . MAX_VALUE ) remaining = r - 1 ; if ( r != 0L ) subscribeNext ( ) ; else downstream . onComplete ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; for ( ; ; ) if ( sd . isDisposed ( ) ) return ; source . subscribe ( this ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
final SequentialDisposable serial = new SequentialDisposable ( ) ; child . onSubscribe ( serial ) ; Observer < U > otherObserver = new DelayObserver ( serial , child ) ; other . subscribe ( otherObserver ) ; 
serial . update ( d ) ; 
if ( done ) RxJavaPlugins . onError ( e ) ; return ; done = true ; child . onError ( e ) ; 
if ( done ) return ; done = true ; main . subscribe ( new OnComplete ( ) ) ; 
serial . update ( d ) ; 
child . onError ( e ) ; 
child . onComplete ( ) ; 
U u ; try u = Objects . requireNonNull ( initialSupplier . get ( ) , "The initialSupplier returned a null value" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , t ) ; return ; source . subscribe ( new CollectObserver < > ( t , u , collector ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableCollect < > ( source , initialSupplier , collector ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onSuccess ( u ) ; 
CacheDisposable < T > consumer = new CacheDisposable < > ( t , this ) ; t . onSubscribe ( consumer ) ; add ( consumer ) ; if ( ! once . get ( ) && once . compareAndSet ( false , true ) ) source . subscribe ( this ) ; else replay ( consumer ) ; 
return once . get ( ) ; 
return observers . get ( ) . length != 0 ; 
return size ; 
$EMPTY$
error = t ; done = true ; for ( CacheDisposable < T > consumer : observers . getAndSet ( TERMINATED ) ) replay ( consumer ) ; 
done = true ; for ( CacheDisposable < T > consumer : observers . getAndSet ( TERMINATED ) ) replay ( consumer ) ; 
if ( ! disposed ) disposed = true ; parent . remove ( this ) ; 
return disposed ; 
source . subscribe ( new DoFinallyObserver < > ( observer , onFinally ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; if ( d instanceof QueueDisposable ) this . qd = ( QueueDisposable < T > ) d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; runFinally ( ) ; 
downstream . onComplete ( ) ; runFinally ( ) ; 
upstream . dispose ( ) ; runFinally ( ) ; 
return upstream . isDisposed ( ) ; 
qd . clear ( ) ; 
return qd . isEmpty ( ) ; 
T v = qd . poll ( ) ; if ( v == null && syncFused ) runFinally ( ) ; return v ; 
if ( compareAndSet ( 0 , 1 ) ) try onFinally . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
source . subscribe ( new FlatMapCompletableMainObserver < > ( observer , mapper , delayErrors ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableFlatMapCompletable < > ( source , mapper , delayErrors ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) if ( delayErrors ) if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; else disposed = true ; upstream . dispose ( ) ; set . dispose ( ) ; errors . tryTerminateConsumer ( downstream ) ; 
if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; 
disposed = true ; upstream . dispose ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
return upstream . isDisposed ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
innerComplete ( this ) ; 
innerError ( this , e ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
o . onSubscribe ( EmptyDisposable . NEVER ) ; 
if ( ObservableScalarXMap . tryScalarXMapSubscribe ( source , t , mapper ) ) return ; source . subscribe ( new SwitchMapObserver < > ( t , mapper , bufferSize , delayErrors ) ) ; 
