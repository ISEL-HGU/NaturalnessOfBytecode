TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Timed < Integer > > m = source . timestamp ( scheduler ) ; m . subscribe ( observer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 1 , 0 , TimeUnit . MILLISECONDS ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 2 , 0 , TimeUnit . MILLISECONDS ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( new Timed < > ( 3 , 200 , TimeUnit . MILLISECONDS ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler v ) throws Exception return scheduler ; ) ; try Observable . range ( 1 , 5 ) . timestamp ( ) . map ( new Function < Timed < Integer > , Long > ( ) @ Override public Long apply ( Timed < Integer > v ) throws Exception return v . time ( ) ; ) . test ( ) . assertResult ( 0L , 0L , 0L , 0L , 0L ) ; finally RxJavaPlugins . reset ( ) ; 
final TestScheduler scheduler = new TestScheduler ( ) ; RxJavaPlugins . setComputationSchedulerHandler ( new Function < Scheduler , Scheduler > ( ) @ Override public Scheduler apply ( Scheduler v ) throws Exception return scheduler ; ) ; try Observable . range ( 1 , 5 ) . timestamp ( TimeUnit . SECONDS ) . map ( new Function < Timed < Integer > , Long > ( ) @ Override public Long apply ( Timed < Integer > v ) throws Exception return v . time ( ) ; ) . test ( ) . assertResult ( 0L , 0L , 0L , 0L , 0L ) ; finally RxJavaPlugins . reset ( ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
final List < String > list = new ArrayList < > ( ) ; final List < List < String > > lists = new ArrayList < > ( ) ; Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; push ( observer , "one" , 10 ) ; push ( observer , "two" , 90 ) ; push ( observer , "three" , 110 ) ; push ( observer , "four" , 190 ) ; push ( observer , "five" , 210 ) ; complete ( observer , 250 ) ; ) ; Observable < Observable < String > > windowed = source . window ( 100 , TimeUnit . MILLISECONDS , scheduler , 2 ) ; windowed . subscribe ( observeWindow ( list , lists ) ) ; scheduler . advanceTimeTo ( 95 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , lists . size ( ) ) ; assertEquals ( lists . get ( 0 ) , list ( "one" , "two" ) ) ; scheduler . advanceTimeTo ( 195 , TimeUnit . MILLISECONDS ) ; assertEquals ( 3 , lists . size ( ) ) ; assertTrue ( lists . get ( 1 ) . isEmpty ( ) ) ; assertEquals ( lists . get ( 2 ) , list ( "three" , "four" ) ) ; scheduler . advanceTimeTo ( 300 , TimeUnit . MILLISECONDS ) ; assertEquals ( 5 , lists . size ( ) ) ; assertTrue ( lists . get ( 3 ) . isEmpty ( ) ) ; assertEquals ( lists . get ( 4 ) , list ( "five" ) ) ; 
final List < String > list = new ArrayList < > ( ) ; final List < List < String > > lists = new ArrayList < > ( ) ; Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; push ( observer , "one" , 98 ) ; push ( observer , "two" , 99 ) ; push ( observer , "three" , 99 ) ; push ( observer , "four" , 101 ) ; push ( observer , "five" , 102 ) ; complete ( observer , 150 ) ; ) ; Observable < Observable < String > > windowed = source . window ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; windowed . subscribe ( observeWindow ( list , lists ) ) ; scheduler . advanceTimeTo ( 101 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , lists . size ( ) ) ; assertEquals ( lists . get ( 0 ) , list ( "one" , "two" , "three" ) ) ; scheduler . advanceTimeTo ( 201 , TimeUnit . MILLISECONDS ) ; assertEquals ( 2 , lists . size ( ) ) ; assertEquals ( lists . get ( 1 ) , list ( "four" , "five" ) ) ; 
return new Consumer < Observable < T > > ( ) @ Override public void accept ( Observable < T > stringObservable ) stringObservable . subscribe ( new DefaultObserver < T > ( ) @ Override public void onComplete ( ) lists . add ( new ArrayList < > ( list ) ) ; list . clear ( ) ; @ Override public void onError ( Throwable e ) Assert . fail ( e . getMessage ( ) ) ; @ Override public void onNext ( T args ) list . add ( args ) ; ) ; ; 
Observable < Observable < Integer > > source = Observable . range ( 1 , 10 ) . window ( 1 , TimeUnit . MINUTES , scheduler , 3 ) ; final List < Integer > list = new ArrayList < > ( ) ; final List < List < Integer > > lists = new ArrayList < > ( ) ; source . subscribe ( observeWindow ( list , lists ) ) ; assertEquals ( 4 , lists . size ( ) ) ; assertEquals ( 3 , lists . get ( 0 ) . size ( ) ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , lists . get ( 0 ) ) ; assertEquals ( 3 , lists . get ( 1 ) . size ( ) ) ; assertEquals ( Arrays . asList ( 4 , 5 , 6 ) , lists . get ( 1 ) ) ; assertEquals ( 3 , lists . get ( 2 ) . size ( ) ) ; assertEquals ( Arrays . asList ( 7 , 8 , 9 ) , lists . get ( 2 ) ) ; assertEquals ( 1 , lists . get ( 3 ) . size ( ) ) ; assertEquals ( Arrays . asList ( 10 ) , lists . get ( 3 ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; final AtomicInteger wip = new AtomicInteger ( ) ; final int indicator = 999999999 ; ObservableWindowWithSizeTest . hotStream ( ) . window ( 300 , TimeUnit . MILLISECONDS ) . take ( 10 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "Main done!" ) ; ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) return w . startWithItem ( indicator ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "inner done: " + wip . incrementAndGet ( ) ) ; ) ; ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer pv ) System . out . println ( pv ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertComplete ( ) ; Assert . assertTrue ( to . values ( ) . size ( ) != 0 ) ; 
Observable . just ( 1 ) . window ( 1 , 1 , TimeUnit . MINUTES ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . window ( 1 , 1 , TimeUnit . MINUTES , Schedulers . io ( ) ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . range ( 1 , 10 ) . window ( 1 , 1 , TimeUnit . MINUTES , Schedulers . io ( ) , 2 ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable . range ( 1 , 10 ) . window ( 1 , TimeUnit . MINUTES , 20 ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable . range ( 1 , 10 ) . window ( 1 , TimeUnit . MINUTES , 20 , true ) . flatMap ( Functions . < Observable < Integer > > identity ( ) , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
try Observable . just ( 1 ) . window ( - 99 , 1 , TimeUnit . SECONDS ) ; fail ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "timespan > 0 required but it was -99" , ex . getMessage ( ) ) ; 
Observable . just ( 1 ) . window ( 2 , 1 , TimeUnit . MINUTES , Schedulers . single ( ) ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . window ( 1 , 2 , TimeUnit . MINUTES , Schedulers . single ( ) ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 1 , 2 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ps . onNext ( 3 ) ; ps . onNext ( 4 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ps . onNext ( 5 ) ; ps . onNext ( 6 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ps . onNext ( 7 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 5 , 6 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 2 , 1 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ps . onNext ( 3 ) ; ps . onNext ( 4 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ps . onNext ( 5 ) ; ps . onNext ( 6 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ps . onNext ( 7 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 , 6 , 7 , 7 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 1 , 1 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; ps . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 2 , 1 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; ps . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 1 , 2 , TimeUnit . SECONDS , scheduler ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; ps . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . window ( 1 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . window ( 2 , 1 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . window ( 1 , 2 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Observable . never ( ) . window ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , true ) ) ; 
Observable . range ( 1 , 5 ) . window ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , true ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . error ( new TestException ( ) ) . window ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , true ) . to ( TestHelper . < Observable < Object > > testConsumer ( ) ) . assertSubscribed ( ) . assertError ( TestException . class ) . assertNotComplete ( ) ; 
Observable . intervalRange ( 1 , 1000 , 1 , 1 , TimeUnit . MILLISECONDS ) . window ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , 2 , true ) . flatMap ( Functions . < Observable < Long > > identity ( ) ) . take ( 500 ) . to ( TestHelper . < Long > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( 1 , TimeUnit . MILLISECONDS , scheduler ) . flatMap ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return v ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( 1 , TimeUnit . MILLISECONDS , scheduler , 10 , true ) . flatMap ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return v ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( 1 , TimeUnit . MILLISECONDS , scheduler , 2 , true ) . flatMap ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return v ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; final Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ; ps . window ( 1 , 2 , TimeUnit . MILLISECONDS , scheduler ) . flatMap ( new Function < Observable < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Integer > v ) throws Exception return v ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 100 ) . test ( ) . assertValueCount ( 1 ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . MILLISECONDS ) ; to . assertValueCount ( 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; to . values ( ) . get ( 0 ) . test ( ) . assertResult ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , Long . MAX_VALUE , false ) . test ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValueCount ( 21 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , Long . MAX_VALUE , true ) . test ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValueCount ( 21 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 5 , false ) . test ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValueCount ( 21 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 5 , true ) . test ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValueCount ( 21 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 2 , true ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValueCount ( 22 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Subject < Integer > ps = PublishSubject . < Integer > create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 5 , TimeUnit . MILLISECONDS , scheduler , 5 , true ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . MILLISECONDS ) ; ps . onNext ( 3 ) ; ps . onNext ( 4 ) ; ps . onNext ( 5 ) ; ps . onNext ( 6 ) ; to . assertValueCount ( 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; ps . window ( 100 , TimeUnit . MILLISECONDS ) . doOnNext ( new Consumer < Observable < Integer > > ( ) int count ; @ Override public void accept ( Observable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; ps . onComplete ( ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; ps . window ( 100 , TimeUnit . MILLISECONDS ) . doOnNext ( new Consumer < Observable < Integer > > ( ) int count ; @ Override public void accept ( Observable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; ps . window ( 100 , TimeUnit . MILLISECONDS , 10 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) int count ; @ Override public void accept ( Observable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; ps . onComplete ( ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; ps . window ( 100 , TimeUnit . MILLISECONDS , 10 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) int count ; @ Override public void accept ( Observable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; ps . window ( 90 , 100 , TimeUnit . MILLISECONDS ) . doOnNext ( new Consumer < Observable < Integer > > ( ) int count ; @ Override public void accept ( Observable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; ps . onComplete ( ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
final AtomicBoolean isInterrupted = new AtomicBoolean ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final CountDownLatch doOnNextDone = new CountDownLatch ( 1 ) ; final CountDownLatch secondWindowProcessing = new CountDownLatch ( 1 ) ; ps . window ( 90 , 100 , TimeUnit . MILLISECONDS ) . doOnNext ( new Consumer < Observable < Integer > > ( ) int count ; @ Override public void accept ( Observable < Integer > v ) throws Exception System . out . println ( Thread . currentThread ( ) ) ; if ( count ++ == 1 ) secondWindowProcessing . countDown ( ) ; try Thread . sleep ( 200 ) ; isInterrupted . set ( Thread . interrupted ( ) ) ; catch ( InterruptedException ex ) isInterrupted . set ( true ) ; doOnNextDone . countDown ( ) ; ) . test ( ) ; ps . onNext ( 1 ) ; assertTrue ( secondWindowProcessing . await ( 5 , TimeUnit . SECONDS ) ) ; ps . onError ( new TestException ( ) ) ; assertTrue ( doOnNextDone . await ( 5 , TimeUnit . SECONDS ) ) ; assertFalse ( "The doOnNext got interrupted!" , isInterrupted . get ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 10 , TimeUnit . MINUTES ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < Observable < Integer > > inner = new AtomicReference < > ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 , TimeUnit . MINUTES ) . take ( 1 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; to . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 10 , TimeUnit . MINUTES , 100 ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < Observable < Integer > > inner = new AtomicReference < > ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 , TimeUnit . MINUTES , 100 ) . take ( 1 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; to . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . window ( 10 , 15 , TimeUnit . MINUTES ) . take ( 1 ) . flatMap ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > w ) throws Throwable return w . take ( 1 ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicReference < Observable < Integer > > inner = new AtomicReference < > ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 10 , 15 , TimeUnit . MINUTES ) . take ( 1 ) . doOnNext ( new Consumer < Observable < Integer > > ( ) @ Override public void accept ( Observable < Integer > v ) throws Throwable inner . set ( v ) ; ) . test ( ) ; assertFalse ( "Subject still has observers!" , ps . hasObservers ( ) ) ; to . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; inner . get ( ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . window ( 1 , TimeUnit . SECONDS ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Observable < Integer > > to = ps . window ( 1 , TimeUnit . MINUTES , scheduler , 1 ) . test ( ) ; TestHelper . race ( ( ) -> ps . onNext ( 1 ) , ( ) -> to . dispose ( ) ) ; 
Observable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; , true ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( to , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return null ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( NullPointerException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . error ( new TestException ( ) ) ; , true ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 11 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 2 ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( to , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable . range ( 1 , 10 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( v ) ; ) . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . fromArray ( new String [ ] "1" , "a" , "2" ) . flatMapSingle ( new Function < String , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( final String s ) throws NumberFormatException return Single . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws NumberFormatException return Integer . valueOf ( s ) ; ) ; ) . test ( ) . assertFailure ( NumberFormatException . class , 1 ) ; 
Observable . range ( 1 , 1000 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 500 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . range ( 1 , 2 ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) return ps . singleOrError ( ) ; return Single . error ( new TestException ( ) ) ; , true ) . test ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class , 1 ) ; 
TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) throws Exception return Single . < Integer > just ( 1 ) ; ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( 1 ) . flatMapSingle ( Functions . justFunction ( ps . singleOrError ( ) ) ) . test ( ) ; ps . onNext ( 2 ) ; ps . onComplete ( ) ; to . assertResult ( 2 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Object > f ) throws Exception return f . flatMapSingle ( Functions . justFunction ( Single . just ( 2 ) ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onError ( new TestException ( "Second" ) ) ; . flatMapSingle ( Functions . justFunction ( Single . just ( 2 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . just ( 1 ) . flatMapSingle ( Functions . justFunction ( new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onError ( new TestException ( "Second" ) ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps2 . onNext ( 2 ) ; ps2 . onComplete ( ) ; ; Observable . just ( ps1 , ps2 ) . flatMapSingle ( new Function < PublishSubject < Integer > , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( PublishSubject < Integer > v ) throws Exception return v . singleOrError ( ) ; ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; ps1 . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . flatMapSingle ( new Function < Integer , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Integer v ) throws Exception return new Single < Object > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; to . dispose ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . flatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . flatMapSingle ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) throws Throwable return Single . just ( v ) . hide ( ) ; , true ) ; ) ; 
TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; SingleSubject < Integer > ps2 = SingleSubject . create ( ) ; TestObserver < Integer > to = ps1 . flatMapSingle ( v -> ps2 ) . test ( ) ; ps1 . onNext ( 1 ) ; TestHelper . race ( ( ) -> ps1 . onComplete ( ) , ( ) -> ps2 . onError ( ex ) ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; ps1 . flatMapSingle ( v -> TestHelper . raceOther ( ( ) -> to . dispose ( ) ; , cdl ) ; return Single . just ( 1 ) ; ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; cdl . await ( ) ; 
SingleSubject < Integer > ss1 = SingleSubject . create ( ) ; SingleSubject < Integer > ss2 = SingleSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . flatMapSingle ( v -> v == 1 ? ss1 : ss2 ) . doOnNext ( v -> if ( v == 1 ) ss2 . onSuccess ( 2 ) ; to . dispose ( ) ; ) . subscribe ( to ) ; ss1 . onSuccess ( 1 ) ; to . assertValuesOnly ( 1 ) ; 
Observable . fromFuture ( Observable . never ( ) . toFuture ( ) , 100 , TimeUnit . MILLISECONDS ) . subscribeOn ( Schedulers . io ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TimeoutException . class ) ; 
Observable . fromPublisher ( Flowable . just ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
assertSame ( Observable . empty ( ) , Observable . fromArray ( ) ) ; 
assertTrue ( Observable . fromArray ( 1 ) instanceof ScalarSupplier ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . toObservable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowableToObservable ( new Function < Flowable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Flowable < Object > f ) throws Exception return f . toObservable ( ) ; ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; Observable . fromArray ( 1 , 2 , 3 ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 ) ; 
Observable . range ( 1 , 5 ) . toFlowable ( BackpressureStrategy . BUFFER ) . test ( 2L ) . assertValues ( 1 , 2 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
Observable . range ( 1 , 5 ) . toFlowable ( BackpressureStrategy . DROP ) . test ( 1 ) . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = Observable . range ( 1 , 5 ) . toFlowable ( BackpressureStrategy . LATEST ) . test ( 0 ) ; ts . request ( 1 ) ; ts . assertResult ( 5 ) ; 
Observable . range ( 1 , 5 ) . toFlowable ( BackpressureStrategy . ERROR ) . test ( 1 ) . assertFailure ( MissingBackpressureException . class , 1 ) ; 
Observable . range ( 1 , 5 ) . toFlowable ( BackpressureStrategy . ERROR ) . test ( 5 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = Observable . range ( 1 , 5 ) . toFlowable ( BackpressureStrategy . MISSING ) . test ( 0 ) ; ts . request ( 2 ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Maybe < Integer > last = Observable . just ( 1 , 2 , 3 ) . lastElement ( ) ; assertEquals ( 3 , last . blockingGet ( ) . intValue ( ) ) ; 
Maybe < ? > last = Observable . empty ( ) . lastElement ( ) ; assertNull ( last . blockingGet ( ) ) ; 
Maybe < Integer > last = Observable . just ( 1 , 2 , 3 ) . lastElement ( ) ; assertEquals ( 3 , last . blockingGet ( ) . intValue ( ) ) ; assertEquals ( 3 , last . blockingGet ( ) . intValue ( ) ) ; 
Observable . just ( 1 , 2 , 3 ) . lastElement ( ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 , 3 ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 3 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . < Integer > empty ( ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 6 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . lastElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 , 3 ) . last ( 4 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 3 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 ) . last ( 2 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . < Integer > empty ( ) . last ( 1 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . last ( 8 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 6 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . last ( 4 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . last ( 2 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable . empty ( ) . lastOrError ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Observable . just ( 1 ) . lastOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Observable . just ( 1 , 2 , 3 ) . lastOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 3 ) ; 
Observable . error ( new RuntimeException ( "error" ) ) . lastOrError ( ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
TestHelper . checkDisposed ( Observable . never ( ) . lastElement ( ) . toObservable ( ) ) ; TestHelper . checkDisposed ( Observable . never ( ) . lastElement ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . lastOrError ( ) . toObservable ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . lastOrError ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . last ( 2 ) . toObservable ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . last ( 2 ) ) ; 
TestHelper . checkDoubleOnSubscribeObservableToMaybe ( new Function < Observable < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Observable < Object > o ) throws Exception return o . lastElement ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . lastElement ( ) . toObservable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Observable < Object > o ) throws Exception return o . lastOrError ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . lastOrError ( ) . toObservable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Observable < Object > o ) throws Exception return o . last ( 2 ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . last ( 2 ) . toObservable ( ) ; ) ; 
Observable . error ( new TestException ( ) ) . lastElement ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . lastOrError ( ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . empty ( ) . lastOrError ( ) . toObservable ( ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . repeatWhen ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . map ( new Function < Object , Object > ( ) int count ; @ Override public Object apply ( Object v ) throws Exception if ( ++ count == 1 ) to . dispose ( ) ; return v ; ) ; ) . subscribe ( to ) ; 
Observable . just ( 1 ) . retryWhen ( new Function < Observable < Throwable > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Throwable > v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
objectObserver = TestHelper . mockObserver ( ) ; singleObserver = TestHelper . mockSingleObserver ( ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Observable < Map < Integer , String > > mapped = source . toMap ( lengthFunc ) . toObservable ( ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "a" ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( 1 ) ) . onNext ( expected ) ; verify ( objectObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Observable < Map < Integer , String > > mapped = source . toMap ( lengthFunc , duplicate ) . toObservable ( ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "aa" ) ; expected . put ( 2 , "bbbb" ) ; expected . put ( 3 , "cccccc" ) ; expected . put ( 4 , "dddddddd" ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( 1 ) ) . onNext ( expected ) ; verify ( objectObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Function < String , Integer > lengthFuncErr = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) if ( "bb" . equals ( t1 ) ) throw new RuntimeException ( "Forced Failure" ) ; return t1 . length ( ) ; ; Observable < Map < Integer , String > > mapped = source . toMap ( lengthFuncErr ) . toObservable ( ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "a" ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onComplete ( ) ; verify ( objectObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Function < String , String > duplicateErr = new Function < String , String > ( ) @ Override public String apply ( String t1 ) if ( "bb" . equals ( t1 ) ) throw new RuntimeException ( "Forced failure" ) ; return t1 + t1 ; ; Observable < Map < Integer , String > > mapped = source . toMap ( lengthFunc , duplicateErr ) . toObservable ( ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "aa" ) ; expected . put ( 2 , "bbbb" ) ; expected . put ( 3 , "cccccc" ) ; expected . put ( 4 , "dddddddd" ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onComplete ( ) ; verify ( objectObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Supplier < Map < Integer , String > > mapFactory = new Supplier < Map < Integer , String > > ( ) @ Override public Map < Integer , String > get ( ) return new LinkedHashMap < Integer , String > ( ) private static final long serialVersionUID = - 3296811238780863394L ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , String > eldest ) return size ( ) > 3 ; ; ; Function < String , Integer > lengthFunc = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) return t1 . length ( ) ; ; Observable < Map < Integer , String > > mapped = source . toMap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) . toObservable ( ) ; Map < Integer , String > expected = new LinkedHashMap < > ( ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( 1 ) ) . onNext ( expected ) ; verify ( objectObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Supplier < Map < Integer , String > > mapFactory = new Supplier < Map < Integer , String > > ( ) @ Override public Map < Integer , String > get ( ) throw new RuntimeException ( "Forced failure" ) ; ; Function < String , Integer > lengthFunc = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) return t1 . length ( ) ; ; Observable < Map < Integer , String > > mapped = source . toMap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) . toObservable ( ) ; Map < Integer , String > expected = new LinkedHashMap < > ( ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onComplete ( ) ; verify ( objectObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "a" ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc , duplicate ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "aa" ) ; expected . put ( 2 , "bbbb" ) ; expected . put ( 3 , "cccccc" ) ; expected . put ( 4 , "dddddddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Function < String , Integer > lengthFuncErr = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) if ( "bb" . equals ( t1 ) ) throw new RuntimeException ( "Forced Failure" ) ; return t1 . length ( ) ; ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFuncErr ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "a" ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Function < String , String > duplicateErr = new Function < String , String > ( ) @ Override public String apply ( String t1 ) if ( "bb" . equals ( t1 ) ) throw new RuntimeException ( "Forced failure" ) ; return t1 + t1 ; ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc , duplicateErr ) ; Map < Integer , String > expected = new HashMap < > ( ) ; expected . put ( 1 , "aa" ) ; expected . put ( 2 , "bbbb" ) ; expected . put ( 3 , "cccccc" ) ; expected . put ( 4 , "dddddddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Supplier < Map < Integer , String > > mapFactory = new Supplier < Map < Integer , String > > ( ) @ Override public Map < Integer , String > get ( ) return new LinkedHashMap < Integer , String > ( ) private static final long serialVersionUID = - 3296811238780863394L ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , String > eldest ) return size ( ) > 3 ; ; ; Function < String , Integer > lengthFunc = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) return t1 . length ( ) ; ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) ; Map < Integer , String > expected = new LinkedHashMap < > ( ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "a" , "bb" , "ccc" , "dddd" ) ; Supplier < Map < Integer , String > > mapFactory = new Supplier < Map < Integer , String > > ( ) @ Override public Map < Integer , String > get ( ) throw new RuntimeException ( "Forced failure" ) ; ; Function < String , Integer > lengthFunc = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) return t1 . length ( ) ; ; Single < Map < Integer , String > > mapped = source . toMap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) ; Map < Integer , String > expected = new LinkedHashMap < > ( ) ; expected . put ( 2 , "bb" ) ; expected . put ( 3 , "ccc" ) ; expected . put ( 4 , "dddd" ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
aAction0 = mock ( Action . class ) ; observer = TestHelper . mockObserver ( ) ; 
input . doAfterTerminate ( aAction0 ) . subscribe ( observer ) ; try verify ( aAction0 , times ( 1 ) ) . run ( ) ; catch ( Throwable e ) throw ExceptionHelper . wrapOrThrow ( e ) ; 
checkActionCalled ( Observable . fromArray ( "1" , "2" , "3" ) ) ; 
checkActionCalled ( Observable . < String > error ( new RuntimeException ( "expected" ) ) ) ; 
Observable < String > o = Observable . fromIterable ( Arrays . < String > asList ( "one" , "two" , "three" ) ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Iterable < String > it = new Iterable < String > ( ) @ Override public Iterator < String > iterator ( ) return new Iterator < String > ( ) int i ; @ Override public boolean hasNext ( ) return i < 3 ; @ Override public String next ( ) return String . valueOf ( ++ i ) ; @ Override public void remove ( ) ; ; Observable < String > o = Observable . fromIterable ( it ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "1" ) ; verify ( observer , times ( 1 ) ) . onNext ( "2" ) ; verify ( observer , times ( 1 ) ) . onNext ( "3" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > o = Observable . fromIterable ( Arrays . < String > asList ( "one" , "two" , "three" ) ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > o = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; o . subscribe ( to ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; to . assertTerminated ( ) ; 
Observable < Integer > o = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; o . subscribe ( to ) ; to . assertValues ( 1 , 2 , 3 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
final AtomicBoolean called = new AtomicBoolean ( false ) ; Iterable < Integer > iterable = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count = 1 ; @ Override public void remove ( ) @ Override public boolean hasNext ( ) if ( count > 1 ) called . set ( true ) ; return false ; return true ; @ Override public Integer next ( ) return count ++ ; ; ; Observable . fromIterable ( iterable ) . take ( 1 ) . subscribe ( ) ; assertFalse ( called . get ( ) ) ; 
final AtomicBoolean called = new AtomicBoolean ( false ) ; Iterable < Integer > iterable = new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) int count = 1 ; @ Override public boolean hasNext ( ) if ( count > 1 ) called . set ( true ) ; return false ; return true ; @ Override public Integer next ( ) return count ++ ; ; ; Observable . fromIterable ( iterable ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) cancel ( ) ; ) ; assertFalse ( called . get ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) return Observable . range ( v , 2 ) ; ) . subscribe ( to ) ; to . assertValues ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable . fromIterable ( new CrashingIterable ( 1 , 100 , 100 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Observable . fromIterable ( new CrashingIterable ( 100 , 2 , 100 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" , 0 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( ++ count == 2 ) to . dispose ( ) ; return true ; @ Override public Integer next ( ) return 1 ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) . subscribe ( to ) ; to . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 ) ; 
Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < Integer > qd = ( QueueDisposable < Integer > ) d ; qd . requestFusion ( QueueFuseable . ANY ) ; try assertEquals ( 1 , qd . poll ( ) . intValue ( ) ) ; catch ( Throwable ex ) fail ( ex . toString ( ) ) ; qd . clear ( ) ; try assertNull ( qd . poll ( ) ) ; catch ( Throwable ex ) fail ( ex . toString ( ) ) ; @ Override public void onNext ( Integer value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . fromIterable ( ( ) -> new Iterator < Integer > ( ) int count ; @ Override public boolean hasNext ( ) if ( count ++ == 2 ) to . dispose ( ) ; return false ; return true ; @ Override public Integer next ( ) return 1 ; ) . subscribeWith ( to ) . assertValuesOnly ( 1 , 1 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Void > to = us . concatMapCompletable ( completableComplete ( ) , 2 ) . test ( ) ; us . onNext ( 1 ) ; us . onComplete ( ) ; to . assertComplete ( ) ; to . assertValueCount ( 0 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Void > to = us . hide ( ) . concatMapCompletable ( completableComplete ( ) , 2 ) . test ( ) ; us . onNext ( 1 ) ; us . onNext ( 2 ) ; us . onComplete ( ) ; to . assertComplete ( ) ; to . assertValueCount ( 0 ) ; to . assertNoErrors ( ) ; 
TestHelper . checkDisposed ( Observable . < Integer > just ( 1 ) . hide ( ) . concatMapCompletable ( completableError ( ) ) ) ; 
Observable . < Integer > error ( new TestException ( ) ) . concatMapCompletable ( completableComplete ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > just ( 1 ) . hide ( ) . concatMapCompletable ( completableError ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . concatMapCompletable ( completableComplete ( ) ) . test ( ) . assertComplete ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Void > to = ps1 . concatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . fromObservable ( ps2 ) ; ) . test ( ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertError ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapCompletable ( completableThrows ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMapCompletable ( completableComplete ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
final Disposable [ ] disposable = null ; Observable . just ( 1 ) . hide ( ) . concatMapCompletable ( completableComplete ( ) ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) disposable [ 0 ] = d ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; assertTrue ( disposable [ 0 ] . isDisposed ( ) ) ; 
final Disposable [ ] disposable = null ; Observable . just ( 1 ) . hide ( ) . concatMapCompletable ( completableError ( ) ) . subscribe ( new CompletableObserver ( ) @ Override public void onSubscribe ( Disposable d ) disposable [ 0 ] = d ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; assertTrue ( disposable [ 0 ] . isDisposed ( ) ) ; 
return new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ; 
return new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; ; 
return new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; ) . test ( ) ; us . onNext ( 1 ) ; us . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
TestHelper . checkDisposed ( Observable . < Integer > just ( 1 ) . hide ( ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . error ( new TestException ( ) ) ; ) ) ; 
TestHelper . checkDisposed ( Observable . < Integer > just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . error ( new TestException ( ) ) ; ) ) ; 
Observable . < Integer > error ( new TestException ( ) ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > just ( 1 ) . hide ( ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > error ( new TestException ( ) ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception throw new TestException ( ) ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; , true , 16 ) . test ( ) . assertResult ( 1 , 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = ps1 . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return ps2 ; ) . test ( ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertFailure ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertError ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . just ( 1 ) . hide ( ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( v , 2 ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
@ SuppressWarnings ( "rawtypes" ) final Observer [ ] o = null ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) o [ 0 ] = observer ; observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; ; ) . test ( ) . assertResult ( ) ; o [ 0 ] . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final Disposable [ ] disposable = null ; Observable . fromArray ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . hide ( ) . concatMap ( Functions . < Observable < Integer > > identity ( ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) disposable [ 0 ] = d ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; assertTrue ( disposable [ 0 ] . isDisposed ( ) ) ; 
final Disposable [ ] disposable = null ; Observable . fromArray ( Observable . just ( 1 ) , Observable . < Integer > error ( new TestException ( ) ) ) . hide ( ) . concatMap ( Functions . < Observable < Integer > > identity ( ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) disposable [ 0 ] = d ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; assertTrue ( disposable [ 0 ] . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . just ( v + 1 ) ; , 1 ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) for ( int i = 1 ; i < 10 ; i ++ ) ps . onNext ( i ) ; ps . onComplete ( ) ; ) ; ps . onNext ( 0 ) ; if ( ! errors . isEmpty ( ) ) to . onError ( new CompositeException ( errors ) ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . just ( v + 1 ) . hide ( ) ; , 1 ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) for ( int i = 1 ; i < 10 ; i ++ ) ps . onNext ( i ) ; ps . onComplete ( ) ; ) ; ps . onNext ( 0 ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable . range ( 1 , 5 ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . just ( v ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; , false , 2 ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; , true , 2 ) ; ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . concatMap ( v -> Observable . never ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . concatMapDelayError ( v -> Observable . never ( ) ) ) ; 
Observable . fromCallable ( ( ) -> 1 ) . concatMap ( v -> Observable . just ( 2 ) . hide ( ) ) . test ( ) . assertResult ( 2 ) ; 
TestHelper . rejectObservableFusion ( ) . concatMap ( v -> Observable . never ( ) ) . test ( ) ; 
TestHelper . rejectObservableFusion ( ) . concatMapDelayError ( v -> Observable . never ( ) ) . test ( ) ; 
UnicastSubject < Integer > uc = UnicastSubject . create ( ) ; TestObserver < Integer > to = uc . concatMapDelayError ( v -> Observable . just ( v ) . hide ( ) ) . test ( ) ; uc . onNext ( 1 ) ; uc . onComplete ( ) ; to . assertResult ( 1 ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( v -> Observable . just ( v ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( v -> Observable . empty ( ) ) . test ( ) . assertResult ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( v -> Observable . fromCallable ( ( ) -> to . dispose ( ) ; return 1 ; ) ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( v -> new EmptyDisposingObservable ( to ) ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . range ( 1 , 5 ) . hide ( ) . concatMapDelayError ( v -> ps ) . test ( ) ; ps . onComplete ( ) ; to . assertResult ( ) ; 
Observer < String > w = TestHelper . mockObserver ( ) ; PublishSubject < String > w1 = PublishSubject . create ( ) ; PublishSubject < String > w2 = PublishSubject . create ( ) ; Observable < String > combined = Observable . combineLatest ( w1 , w2 , new BiFunction < String , String , String > ( ) @ Override public String apply ( String v1 , String v2 ) throw new RuntimeException ( "I don't work." ) ; ) ; combined . subscribe ( w ) ; w1 . onNext ( "first value of w1" ) ; w2 . onNext ( "first value of w2" ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onComplete ( ) ; verify ( w , times ( 1 ) ) . onError ( Mockito . < RuntimeException > any ( ) ) ; 
Observer < String > w = TestHelper . mockObserver ( ) ; PublishSubject < String > w1 = PublishSubject . create ( ) ; PublishSubject < String > w2 = PublishSubject . create ( ) ; PublishSubject < String > w3 = PublishSubject . create ( ) ; Observable < String > combineLatestW = Observable . combineLatest ( w1 , w2 , w3 , getConcat3StringsCombineLatestFunction ( ) ) ; combineLatestW . subscribe ( w ) ; w1 . onNext ( "1a" ) ; w2 . onNext ( "2a" ) ; w3 . onNext ( "3a" ) ; w1 . onComplete ( ) ; w2 . onNext ( "2b" ) ; w2 . onComplete ( ) ; w3 . onNext ( "3b" ) ; w3 . onNext ( "3c" ) ; w3 . onNext ( "3d" ) ; w3 . onComplete ( ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w ) . onNext ( "1a2a3a" ) ; inOrder . verify ( w ) . onNext ( "1a2b3a" ) ; inOrder . verify ( w ) . onNext ( "1a2b3b" ) ; inOrder . verify ( w ) . onNext ( "1a2b3c" ) ; inOrder . verify ( w ) . onNext ( "1a2b3d" ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observer < String > w = TestHelper . mockObserver ( ) ; PublishSubject < String > w1 = PublishSubject . create ( ) ; PublishSubject < String > w2 = PublishSubject . create ( ) ; PublishSubject < String > w3 = PublishSubject . create ( ) ; Observable < String > combineLatestW = Observable . combineLatest ( w1 , w2 , w3 , getConcat3StringsCombineLatestFunction ( ) ) ; combineLatestW . subscribe ( w ) ; w1 . onNext ( "1a" ) ; w1 . onNext ( "1b" ) ; w1 . onNext ( "1c" ) ; w1 . onNext ( "1d" ) ; w1 . onComplete ( ) ; w2 . onNext ( "2a" ) ; w2 . onNext ( "2b" ) ; w2 . onComplete ( ) ; w3 . onNext ( "3a" ) ; w3 . onComplete ( ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "1d2b3a" ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observer < String > w = TestHelper . mockObserver ( ) ; PublishSubject < String > w1 = PublishSubject . create ( ) ; PublishSubject < String > w2 = PublishSubject . create ( ) ; PublishSubject < String > w3 = PublishSubject . create ( ) ; Observable < String > combineLatestW = Observable . combineLatest ( w1 , w2 , w3 , getConcat3StringsCombineLatestFunction ( ) ) ; combineLatestW . subscribe ( w ) ; w1 . onNext ( "1a" ) ; w2 . onNext ( "2a" ) ; w2 . onNext ( "2b" ) ; w3 . onNext ( "3a" ) ; w1 . onNext ( "1b" ) ; w2 . onNext ( "2c" ) ; w2 . onNext ( "2d" ) ; w3 . onNext ( "3b" ) ; w1 . onComplete ( ) ; w2 . onComplete ( ) ; w3 . onComplete ( ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w ) . onNext ( "1a2b3a" ) ; inOrder . verify ( w ) . onNext ( "1b2b3a" ) ; inOrder . verify ( w ) . onNext ( "1b2c3a" ) ; inOrder . verify ( w ) . onNext ( "1b2d3a" ) ; inOrder . verify ( w ) . onNext ( "1b2d3b" ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
BiFunction < String , Integer , String > combineLatestFunction = getConcatStringIntegerCombineLatestFunction ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > w = Observable . combineLatest ( Observable . just ( "one" , "two" ) , Observable . just ( 2 , 3 , 4 ) , combineLatestFunction ) ; w . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "two2" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two3" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two4" ) ; 
Function3 < String , Integer , int [ ] , String > combineLatestFunction = getConcatStringIntegerIntArrayCombineLatestFunction ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > w = Observable . combineLatest ( Observable . just ( "one" , "two" ) , Observable . just ( 2 ) , Observable . just ( new int [ ] 4 , 5 , 6 ) , combineLatestFunction ) ; w . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "two2[4, 5, 6]" ) ; 
Function3 < String , Integer , int [ ] , String > combineLatestFunction = getConcatStringIntegerIntArrayCombineLatestFunction ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > w = Observable . combineLatest ( Observable . just ( "one" ) , Observable . just ( 2 ) , Observable . just ( new int [ ] 4 , 5 , 6 , new int [ ] 7 , 8 ) , combineLatestFunction ) ; w . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one2[4, 5, 6]" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one2[7, 8]" ) ; 
Function3 < String , String , String , String > combineLatestFunction = new Function3 < String , String , String , String > ( ) @ Override public String apply ( String a1 , String a2 , String a3 ) if ( a1 == null ) a1 = "" ; if ( a2 == null ) a2 = "" ; if ( a3 == null ) a3 = "" ; return a1 + a2 + a3 ; ; return combineLatestFunction ; 
BiFunction < String , Integer , String > combineLatestFunction = new BiFunction < String , Integer , String > ( ) @ Override public String apply ( String s , Integer i ) return getStringValue ( s ) + getStringValue ( i ) ; ; return combineLatestFunction ; 
return new Function3 < String , Integer , int [ ] , String > ( ) @ Override public String apply ( String s , Integer i , int [ ] iArray ) return getStringValue ( s ) + getStringValue ( i ) + getStringValue ( iArray ) ; ; 
if ( o == null ) return "" ; else if ( o instanceof int [ ] ) return Arrays . toString ( ( int [ ] ) o ) ; else return String . valueOf ( o ) ; 
PublishSubject < Integer > a = PublishSubject . create ( ) ; PublishSubject < Integer > b = PublishSubject . create ( ) ; Observable < Integer > source = Observable . combineLatest ( a , b , or ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer ) ; source . subscribe ( observer ) ; a . onNext ( 1 ) ; inOrder . verify ( observer , never ( ) ) . onNext ( any ( ) ) ; a . onNext ( 2 ) ; inOrder . verify ( observer , never ( ) ) . onNext ( any ( ) ) ; b . onNext ( 0x10 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 0x12 ) ; b . onNext ( 0x20 ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 0x22 ) ; b . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; a . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; a . onNext ( 3 ) ; b . onNext ( 0x30 ) ; a . onComplete ( ) ; b . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > a = PublishSubject . create ( ) ; PublishSubject < Integer > b = PublishSubject . create ( ) ; Observable < Integer > source = Observable . combineLatest ( a , b , or ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; Observer < Object > observer2 = TestHelper . mockObserver ( ) ; InOrder inOrder1 = inOrder ( observer1 ) ; InOrder inOrder2 = inOrder ( observer2 ) ; source . subscribe ( observer1 ) ; source . subscribe ( observer2 ) ; a . onNext ( 1 ) ; inOrder1 . verify ( observer1 , never ( ) ) . onNext ( any ( ) ) ; inOrder2 . verify ( observer2 , never ( ) ) . onNext ( any ( ) ) ; a . onNext ( 2 ) ; inOrder1 . verify ( observer1 , never ( ) ) . onNext ( any ( ) ) ; inOrder2 . verify ( observer2 , never ( ) ) . onNext ( any ( ) ) ; b . onNext ( 0x10 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onNext ( 0x12 ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 0x12 ) ; b . onNext ( 0x20 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onNext ( 0x22 ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 0x22 ) ; b . onComplete ( ) ; inOrder1 . verify ( observer1 , never ( ) ) . onComplete ( ) ; inOrder2 . verify ( observer2 , never ( ) ) . onComplete ( ) ; a . onComplete ( ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; a . onNext ( 3 ) ; b . onNext ( 0x30 ) ; a . onComplete ( ) ; b . onComplete ( ) ; inOrder1 . verifyNoMoreInteractions ( ) ; inOrder2 . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > a = PublishSubject . create ( ) ; PublishSubject < Integer > b = PublishSubject . create ( ) ; Observable < Integer > source = Observable . combineLatest ( a , b , or ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer ) ; source . subscribe ( observer ) ; b . onNext ( 0x10 ) ; b . onNext ( 0x20 ) ; a . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > a = PublishSubject . create ( ) ; PublishSubject < Integer > b = PublishSubject . create ( ) ; Observable < Integer > source = Observable . combineLatest ( a , b , or ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer ) ; source . subscribe ( observer ) ; a . onNext ( 0x1 ) ; a . onNext ( 0x2 ) ; b . onComplete ( ) ; a . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
int n = 30 ; Function < Object [ ] , List < Object > > func = new Function < Object [ ] , List < Object > > ( ) @ Override public List < Object > apply ( Object [ ] args ) return Arrays . asList ( args ) ; ; for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( "test1ToNSources: " + i + " sources" ) ; List < Observable < Integer > > sources = new ArrayList < > ( ) ; List < Object > values = new ArrayList < > ( ) ; for ( int j = 0 ; j < i ; j ++ ) sources . add ( Observable . just ( j ) ) ; values . add ( j ) ; Observable < List < Object > > result = Observable . combineLatest ( sources , func ) ; Observer < List < Object > > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( values ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
int n = 10 ; Function < Object [ ] , List < Object > > func = new Function < Object [ ] , List < Object > > ( ) @ Override public List < Object > apply ( Object [ ] args ) return Arrays . asList ( args ) ; ; for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( "test1ToNSourcesScheduled: " + i + " sources" ) ; List < Observable < Integer > > sources = new ArrayList < > ( ) ; List < Object > values = new ArrayList < > ( ) ; for ( int j = 0 ; j < i ; j ++ ) sources . add ( Observable . just ( j ) . subscribeOn ( Schedulers . io ( ) ) ) ; values . add ( j ) ; Observable < List < Object > > result = Observable . combineLatest ( sources , func ) ; final Observer < List < Object > > o = TestHelper . mockObserver ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; Observer < List < Object > > observer = new DefaultObserver < List < Object > > ( ) @ Override public void onNext ( List < Object > t ) o . onNext ( t ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; cdl . countDown ( ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; cdl . countDown ( ) ; ; result . subscribe ( observer ) ; cdl . await ( ) ; verify ( o ) . onNext ( values ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > s1 = Observable . just ( 1 ) ; Observable < Integer > s2 = Observable . just ( 2 ) ; Observable < List < Integer > > result = Observable . combineLatest ( s1 , s2 , new BiFunction < Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 ) return Arrays . asList ( t1 , t2 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 2 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > s1 = Observable . just ( 1 ) ; Observable < Integer > s2 = Observable . just ( 2 ) ; Observable < Integer > s3 = Observable . just ( 3 ) ; Observable < List < Integer > > result = Observable . combineLatest ( s1 , s2 , s3 , new Function3 < Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 ) return Arrays . asList ( t1 , t2 , t3 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 2 , 3 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > s1 = Observable . just ( 1 ) ; Observable < Integer > s2 = Observable . just ( 2 ) ; Observable < Integer > s3 = Observable . just ( 3 ) ; Observable < Integer > s4 = Observable . just ( 4 ) ; Observable < List < Integer > > result = Observable . combineLatest ( s1 , s2 , s3 , s4 , new Function4 < Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 ) return Arrays . asList ( t1 , t2 , t3 , t4 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > s1 = Observable . just ( 1 ) ; Observable < Integer > s2 = Observable . just ( 2 ) ; Observable < Integer > s3 = Observable . just ( 3 ) ; Observable < Integer > s4 = Observable . just ( 4 ) ; Observable < Integer > s5 = Observable . just ( 5 ) ; Observable < List < Integer > > result = Observable . combineLatest ( s1 , s2 , s3 , s4 , s5 , new Function5 < Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > s1 = Observable . just ( 1 ) ; Observable < Integer > s2 = Observable . just ( 2 ) ; Observable < Integer > s3 = Observable . just ( 3 ) ; Observable < Integer > s4 = Observable . just ( 4 ) ; Observable < Integer > s5 = Observable . just ( 5 ) ; Observable < Integer > s6 = Observable . just ( 6 ) ; Observable < List < Integer > > result = Observable . combineLatest ( s1 , s2 , s3 , s4 , s5 , s6 , new Function6 < Integer , Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 , t6 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > s1 = Observable . just ( 1 ) ; Observable < Integer > s2 = Observable . just ( 2 ) ; Observable < Integer > s3 = Observable . just ( 3 ) ; Observable < Integer > s4 = Observable . just ( 4 ) ; Observable < Integer > s5 = Observable . just ( 5 ) ; Observable < Integer > s6 = Observable . just ( 6 ) ; Observable < Integer > s7 = Observable . just ( 7 ) ; Observable < List < Integer > > result = Observable . combineLatest ( s1 , s2 , s3 , s4 , s5 , s6 , s7 , new Function7 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 , t6 , t7 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > s1 = Observable . just ( 1 ) ; Observable < Integer > s2 = Observable . just ( 2 ) ; Observable < Integer > s3 = Observable . just ( 3 ) ; Observable < Integer > s4 = Observable . just ( 4 ) ; Observable < Integer > s5 = Observable . just ( 5 ) ; Observable < Integer > s6 = Observable . just ( 6 ) ; Observable < Integer > s7 = Observable . just ( 7 ) ; Observable < Integer > s8 = Observable . just ( 8 ) ; Observable < List < Integer > > result = Observable . combineLatest ( s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , new Function8 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 , Integer t8 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 , t6 , t7 , t8 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > s1 = Observable . just ( 1 ) ; Observable < Integer > s2 = Observable . just ( 2 ) ; Observable < Integer > s3 = Observable . just ( 3 ) ; Observable < Integer > s4 = Observable . just ( 4 ) ; Observable < Integer > s5 = Observable . just ( 5 ) ; Observable < Integer > s6 = Observable . just ( 6 ) ; Observable < Integer > s7 = Observable . just ( 7 ) ; Observable < Integer > s8 = Observable . just ( 8 ) ; Observable < Integer > s9 = Observable . just ( 9 ) ; Observable < List < Integer > > result = Observable . combineLatest ( s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , new Function9 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 , Integer t2 , Integer t3 , Integer t4 , Integer t5 , Integer t6 , Integer t7 , Integer t8 , Integer t9 ) return Arrays . asList ( t1 , t2 , t3 , t4 , t5 , t6 , t7 , t8 , t9 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Object > result = Observable . combineLatest ( Collections . < Observable < Object > > emptyList ( ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] args ) return args ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicInteger count = new AtomicInteger ( ) ; final int SIZE = 2000 ; Observable < Long > timer = Observable . interval ( 0 , 1 , TimeUnit . MILLISECONDS ) . observeOn ( Schedulers . newThread ( ) ) . doOnEach ( new Consumer < Notification < Long > > ( ) @ Override public void accept ( Notification < Long > n ) if ( count . incrementAndGet ( ) >= SIZE ) latch . countDown ( ) ; ) . take ( SIZE ) ; TestObserver < Long > to = new TestObserver < > ( ) ; Observable . combineLatest ( timer , Observable . < Integer > never ( ) , new BiFunction < Long , Integer , Long > ( ) @ Override public Long apply ( Long t1 , Integer t2 ) return t1 ; ) . subscribe ( to ) ; if ( ! latch . await ( SIZE + 1000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out" ) ; assertEquals ( SIZE , count . get ( ) ) ; 
Observable . combineLatestArray ( new ObservableSource [ ] Observable . just ( 1 ) , Observable . just ( 2 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertResult ( "[1, 2]" ) ; 
Observable . combineLatestArrayDelayError ( new ObservableSource [ ] Observable . just ( 1 ) , Observable . just ( 2 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertResult ( "[1, 2]" ) ; 
Observable . combineLatestArrayDelayError ( new ObservableSource [ ] Observable . just ( 1 ) , Observable . just ( 2 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertFailure ( TestException . class , "[1, 2]" ) ; 
Observable . combineLatestDelayError ( Arrays . asList ( Observable . just ( 1 ) , Observable . just ( 2 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertResult ( "[1, 2]" ) ; 
Observable . combineLatestDelayError ( Arrays . asList ( Observable . just ( 1 ) , Observable . just ( 2 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertFailure ( TestException . class , "[1, 2]" ) ; 
assertSame ( Observable . empty ( ) , Observable . combineLatestArray ( new ObservableSource [ 0 ] , Functions . < Object [ ] > identity ( ) , 16 ) ) ; 
assertSame ( Observable . empty ( ) , Observable . combineLatestArrayDelayError ( new ObservableSource [ 0 ] , Functions . < Object [ ] > identity ( ) , 16 ) ) ; 
TestHelper . checkDisposed ( Observable . combineLatest ( Observable . never ( ) , Observable . never ( ) , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; Observable . combineLatest ( Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception to . dispose ( ) ; ) , Observable . never ( ) , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . subscribe ( to ) ; 
Observable < Integer > source = Observable . range ( 1 , 1000 ) . subscribeOn ( Schedulers . computation ( ) ) ; Observable . combineLatest ( source , source , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . take ( 500 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . combineLatest ( Observable . never ( ) , Observable . error ( new TestException ( ) ) , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . combineLatestArrayDelayError ( new ObservableSource [ ] Observable . error ( new TestException ( ) ) , Observable . just ( 1 ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return a ; , 128 ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . combineLatestArrayDelayError ( new ObservableSource [ ] Observable . error ( new TestException ( ) ) . startWithItem ( 1 ) , Observable . empty ( ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return a ; , 128 ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserverEx < Integer > to = Observable . combineLatest ( ps1 , ps2 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to . errors ( ) . size ( ) != 0 ) if ( to . errors ( ) . get ( 0 ) instanceof CompositeException ) to . assertSubscribed ( ) . assertNotComplete ( ) . assertNoValues ( ) ; for ( Throwable e : TestHelper . errorList ( to ) ) assertTrue ( e . toString ( ) , e instanceof TestException ) ; else to . assertFailure ( TestException . class ) ; for ( Throwable e : errors ) assertTrue ( e . toString ( ) , e . getCause ( ) instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final int [ ] count = 0 ; Observable . combineLatest ( Observable . empty ( ) , Observable . error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception count [ 0 ] ++ ; ) , new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return 0 ; ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , count [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final int [ ] count = 0 ; Observable . combineLatestDelayError ( Arrays . asList ( Observable . empty ( ) , Observable . error ( new TestException ( ) ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception count [ 0 ] ++ ; ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return 0 ; ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , count [ 0 ] ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestObserver < Object > testObserver = TestObserver . create ( ) ; TestScheduler testScheduler = new TestScheduler ( ) ; Observable < Integer > emptyObservable = Observable . timer ( 10 , TimeUnit . MILLISECONDS , testScheduler ) . flatMap ( new Function < Long , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Long aLong ) throws Exception return Observable . error ( new Exception ( ) ) ; ) ; Observable < Object > errorObservable = Observable . timer ( 100 , TimeUnit . MILLISECONDS , testScheduler ) . map ( new Function < Long , Object > ( ) @ Override public Object apply ( Long aLong ) throws Exception throw new Exception ( ) ; ) ; Observable . combineLatestDelayError ( Arrays . asList ( emptyObservable . doOnEach ( new Consumer < Notification < Integer > > ( ) @ Override public void accept ( Notification < Integer > integerNotification ) throws Exception System . out . println ( "emptyObservable: " + integerNotification ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception System . out . println ( "emptyObservable: doFinally" ) ; ) , errorObservable . doOnEach ( new Consumer < Notification < Object > > ( ) @ Override public void accept ( Notification < Object > integerNotification ) throws Exception System . out . println ( "errorObservable: " + integerNotification ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception System . out . println ( "errorObservable: doFinally" ) ; ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] objects ) throws Exception return 0 ; ) . doOnEach ( new Consumer < Notification < Object > > ( ) @ Override public void accept ( Notification < Object > integerNotification ) throws Exception System . out . println ( "combineLatestDelayError: " + integerNotification ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception System . out . println ( "combineLatestDelayError: doFinally" ) ; ) . subscribe ( testObserver ) ; testScheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; testObserver . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; dispose ( ) ; if ( ps1 . hasObservers ( ) ) onError ( new IllegalStateException ( "ps1 not disposed" ) ) ; else if ( ps2 . hasObservers ( ) ) onError ( new IllegalStateException ( "ps2 not disposed" ) ) ; else onComplete ( ) ; ; Observable . combineLatest ( ps1 , ps2 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throws Exception return t1 + t2 ; ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; ps2 . onNext ( 2 ) ; to . assertResult ( 3 ) ; 
Observable . combineLatestDelayError ( Arrays . asList ( Observable . just ( 21 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 21 ) . delay ( 100 , TimeUnit . MILLISECONDS ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return ( Integer ) a [ 0 ] + ( Integer ) a [ 1 ] ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class , 42 ) ; 
ObservableSource < Integer > source = new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) Observable . just ( 1 ) . subscribe ( observer ) ; ; Observable . combineLatest ( Arrays . asList ( source , source ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] t ) throws Throwable return 2 ; ) . test ( ) . assertResult ( 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observable . combineLatest ( ps , Observable . never ( ) , ( a , b ) -> a ) . subscribe ( to ) ; TestHelper . race ( ( ) -> ps . onComplete ( ) , ( ) -> to . dispose ( ) ) ; 
TestHelper . withErrorTracking ( errors -> TestException ex = new TestException ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserverEx < Object [ ] > to = new TestObserverEx < > ( ) ; AtomicReference < Observer < ? super Object > > ref = new AtomicReference < > ( ) ; Observable < Object > o = new Observable < Object > ( ) @ Override public void subscribeActual ( Observer < ? super Object > observer ) ref . set ( observer ) ; ; Observable . combineLatestDelayError ( Arrays . asList ( o , Observable . never ( ) ) , ( a ) -> a ) . subscribe ( to ) ; ref . get ( ) . onSubscribe ( Disposable . empty ( ) ) ; TestHelper . race ( ( ) -> ref . get ( ) . onError ( ex ) , ( ) -> to . dispose ( ) ) ; if ( to . errors ( ) . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . combineLatest ( ps1 , ps2 , ( a , b ) -> a + b ) . doOnNext ( v -> if ( v == 2 ) ps2 . onNext ( 3 ) ; ps2 . onComplete ( ) ; ps1 . onComplete ( ) ; ) . test ( ) ; ps1 . onNext ( 1 ) ; ps2 . onNext ( 1 ) ; to . assertResult ( 2 , 4 ) ; 
Observable . combineLatest ( Arrays . asList ( Observable . never ( ) , null ) , ( a ) -> a ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
w = TestHelper . mockObserver ( ) ; w2 = TestHelper . mockObserver ( ) ; 
Observable < String > src = Observable . empty ( ) ; src . distinctUntilChanged ( ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > src = Observable . empty ( ) ; src . distinctUntilChanged ( TO_UPPER_WITH_EXCEPTION ) . subscribe ( w ) ; verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" , "c" , "c" , "b" , "b" , "a" , "e" ) ; src . distinctUntilChanged ( ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "e" ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" , "C" , "c" , "B" , "b" , "a" , "e" ) ; src . distinctUntilChanged ( TO_UPPER_WITH_EXCEPTION ) . subscribe ( w ) ; InOrder inOrder = inOrder ( w ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "B" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( w , times ( 1 ) ) . onNext ( "e" ) ; inOrder . verify ( w , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( w , never ( ) ) . onNext ( anyString ( ) ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "B" , "A" , "a" , "C" ) ; TestObserver < String > to = TestObserver . create ( ) ; source . distinctUntilChanged ( new BiPredicate < String , String > ( ) @ Override public boolean test ( String a , String b ) return a . compareToIgnoreCase ( b ) == 0 ; ) . subscribe ( to ) ; to . assertValues ( "a" , "b" , "A" , "C" ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "B" , "A" , "a" , "C" ) ; TestObserver < String > to = TestObserver . create ( ) ; source . distinctUntilChanged ( new BiPredicate < String , String > ( ) @ Override public boolean test ( String a , String b ) throw new TestException ( ) ; ) . subscribe ( to ) ; to . assertValue ( "a" ) ; to . assertNotComplete ( ) ; to . assertError ( TestException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Observable . just ( 1 , 2 , 2 , 3 , 3 , 4 , 5 ) . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) throws Exception return a . equals ( b ) ; ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) throws Exception return a . equals ( b ) ; ) . subscribe ( to ) ; TestHelper . emit ( us , 1 , 2 , 2 , 3 , 3 , 4 , 5 ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . wrap ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onNext ( 3 ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; ) . distinctUntilChanged ( new BiPredicate < Integer , Integer > ( ) @ Override public boolean test ( Integer a , Integer b ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Mutable m = new Mutable ( ) ; PublishSubject < Mutable > ps = PublishSubject . create ( ) ; TestObserver < Mutable > to = ps . distinctUntilChanged ( new Function < Mutable , Object > ( ) @ Override public Object apply ( Mutable m ) throws Exception return m . value ; ) . test ( ) ; ps . onNext ( m ) ; m . value = 1 ; ps . onNext ( m ) ; ps . onComplete ( ) ; to . assertResult ( m , m ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . range ( 1 , 10 ) . takeLast ( 1 ) . subscribe ( to ) ; to . assertValue ( 10 ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; Observable . empty ( ) . takeLast ( 1 ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 ) . takeLast ( 1 ) . subscribe ( to ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; 
final AtomicBoolean unsubscribed = new AtomicBoolean ( false ) ; Action unsubscribeAction = new Action ( ) @ Override public void run ( ) unsubscribed . set ( true ) ; ; Observable . just ( 1 ) . concatWith ( Observable . < Integer > never ( ) ) . doOnDispose ( unsubscribeAction ) . takeLast ( 1 ) . subscribe ( ) . dispose ( ) ; assertTrue ( unsubscribed . get ( ) ) ; 
final AtomicInteger upstreamCount = new AtomicInteger ( ) ; final int num = 10 ; long count = Observable . range ( 1 , num ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) upstreamCount . incrementAndGet ( ) ; ) . takeLast ( 0 ) . count ( ) . blockingGet ( ) ; assertEquals ( num , upstreamCount . get ( ) ) ; assertEquals ( 0L , count ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . takeLast ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > f ) throws Exception return f . takeLast ( 1 ) ; ) ; 
Observable . error ( new TestException ( ) ) . takeLast ( 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable < Integer > o = Observable . just ( 1 ) . singleElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 ) . singleElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . < Integer > empty ( ) . singleElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 ) . single ( 2 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 ) . single ( 3 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . < Integer > empty ( ) . single ( 1 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 4 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 6 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 2 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > source = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Observable < Integer > reduced = source . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 + i2 ; ) . toObservable ( ) ; Integer r = reduced . blockingFirst ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Maybe < Integer > o = Observable . just ( 1 ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . < Integer > empty ( ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 , 3 , 4 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . singleElement ( ) ; MaybeObserver < Integer > observer = TestHelper . mockMaybeObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 ) . single ( 2 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 ) . single ( 3 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . < Integer > empty ( ) . single ( 1 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 4 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 , 3 , 4 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 6 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . single ( 2 ) ; SingleObserver < Integer > observer = TestHelper . mockSingleObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > source = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Maybe < Integer > reduced = source . reduce ( new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 + i2 ; ) ; Integer r = reduced . blockingGet ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
final Throwable exception = new RuntimeException ( "some error" ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; try RxJavaPlugins . setErrorHandler ( new Consumer < Throwable > ( ) @ Override public void accept ( final Throwable throwable ) throws Exception error . set ( throwable ) ; ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( final Observer < ? super Integer > observer ) observer . onComplete ( ) ; observer . onError ( exception ) ; ) . singleElement ( ) . test ( ) . assertComplete ( ) ; assertSame ( exception , error . get ( ) . getCause ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . empty ( ) . singleOrError ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Observable . just ( 1 ) . singleOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Observable . just ( 1 , 2 , 3 ) . singleOrError ( ) . test ( ) . assertNoValues ( ) . assertError ( IllegalArgumentException . class ) ; 
Observable . error ( new RuntimeException ( "error" ) ) . singleOrError ( ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Object > , Object > ( ) @ Override public Object apply ( Observable < Object > o ) throws Exception return o . singleOrError ( ) ; , false , 1 , 1 , 1 ) ; TestHelper . checkBadSourceObservable ( new Function < Observable < Object > , Object > ( ) @ Override public Object apply ( Observable < Object > o ) throws Exception return o . singleElement ( ) ; , false , 1 , 1 , 1 ) ; 
TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Object > , SingleSource < Object > > ( ) @ Override public SingleSource < Object > apply ( Observable < Object > o ) throws Exception return o . singleOrError ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservableToMaybe ( new Function < Observable < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Observable < Object > o ) throws Exception return o . singleElement ( ) ; ) ; 
Observable . empty ( ) . singleOrError ( ) . toObservable ( ) . test ( ) . assertFailure ( NoSuchElementException . class ) ; 
observer = TestHelper . mockObserver ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > m = source . skipUntil ( other ) ; m . subscribe ( observer ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; other . onNext ( 100 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onNext ( 3 ) ; verify ( observer , times ( 1 ) ) . onNext ( 4 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > m = source . skipUntil ( Observable . never ( ) ) ; m . subscribe ( observer ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > m = source . skipUntil ( Observable . empty ( ) ) ; m . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > m = source . skipUntil ( other ) ; m . subscribe ( observer ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; other . onNext ( 100 ) ; other . onComplete ( ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onNext ( 3 ) ; verify ( observer , times ( 1 ) ) . onNext ( 4 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > m = source . skipUntil ( other ) ; m . subscribe ( observer ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; other . onNext ( 100 ) ; other . onComplete ( ) ; source . onNext ( 2 ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > m = source . skipUntil ( other ) ; m . subscribe ( observer ) ; source . onNext ( 0 ) ; source . onNext ( 1 ) ; other . onError ( new RuntimeException ( "Forced failure" ) ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . skipUntil ( PublishSubject . create ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . skipUntil ( Observable . never ( ) ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return Observable . never ( ) . skipUntil ( o ) ; ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; observer = TestHelper . mockObserver ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; publishNext ( innerObserver , 100 , "one" ) ; publishNext ( innerObserver , 300 , "two" ) ; publishNext ( innerObserver , 900 , "three" ) ; publishNext ( innerObserver , 905 , "four" ) ; publishCompleted ( innerObserver , 1000 ) ; ) ; Observable < String > sampled = source . throttleFirst ( 400 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 1000 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 0 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 0 ) ) . onNext ( "four" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > innerObserver ) innerObserver . onSubscribe ( Disposable . empty ( ) ) ; Exception error = new TestException ( ) ; publishNext ( innerObserver , 100 , "one" ) ; publishNext ( innerObserver , 200 , "two" ) ; publishError ( innerObserver , 300 , error ) ; ) ; Observable < String > sampled = source . throttleFirst ( 400 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 400 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer ) . onNext ( "one" ) ; inOrder . verify ( observer ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observer < Integer > observer = TestHelper . mockObserver ( ) ; TestScheduler s = new TestScheduler ( ) ; PublishSubject < Integer > o = PublishSubject . create ( ) ; o . throttleFirst ( 500 , TimeUnit . MILLISECONDS , s ) . subscribe ( observer ) ; s . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; o . onNext ( 1 ) ; o . onNext ( 2 ) ; s . advanceTimeTo ( 501 , TimeUnit . MILLISECONDS ) ; o . onNext ( 3 ) ; s . advanceTimeTo ( 600 , TimeUnit . MILLISECONDS ) ; o . onNext ( 4 ) ; s . advanceTimeTo ( 700 , TimeUnit . MILLISECONDS ) ; o . onNext ( 5 ) ; o . onNext ( 6 ) ; s . advanceTimeTo ( 1001 , TimeUnit . MILLISECONDS ) ; o . onNext ( 7 ) ; s . advanceTimeTo ( 1501 , TimeUnit . MILLISECONDS ) ; o . onComplete ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onNext ( 1 ) ; inOrder . verify ( observer ) . onNext ( 3 ) ; inOrder . verify ( observer ) . onNext ( 7 ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable . just ( 1 ) . throttleFirst ( 100 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . throttleFirst ( 1 , TimeUnit . DAYS ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . throttleFirst ( 1 , TimeUnit . SECONDS ) ) ; 
subscribedObserver = TestHelper . mockObserver ( ) ; sideEffectObserver = TestHelper . mockObserver ( ) ; 
Observable < String > base = Observable . just ( "a" , "b" , "c" ) ; Observable < String > doOnEach = base . doOnEach ( sideEffectObserver ) ; doOnEach . subscribe ( subscribedObserver ) ; verify ( subscribedObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscribedObserver , times ( 1 ) ) . onNext ( "a" ) ; verify ( subscribedObserver , times ( 1 ) ) . onNext ( "b" ) ; verify ( subscribedObserver , times ( 1 ) ) . onNext ( "c" ) ; verify ( subscribedObserver , times ( 1 ) ) . onComplete ( ) ; verify ( sideEffectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( sideEffectObserver , times ( 1 ) ) . onNext ( "a" ) ; verify ( sideEffectObserver , times ( 1 ) ) . onNext ( "b" ) ; verify ( sideEffectObserver , times ( 1 ) ) . onNext ( "c" ) ; verify ( sideEffectObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > base = Observable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; Observable < String > errs = base . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; return s ; ) ; Observable < String > doOnEach = errs . doOnEach ( sideEffectObserver ) ; doOnEach . subscribe ( subscribedObserver ) ; verify ( subscribedObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscribedObserver , never ( ) ) . onNext ( "two" ) ; verify ( subscribedObserver , never ( ) ) . onNext ( "three" ) ; verify ( subscribedObserver , never ( ) ) . onComplete ( ) ; verify ( subscribedObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( sideEffectObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( sideEffectObserver , never ( ) ) . onNext ( "two" ) ; verify ( sideEffectObserver , never ( ) ) . onNext ( "three" ) ; verify ( sideEffectObserver , never ( ) ) . onComplete ( ) ; verify ( sideEffectObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > base = Observable . just ( "one" , "two" , "fail" , "three" ) ; Observable < String > doOnEach = base . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; ) ; doOnEach . subscribe ( subscribedObserver ) ; verify ( subscribedObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscribedObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscribedObserver , never ( ) ) . onNext ( "three" ) ; verify ( subscribedObserver , never ( ) ) . onComplete ( ) ; verify ( subscribedObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
final int expectedCount = 3 ; final AtomicInteger count = new AtomicInteger ( ) ; for ( int i = 0 ; i < expectedCount ; i ++ ) Observable . just ( Boolean . TRUE , Boolean . FALSE ) . takeWhile ( new Predicate < Boolean > ( ) @ Override public boolean test ( Boolean value ) return value ; ) . toList ( ) . doOnSuccess ( new Consumer < List < Boolean > > ( ) @ Override public void accept ( List < Boolean > booleans ) count . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( expectedCount , count . get ( ) ) ; 
final int expectedCount = 3 ; final AtomicInteger count = new AtomicInteger ( ) ; for ( int i = 0 ; i < expectedCount ; i ++ ) Observable . just ( Boolean . TRUE , Boolean . FALSE , Boolean . FALSE ) . takeWhile ( new Predicate < Boolean > ( ) @ Override public boolean test ( Boolean value ) return value ; ) . toList ( ) . doOnSuccess ( new Consumer < List < Boolean > > ( ) @ Override public void accept ( List < Boolean > booleans ) count . incrementAndGet ( ) ; ) . subscribe ( ) ; assertEquals ( expectedCount , count . get ( ) ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; Observable . error ( new TestException ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throw new TestException ( ) ; ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( CompositeException . class ) ; CompositeException ex = ( CompositeException ) to . errors ( ) . get ( 0 ) ; List < Throwable > exceptions = ex . getExceptions ( ) ; assertEquals ( 2 , exceptions . size ( ) ) ; Assert . assertTrue ( exceptions . get ( 0 ) instanceof TestException ) ; Assert . assertTrue ( exceptions . get ( 1 ) instanceof TestException ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . wrap ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; ) . doOnNext ( new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . wrap ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( ) ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . wrap ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . wrap ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . test ( ) . assertFailure ( IOException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . wrap ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; ) . doOnNext ( new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . wrap ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( ) ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final int [ ] call = 0 ; Observable . just ( 1 ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , call [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . wrap ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . wrap ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception throw new IOException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( IOException . class ) ; 
TestObserverEx < Object > to = Observable . error ( new TestException ( "Outer" ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception throw new TestException ( "Inner" ) ; ) . filter ( Functions . alwaysTrue ( ) ) . to ( TestHelper . testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Inner" ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; Observable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; final int [ ] call = 0 ; Observable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; Observable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; final int [ ] call = 0 ; Observable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception throw new TestException ( ) ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 0 ] ++ ; ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . SYNC ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . subscribe ( to ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; final int [ ] call = 0 , 0 ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . hide ( ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception call [ 0 ] ++ ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) throws Exception call [ 1 ] ++ ; ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 5 , call [ 0 ] ) ; assertEquals ( 1 , call [ 1 ] ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . doOnEach ( new TestObserver < > ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . doOnEach ( new TestObserver < > ( ) ) ; ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; for ( T item : items ) observer . onNext ( item ) ; if ( error != null ) observer . onError ( error ) ; else observer . onComplete ( ) ; 
this . error = e ; return create ( ) ; 
return new Burst < > ( error , items ) ; 
@ SuppressWarnings ( "unchecked" ) Future < Object > future = mock ( Future . class ) ; Object value = new Object ( ) ; when ( future . get ( ) ) . thenReturn ( value ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( o ) ; Observable . fromFuture ( future ) . subscribe ( to ) ; to . dispose ( ) ; verify ( o , times ( 1 ) ) . onNext ( value ) ; verify ( o , times ( 1 ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( future , never ( ) ) . cancel ( true ) ; 
@ SuppressWarnings ( "unchecked" ) Future < Object > future = mock ( Future . class ) ; Object value = new Object ( ) ; when ( future . get ( ) ) . thenReturn ( value ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Object > to = new TestObserver < > ( o ) ; Observable . fromFuture ( future ) . subscribeOn ( scheduler ) . subscribe ( to ) ; verify ( o , never ( ) ) . onNext ( value ) ; scheduler . triggerActions ( ) ; verify ( o , times ( 1 ) ) . onNext ( value ) ; 
@ SuppressWarnings ( "unchecked" ) Future < Object > future = mock ( Future . class ) ; RuntimeException e = new RuntimeException ( ) ; when ( future . get ( ) ) . thenThrow ( e ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( o ) ; Observable . fromFuture ( future ) . subscribe ( to ) ; to . dispose ( ) ; verify ( o , never ( ) ) . onNext ( null ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , times ( 1 ) ) . onError ( e ) ; verify ( future , never ( ) ) . cancel ( true ) ; 
@ SuppressWarnings ( "unchecked" ) Future < Object > future = mock ( Future . class ) ; CancellationException e = new CancellationException ( "unit test synthetic cancellation" ) ; when ( future . get ( ) ) . thenThrow ( e ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( o ) ; to . dispose ( ) ; Observable . fromFuture ( future ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; 
Future < Object > future = new Future < Object > ( ) private AtomicBoolean isCancelled = new AtomicBoolean ( false ) ; private AtomicBoolean isDone = new AtomicBoolean ( false ) ; @ Override public boolean cancel ( boolean mayInterruptIfRunning ) isCancelled . compareAndSet ( false , true ) ; return true ; @ Override public boolean isCancelled ( ) return isCancelled . get ( ) ; @ Override public boolean isDone ( ) return isCancelled ( ) || isDone . get ( ) ; @ Override public Object get ( ) throws InterruptedException , ExecutionException Thread . sleep ( 500 ) ; isDone . compareAndSet ( false , true ) ; return "foo" ; @ Override public Object get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException return get ( ) ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( o ) ; Observable < Object > futureObservable = Observable . fromFuture ( future ) ; futureObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; Thread . sleep ( 100 ) ; to . dispose ( ) ; to . assertNoErrors ( ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; 
Observable . range ( 1 , 5 ) . mergeWith ( Maybe . just ( 100 ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
Observable . range ( 1 , 5 ) . mergeWith ( Maybe . < Integer > empty ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 512 ) . mergeWith ( Maybe . just ( 100 ) ) . test ( ) . assertValueCount ( 513 ) . assertComplete ( ) ; 
Observable . range ( 1 , 5 ) . mergeWith ( Maybe . just ( 100 ) ) . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( cs . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps . hasObservers ( ) ) ; assertFalse ( cs . hasObservers ( ) ) ; 
Observable . error ( new TestException ( ) ) . mergeWith ( Maybe . just ( 100 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . never ( ) . mergeWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < 10000 ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) cs . onSuccess ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( 1 , 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ) ; ps . onNext ( 1 ) ; cs . onSuccess ( 3 ) ; ps . onNext ( 4 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 , 4 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cs . onSuccess ( 2 ) ; ) ; ps . onNext ( 1 ) ; ps . onNext ( 3 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final AtomicReference < Observer < ? > > observerRef = new AtomicReference < > ( ) ; TestObserver < Integer > to = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observerRef . set ( observer ) ; . mergeWith ( Maybe . < Integer > error ( new IOException ( ) ) ) . test ( ) ; observerRef . get ( ) . onError ( new TestException ( ) ) ; to . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . error ( new IOException ( ) ) . mergeWith ( Maybe . error ( new TestException ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . mergeWith ( Maybe . just ( 1 ) ) ; ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onNext ( 1 ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; . mergeWith ( Maybe . < Integer > empty ( ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final MaybeSubject < Integer > cs = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( cs ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; ps . onNext ( 3 ) ; ) ; cs . onSuccess ( 0 ) ; ps . onNext ( 1 ) ; ps . onNext ( 4 ) ; ps . onComplete ( ) ; to . assertResult ( 0 , 1 , 2 , 3 , 4 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( ms ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ps . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , ps . hasObservers ( ) ) ; assertFalse ( "other has observers" , ms . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; MaybeSubject < Integer > ms = MaybeSubject . create ( ) ; TestObserver < Integer > to = ps . mergeWith ( ms ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; assertTrue ( ms . hasObservers ( ) ) ; ms . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; assertFalse ( "main has observers!" , ps . hasObservers ( ) ) ; assertFalse ( "other has observers" , ms . hasObservers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . mergeWith ( Maybe . just ( 1 ) . hide ( ) ) ; ) ; 
observer = TestHelper . mockObserver ( ) ; 
TestSingleThreadedObservable onSubscribe = new TestSingleThreadedObservable ( "one" , "two" , "three" ) ; Observable < String > w = Observable . unsafeCreate ( onSubscribe ) ; w . serialize ( ) . subscribe ( observer ) ; onSubscribe . waitToFinish ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" ) ; Observable < String > w = Observable . unsafeCreate ( onSubscribe ) ; BusyObserver busyobserver = new BusyObserver ( ) ; w . serialize ( ) . subscribe ( busyobserver ) ; onSubscribe . waitToFinish ( ) ; assertEquals ( 3 , busyobserver . onNextCount . get ( ) ) ; assertFalse ( busyobserver . onError ) ; assertTrue ( busyobserver . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busyobserver . maxConcurrentThreads . get ( ) ) ; 
int max = 9 ; for ( int i = 0 ; i <= max ; i ++ ) try multiThreadedWithNPE ( ) ; return ; catch ( AssertionError ex ) if ( i == max ) throw ex ; Thread . sleep ( ( long ) ( 1000 * Math . random ( ) + 100 ) ) ; 
TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" , null ) ; Observable < String > w = Observable . unsafeCreate ( onSubscribe ) ; BusyObserver busyobserver = new BusyObserver ( ) ; w . serialize ( ) . subscribe ( busyobserver ) ; onSubscribe . waitToFinish ( ) ; System . out . println ( "maxConcurrentThreads: " + onSubscribe . maxConcurrentThreads . get ( ) ) ; assertTrue ( busyobserver . onNextCount . get ( ) < 4 ) ; assertTrue ( busyobserver . onError ) ; assertFalse ( busyobserver . onComplete ) ; assertTrue ( onSubscribe . maxConcurrentThreads . get ( ) > 1 ) ; assertEquals ( 1 , busyobserver . maxConcurrentThreads . get ( ) ) ; 
int max = 9 ; for ( int i = 0 ; i <= max ; i ++ ) try multiThreadedWithNPEinMiddle ( ) ; return ; catch ( AssertionError ex ) if ( i == max ) throw ex ; Thread . sleep ( ( long ) ( 1000 * Math . random ( ) + 100 ) ) ; 
boolean lessThan9 = false ; for ( int i = 0 ; i < 3 ; i ++ ) TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable ( "one" , "two" , "three" , null , "four" , "five" , "six" , "seven" , "eight" , "nine" ) ; Observable < String > w = Observable . unsafeCreate ( onSubscribe ) ; BusyObserver busyobserver = new BusyObserver ( ) ; w . serialize ( ) . subscribe ( busyobserver ) ; onSubscribe . waitToFinish ( ) ; System . out . println ( "maxConcurrentThreads: " + onSubscribe . maxConcurrentThreads . get ( ) ) ; System . out . println ( "onNext count: " + busyobserver . onNextCount . get ( ) ) ; if ( busyobserver . onNextCount . get ( ) < 9 ) lessThan9 = true ; assertTrue ( busyobserver . onError ) ; assertFalse ( busyobserver . onComplete ) ; int n = onSubscribe . maxConcurrentThreads . get ( ) ; assertTrue ( "" + n , n > 1 ) ; assertEquals ( 1 , busyobserver . maxConcurrentThreads . get ( ) ) ; assertTrue ( lessThan9 ) ; 
for ( int i = 0 ; i < numStringsToSend ; i ++ ) observer . onNext ( "aString" ) ; 
if ( waitOnThese != null ) for ( Future < ? > f : waitOnThese ) try f . get ( ) ; catch ( Throwable e ) System . err . println ( "Error while waiting on future in CompletionThread" ) ; if ( event == TestConcurrencyobserverEvent . onError ) observer . onError ( new RuntimeException ( "mocked exception" ) ) ; else if ( event == TestConcurrencyobserverEvent . onComplete ) observer . onComplete ( ) ; else throw new IllegalArgumentException ( "Expecting either onError or onComplete" ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "TestSingleThreadedObservable subscribed to ..." ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestSingleThreadedObservable thread" ) ; for ( String s : values ) System . out . println ( "TestSingleThreadedObservable onNext: " + s ) ; observer . onNext ( s ) ; observer . onComplete ( ) ; catch ( Throwable e ) throw new RuntimeException ( e ) ; ) ; System . out . println ( "starting TestSingleThreadedObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestSingleThreadedObservable thread" ) ; 
try t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "TestMultiThreadedObservable subscribed to ..." ) ; final NullPointerException npe = new NullPointerException ( ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestMultiThreadedObservable thread" ) ; for ( final String s : values ) threadPool . execute ( new Runnable ( ) @ Override public void run ( ) threadsRunning . incrementAndGet ( ) ; try if ( s == null ) System . out . println ( "TestMultiThreadedObservable onNext: null" ) ; throw npe ; else System . out . println ( "TestMultiThreadedObservable onNext: " + s ) ; observer . onNext ( s ) ; int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; catch ( Throwable e ) observer . onError ( e ) ; finally threadsRunning . decrementAndGet ( ) ; ) ; threadPool . shutdown ( ) ; catch ( Throwable e ) throw new RuntimeException ( e ) ; try threadPool . awaitTermination ( 2 , TimeUnit . SECONDS ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; observer . onComplete ( ) ; ) ; System . out . println ( "starting TestMultiThreadedObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestMultiThreadedObservable thread" ) ; 
try t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; 
threadsRunning . incrementAndGet ( ) ; System . out . println ( ">>> Busyobserver received onComplete" ) ; onComplete = true ; int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; threadsRunning . decrementAndGet ( ) ; 
threadsRunning . incrementAndGet ( ) ; System . out . println ( ">>> Busyobserver received onError: " + e . getMessage ( ) ) ; onError = true ; int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; threadsRunning . decrementAndGet ( ) ; 
threadsRunning . incrementAndGet ( ) ; try onNextCount . incrementAndGet ( ) ; System . out . println ( ">>> Busyobserver received onNext: " + args ) ; try Thread . sleep ( 200 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; finally int concurrentThreads = threadsRunning . get ( ) ; int maxThreads = maxConcurrentThreads . get ( ) ; if ( concurrentThreads > maxThreads ) maxConcurrentThreads . compareAndSet ( maxThreads , concurrentThreads ) ; threadsRunning . decrementAndGet ( ) ; 
new Thread ( ) @ Override public void run ( ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) o . onNext ( value ) ; . start ( ) ; 
new Thread ( ) @ Override public void run ( ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) o . onError ( new TestException ( ) ) ; . start ( ) ; 
return new BlockingObservableNext < > ( source ) ; 
Subject < String > obs = PublishSubject . create ( ) ; Iterator < String > it = next ( obs ) . iterator ( ) ; fireOnNextInNewThread ( obs , "one" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; fireOnNextInNewThread ( obs , "two" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "two" , it . next ( ) ) ; fireOnNextInNewThread ( obs , "three" ) ; try assertEquals ( "three" , it . next ( ) ) ; catch ( NoSuchElementException e ) fail ( "Calling next() without hasNext() should wait for next fire" ) ; obs . onComplete ( ) ; assertFalse ( it . hasNext ( ) ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) assertFalse ( it . hasNext ( ) ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) 
Subject < String > obs = PublishSubject . create ( ) ; Iterator < String > it = next ( obs ) . iterator ( ) ; fireOnNextInNewThread ( obs , "one" ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; fireOnErrorInNewThread ( obs ) ; try it . hasNext ( ) ; fail ( "Expected an TestException" ) ; catch ( TestException e ) assertErrorAfterObservableFail ( it ) ; 
Observable < String > obs = Observable . < String > empty ( ) . observeOn ( Schedulers . newThread ( ) ) ; Iterator < String > it = next ( obs ) . iterator ( ) ; assertFalse ( it . hasNext ( ) ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) assertFalse ( it . hasNext ( ) ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) 
Subject < String > obs = PublishSubject . create ( ) ; Iterator < String > it = next ( obs ) . iterator ( ) ; obs . onError ( new TestException ( ) ) ; try it . hasNext ( ) ; fail ( "Expected an TestException" ) ; catch ( TestException e ) assertErrorAfterObservableFail ( it ) ; 
Subject < String > obs = PublishSubject . create ( ) ; Iterator < String > it = next ( obs ) . iterator ( ) ; fireOnErrorInNewThread ( obs ) ; try it . hasNext ( ) ; fail ( "Expected an TestException" ) ; catch ( TestException e ) assertErrorAfterObservableFail ( it ) ; 
try it . hasNext ( ) ; fail ( "hasNext should throw a TestException" ) ; catch ( TestException e ) try it . next ( ) ; fail ( "next should throw a TestException" ) ; catch ( TestException e ) 
Subject < String > obs = PublishSubject . create ( ) ; Iterator < String > it = next ( obs ) . iterator ( ) ; fireOnNextInNewThread ( obs , "one" ) ; assertEquals ( "one" , it . next ( ) ) ; fireOnNextInNewThread ( obs , "two" ) ; assertEquals ( "two" , it . next ( ) ) ; obs . onComplete ( ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) 
Subject < String > obs = PublishSubject . create ( ) ; Iterator < String > it = next ( obs ) . iterator ( ) ; fireOnNextInNewThread ( obs , "one" ) ; assertTrue ( it . hasNext ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; obs . onComplete ( ) ; try it . next ( ) ; fail ( "At the end of an iterator should throw a NoSuchElementException" ) ; catch ( NoSuchElementException e ) 
int repeat = 0 ; for ( ; ; ) final SerialDisposable task = new SerialDisposable ( ) ; try final CountDownLatch finished = new CountDownLatch ( 1 ) ; final int COUNT = 30 ; final CountDownLatch timeHasPassed = new CountDownLatch ( COUNT ) ; final AtomicBoolean running = new AtomicBoolean ( true ) ; final AtomicInteger count = new AtomicInteger ( 0 ) ; final Observable < Integer > obs = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( final Observer < ? super Integer > o ) o . onSubscribe ( Disposable . empty ( ) ) ; task . replace ( Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) try while ( running . get ( ) && ! task . isDisposed ( ) ) o . onNext ( count . incrementAndGet ( ) ) ; timeHasPassed . countDown ( ) ; o . onComplete ( ) ; catch ( Throwable e ) o . onError ( e ) ; finally finished . countDown ( ) ; ) ) ; ) ; Iterator < Integer > it = next ( obs ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; int a = it . next ( ) ; assertTrue ( it . hasNext ( ) ) ; int b = it . next ( ) ; assertTrue ( "a and b should be different" , a != b ) ; timeHasPassed . await ( 8000 , TimeUnit . MILLISECONDS ) ; assertTrue ( it . hasNext ( ) ) ; int c = it . next ( ) ; assertTrue ( "c should not just be the next in sequence" , c != ( b + 1 ) ) ; assertTrue ( "expected that c [" + c + "] is higher than or equal to " + COUNT , c >= COUNT ) ; assertTrue ( it . hasNext ( ) ) ; int d = it . next ( ) ; assertTrue ( d > c ) ; running . set ( false ) ; finished . await ( ) ; assertFalse ( it . hasNext ( ) ) ; System . out . println ( "a: " + a + " b: " + b + " c: " + c ) ; break ; catch ( AssertionError ex ) if ( ++ repeat == 3 ) throw ex ; Thread . sleep ( ( int ) ( 1000 * Math . pow ( 2 , repeat - 1 ) ) ) ; finally task . dispose ( ) ; 
Observable < Long > o = Observable . interval ( 250 , TimeUnit . MILLISECONDS ) ; PublishSubject < Integer > terminal = PublishSubject . create ( ) ; Observable < Long > source = o . takeUntil ( terminal ) ; Iterable < Long > iter = source . blockingNext ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) BlockingObservableNext . NextIterator < Long > it = ( BlockingObservableNext . NextIterator < Long > ) iter . iterator ( ) ; for ( long i = 0 ; i < 10 ; i ++ ) Assert . assertTrue ( it . hasNext ( ) ) ; Assert . assertEquals ( j + "th iteration next" , Long . valueOf ( i ) , it . next ( ) ) ; terminal . onNext ( 1 ) ; 
assertEquals ( 1 , BehaviorSubject . createDefault ( 1 ) . take ( 1 ) . blockingSingle ( ) . intValue ( ) ) ; assertEquals ( 2 , BehaviorSubject . createDefault ( 2 ) . blockingIterable ( ) . iterator ( ) . next ( ) . intValue ( ) ) ; assertEquals ( 3 , BehaviorSubject . createDefault ( 3 ) . blockingNext ( ) . iterator ( ) . next ( ) . intValue ( ) ) ; 
Iterator < Object > it = Observable . never ( ) . blockingNext ( ) . iterator ( ) ; try Thread . currentThread ( ) . interrupt ( ) ; it . next ( ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
Observable . never ( ) . blockingNext ( ) . iterator ( ) . remove ( ) ; 
NextObserver < Integer > no = new NextObserver < > ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try no . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
NextObserver < Integer > no = new NextObserver < > ( ) ; no . setWaiting ( ) ; no . onNext ( Notification . createOnNext ( 1 ) ) ; no . setWaiting ( ) ; no . onNext ( Notification . createOnNext ( 1 ) ) ; assertEquals ( 1 , no . takeNext ( ) . getValue ( ) . intValue ( ) ) ; 
NextObserver < Integer > no = new NextObserver < > ( ) ; no . setWaiting ( ) ; no . onNext ( Notification . < Integer > createOnComplete ( ) ) ; no . setWaiting ( ) ; no . onNext ( Notification . createOnNext ( 1 ) ) ; assertTrue ( no . takeNext ( ) . isOnComplete ( ) ) ; 
final CountDownLatch scheduled = new CountDownLatch ( 1 ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final CountDownLatch doneLatch = new CountDownLatch ( 1 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( final Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; scheduled . countDown ( ) ; try try latch . await ( ) ; catch ( InterruptedException e ) observer . onComplete ( ) ; catch ( Throwable e ) observer . onError ( e ) ; finally doneLatch . countDown ( ) ; ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; scheduled . await ( ) ; to . dispose ( ) ; latch . countDown ( ) ; doneLatch . await ( ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserverEx < String > to = new TestObserverEx < > ( ) ; Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new RuntimeException ( "fail" ) ) ; ) . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 1000 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; 
return new SlowInner ( actual . createWorker ( ) ) ; 
actualInner . dispose ( ) ; 
return actualInner . isDisposed ( ) ; 
return actualInner . schedule ( action , delay , unit ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > sub ) Disposable d = Disposable . empty ( ) ; sub . onSubscribe ( d ) ; for ( int i = 1 ; ! d . isDisposed ( ) ; i ++ ) count . incrementAndGet ( ) ; sub . onNext ( i ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) . take ( 10 ) . subscribe ( to ) ; to . awaitDone ( 1000 , TimeUnit . MILLISECONDS ) ; to . dispose ( ) ; Thread . sleep ( 200 ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertEquals ( 10 , count . get ( ) ) ; 
TestScheduler test = new TestScheduler ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . just ( 1 ) . hide ( ) . subscribeOn ( test ) . subscribe ( to ) ; to . dispose ( ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertSubscribed ( ) . assertNoValues ( ) . assertNotTerminated ( ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . subscribeOn ( Schedulers . single ( ) ) ) ; 
performTestUsing ( false ) ; 
performTestUsing ( true ) ; 
performTestUsingWithSubscribingTwice ( false ) ; 
performTestUsingWithSubscribingTwice ( true ) ; 
$EMPTY$
performTestUsingWithResourceFactoryError ( false ) ; 
performTestUsingWithResourceFactoryError ( true ) ; 
performTestUsingWithObservableFactoryError ( false ) ; 
performTestUsingWithObservableFactoryError ( true ) ; 
final List < String > events = new ArrayList < > ( ) ; Supplier < Resource > resourceFactory = createResourceFactory ( events ) ; final Action completion = createOnCompletedAction ( events ) ; final Action unsub = createUnsubAction ( events ) ; Function < Resource , Observable < String > > observableFactory = new Function < Resource , Observable < String > > ( ) @ Override public Observable < String > apply ( Resource resource ) return Observable . fromArray ( resource . getTextFromWeb ( ) . split ( " " ) ) ; ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > o = Observable . using ( resourceFactory , observableFactory , new DisposeAction ( ) , true ) . doOnDispose ( unsub ) . doOnComplete ( completion ) ; o . safeSubscribe ( observer ) ; assertEquals ( Arrays . asList ( "disposed" , "completed" ) , events ) ; 
final List < String > events = new ArrayList < > ( ) ; Supplier < Resource > resourceFactory = createResourceFactory ( events ) ; final Action completion = createOnCompletedAction ( events ) ; final Action unsub = createUnsubAction ( events ) ; Function < Resource , Observable < String > > observableFactory = new Function < Resource , Observable < String > > ( ) @ Override public Observable < String > apply ( Resource resource ) return Observable . fromArray ( resource . getTextFromWeb ( ) . split ( " " ) ) ; ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > o = Observable . using ( resourceFactory , observableFactory , new DisposeAction ( ) , false ) . doOnDispose ( unsub ) . doOnComplete ( completion ) ; o . safeSubscribe ( observer ) ; assertEquals ( Arrays . asList ( "completed" , "disposed" ) , events ) ; 
final List < String > events = new ArrayList < > ( ) ; Supplier < Resource > resourceFactory = createResourceFactory ( events ) ; final Consumer < Throwable > onError = createOnErrorAction ( events ) ; final Action unsub = createUnsubAction ( events ) ; Function < Resource , Observable < String > > observableFactory = new Function < Resource , Observable < String > > ( ) @ Override public Observable < String > apply ( Resource resource ) return Observable . fromArray ( resource . getTextFromWeb ( ) . split ( " " ) ) . concatWith ( Observable . < String > error ( new RuntimeException ( ) ) ) ; ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > o = Observable . using ( resourceFactory , observableFactory , new DisposeAction ( ) , true ) . doOnDispose ( unsub ) . doOnError ( onError ) ; o . safeSubscribe ( observer ) ; assertEquals ( Arrays . asList ( "disposed" , "error" ) , events ) ; 
final List < String > events = new ArrayList < > ( ) ; final Supplier < Resource > resourceFactory = createResourceFactory ( events ) ; final Consumer < Throwable > onError = createOnErrorAction ( events ) ; final Action unsub = createUnsubAction ( events ) ; Function < Resource , Observable < String > > observableFactory = new Function < Resource , Observable < String > > ( ) @ Override public Observable < String > apply ( Resource resource ) return Observable . fromArray ( resource . getTextFromWeb ( ) . split ( " " ) ) . concatWith ( Observable . < String > error ( new RuntimeException ( ) ) ) ; ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > o = Observable . using ( resourceFactory , observableFactory , new DisposeAction ( ) , false ) . doOnDispose ( unsub ) . doOnError ( onError ) ; o . safeSubscribe ( observer ) ; assertEquals ( Arrays . asList ( "error" , "disposed" ) , events ) ; 
return new Action ( ) @ Override public void run ( ) events . add ( "unsub" ) ; ; 
return new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t ) events . add ( "error" ) ; ; 
return new Supplier < Resource > ( ) @ Override public Resource get ( ) return new Resource ( ) @ Override public String getTextFromWeb ( ) return "hello world" ; @ Override public void dispose ( ) events . add ( "disposed" ) ; ; ; 
return new Action ( ) @ Override public void run ( ) events . add ( "completed" ) ; ; 
TestObserverEx < Object > to = Observable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object v ) throws Exception throw new TestException ( "First" ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( "Second" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "First" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Second" ) ; 
throw new TestException ( "Second" ) ; 
TestObserverEx < Object > to = Observable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object v ) throws Exception return Observable . error ( new TestException ( "First" ) ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( "Second" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; TestHelper . assertError ( errors , 0 , TestException . class , "First" ) ; TestHelper . assertError ( errors , 1 , TestException . class , "Second" ) ; 
Observable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object v ) throws Exception return Observable . empty ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( "Second" ) ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "Second" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . using ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object v ) throws Exception return Observable . empty ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object e ) throws Exception throw new TestException ( "Second" ) ; , false ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( ( Observable < Object > ) null ) , Functions . emptyConsumer ( ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The sourceSupplier returned a null ObservableSource" ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return Observable . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( o ) , Functions . emptyConsumer ( ) ) ; ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; to . dispose ( ) ; observer . onComplete ( ) ; ) , Functions . emptyConsumer ( ) , true ) . subscribe ( to ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . using ( Functions . justSupplier ( 1 ) , Functions . justFunction ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; to . dispose ( ) ; observer . onError ( new TestException ( ) ) ; ) , Functions . emptyConsumer ( ) , true ) . subscribe ( to ) ; 
final StringBuilder sb = new StringBuilder ( ) ; Observable . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) throws Throwable return Observable . range ( 1 , 2 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Dispose" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , true ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; assertEquals ( "ResourceDispose" , sb . toString ( ) ) ; 
final StringBuilder sb = new StringBuilder ( ) ; Observable . using ( Functions . justSupplier ( 1 ) , new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) throws Throwable return Observable . range ( 1 , 2 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Throwable sb . append ( "Dispose" ) ; ) ; , new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) throws Throwable sb . append ( "Resource" ) ; , false ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; assertEquals ( "DisposeResource" , sb . toString ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > timeout = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return timeout ; ; Observable < Integer > other = Observable . fromIterable ( Arrays . asList ( 100 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . timeout ( timeout , timeoutFunc , other ) . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; timeout . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onNext ( 100 ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > source = Observable . < Integer > never ( ) ; final PublishSubject < Integer > timeout = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return timeout ; ; Observable < Integer > other = Observable . fromIterable ( Arrays . asList ( 100 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . timeout ( timeout , timeoutFunc , other ) . subscribe ( o ) ; timeout . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 100 ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > source = Observable . < Integer > never ( ) ; final PublishSubject < Integer > timeout = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return timeout ; ; Supplier < Observable < Integer > > firstTimeoutFunc = new Supplier < Observable < Integer > > ( ) @ Override public Observable < Integer > get ( ) throw new TestException ( ) ; ; Observable < Integer > other = Observable . fromIterable ( Arrays . asList ( 100 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . timeout ( Observable . defer ( firstTimeoutFunc ) , timeoutFunc , other ) . subscribe ( o ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > timeout = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; Observable < Integer > other = Observable . fromIterable ( Arrays . asList ( 100 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . timeout ( timeout , timeoutFunc , other ) . subscribe ( o ) ; source . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > timeout = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return timeout ; ; Observable < Integer > other = Observable . fromIterable ( Arrays . asList ( 100 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . timeout ( Observable . < Integer > error ( new TestException ( ) ) , timeoutFunc , other ) . subscribe ( o ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > timeout = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return Observable . < Integer > error ( new TestException ( ) ) ; ; Observable < Integer > other = Observable . fromIterable ( Arrays . asList ( 100 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . timeout ( timeout , timeoutFunc , other ) . subscribe ( o ) ; source . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > timeout = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return PublishSubject . create ( ) ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . timeout ( timeout , timeoutFunc ) . subscribe ( o ) ; timeout . onNext ( 1 ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onError ( isA ( TimeoutException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > timeout = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return timeout ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . timeout ( PublishSubject . create ( ) , timeoutFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; timeout . onNext ( 1 ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onError ( isA ( TimeoutException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final CountDownLatch observerReceivedTwo = new CountDownLatch ( 1 ) ; final CountDownLatch timeoutEmittedOne = new CountDownLatch ( 1 ) ; final CountDownLatch observerCompleted = new CountDownLatch ( 1 ) ; final CountDownLatch enteredTimeoutOne = new CountDownLatch ( 1 ) ; final AtomicBoolean latchTimeout = new AtomicBoolean ( false ) ; final Function < Integer , Observable < Integer > > timeoutFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) if ( t1 == 1 ) return Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; enteredTimeoutOne . countDown ( ) ; while ( true ) try if ( ! observerReceivedTwo . await ( 30 , TimeUnit . SECONDS ) ) latchTimeout . set ( true ) ; break ; catch ( InterruptedException e ) observer . onNext ( 1 ) ; timeoutEmittedOne . countDown ( ) ; ) . subscribeOn ( Schedulers . newThread ( ) ) ; else return PublishSubject . create ( ) ; ; final Observer < Integer > o = TestHelper . mockObserver ( ) ; doAnswer ( new Answer < Void > ( ) @ Override public Void answer ( InvocationOnMock invocation ) throws Throwable observerReceivedTwo . countDown ( ) ; return null ; ) . when ( o ) . onNext ( 2 ) ; doAnswer ( new Answer < Void > ( ) @ Override public Void answer ( InvocationOnMock invocation ) throws Throwable observerCompleted . countDown ( ) ; return null ; ) . when ( o ) . onComplete ( ) ; final TestObserver < Integer > to = new TestObserver < > ( o ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) PublishSubject < Integer > source = PublishSubject . create ( ) ; source . timeout ( timeoutFunc , Observable . just ( 3 ) ) . subscribe ( to ) ; source . onNext ( 1 ) ; try if ( ! enteredTimeoutOne . await ( 30 , TimeUnit . SECONDS ) ) latchTimeout . set ( true ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; source . onNext ( 2 ) ; try if ( ! timeoutEmittedOne . await ( 30 , TimeUnit . SECONDS ) ) latchTimeout . set ( true ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; source . onComplete ( ) ; ) . start ( ) ; if ( ! observerCompleted . await ( 30 , TimeUnit . SECONDS ) ) latchTimeout . set ( true ) ; assertFalse ( "CoundDownLatch timeout" , latchTimeout . get ( ) ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . timeout ( Functions . justFunction ( Observable . never ( ) ) ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . timeout ( Functions . justFunction ( Observable . never ( ) ) , Observable . never ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . timeout ( Functions . justFunction ( Observable . never ( ) ) ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . timeout ( Functions . justFunction ( Observable . never ( ) ) , Observable . never ( ) ) ; ) ; 
Observable . empty ( ) . timeout ( Functions . justFunction ( Observable . never ( ) ) ) . test ( ) . assertResult ( ) ; 
Observable . error ( new TestException ( ) ) . timeout ( Functions . justFunction ( Observable . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . timeout ( Functions . justFunction ( Observable . empty ( ) ) ) . test ( ) ; ps . onNext ( 1 ) ; to . assertFailure ( TimeoutException . class , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserverEx < Integer > to = ps . timeout ( Functions . justFunction ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ps . onNext ( 1 ) ; to . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserverEx < Integer > to = ps . timeout ( Functions . justFunction ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; ) , Observable . just ( 2 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; ps . onNext ( 1 ) ; to . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . error ( new TestException ( ) ) . timeout ( Functions . justFunction ( Observable . never ( ) ) , Observable . never ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onNext ( 3 ) ; observer . onComplete ( ) ; observer . onError ( new TestException ( "Second" ) ) ; . timeout ( Functions . justFunction ( Observable . never ( ) ) , Observable . < Integer > never ( ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . timeout ( Functions . justFunction ( Observable . never ( ) ) ) . take ( 1 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . timeout ( Functions . justFunction ( Observable . never ( ) ) , Observable . just ( 2 ) ) . take ( 1 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Observer < ? > [ ] sub = null , null ; final Observable < Integer > pp2 = new Observable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; sub [ count ++ ] = observer ; ; TestObserver < Integer > to = ps . timeout ( Functions . justFunction ( pp2 ) ) . test ( ) ; ps . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; final Throwable ex = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Observer < ? > [ ] sub = null , null ; final Observable < Integer > pp2 = new Observable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; sub [ count ++ ] = observer ; ; TestObserver < Integer > to = ps . timeout ( Functions . justFunction ( pp2 ) , Observable . < Integer > never ( ) ) . test ( ) ; ps . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; final Throwable ex = new TestException ( ) ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onError ( ex ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Observer < ? > [ ] sub = null , null ; final Observable < Integer > pp2 = new Observable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; sub [ count ++ ] = observer ; ; TestObserver < Integer > to = ps . timeout ( Functions . justFunction ( pp2 ) ) . test ( ) ; ps . onNext ( 0 ) ; final Throwable ex = new TestException ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onError ( ex ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Observer < ? > [ ] sub = null , null ; final Observable < Integer > pp2 = new Observable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; sub [ count ++ ] = observer ; ; TestObserver < Integer > to = ps . timeout ( Functions . justFunction ( pp2 ) ) . test ( ) ; ps . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final Observer < ? > [ ] sub = null , null ; final Observable < Integer > pp2 = new Observable < Integer > ( ) int count ; @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onSubscribe ( Disposable . empty ( ) ) ; sub [ count ++ ] = observer ; ; TestObserver < Integer > to = ps . timeout ( Functions . justFunction ( pp2 ) , Observable . < Integer > never ( ) ) . test ( ) ; ps . onNext ( 0 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sub [ 0 ] . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertValueAt ( 0 , 0 ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; Observable < Object > timeoutAndFallback = Observable . never ( ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception counter . incrementAndGet ( ) ; ) ; ps . timeout ( timeoutAndFallback , Functions . justFunction ( timeoutAndFallback ) ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , counter . get ( ) ) ; 
PublishSubject < Object > ps = PublishSubject . create ( ) ; final AtomicInteger counter = new AtomicInteger ( ) ; Observable < Object > timeoutAndFallback = Observable . never ( ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception counter . incrementAndGet ( ) ; ) ; ps . timeout ( timeoutAndFallback , Functions . justFunction ( timeoutAndFallback ) , timeoutAndFallback ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , counter . get ( ) ) ; 
Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . toObservable ( ) . test ( ) . assertResult ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . < Integer > toObservable ( ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return null ; ) . < Integer > toObservable ( ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( NullPointerException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; , true ) . toObservable ( ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 1000 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Observable . range ( 1 , 100 ) . subscribeOn ( Schedulers . computation ( ) ) . ignoreElements ( ) ; ) . toObservable ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; , true ) . < Integer > toObservable ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 11 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; , true ) . < Integer > toObservable ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; , false ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . < Integer > toObservable ( ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . toObservable ( ) ) ; 
Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . test ( ) . assertResult ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Void > to = ps . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Void > to = ps . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return null ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( NullPointerException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; , true ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 1000 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Observable . range ( 1 , 100 ) . subscribeOn ( Schedulers . computation ( ) ) . ignoreElements ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
TestObserverEx < Void > to = Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; , true ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 11 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
TestObserverEx < Void > to = Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . error ( new TestException ( ) ) ; , true ) . to ( TestHelper . < Void > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; , false ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . < Integer > toObservable ( ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) ) ; 
Observable . range ( 1 , 3 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ( ( Disposable ) observer ) . dispose ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; ) . test ( ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > o ) throws Exception return o . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) ; , false , 1 , null ) ; 
Observable . range ( 1 , 10 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . toObservable ( ) . subscribe ( new Observer < Object > ( ) @ Override public void onSubscribe ( Disposable d ) QueueDisposable < ? > qd = ( QueueDisposable < ? > ) d ; try assertNull ( qd . poll ( ) ) ; catch ( Throwable ex ) throw new RuntimeException ( ex ) ; assertTrue ( qd . isEmpty ( ) ) ; qd . clear ( ) ; @ Override public void onNext ( Object t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; 
Observable . range ( 1 , 3 ) . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return new Completable ( ) @ Override protected void subscribeActual ( CompletableObserver observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ( ( Disposable ) observer ) . dispose ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; ) . toObservable ( ) . test ( ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > o ) throws Exception return o . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) throws Exception return Completable . complete ( ) ; ) . toObservable ( ) ; , false , 1 , null ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Observable < Integer > upstream ) return upstream . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Completable > ( ) @ Override public Completable apply ( Observable < Integer > upstream ) return upstream . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) throws Throwable return Completable . complete ( ) . hide ( ) ; , true ) ; ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . flatMapCompletable ( v -> Completable . never ( ) ) . toObservable ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservableToCompletable ( o -> o . flatMapCompletable ( v -> Completable . never ( ) ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; TestObserver < Object > to = new TestObserver < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; ps1 . flatMapCompletable ( v -> TestHelper . raceOther ( ( ) -> to . dispose ( ) ; , cdl ) ; return Completable . complete ( ) ; ) . toObservable ( ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; cdl . await ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; TestObserver < Void > to = new TestObserver < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; ps1 . flatMapCompletable ( v -> TestHelper . raceOther ( ( ) -> to . dispose ( ) ; , cdl ) ; return Completable . complete ( ) ; ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; cdl . await ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . take ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( 4 ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . take ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( 4 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . take ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; source . onNext ( 4 ) ; source . onError ( new TestException ( ) ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( 4 ) ; verify ( o , never ( ) ) . onError ( any ( TestException . class ) ) ; 
Observable . range ( 1 , 5 ) . take ( 1 , TimeUnit . MINUTES ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
concat2Strings = new BiFunction < String , String , String > ( ) @ Override public String apply ( String t1 , String t2 ) return t1 + "-" + t2 ; ; s1 = PublishSubject . create ( ) ; s2 = PublishSubject . create ( ) ; zipped = Observable . zip ( s1 , s2 , concat2Strings ) ; observer = TestHelper . mockObserver ( ) ; inOrder = inOrder ( observer ) ; zipped . subscribe ( observer ) ; 
Function < Object [ ] , String > zipr = Functions . toFunction ( getConcatStringIntegerIntArrayZipr ( ) ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; @ SuppressWarnings ( "rawtypes" ) Collection ws = java . util . Collections . singleton ( Observable . just ( "one" , "two" ) ) ; Observable < String > w = Observable . zip ( ws , zipr ) ; w . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; 
Observer < String > w = TestHelper . mockObserver ( ) ; TestObservable w1 = new TestObservable ( ) ; TestObservable w2 = new TestObservable ( ) ; TestObservable w3 = new TestObservable ( ) ; Observable < String > zipW = Observable . zip ( Observable . unsafeCreate ( w1 ) , Observable . unsafeCreate ( w2 ) , Observable . unsafeCreate ( w3 ) , getConcat3StringsZipr ( ) ) ; zipW . subscribe ( w ) ; w1 . observer . onNext ( "1a" ) ; w1 . observer . onComplete ( ) ; w2 . observer . onNext ( "2a" ) ; w2 . observer . onNext ( "2b" ) ; w2 . observer . onComplete ( ) ; w3 . observer . onNext ( "3a" ) ; w3 . observer . onNext ( "3b" ) ; w3 . observer . onNext ( "3c" ) ; w3 . observer . onNext ( "3d" ) ; w3 . observer . onComplete ( ) ; InOrder io = inOrder ( w ) ; io . verify ( w ) . onNext ( "1a2a3a" ) ; io . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observer < String > w = TestHelper . mockObserver ( ) ; TestObservable w1 = new TestObservable ( ) ; TestObservable w2 = new TestObservable ( ) ; TestObservable w3 = new TestObservable ( ) ; Observable < String > zipW = Observable . zip ( Observable . unsafeCreate ( w1 ) , Observable . unsafeCreate ( w2 ) , Observable . unsafeCreate ( w3 ) , getConcat3StringsZipr ( ) ) ; zipW . subscribe ( w ) ; w1 . observer . onNext ( "1a" ) ; w1 . observer . onNext ( "1b" ) ; w1 . observer . onNext ( "1c" ) ; w1 . observer . onNext ( "1d" ) ; w1 . observer . onComplete ( ) ; w2 . observer . onNext ( "2a" ) ; w2 . observer . onNext ( "2b" ) ; w2 . observer . onComplete ( ) ; w3 . observer . onNext ( "3a" ) ; w3 . observer . onComplete ( ) ; InOrder io = inOrder ( w ) ; io . verify ( w ) . onNext ( "1a2a3a" ) ; io . verify ( w , times ( 1 ) ) . onComplete ( ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; PublishSubject < String > r2 = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable . zip ( r1 , r2 , zipr2 ) . subscribe ( observer ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "world" ) ; InOrder inOrder = inOrder ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "helloworld" ) ; r1 . onNext ( "hello " ) ; r2 . onNext ( "again" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "hello again" ) ; r1 . onComplete ( ) ; r2 . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; PublishSubject < String > r2 = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable . zip ( r1 , r2 , zipr2 ) . subscribe ( observer ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "world" ) ; r2 . onComplete ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "helloworld" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; r1 . onNext ( "hi" ) ; r1 . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; PublishSubject < Integer > r2 = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable . zip ( r1 , r2 , zipr2 ) . subscribe ( observer ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( 1 ) ; r2 . onComplete ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "hello1" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; r1 . onNext ( "hi" ) ; r1 . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; PublishSubject < Integer > r2 = PublishSubject . create ( ) ; PublishSubject < List < Integer > > r3 = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable . zip ( r1 , r2 , r3 , zipr3 ) . subscribe ( observer ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( 2 ) ; r3 . onNext ( Arrays . asList ( 5 , 6 , 7 ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "hello2[5, 6, 7]" ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; PublishSubject < String > r2 = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable . zip ( r1 , r2 , zipr2 ) . subscribe ( observer ) ; r1 . onNext ( "one" ) ; r1 . onNext ( "two" ) ; r1 . onNext ( "three" ) ; r2 . onNext ( "A" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "oneA" ) ; r1 . onNext ( "four" ) ; r1 . onComplete ( ) ; r2 . onNext ( "B" ) ; verify ( observer , times ( 1 ) ) . onNext ( "twoB" ) ; r2 . onNext ( "C" ) ; verify ( observer , times ( 1 ) ) . onNext ( "threeC" ) ; r2 . onNext ( "D" ) ; verify ( observer , times ( 1 ) ) . onNext ( "fourD" ) ; r2 . onNext ( "E" ) ; verify ( observer , never ( ) ) . onNext ( "E" ) ; r2 . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; PublishSubject < String > r2 = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable . zip ( r1 , r2 , zipr2 ) . subscribe ( observer ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "world" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "helloworld" ) ; r1 . onError ( new RuntimeException ( "" ) ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "again" ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 0 ) ) . onNext ( "helloagain" ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; PublishSubject < String > r2 = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; Observable . zip ( r1 , r2 , zipr2 ) . subscribe ( to ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "world" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "helloworld" ) ; to . dispose ( ) ; r1 . onNext ( "hello" ) ; r2 . onNext ( "again" ) ; verify ( observer , times ( 0 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 0 ) ) . onNext ( "helloagain" ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; PublishSubject < String > r2 = PublishSubject . create ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable . zip ( r1 , r2 , zipr2 ) . subscribe ( observer ) ; r1 . onNext ( "one" ) ; r1 . onNext ( "two" ) ; r1 . onComplete ( ) ; r2 . onNext ( "A" ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "oneA" ) ; r2 . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyString ( ) ) ; 
BiFunction < String , Integer , String > zipr = getConcatStringIntegerZipr ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > w = Observable . zip ( Observable . just ( "one" , "two" ) , Observable . just ( 2 , 3 , 4 ) , zipr ) ; w . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one2" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two3" ) ; verify ( observer , never ( ) ) . onNext ( "4" ) ; 
Function3 < String , Integer , int [ ] , String > zipr = getConcatStringIntegerIntArrayZipr ( ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > w = Observable . zip ( Observable . just ( "one" , "two" ) , Observable . just ( 2 ) , Observable . just ( new int [ ] 4 , 5 , 6 ) , zipr ) ; w . subscribe ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one2[4, 5, 6]" ) ; verify ( observer , never ( ) ) . onNext ( "two" ) ; 
BiFunction < Integer , Integer , Integer > zipr = getDivideZipr ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; Observable < Integer > w = Observable . zip ( Observable . just ( 10 , 20 , 30 ) , Observable . just ( 0 , 1 , 2 ) , zipr ) ; w . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < String > oA = PublishSubject . create ( ) ; PublishSubject < String > oB = PublishSubject . create ( ) ; Observer < String > obs = TestHelper . mockObserver ( ) ; Observable < String > o = Observable . zip ( oA , oB , getConcat2Strings ( ) ) ; o . subscribe ( obs ) ; InOrder io = inOrder ( obs ) ; oA . onNext ( "a1" ) ; io . verify ( obs , never ( ) ) . onNext ( anyString ( ) ) ; oB . onNext ( "b1" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a1-b1" ) ; oB . onNext ( "b2" ) ; io . verify ( obs , never ( ) ) . onNext ( anyString ( ) ) ; oA . onNext ( "a2" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a2-b2" ) ; oA . onNext ( "a3" ) ; oA . onNext ( "a4" ) ; oA . onNext ( "a5" ) ; oA . onComplete ( ) ; oB . onNext ( "b3" ) ; oB . onNext ( "b4" ) ; oB . onNext ( "b5" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a3-b3" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a4-b4" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a5-b5" ) ; io . verify ( obs , times ( 1 ) ) . onComplete ( ) ; oB . onNext ( "b6" ) ; oB . onNext ( "b7" ) ; oB . onNext ( "b8" ) ; oB . onNext ( "b9" ) ; io . verifyNoMoreInteractions ( ) ; 
PublishSubject < String > oA = PublishSubject . create ( ) ; PublishSubject < String > oB = PublishSubject . create ( ) ; Observer < String > obs = TestHelper . mockObserver ( ) ; Observable < String > o = Observable . zip ( oA , oB , getConcat2Strings ( ) ) ; o . subscribe ( obs ) ; InOrder io = inOrder ( obs ) ; oA . onNext ( "a1" ) ; io . verify ( obs , never ( ) ) . onNext ( anyString ( ) ) ; oB . onNext ( "b1" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a1-b1" ) ; oB . onNext ( "b2" ) ; io . verify ( obs , never ( ) ) . onNext ( anyString ( ) ) ; oA . onNext ( "a2" ) ; io . verify ( obs , times ( 1 ) ) . onNext ( "a2-b2" ) ; oA . onNext ( "a3" ) ; oA . onNext ( "a4" ) ; oA . onNext ( "a5" ) ; oA . onError ( new RuntimeException ( "forced failure" ) ) ; io . verify ( obs , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; oB . onNext ( "b3" ) ; oB . onNext ( "b4" ) ; oB . onNext ( "b5" ) ; oB . onNext ( "b6" ) ; oB . onNext ( "b7" ) ; oB . onNext ( "b8" ) ; oB . onNext ( "b9" ) ; io . verifyNoMoreInteractions ( ) ; 
return new BiFunction < String , String , String > ( ) @ Override public String apply ( String t1 , String t2 ) return t1 + "-" + t2 ; ; 
BiFunction < Integer , Integer , Integer > zipr = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 / i2 ; ; return zipr ; 
Function3 < String , String , String , String > zipr = new Function3 < String , String , String , String > ( ) @ Override public String apply ( String a1 , String a2 , String a3 ) if ( a1 == null ) a1 = "" ; if ( a2 == null ) a2 = "" ; if ( a3 == null ) a3 = "" ; return a1 + a2 + a3 ; ; return zipr ; 
BiFunction < String , Integer , String > zipr = new BiFunction < String , Integer , String > ( ) @ Override public String apply ( String s , Integer i ) return getStringValue ( s ) + getStringValue ( i ) ; ; return zipr ; 
Function3 < String , Integer , int [ ] , String > zipr = new Function3 < String , Integer , int [ ] , String > ( ) @ Override public String apply ( String s , Integer i , int [ ] iArray ) return getStringValue ( s ) + getStringValue ( i ) + getStringValue ( iArray ) ; ; return zipr ; 
if ( o == null ) return "" ; else if ( o instanceof int [ ] ) return Arrays . toString ( ( int [ ] ) o ) ; else return String . valueOf ( o ) ; 
this . observer = observer ; observer . onSubscribe ( Disposable . empty ( ) ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s1 . onComplete ( ) ; s2 . onNext ( "1" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a-1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b-2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; s1 . onNext ( "a" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a-1" ) ; s1 . onNext ( "b" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b-2" ) ; s1 . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; s2 . onComplete ( ) ; s1 . onNext ( "a" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a-1" ) ; s1 . onNext ( "b" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b-2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s2 . onNext ( "1" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a-1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b-2" ) ; s2 . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s2 . onNext ( "a" ) ; s1 . onError ( new RuntimeException ( "Forced failure" ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; s2 . onNext ( "b" ) ; s1 . onNext ( "1" ) ; s1 . onNext ( "2" ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
s1 . onNext ( "a" ) ; s1 . onNext ( "b" ) ; s2 . onError ( new RuntimeException ( "Forced failure" ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; s2 . onNext ( "1" ) ; s2 . onNext ( "2" ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final Observer < Integer > observer = TestHelper . mockObserver ( ) ; Observable . zip ( Observable . just ( 1 ) , Observable . just ( 1 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return a + b ; ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onComplete ( ) observer . onComplete ( ) ; @ Override public void onError ( Throwable e ) observer . onError ( e ) ; @ Override public void onNext ( Integer args ) observer . onNext ( args ) ; ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < String > os = OBSERVABLE_OF_5_INTEGERS . zipWith ( OBSERVABLE_OF_5_INTEGERS , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer a , Integer b ) return a + "-" + b ; ) ; final ArrayList < String > list = new ArrayList < > ( ) ; os . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) System . out . println ( s ) ; list . add ( s ) ; ) ; assertEquals ( 5 , list . size ( ) ) ; assertEquals ( "1-1" , list . get ( 0 ) ) ; assertEquals ( "2-2" , list . get ( 1 ) ) ; assertEquals ( "5-5" , list . get ( 4 ) ) ; 
Observable < String > os = ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS ( new CountDownLatch ( 1 ) ) . zipWith ( ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS ( new CountDownLatch ( 1 ) ) , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer a , Integer b ) return a + "-" + b ; ) . take ( 5 ) ; TestObserver < String > to = new TestObserver < > ( ) ; os . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( 5 , to . values ( ) . size ( ) ) ; assertEquals ( "1-1" , to . values ( ) . get ( 0 ) ) ; assertEquals ( "2-2" , to . values ( ) . get ( 1 ) ) ; assertEquals ( "5-5" , to . values ( ) . get ( 4 ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final CountDownLatch infiniteObservable = new CountDownLatch ( 1 ) ; Observable < String > os = OBSERVABLE_OF_5_INTEGERS . zipWith ( ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS ( infiniteObservable ) , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer a , Integer b ) return a + "-" + b ; ) ; final ArrayList < String > list = new ArrayList < > ( ) ; os . subscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String s ) System . out . println ( s ) ; list . add ( s ) ; ) ; latch . await ( 1000 , TimeUnit . MILLISECONDS ) ; if ( ! infiniteObservable . await ( 2000 , TimeUnit . MILLISECONDS ) ) throw new RuntimeException ( "didn't unsubscribe" ) ; assertEquals ( 5 , list . size ( ) ) ; assertEquals ( "1-1" , list . get ( 0 ) ) ; assertEquals ( "2-2" , list . get ( 1 ) ) ; assertEquals ( "5-5" , list . get ( 4 ) ) ; 
if ( notification . isOnError ( ) ) return "OnError" ; if ( notification . isOnNext ( ) ) return "OnNext" ; return "OnComplete" ; 
if ( notification . isOnNext ( ) ) return String . valueOf ( notification . getValue ( ) ) ; return "null" ; 
Observable < Notification < Integer > > oi = Observable . just ( 1 , 2 , 3 ) . materialize ( ) ; Observable < Notification < String > > os = Observable . just ( "a" , "b" , "c" ) . materialize ( ) ; Observable < String > o = Observable . zip ( oi , os , new BiFunction < Notification < Integer > , Notification < String > , String > ( ) @ Override public String apply ( Notification < Integer > t1 , Notification < String > t2 ) return kind ( t1 ) + "_" + value ( t1 ) + "-" + kind ( t2 ) + "_" + value ( t2 ) ; ) ; final ArrayList < String > list = new ArrayList < > ( ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) System . out . println ( s ) ; list . add ( s ) ; ) ; assertEquals ( 4 , list . size ( ) ) ; assertEquals ( "OnNext_1-OnNext_a" , list . get ( 0 ) ) ; assertEquals ( "OnNext_2-OnNext_b" , list . get ( 1 ) ) ; assertEquals ( "OnNext_3-OnNext_c" , list . get ( 2 ) ) ; assertEquals ( "OnComplete_null-OnComplete_null" , list . get ( 3 ) ) ; 
Observable < String > o = Observable . zip ( Observable . < Integer > empty ( ) , Observable . < String > empty ( ) , new BiFunction < Integer , String , String > ( ) @ Override public String apply ( Integer t1 , String t2 ) return t1 + "-" + t2 ; ) ; final ArrayList < String > list = new ArrayList < > ( ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) System . out . println ( s ) ; list . add ( s ) ; ) ; assertEquals ( 0 , list . size ( ) ) ; 
final Object invoked = new Object ( ) ; Collection < Observable < Object > > observables = Collections . emptyList ( ) ; Observable < Object > o = Observable . zip ( observables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( final Object [ ] args ) assertEquals ( "No argument should have been passed" , 0 , args . length ) ; return invoked ; ) ; TestObserver < Object > to = new TestObserver < > ( ) ; o . subscribe ( to ) ; to . awaitDone ( 200 , TimeUnit . MILLISECONDS ) ; to . assertNoValues ( ) ; 
final Object invoked = new Object ( ) ; Collection < Observable < Object > > observables = Collections . emptyList ( ) ; Observable < Object > o = Observable . zip ( observables , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( final Object [ ] args ) assertEquals ( "No argument should have been passed" , 0 , args . length ) ; return invoked ; ) ; o . blockingLast ( ) ; 
AtomicInteger generatedA = new AtomicInteger ( ) ; AtomicInteger generatedB = new AtomicInteger ( ) ; Observable < Integer > o1 = createInfiniteObservable ( generatedA ) . take ( Observable . bufferSize ( ) * 2 ) ; Observable < Integer > o2 = createInfiniteObservable ( generatedB ) . take ( Observable . bufferSize ( ) * 2 ) ; TestObserver < String > to = new TestObserver < > ( ) ; Observable . zip ( o1 , o2 , new BiFunction < Integer , Integer , String > ( ) @ Override public String apply ( Integer t1 , Integer t2 ) return t1 + "-" + t2 ; ) . observeOn ( Schedulers . computation ( ) ) . take ( Observable . bufferSize ( ) * 2 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( Observable . bufferSize ( ) * 2 , to . values ( ) . size ( ) ) ; System . out . println ( "Generated => A: " + generatedA . get ( ) + " B: " + generatedB . get ( ) ) ; assertTrue ( generatedA . get ( ) < ( Observable . bufferSize ( ) * 3 ) ) ; assertTrue ( generatedB . get ( ) < ( Observable . bufferSize ( ) * 3 ) ) ; 
Observable < Integer > o = Observable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) @ Override public Integer next ( ) return generated . getAndIncrement ( ) ; @ Override public boolean hasNext ( ) return true ; ; ) ; return o ; 
return Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( final Observer < ? super Integer > o ) Disposable d = Disposable . empty ( ) ; o . onSubscribe ( d ) ; for ( int i = 1 ; i <= 5 ; i ++ ) if ( d . isDisposed ( ) ) break ; numEmitted . incrementAndGet ( ) ; o . onNext ( i ) ; Thread . yield ( ) ; o . onComplete ( ) ; ) ; 
return Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( final Observer < ? super Integer > o ) final Disposable d = Disposable . empty ( ) ; o . onSubscribe ( d ) ; Thread t = new Thread ( new Runnable ( ) @ Override public void run ( ) System . out . println ( "-------> subscribe to infinite sequence" ) ; System . out . println ( "Starting thread: " + Thread . currentThread ( ) ) ; int i = 1 ; while ( ! d . isDisposed ( ) ) o . onNext ( i ++ ) ; Thread . yield ( ) ; o . onComplete ( ) ; latch . countDown ( ) ; System . out . println ( "Ending thread: " + Thread . currentThread ( ) ) ; ) ; t . start ( ) ; ) ; 
Observable < Integer > zip1 = Observable . zip ( Observable . range ( 0 , 1026 ) , Observable . range ( 0 , 1026 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 + i2 ; ) ; Observable < Integer > zip2 = Observable . zip ( zip1 , Observable . range ( 0 , 1026 ) , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer i1 , Integer i2 ) return i1 + i2 ; ) ; List < Integer > expected = new ArrayList < > ( ) ; for ( int i = 0 ; i < 1026 ; i ++ ) expected . add ( i * 3 ) ; assertEquals ( expected , zip2 . toList ( ) . blockingGet ( ) ) ; 
long startTime = System . currentTimeMillis ( ) ; Observable < Integer > src = Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; int i = 0 ; while ( System . currentTimeMillis ( ) - startTime < 9000 && i ++ < 100000 ) int value = Observable . zip ( src , src , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 + t2 * 10 ; ) . blockingSingle ( 0 ) ; Assert . assertEquals ( 11 , value ) ; 
Observable . zip ( Observable . just ( 1 ) , Observable . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return "" + a + b ; ) . test ( ) . assertResult ( "12" ) ; 
Observable . zip ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception return "" + a + b + c ; ) . test ( ) . assertResult ( "123" ) ; 
Observable . zip ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) , new Function4 < Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d ) throws Exception return "" + a + b + c + d ; ) . test ( ) . assertResult ( "1234" ) ; 
Observable . zip ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) , Observable . just ( 5 ) , new Function5 < Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e ) throws Exception return "" + a + b + c + d + e ; ) . test ( ) . assertResult ( "12345" ) ; 
Observable . zip ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) , Observable . just ( 5 ) , Observable . just ( 6 ) , new Function6 < Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f ) throws Exception return "" + a + b + c + d + e + f ; ) . test ( ) . assertResult ( "123456" ) ; 
Observable . zip ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) , Observable . just ( 5 ) , Observable . just ( 6 ) , Observable . just ( 7 ) , new Function7 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g ) throws Exception return "" + a + b + c + d + e + f + g ; ) . test ( ) . assertResult ( "1234567" ) ; 
Observable . zip ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) , Observable . just ( 5 ) , Observable . just ( 6 ) , Observable . just ( 7 ) , Observable . just ( 8 ) , new Function8 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g , Integer h ) throws Exception return "" + a + b + c + d + e + f + g + h ; ) . test ( ) . assertResult ( "12345678" ) ; 
Observable . zip ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) , Observable . just ( 4 ) , Observable . just ( 5 ) , Observable . just ( 6 ) , Observable . just ( 7 ) , Observable . just ( 8 ) , Observable . just ( 9 ) , new Function9 < Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c , Integer d , Integer e , Integer f , Integer g , Integer h , Integer i ) throws Exception return "" + a + b + c + d + e + f + g + h + i ; ) . test ( ) . assertResult ( "123456789" ) ; 
Observable . zip ( Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return "" + a + b ; , true ) . test ( ) . assertFailure ( TestException . class , "12" ) ; 
Observable . zip ( Observable . range ( 1 , 9 ) , Observable . range ( 21 , 9 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return "" + a + b ; , false , 2 ) . takeLast ( 1 ) . test ( ) . assertResult ( "929" ) ; 
Observable . zip ( Observable . range ( 1 , 9 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . range ( 21 , 9 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return "" + a + b ; , true , 2 ) . skip ( 8 ) . test ( ) . assertFailure ( TestException . class , "929" ) ; 
assertSame ( Observable . empty ( ) , Observable . zipArray ( Functions . < Object [ ] > identity ( ) , false , 16 ) ) ; 
@ SuppressWarnings ( "unchecked" ) Observable < Integer > [ ] arr = new Observable [ 10 ] ; Arrays . fill ( arr , Observable . just ( 1 ) ) ; Observable . zip ( Arrays . asList ( arr ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return Arrays . toString ( a ) ; ) . test ( ) . assertResult ( "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]" ) ; 
TestHelper . checkDisposed ( Observable . zip ( Observable . just ( 1 ) , Observable . just ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) TestObserver < List < Object > > to = Observable . zip ( Observable . just ( 1 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return Thread . currentThread ( ) . getName ( ) . substring ( 0 , 4 ) ; ) , Observable . just ( 1 ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return Thread . currentThread ( ) . getName ( ) . substring ( 0 , 4 ) ; ) , new BiFunction < Object , Object , List < Object > > ( ) @ Override public List < Object > apply ( Object t1 , Object t2 ) throws Exception return Arrays . asList ( t1 , t2 ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) ; List < Object > list = to . values ( ) . get ( 0 ) ; assertTrue ( list . toString ( ) , list . contains ( "RxSi" ) ) ; assertTrue ( list . toString ( ) , list . contains ( "RxCo" ) ) ; 
final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; dispose ( ) ; if ( ps1 . hasObservers ( ) ) onError ( new IllegalStateException ( "ps1 not disposed" ) ) ; else if ( ps2 . hasObservers ( ) ) onError ( new IllegalStateException ( "ps2 not disposed" ) ) ; else onComplete ( ) ; ; Observable . zip ( ps1 , ps2 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throws Exception return t1 + t2 ; ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; ps2 . onNext ( 2 ) ; to . assertResult ( 3 ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; List < Observable < ? > > observableList = new ArrayList < > ( ) ; observableList . add ( Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception throw new TestException ( ) ; ) ) ; observableList . add ( Observable . create ( new ObservableOnSubscribe < Object > ( ) @ Override public void subscribe ( ObservableEmitter < Object > e ) throws Exception counter . getAndIncrement ( ) ; ) ) ; Observable . zip ( observableList , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return a ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , counter . get ( ) ) ; 
ObservableSource < Integer > source = new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) Observable . just ( 1 ) . subscribe ( observer ) ; ; Observable . zip ( Arrays . asList ( source , source ) , new Function < Object [ ] , Integer > ( ) @ Override public Integer apply ( Object [ ] t ) throws Throwable return 2 ; ) . test ( ) . assertResult ( 2 ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" ) , Observable . just ( "one" , "two" , "three" ) ) . toObservable ( ) ; verifyResult ( o , true ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" ) , Observable . just ( "one" , "two" , "three" , "four" ) ) . toObservable ( ) ; verifyResult ( o , false ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" , "four" ) , Observable . just ( "one" , "two" , "three" ) ) . toObservable ( ) ; verifyResult ( o , false ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . concat ( Observable . just ( "one" ) , Observable . < String > error ( new TestException ( ) ) ) , Observable . just ( "one" , "two" , "three" ) ) . toObservable ( ) ; verifyError ( o ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" ) , Observable . concat ( Observable . just ( "one" ) , Observable . < String > error ( new TestException ( ) ) ) ) . toObservable ( ) ; verifyError ( o ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . concat ( Observable . just ( "one" ) , Observable . < String > error ( new TestException ( ) ) ) , Observable . concat ( Observable . just ( "one" ) , Observable . < String > error ( new TestException ( ) ) ) ) . toObservable ( ) ; verifyError ( o ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . < String > empty ( ) , Observable . just ( "one" , "two" , "three" ) ) . toObservable ( ) ; verifyResult ( o , false ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" ) , Observable . < String > empty ( ) ) . toObservable ( ) ; verifyResult ( o , false ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . < String > empty ( ) , Observable . < String > empty ( ) ) . toObservable ( ) ; verifyResult ( o , true ) ; 
Observable < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" ) , Observable . just ( "one" ) , new BiPredicate < String , String > ( ) @ Override public boolean test ( String t1 , String t2 ) throw new TestException ( ) ; ) . toObservable ( ) ; verifyError ( o ) ; 
Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( isA ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable . sequenceEqual ( Observable . range ( 1 , 20 ) , Observable . range ( 1 , 20 ) , 2 ) . toObservable ( ) . test ( ) . assertResult ( true ) ; 
TestHelper . checkDisposed ( Observable . sequenceEqual ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . toObservable ( ) ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" ) , Observable . just ( "one" , "two" , "three" ) ) ; verifyResult ( o , true ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" ) , Observable . just ( "one" , "two" , "three" , "four" ) ) ; verifyResult ( o , false ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" , "four" ) , Observable . just ( "one" , "two" , "three" ) ) ; verifyResult ( o , false ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . concat ( Observable . just ( "one" ) , Observable . < String > error ( new TestException ( ) ) ) , Observable . just ( "one" , "two" , "three" ) ) ; verifyError ( o ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" ) , Observable . concat ( Observable . just ( "one" ) , Observable . < String > error ( new TestException ( ) ) ) ) ; verifyError ( o ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . concat ( Observable . just ( "one" ) , Observable . < String > error ( new TestException ( ) ) ) , Observable . concat ( Observable . just ( "one" ) , Observable . < String > error ( new TestException ( ) ) ) ) ; verifyError ( o ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . < String > empty ( ) , Observable . just ( "one" , "two" , "three" ) ) ; verifyResult ( o , false ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" , "two" , "three" ) , Observable . < String > empty ( ) ) ; verifyResult ( o , false ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . < String > empty ( ) , Observable . < String > empty ( ) ) ; verifyResult ( o , true ) ; 
Single < Boolean > o = Observable . sequenceEqual ( Observable . just ( "one" ) , Observable . just ( "one" ) , new BiPredicate < String , String > ( ) @ Override public boolean test ( String t1 , String t2 ) throw new TestException ( ) ; ) ; verifyError ( o ) ; 
Observable . sequenceEqual ( Observable . range ( 1 , 20 ) , Observable . range ( 1 , 20 ) , 2 ) . test ( ) . assertResult ( true ) ; 
TestHelper . checkDisposed ( Observable . sequenceEqual ( Observable . just ( 1 ) , Observable . just ( 2 ) ) ) ; 
Observable . sequenceEqual ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . test ( ) . assertResult ( false ) ; 
Observable . sequenceEqual ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . toObservable ( ) . test ( ) . assertResult ( false ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Boolean > to = Observable . sequenceEqual ( Observable . never ( ) , ps ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Boolean > to = Observable . sequenceEqual ( Observable . never ( ) , ps ) . toObservable ( ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
Observable . sequenceEqual ( Observable . just ( 1 ) , Observable . empty ( ) ) . test ( ) . assertResult ( false ) ; 
Observable . sequenceEqual ( Observable . empty ( ) , Observable . just ( 1 ) ) . test ( ) . assertResult ( false ) ; 
Observable . sequenceEqual ( Observable . empty ( ) , Observable . empty ( ) ) . test ( ) . assertResult ( true ) ; 
Observable . sequenceEqual ( Observable . just ( 1 ) , Observable . just ( 1 ) ) . test ( ) . assertResult ( true ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Boolean > to = Observable . sequenceEqual ( ps1 , ps2 , ( a , b ) -> ps1 . onNext ( 1 ) ; ps1 . onComplete ( ) ; ps2 . onNext ( 1 ) ; ps2 . onComplete ( ) ; return a . equals ( b ) ; ) . test ( ) ; ps1 . onNext ( 0 ) ; ps2 . onNext ( 0 ) ; to . assertResult ( true ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Boolean > to = Observable . sequenceEqual ( ps1 , ps2 , ( a , b ) -> ps1 . onNext ( 1 ) ; ps1 . onComplete ( ) ; ps2 . onNext ( 1 ) ; ps2 . onComplete ( ) ; return a . equals ( b ) ; ) . toObservable ( ) . test ( ) ; ps1 . onNext ( 0 ) ; ps2 . onNext ( 0 ) ; to . assertResult ( true ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > o = Observable . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) count . incrementAndGet ( ) ; ) ; o . subscribe ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; assertEquals ( 3 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > o = Observable . just ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) count . incrementAndGet ( ) ; ) . take ( 1 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) count . incrementAndGet ( ) ; ) ; o . subscribe ( ) ; assertEquals ( 2 , count . get ( ) ) ; 
final AtomicInteger onSubscribed = new AtomicInteger ( ) ; final AtomicInteger countBefore = new AtomicInteger ( ) ; final AtomicInteger countAfter = new AtomicInteger ( ) ; final AtomicReference < Observer < ? super Integer > > sref = new AtomicReference < > ( ) ; Observable < Integer > o = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; onSubscribed . incrementAndGet ( ) ; sref . set ( observer ) ; ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) countBefore . incrementAndGet ( ) ; ) . publish ( ) . refCount ( ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) countAfter . incrementAndGet ( ) ; ) ; o . subscribe ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; assertEquals ( 1 , countBefore . get ( ) ) ; assertEquals ( 1 , onSubscribed . get ( ) ) ; assertEquals ( 3 , countAfter . get ( ) ) ; sref . get ( ) . onComplete ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; assertEquals ( 2 , countBefore . get ( ) ) ; assertEquals ( 2 , onSubscribed . get ( ) ) ; assertEquals ( 6 , countAfter . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final Disposable bs = Disposable . empty ( ) ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( bs ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) throws Exception throw new TestException ( "First" ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; assertTrue ( bs . isDisposed ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Observable < String > w = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Observable < String > take = w . take ( 2 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; take . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Observable < String > take = w . take ( 1 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; take . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . take ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new IllegalArgumentException ( "some error" ) ; ) . blockingSingle ( ) ; 
Observable < Integer > w = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . take ( 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new IllegalArgumentException ( "some error" ) ; ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; w . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > w = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . take ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new IllegalArgumentException ( "some error" ) ; ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; w . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( IllegalArgumentException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onError ( new Throwable ( "test failed" ) ) ; ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; source . take ( 1 ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verifyNoMoreInteractions ( observer ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onError ( new Throwable ( "test failed" ) ) ; 
TestObservableFunc f = new TestObservableFunc ( "one" , "two" , "three" ) ; Observable < String > w = Observable . unsafeCreate ( f ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > take = w . take ( 1 ) ; take . subscribe ( observer ) ; try f . t . join ( ) ; catch ( Throwable e ) e . printStackTrace ( ) ; fail ( e . getMessage ( ) ) ; System . out . println ( "TestObservable thread finished" ) ; verify ( observer ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verifyNoMoreInteractions ( observer ) ; 
final AtomicLong count = new AtomicLong ( ) ; INFINITE_OBSERVABLE . take ( 10 ) . subscribe ( new Consumer < Long > ( ) @ Override public void accept ( Long l ) count . set ( l ) ; ) ; assertEquals ( 10 , count . get ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) Disposable bs = Disposable . empty ( ) ; observer . onSubscribe ( bs ) ; for ( int i = 0 ; ! bs . isDisposed ( ) ; i ++ ) System . out . println ( "Emit: " + i ) ; count . incrementAndGet ( ) ; observer . onNext ( i ) ; ) . take ( 100 ) . take ( 1 ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) System . out . println ( "Receive: " + t1 ) ; ) ; assertEquals ( 1 , count . get ( ) ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( o ) ; INFINITE_OBSERVABLE . observeOn ( Schedulers . newThread ( ) ) . take ( 1 ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; verify ( o ) . onNext ( 1L ) ; verify ( o , never ( ) ) . onNext ( 2L ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final AtomicReference < Object > exception = new AtomicReference < > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) . take ( 1 ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) try Thread . sleep ( 100 ) ; catch ( Exception e ) exception . set ( e ) ; e . printStackTrace ( ) ; finally latch . countDown ( ) ; ) ; latch . await ( ) ; assertNull ( exception . get ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) . take ( 1 ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) throw new TestException ( ) ; ; source . safeSubscribe ( to ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
final PublishSubject < Integer > source = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . take ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) source . onNext ( 2 ) ; ) . subscribe ( to ) ; source . onNext ( 1 ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
try Observable . just ( 1 ) . take ( - 99 ) ; fail ( "Should have thrown" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "count >= 0 required but it was -99" , ex . getMessage ( ) ) ; 
Observable . just ( 1 ) . take ( 0 ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . take ( 2 ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . take ( 2 ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . error ( new TestException ( ) ) . take ( 0 ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Observable . interval ( 1 , TimeUnit . MILLISECONDS , new TestScheduler ( ) ) ) ; 
Observable . interval ( 1 , TimeUnit . MILLISECONDS , Schedulers . trampoline ( ) ) . take ( 10 ) . test ( ) . assertResult ( 0L , 1L , 2L , 3L , 4L , 5L , 6L , 7L , 8L , 9L ) ; 
TestObserver < Long > to = new TestObserver < > ( ) ; IntervalObserver is = new IntervalObserver ( to ) ; to . onSubscribe ( is ) ; is . dispose ( ) ; is . run ( ) ; to . assertEmpty ( ) ; 
Disposable sSource = mock ( Disposable . class ) ; Disposable sOther = mock ( Disposable . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Observer < String > result = TestHelper . mockObserver ( ) ; Observable < String > stringObservable = Observable . unsafeCreate ( source ) . takeUntil ( Observable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; other . sendOnNext ( "three" ) ; source . sendOnNext ( "four" ) ; source . sendOnCompleted ( ) ; other . sendOnCompleted ( ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( result , times ( 0 ) ) . onNext ( "three" ) ; verify ( result , times ( 0 ) ) . onNext ( "four" ) ; verify ( sSource , times ( 1 ) ) . dispose ( ) ; verify ( sOther , times ( 1 ) ) . dispose ( ) ; 
Disposable sSource = mock ( Disposable . class ) ; Disposable sOther = mock ( Disposable . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Observer < String > result = TestHelper . mockObserver ( ) ; Observable < String > stringObservable = Observable . unsafeCreate ( source ) . takeUntil ( Observable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; source . sendOnCompleted ( ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( sSource , never ( ) ) . dispose ( ) ; verify ( sOther , times ( 1 ) ) . dispose ( ) ; 
Disposable sSource = mock ( Disposable . class ) ; Disposable sOther = mock ( Disposable . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Throwable error = new Throwable ( ) ; Observer < String > result = TestHelper . mockObserver ( ) ; Observable < String > stringObservable = Observable . unsafeCreate ( source ) . takeUntil ( Observable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; source . sendOnError ( error ) ; source . sendOnNext ( "three" ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( result , times ( 0 ) ) . onNext ( "three" ) ; verify ( result , times ( 1 ) ) . onError ( error ) ; verify ( sSource , never ( ) ) . dispose ( ) ; verify ( sOther , times ( 1 ) ) . dispose ( ) ; 
Disposable sSource = mock ( Disposable . class ) ; Disposable sOther = mock ( Disposable . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Throwable error = new Throwable ( ) ; Observer < String > result = TestHelper . mockObserver ( ) ; Observable < String > stringObservable = Observable . unsafeCreate ( source ) . takeUntil ( Observable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; other . sendOnError ( error ) ; source . sendOnNext ( "three" ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( result , times ( 0 ) ) . onNext ( "three" ) ; verify ( result , times ( 1 ) ) . onError ( error ) ; verify ( result , times ( 0 ) ) . onComplete ( ) ; verify ( sSource , times ( 1 ) ) . dispose ( ) ; verify ( sOther , never ( ) ) . dispose ( ) ; 
Disposable sSource = mock ( Disposable . class ) ; Disposable sOther = mock ( Disposable . class ) ; TestObservable source = new TestObservable ( sSource ) ; TestObservable other = new TestObservable ( sOther ) ; Observer < String > result = TestHelper . mockObserver ( ) ; Observable < String > stringObservable = Observable . unsafeCreate ( source ) . takeUntil ( Observable . unsafeCreate ( other ) ) ; stringObservable . subscribe ( result ) ; source . sendOnNext ( "one" ) ; source . sendOnNext ( "two" ) ; other . sendOnCompleted ( ) ; source . sendOnNext ( "three" ) ; verify ( result , times ( 1 ) ) . onNext ( "one" ) ; verify ( result , times ( 1 ) ) . onNext ( "two" ) ; verify ( result , times ( 0 ) ) . onNext ( "three" ) ; verify ( result , times ( 1 ) ) . onComplete ( ) ; verify ( sSource , times ( 1 ) ) . dispose ( ) ; verify ( sOther , never ( ) ) . dispose ( ) ; 
observer . onComplete ( ) ; 
observer . onNext ( value ) ; 
observer . onError ( e ) ; 
this . observer = observer ; observer . onSubscribe ( upstream ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > until = PublishSubject . create ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; source . takeUntil ( until ) . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( until . hasObservers ( ) ) ; source . onNext ( 1 ) ; to . assertValue ( 1 ) ; until . onNext ( 1 ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; assertFalse ( "Source still has observers" , source . hasObservers ( ) ) ; assertFalse ( "Until still has observers" , until . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > until = PublishSubject . create ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; source . takeUntil ( until ) . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( until . hasObservers ( ) ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; assertFalse ( "Source still has observers" , source . hasObservers ( ) ) ; assertFalse ( "Until still has observers" , until . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > until = PublishSubject . create ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; source . takeUntil ( until ) . take ( 1 ) . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( until . hasObservers ( ) ) ; source . onNext ( 1 ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; assertFalse ( "Source still has observers" , source . hasObservers ( ) ) ; assertFalse ( "Until still has observers" , until . hasObservers ( ) ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . takeUntil ( Observable . never ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > o ) throws Exception return o . takeUntil ( Observable . never ( ) ) ; ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onNext ( 1 ) ; main . onNext ( 2 ) ; main . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( 1 , 2 ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; main . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onNext ( 1 ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onComplete ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertResult ( ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; other . onError ( new TestException ( ) ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; TestObserver < Integer > to = main . takeUntil ( other ) . test ( ) ; assertTrue ( "Main no observers?" , main . hasObservers ( ) ) ; assertTrue ( "Other no observers?" , other . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Main has observers?" , main . hasObservers ( ) ) ; assertFalse ( "Other has observers?" , other . hasObservers ( ) ) ; to . assertEmpty ( ) ; 
underlyingSubject = PublishSubject . create ( ) ; testScheduler = new TestScheduler ( ) ; withTimeout = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; withTimeout . subscribe ( to ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; verify ( observer ) . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; to . dispose ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; withTimeout . subscribe ( to ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "Two" ) ; verify ( observer ) . onNext ( "Two" ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; to . dispose ( ) ; 
TestObserverEx < String > observer = new TestObserverEx < > ( ) ; withTimeout . subscribe ( observer ) ; testScheduler . advanceTimeBy ( TIMEOUT + 1 , TimeUnit . SECONDS ) ; observer . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( TIMEOUT , TIME_UNIT ) ) ; 
TestObserverEx < String > observer = new TestObserverEx < > ( ) ; withTimeout . subscribe ( observer ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; observer . assertValue ( "One" ) ; testScheduler . advanceTimeBy ( TIMEOUT + 1 , TimeUnit . SECONDS ) ; observer . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( TIMEOUT , TIME_UNIT ) , "One" ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; withTimeout . subscribe ( observer ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onComplete ( ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; verify ( observer ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; to . dispose ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; withTimeout . subscribe ( observer ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onError ( new UnsupportedOperationException ( ) ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; verify ( observer ) . onError ( any ( UnsupportedOperationException . class ) ) ; to . dispose ( ) ; 
Observable < String > other = Observable . just ( "a" , "b" , "c" ) ; Observable < String > source = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler , other ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; source . subscribe ( to ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 4 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "Two" ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "One" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; to . dispose ( ) ; 
Observable < String > other = Observable . just ( "a" , "b" , "c" ) ; Observable < String > source = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler , other ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; source . subscribe ( to ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 4 , TimeUnit . SECONDS ) ; underlyingSubject . onError ( new UnsupportedOperationException ( ) ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "One" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; to . dispose ( ) ; 
Observable < String > other = Observable . just ( "a" , "b" , "c" ) ; Observable < String > source = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler , other ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; source . subscribe ( to ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 4 , TimeUnit . SECONDS ) ; underlyingSubject . onComplete ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "One" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "c" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; to . dispose ( ) ; 
PublishSubject < String > other = PublishSubject . create ( ) ; Observable < String > source = underlyingSubject . timeout ( TIMEOUT , TIME_UNIT , testScheduler , other ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; source . subscribe ( to ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "One" ) ; testScheduler . advanceTimeBy ( 4 , TimeUnit . SECONDS ) ; underlyingSubject . onNext ( "Two" ) ; other . onNext ( "a" ) ; other . onNext ( "b" ) ; to . dispose ( ) ; other . onNext ( "c" ) ; other . onNext ( "d" ) ; other . onComplete ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "One" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "a" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "b" ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final CountDownLatch exit = new CountDownLatch ( 1 ) ; final CountDownLatch timeoutSetuped = new CountDownLatch ( 1 ) ; final TestObserverEx < String > observer = new TestObserverEx < > ( ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; try timeoutSetuped . countDown ( ) ; exit . await ( ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; observer . onNext ( "a" ) ; observer . onComplete ( ) ; ) . timeout ( 1 , TimeUnit . SECONDS , testScheduler ) . subscribe ( observer ) ; ) . start ( ) ; timeoutSetuped . await ( ) ; testScheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; observer . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( 1 , TimeUnit . SECONDS ) ) ; exit . countDown ( ) ; 
final Disposable upstream = mock ( Disposable . class ) ; Observable < String > never = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( upstream ) ; ) ; TestScheduler testScheduler = new TestScheduler ( ) ; Observable < String > observableWithTimeout = never . timeout ( 1000 , TimeUnit . MILLISECONDS , testScheduler ) ; TestObserverEx < String > observer = new TestObserverEx < > ( ) ; observableWithTimeout . subscribe ( observer ) ; testScheduler . advanceTimeBy ( 2000 , TimeUnit . MILLISECONDS ) ; observer . assertFailureAndMessage ( TimeoutException . class , timeoutMessage ( 1000 , TimeUnit . MILLISECONDS ) ) ; verify ( upstream , times ( 1 ) ) . dispose ( ) ; 
final PublishSubject < String > subject = PublishSubject . create ( ) ; final TestScheduler scheduler = new TestScheduler ( ) ; final TestObserver < String > observer = subject . timeout ( 100 , TimeUnit . MILLISECONDS , scheduler ) . test ( ) ; assertTrue ( subject . hasObservers ( ) ) ; observer . dispose ( ) ; assertFalse ( subject . hasObservers ( ) ) ; 
Observable . never ( ) . timeout ( 100 , TimeUnit . MILLISECONDS , Observable . just ( 1 ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . timeout ( 1 , TimeUnit . DAYS ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . timeout ( 1 , TimeUnit . DAYS , Observable . just ( 1 ) ) ) ; 
Observable . error ( new TestException ( ) ) . timeout ( 1 , TimeUnit . DAYS , Observable . just ( 1 ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . empty ( ) . timeout ( 1 , TimeUnit . DAYS , Observable . just ( 1 ) ) . test ( ) . assertResult ( ) ; 
Observable . empty ( ) . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . timeout ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . timeout ( 1 , TimeUnit . DAYS , Observable . just ( 3 ) ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . timeout ( 1 , TimeUnit . DAYS ) . take ( 1 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . timeout ( 1 , TimeUnit . DAYS , Observable . just ( 2 ) ) . take ( 1 ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertResult ( 1 ) ; 
Observable . never ( ) . timeout ( 1 , TimeUnit . MILLISECONDS , Observable . error ( new TestException ( ) ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestScheduler sch = new TestScheduler ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserverEx < Integer > to = ps . timeout ( 1 , TimeUnit . SECONDS , sch ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to . values ( ) . size ( ) != 0 ) if ( to . errors ( ) . size ( ) != 0 ) to . assertFailure ( TimeoutException . class , 1 ) ; to . assertErrorMessage ( timeoutMessage ( 1 , TimeUnit . SECONDS ) ) ; else to . assertValuesOnly ( 1 ) ; else to . assertFailure ( TimeoutException . class ) ; to . assertErrorMessage ( timeoutMessage ( 1 , TimeUnit . SECONDS ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestScheduler sch = new TestScheduler ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserverEx < Integer > to = ps . timeout ( 1 , TimeUnit . SECONDS , sch , Observable . just ( 2 ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; if ( to . isTerminated ( ) ) int c = to . values ( ) . size ( ) ; if ( c == 1 ) int v = to . values ( ) . get ( 0 ) ; assertTrue ( "" + v , v == 1 || v == 2 ) ; else to . assertResult ( 1 , 2 ) ; else to . assertValuesOnly ( 1 ) ; 
objectObserver = TestHelper . mockObserver ( ) ; singleObserver = TestHelper . mockSingleObserver ( ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" ) ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc ) . toObservable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "a" , "b" ) ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( 1 ) ) . onNext ( expected ) ; verify ( objectObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" ) ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicate ) . toObservable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "aa" , "bb" ) ) ; expected . put ( 2 , Arrays . asList ( "cccc" , "dddd" ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( 1 ) ) . onNext ( expected ) ; verify ( objectObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" , "eee" , "fff" ) ; Supplier < Map < Integer , Collection < String > > > mapFactory = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new LinkedHashMap < Integer , Collection < String > > ( ) private static final long serialVersionUID = - 2084477070717362859L ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , Collection < String > > eldest ) return size ( ) > 2 ; ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapFactory , new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer v ) return new ArrayList < > ( ) ; ) . toObservable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Arrays . asList ( "eee" , "fff" ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( 1 ) ) . onNext ( expected ) ; verify ( objectObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "cc" , "dd" , "eee" , "eee" ) ; Function < Integer , Collection < String > > collectionFactory = new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer t1 ) if ( t1 == 2 ) return new ArrayList < > ( ) ; else return new HashSet < > ( ) ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Supplier < Map < Integer , Collection < String > > > mapSupplier = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new HashMap < > ( ) ; ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapSupplier , collectionFactory ) . toObservable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , new HashSet < > ( Arrays . asList ( "eee" ) ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , times ( 1 ) ) . onNext ( expected ) ; verify ( objectObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" ) ; Function < String , Integer > lengthFuncErr = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) if ( "b" . equals ( t1 ) ) throw new RuntimeException ( "Forced Failure" ) ; return t1 . length ( ) ; ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFuncErr ) . toObservable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "a" , "b" ) ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" ) ; Function < String , String > duplicateErr = new Function < String , String > ( ) @ Override public String apply ( String t1 ) if ( "b" . equals ( t1 ) ) throw new RuntimeException ( "Forced failure" ) ; return t1 + t1 ; ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicateErr ) . toObservable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "aa" , "bb" ) ) ; expected . put ( 2 , Arrays . asList ( "cccc" , "dddd" ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" , "eee" , "fff" ) ; Supplier < Map < Integer , Collection < String > > > mapFactory = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) throw new RuntimeException ( "Forced failure" ) ; ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) . toObservable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Arrays . asList ( "eee" , "fff" ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "cc" , "cc" , "eee" , "eee" ) ; Function < Integer , Collection < String > > collectionFactory = new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer t1 ) if ( t1 == 2 ) throw new RuntimeException ( "Forced failure" ) ; else return new HashSet < > ( ) ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Supplier < Map < Integer , Collection < String > > > mapSupplier = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new HashMap < > ( ) ; ; Observable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapSupplier , collectionFactory ) . toObservable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Collections . singleton ( "eee" ) ) ; mapped . subscribe ( objectObserver ) ; verify ( objectObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectObserver , never ( ) ) . onNext ( expected ) ; verify ( objectObserver , never ( ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" ) ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "a" , "b" ) ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" ) ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicate ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "aa" , "bb" ) ) ; expected . put ( 2 , Arrays . asList ( "cccc" , "dddd" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" , "eee" , "fff" ) ; Supplier < Map < Integer , Collection < String > > > mapFactory = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new LinkedHashMap < Integer , Collection < String > > ( ) private static final long serialVersionUID = - 2084477070717362859L ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , Collection < String > > eldest ) return size ( ) > 2 ; ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapFactory , new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer v ) return new ArrayList < > ( ) ; ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Arrays . asList ( "eee" , "fff" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "cc" , "dd" , "eee" , "eee" ) ; Function < Integer , Collection < String > > collectionFactory = new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer t1 ) if ( t1 == 2 ) return new ArrayList < > ( ) ; else return new HashSet < > ( ) ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Supplier < Map < Integer , Collection < String > > > mapSupplier = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new HashMap < > ( ) ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapSupplier , collectionFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , new HashSet < > ( Arrays . asList ( "eee" ) ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" ) ; Function < String , Integer > lengthFuncErr = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) if ( "b" . equals ( t1 ) ) throw new RuntimeException ( "Forced Failure" ) ; return t1 . length ( ) ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFuncErr ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "a" , "b" ) ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" ) ; Function < String , String > duplicateErr = new Function < String , String > ( ) @ Override public String apply ( String t1 ) if ( "b" . equals ( t1 ) ) throw new RuntimeException ( "Forced failure" ) ; return t1 + t1 ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicateErr ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "aa" , "bb" ) ) ; expected . put ( 2 , Arrays . asList ( "cccc" , "dddd" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "a" , "b" , "cc" , "dd" , "eee" , "fff" ) ; Supplier < Map < Integer , Collection < String > > > mapFactory = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) throw new RuntimeException ( "Forced failure" ) ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Arrays . asList ( "eee" , "fff" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; 
Observable < String > source = Observable . just ( "cc" , "cc" , "eee" , "eee" ) ; Function < Integer , Collection < String > > collectionFactory = new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer t1 ) if ( t1 == 2 ) throw new RuntimeException ( "Forced failure" ) ; else return new HashSet < > ( ) ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Supplier < Map < Integer , Collection < String > > > mapSupplier = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new HashMap < > ( ) ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapSupplier , collectionFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Collections . singleton ( "eee" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; 
Observable < String > o = Observable . < String > empty ( ) . skipLast ( 2 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > o = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) . skipLast ( 2 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer ) ; o . subscribe ( observer ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "two" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > o = Observable . fromIterable ( Arrays . asList ( "one" , "two" ) ) . skipLast ( 2 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . just ( "one" , "two" ) ; Observable < String > observable = w . skipLast ( 0 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > o = Observable . range ( 0 , Flowable . bufferSize ( ) * 2 ) . skipLast ( Flowable . bufferSize ( ) + 10 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; o . observeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( ( Flowable . bufferSize ( ) ) - 10 , to . values ( ) . size ( ) ) ; 
Observable . just ( "one" ) . skipLast ( - 1 ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . skipLast ( 1 ) ) ; 
Observable . error ( new TestException ( ) ) . skipLast ( 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > o ) throws Exception return o . skipLast ( 1 ) ; ) ; 
Observable < String > source = Observable . just ( "one" , "two" , "three" , "four" , "five" , "six" ) ; Observable < GroupedObservable < Integer , String > > grouped = source . groupBy ( length ) ; Map < Integer , Collection < String > > map = toMap ( grouped ) ; assertEquals ( 3 , map . size ( ) ) ; assertArrayEquals ( Arrays . asList ( "one" , "two" , "six" ) . toArray ( ) , map . get ( 3 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( "four" , "five" ) . toArray ( ) , map . get ( 4 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( "three" ) . toArray ( ) , map . get ( 5 ) . toArray ( ) ) ; 
Observable < String > source = Observable . just ( "one" , "two" , "three" , "four" , "five" , "six" ) ; Observable < GroupedObservable < Integer , Integer > > grouped = source . groupBy ( length , length ) ; Map < Integer , Collection < Integer > > map = toMap ( grouped ) ; assertEquals ( 3 , map . size ( ) ) ; assertArrayEquals ( Arrays . asList ( 3 , 3 , 3 ) . toArray ( ) , map . get ( 3 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( 4 , 4 ) . toArray ( ) , map . get ( 4 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( 5 ) . toArray ( ) , map . get ( 5 ) . toArray ( ) ) ; 
Observable < String > source = Observable . just ( "one" , "two" , "three" , "four" , "five" , "six" ) ; Observable < GroupedObservable < Integer , Integer > > grouped = source . groupBy ( length , length ) ; Map < Integer , Collection < Integer > > map = toMap ( grouped ) ; assertEquals ( 3 , map . size ( ) ) ; assertArrayEquals ( Arrays . asList ( 3 , 3 , 3 ) . toArray ( ) , map . get ( 3 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( 4 , 4 ) . toArray ( ) , map . get ( 4 ) . toArray ( ) ) ; assertArrayEquals ( Arrays . asList ( 5 ) . toArray ( ) , map . get ( 5 ) . toArray ( ) ) ; 
Observable < String > source = Observable . empty ( ) ; Observable < GroupedObservable < Integer , String > > grouped = source . groupBy ( length ) ; Map < Integer , Collection < String > > map = toMap ( grouped ) ; assertTrue ( map . isEmpty ( ) ) ; 
Observable < String > sourceStrings = Observable . just ( "one" , "two" , "three" , "four" , "five" , "six" ) ; Observable < String > errorSource = Observable . error ( new RuntimeException ( "forced failure" ) ) ; Observable < String > source = Observable . concat ( sourceStrings , errorSource ) ; Observable < GroupedObservable < Integer , String > > grouped = source . groupBy ( length ) ; final AtomicInteger groupCounter = new AtomicInteger ( ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; grouped . flatMap ( new Function < GroupedObservable < Integer , String > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Integer , String > o ) groupCounter . incrementAndGet ( ) ; return o . map ( new Function < String , String > ( ) @ Override public String apply ( String v ) return "Event => key: " + o . getKey ( ) + " value: " + v ; ) ; ) . subscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; error . set ( e ) ; @ Override public void onNext ( String v ) eventCounter . incrementAndGet ( ) ; System . out . println ( v ) ; ) ; assertEquals ( 3 , groupCounter . get ( ) ) ; assertEquals ( 6 , eventCounter . get ( ) ) ; assertNotNull ( error . get ( ) ) ; 
final ConcurrentHashMap < K , Collection < V > > result = new ConcurrentHashMap < > ( ) ; observable . doOnNext ( new Consumer < GroupedObservable < K , V > > ( ) @ Override public void accept ( final GroupedObservable < K , V > o ) result . put ( o . getKey ( ) , new ConcurrentLinkedQueue < > ( ) ) ; o . subscribe ( new Consumer < V > ( ) @ Override public void accept ( V v ) result . get ( o . getKey ( ) ) . add ( v ) ; ) ; ) . blockingSubscribe ( ) ; return result ; 
final AtomicInteger eventCounter = new AtomicInteger ( ) ; final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger groupCounter = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final int count = 100 ; final int groupCount = 2 ; Observable < Event > es = Observable . unsafeCreate ( new ObservableSource < Event > ( ) @ Override public void subscribe ( final Observer < ? super Event > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "*** Subscribing to EventStream ***" ) ; subscribeCounter . incrementAndGet ( ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < count ; i ++ ) Event e = new Event ( ) ; e . source = i % groupCount ; e . message = "Event-" + i ; observer . onNext ( e ) ; observer . onComplete ( ) ; ) . start ( ) ; ) ; es . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . flatMap ( new Function < GroupedObservable < Integer , Event > , Observable < String > > ( ) @ Override public Observable < String > apply ( GroupedObservable < Integer , Event > eventGroupedObservable ) System . out . println ( "GroupedObservable Key: " + eventGroupedObservable . getKey ( ) ) ; groupCounter . incrementAndGet ( ) ; return eventGroupedObservable . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "Source: " + event . source + "  Message: " + event . message ; ) ; ) . subscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String outputMessage ) System . out . println ( outputMessage ) ; eventCounter . incrementAndGet ( ) ; ) ; latch . await ( 5000 , TimeUnit . MILLISECONDS ) ; assertEquals ( 1 , subscribeCounter . get ( ) ) ; assertEquals ( groupCount , groupCounter . get ( ) ) ; assertEquals ( count , eventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream ( SYNC_INFINITE_OBSERVABLE_OF_EVENT ( 2 , subscribeCounter , sentEventCounter ) , subscribeCounter ) ; Thread . sleep ( 500 ) ; assertEquals ( 39 , sentEventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream ( ASYNC_INFINITE_OBSERVABLE_OF_EVENT ( 2 , subscribeCounter , sentEventCounter ) , subscribeCounter ) ; Thread . sleep ( 500 ) ; assertEquals ( 39 , sentEventCounter . get ( ) ) ; 
final AtomicInteger eventCounter = new AtomicInteger ( ) ; final AtomicInteger groupCounter = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; es . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . take ( 1 ) . flatMap ( new Function < GroupedObservable < Integer , Event > , Observable < String > > ( ) @ Override public Observable < String > apply ( GroupedObservable < Integer , Event > eventGroupedObservable ) System . out . println ( "testUnsubscribe => GroupedObservable Key: " + eventGroupedObservable . getKey ( ) ) ; groupCounter . incrementAndGet ( ) ; return eventGroupedObservable . take ( 20 ) . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "testUnsubscribe => Source: " + event . source + "  Message: " + event . message ; ) ; ) . subscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( String outputMessage ) System . out . println ( outputMessage ) ; eventCounter . incrementAndGet ( ) ; ) ; if ( ! latch . await ( 2000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out so likely did not unsubscribe correctly" ) ; assertEquals ( 1 , subscribeCounter . get ( ) ) ; assertEquals ( 1 , groupCounter . get ( ) ) ; assertEquals ( 20 , eventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; SYNC_INFINITE_OBSERVABLE_OF_EVENT ( 4 , subscribeCounter , sentEventCounter ) . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . take ( 2 ) . flatMap ( new Function < GroupedObservable < Integer , Event > , Observable < String > > ( ) @ Override public Observable < String > apply ( GroupedObservable < Integer , Event > eventGroupedObservable ) return eventGroupedObservable . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "testUnsubscribe => Source: " + event . source + "  Message: " + event . message ; ) ; ) . take ( 30 ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; assertEquals ( 30 , eventCounter . get ( ) ) ; assertEquals ( 58 , sentEventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; SYNC_INFINITE_OBSERVABLE_OF_EVENT ( 4 , subscribeCounter , sentEventCounter ) . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . take ( 2 ) . flatMap ( new Function < GroupedObservable < Integer , Event > , Observable < String > > ( ) @ Override public Observable < String > apply ( GroupedObservable < Integer , Event > eventGroupedObservable ) int numToTake = 0 ; if ( eventGroupedObservable . getKey ( ) == 1 ) numToTake = 10 ; else if ( eventGroupedObservable . getKey ( ) == 2 ) numToTake = 5 ; return eventGroupedObservable . take ( numToTake ) . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "testUnsubscribe => Source: " + event . source + "  Message: " + event . message ; ) ; ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; assertEquals ( 15 , eventCounter . get ( ) ) ; assertEquals ( 37 , sentEventCounter . get ( ) ) ; 
final AtomicInteger eventCounter = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Observable . range ( 0 , 100 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i % 2 ; ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( GroupedObservable < Integer , Integer > group ) if ( group . getKey ( ) == 0 ) return group . delay ( 100 , TimeUnit . MILLISECONDS ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t * 10 ; ) ; else return group ; ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onComplete ( ) System . out . println ( "=> onComplete" ) ; latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( Integer s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; if ( ! latch . await ( 3000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out" ) ; assertEquals ( 100 , eventCounter . get ( ) ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; Observable . range ( 0 , 100 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i % 2 ; ) . subscribe ( new DefaultObserver < GroupedObservable < Integer , Integer > > ( ) @ Override public void onComplete ( ) latch . countDown ( ) ; @ Override public void onError ( Throwable e ) e . printStackTrace ( ) ; latch . countDown ( ) ; @ Override public void onNext ( GroupedObservable < Integer , Integer > s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; if ( ! latch . await ( 500 , TimeUnit . MILLISECONDS ) ) fail ( "timed out - never got completion" ) ; assertEquals ( 100 , eventCounter . get ( ) ) ; 
final AtomicInteger subscribeCounter = new AtomicInteger ( ) ; final AtomicInteger sentEventCounter = new AtomicInteger ( ) ; final AtomicInteger eventCounter = new AtomicInteger ( ) ; SYNC_INFINITE_OBSERVABLE_OF_EVENT ( 4 , subscribeCounter , sentEventCounter ) . groupBy ( new Function < Event , Integer > ( ) @ Override public Integer apply ( Event e ) return e . source ; ) . flatMap ( new Function < GroupedObservable < Integer , Event > , Observable < String > > ( ) @ Override public Observable < String > apply ( GroupedObservable < Integer , Event > eventGroupedObservable ) Observable < Event > eventStream = eventGroupedObservable ; if ( eventGroupedObservable . getKey ( ) >= 2 ) eventStream = eventGroupedObservable . filter ( new Predicate < Event > ( ) @ Override public boolean test ( Event t1 ) return false ; ) ; return eventStream . map ( new Function < Event , String > ( ) @ Override public String apply ( Event event ) return "testUnsubscribe => Source: " + event . source + "  Message: " + event . message ; ) ; ) . take ( 30 ) . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) eventCounter . incrementAndGet ( ) ; System . out . println ( "=> " + s ) ; ) ; assertEquals ( 30 , eventCounter . get ( ) ) ; assertEquals ( 60 , sentEventCounter . get ( ) ) ; 
final CountDownLatch first = new CountDownLatch ( 2 ) ; final ArrayList < String > results = new ArrayList < > ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > sub ) sub . onSubscribe ( Disposable . empty ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; try first . await ( ) ; catch ( InterruptedException e ) sub . onError ( e ) ; return ; sub . onNext ( 3 ) ; sub . onNext ( 3 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Integer , Integer > group ) if ( group . getKey ( ) < 3 ) return group . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "first groups: " + t1 ; ) . take ( 2 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) first . countDown ( ) ; ) ; else return group . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "last group: " + t1 ; ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 6 , results . size ( ) ) ; 
System . err . println ( "----------------------------------------------------------------------------------------------" ) ; final CountDownLatch first = new CountDownLatch ( 2 ) ; final ArrayList < String > results = new ArrayList < > ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > sub ) sub . onSubscribe ( Disposable . empty ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; try first . await ( ) ; catch ( InterruptedException e ) sub . onError ( e ) ; return ; sub . onNext ( 3 ) ; sub . onNext ( 3 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Integer , Integer > group ) if ( group . getKey ( ) < 3 ) return group . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "first groups: " + t1 ; ) . take ( 2 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) first . countDown ( ) ; ) ; else return group . subscribeOn ( Schedulers . newThread ( ) ) . delay ( 400 , TimeUnit . MILLISECONDS ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "last group: " + t1 ; ) . doOnEach ( new Consumer < Notification < String > > ( ) @ Override public void accept ( Notification < String > t1 ) System . err . println ( "subscribeOn notification => " + t1 ) ; ) ; ) . doOnEach ( new Consumer < Notification < String > > ( ) @ Override public void accept ( Notification < String > t1 ) System . err . println ( "outer notification => " + t1 ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 6 , results . size ( ) ) ; 
final CountDownLatch first = new CountDownLatch ( 2 ) ; final ArrayList < String > results = new ArrayList < > ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > sub ) sub . onSubscribe ( Disposable . empty ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; try first . await ( ) ; catch ( InterruptedException e ) sub . onError ( e ) ; return ; sub . onNext ( 3 ) ; sub . onNext ( 3 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Integer , Integer > group ) if ( group . getKey ( ) < 3 ) return group . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "first groups: " + t1 ; ) . take ( 2 ) . doOnComplete ( new Action ( ) @ Override public void run ( ) first . countDown ( ) ; ) ; else return group . observeOn ( Schedulers . newThread ( ) ) . delay ( 400 , TimeUnit . MILLISECONDS ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "last group: " + t1 ; ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 6 , results . size ( ) ) ; 
final ArrayList < String > results = new ArrayList < > ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > sub ) sub . onSubscribe ( Disposable . empty ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Integer , Integer > group ) return group . subscribeOn ( Schedulers . newThread ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) System . out . println ( "Received: " + t1 + " on group : " + group . getKey ( ) ) ; return "first groups: " + t1 ; ) ; ) . doOnEach ( new Consumer < Notification < String > > ( ) @ Override public void accept ( Notification < String > t1 ) System . out . println ( "notification => " + t1 ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 4 , results . size ( ) ) ; 
final ArrayList < String > results = new ArrayList < > ( ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > sub ) sub . onSubscribe ( Disposable . empty ( ) ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onNext ( 1 ) ; sub . onNext ( 2 ) ; sub . onComplete ( ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t ) return t ; ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Integer , Integer > group ) return group . observeOn ( Schedulers . newThread ( ) ) . delay ( 400 , TimeUnit . MILLISECONDS ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "first groups: " + t1 ; ) ; ) . blockingForEach ( new Consumer < String > ( ) @ Override public void accept ( String s ) results . add ( s ) ; ) ; System . out . println ( "Results: " + results ) ; assertEquals ( 4 , results . size ( ) ) ; 
return "Event => source: " + source + " message: " + message ; 
Observable < Long > source = Observable . interval ( 10 , TimeUnit . MILLISECONDS ) . take ( 1 ) ; Observable < GroupedObservable < Boolean , Long > > stream = source . groupBy ( IS_EVEN ) ; Observer < GroupedObservable < Boolean , Long > > o1 = TestHelper . mockObserver ( ) ; Observer < GroupedObservable < Boolean , Long > > o2 = TestHelper . mockObserver ( ) ; stream . subscribe ( o1 ) ; stream . subscribe ( o2 ) ; verify ( o1 , never ( ) ) . onError ( Mockito . < Throwable > any ( ) ) ; verify ( o2 , never ( ) ) . onError ( Mockito . < Throwable > any ( ) ) ; 
TestObserver < String > to = new TestObserver < > ( ) ; Observable . range ( 1 , 4000 ) . groupBy ( IS_EVEN2 ) . flatMap ( new Function < GroupedObservable < Boolean , Integer > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Boolean , Integer > g ) return g . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer l ) if ( g . getKey ( ) ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return l + " is even." ; else return l + " is odd." ; ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; 
Observable < String > source = Observable . fromIterable ( Arrays . asList ( "  foo" , " FoO " , "baR  " , "foO " , " Baz   " , "  qux " , "   bar" , " BAR  " , "FOO " , "baz  " , " bAZ " , "    fOo    " ) ) ; Function < String , String > keysel = new Function < String , String > ( ) @ Override public String apply ( String t1 ) return t1 . trim ( ) . toLowerCase ( ) ; ; Function < String , String > valuesel = new Function < String , String > ( ) @ Override public String apply ( String t1 ) return t1 + t1 ; ; Observable < String > m = source . groupBy ( keysel , valuesel ) . flatMap ( new Function < GroupedObservable < String , String > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < String , String > g ) System . out . println ( "-----------> NEXT: " + g . getKey ( ) ) ; return g . take ( 2 ) . map ( new Function < String , String > ( ) int count ; @ Override public String apply ( String v ) System . out . println ( v ) ; return g . getKey ( ) + "-" + count ++ ; ) ; ) ; TestObserver < String > to = new TestObserver < > ( ) ; m . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; System . out . println ( "ts .get " + to . values ( ) ) ; to . assertNoErrors ( ) ; assertEquals ( to . values ( ) , Arrays . asList ( "foo-0" , "foo-1" , "bar-0" , "foo-0" , "baz-0" , "qux-0" , "bar-1" , "bar-0" , "foo-1" , "baz-1" , "baz-0" , "foo-0" ) ) ; 
Observable < Integer > source = Observable . just ( 0 , 1 , 2 , 3 , 4 , 5 , 6 ) ; Observable < Integer > m = source . groupBy ( fail ( 0 ) , dbl ) . flatMap ( FLATTEN_INTEGER ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; m . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , to . errors ( ) . size ( ) ) ; to . assertNoValues ( ) ; 
Observable < Integer > source = Observable . just ( 0 , 1 , 2 , 3 , 4 , 5 , 6 ) ; Observable < Integer > m = source . groupBy ( identity , fail ( 0 ) ) . flatMap ( FLATTEN_INTEGER ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; m . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , to . errors ( ) . size ( ) ) ; to . assertNoValues ( ) ; 
Observable < Integer > source = Observable . just ( 0 ) ; Observable < Integer > m = source . groupBy ( identity , dbl ) . flatMap ( FLATTEN_INTEGER ) ; TestObserver < Object > to = new TestObserver < > ( ) ; m . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; System . out . println ( to . values ( ) ) ; 
Observable < Integer > source = Observable . just ( 0 ) ; final AtomicReference < GroupedObservable < Integer , Integer > > inner = new AtomicReference < > ( ) ; Observable < GroupedObservable < Integer , Integer > > m = source . groupBy ( identity , dbl ) ; m . subscribe ( new Consumer < GroupedObservable < Integer , Integer > > ( ) @ Override public void accept ( GroupedObservable < Integer , Integer > t1 ) inner . set ( t1 ) ; ) ; inner . get ( ) . subscribe ( ) ; Observer < Integer > o2 = TestHelper . mockObserver ( ) ; inner . get ( ) . subscribe ( o2 ) ; verify ( o2 , never ( ) ) . onComplete ( ) ; verify ( o2 , never ( ) ) . onNext ( anyInt ( ) ) ; verify ( o2 ) . onError ( any ( IllegalStateException . class ) ) ; 
Observable < Integer > source = Observable . concat ( Observable . just ( 0 ) , Observable . < Integer > error ( new TestException ( "Forced failure" ) ) ) ; Observable < Integer > m = source . groupBy ( identity , dbl ) . flatMap ( FLATTEN_INTEGER ) ; TestObserverEx < Object > to = new TestObserverEx < > ( ) ; m . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; assertEquals ( 1 , to . errors ( ) . size ( ) ) ; to . assertValueCount ( 1 ) ; 
TestObserver < String > to = new TestObserver < > ( ) ; Observable . range ( 1 , 4000 ) . groupBy ( IS_EVEN2 ) . flatMap ( new Function < GroupedObservable < Boolean , Integer > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Boolean , Integer > g ) return g . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "//////////////////// COMPLETED-A" ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , String > ( ) int c ; @ Override public String apply ( Integer l ) if ( g . getKey ( ) ) if ( c ++ < 400 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return l + " is even." ; else return l + " is odd." ; ) . doOnComplete ( new Action ( ) @ Override public void run ( ) System . out . println ( "//////////////////// COMPLETED-B" ) ; ) ; ) . doOnEach ( new Consumer < Notification < String > > ( ) @ Override public void accept ( Notification < String > t1 ) System . out . println ( "NEXT: " + t1 ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; 
TestObserver < String > to = new TestObserver < > ( ) ; Observable . range ( 1 , 4000 ) . groupBy ( IS_EVEN2 ) . flatMap ( new Function < GroupedObservable < Boolean , Integer > , Observable < String > > ( ) @ Override public Observable < String > apply ( final GroupedObservable < Boolean , Integer > g ) return g . take ( 2 ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer l ) if ( g . getKey ( ) ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return l + " is even." ; else return l + " is odd." ; ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; 
final String [ ] key = new String [ ] "uninitialized" ; final List < String > values = new ArrayList < > ( ) ; Observable . just ( "a" , "b" , "c" ) . groupBy ( new Function < String , String > ( ) @ Override public String apply ( String value ) return null ; ) . subscribe ( new Consumer < GroupedObservable < String , String > > ( ) @ Override public void accept ( GroupedObservable < String , String > groupedObservable ) key [ 0 ] = groupedObservable . getKey ( ) ; groupedObservable . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String s ) values . add ( s ) ; ) ; ) ; assertNull ( key [ 0 ] ) ; assertEquals ( Arrays . asList ( "a" , "b" , "c" ) , values ) ; 
final Disposable upstream = mock ( Disposable . class ) ; Observable < Integer > o = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( upstream ) ; ) ; TestObserver < Object > to = new TestObserver < > ( ) ; o . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer integer ) return null ; ) . subscribe ( to ) ; to . dispose ( ) ; verify ( upstream ) . dispose ( ) ; 
final Throwable e = new RuntimeException ( "Oops" ) ; final TestObserverEx < Integer > inner1 = new TestObserverEx < > ( ) ; final TestObserverEx < Integer > inner2 = new TestObserverEx < > ( ) ; final TestObserverEx < GroupedObservable < Integer , Integer > > outer = new TestObserverEx < > ( new DefaultObserver < GroupedObservable < Integer , Integer > > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( GroupedObservable < Integer , Integer > o ) if ( o . getKey ( ) == 0 ) o . subscribe ( inner1 ) ; else o . subscribe ( inner2 ) ; ) ; Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 0 ) ; observer . onNext ( 1 ) ; observer . onError ( e ) ; ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i % 2 ; ) . subscribe ( outer ) ; assertEquals ( Arrays . asList ( e ) , outer . errors ( ) ) ; assertEquals ( Arrays . asList ( e ) , inner1 . errors ( ) ) ; assertEquals ( Arrays . asList ( e ) , inner2 . errors ( ) ) ; 
Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . groupBy ( Functions . < Integer > identity ( ) , true ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( GroupedObservable < Integer , Integer > g ) throws Exception return g ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . groupBy ( Functions . < Integer > identity ( ) , Functions . < Integer > identity ( ) , true ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( GroupedObservable < Integer , Integer > g ) throws Exception return g ; ) . test ( ) . assertFailure ( TestException . class , 1 ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . groupBy ( Functions . justFunction ( 1 ) ) ) ; Observable . just ( 1 ) . groupBy ( Functions . justFunction ( 1 ) ) . doOnNext ( new Consumer < GroupedObservable < Integer , Integer > > ( ) @ Override public void accept ( GroupedObservable < Integer , Integer > g ) throws Exception TestHelper . checkDisposed ( g ) ; ) . test ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onComplete ( ) ; ; Observable . merge ( ps . groupBy ( Functions . justFunction ( 1 ) ) ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserverEx < Integer > to = new TestObserverEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onComplete ( ) ; dispose ( ) ; ; Observable . merge ( ps . groupBy ( Functions . justFunction ( 1 ) ) ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertSubscribed ( ) . assertValue ( 1 ) . assertNoErrors ( ) . assertNotComplete ( ) ; 
Observable . just ( 1 ) . groupBy ( Functions . justFunction ( 1 ) , true ) . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) final TestObserver < Integer > to = new TestObserver < > ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; ps . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Throwable return v % 10 ; ) . flatMap ( new Function < GroupedObservable < Integer , Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( GroupedObservable < Integer , Integer > v ) throws Throwable return v ; ) . subscribe ( to ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) ps . onNext ( j ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertFalse ( "Round " + i , ps . hasObservers ( ) ) ; 
final List < GroupedObservable < Integer , Integer > > groups = new ArrayList < > ( ) ; Observable . range ( 1 , 1000 ) . groupBy ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Throwable return v % 10 ; ) . doOnNext ( new Consumer < GroupedObservable < Integer , Integer > > ( ) @ Override public void accept ( GroupedObservable < Integer , Integer > v ) throws Throwable groups . add ( v ) ; ) . test ( ) . assertValueCount ( 1000 ) . assertComplete ( ) . assertNoErrors ( ) ; Observable . concat ( groups ) . test ( ) . assertValueCount ( 1000 ) . assertNoErrors ( ) . assertComplete ( ) ; 
TestObserver < Object > to1 = new TestObserver < > ( ) ; final TestObserver < Object > to2 = new TestObserver < > ( ) ; Observable . just ( 1 ) . groupBy ( Functions . < Integer > identity ( ) , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Throwable throw new TestException ( ) ; ) . doOnNext ( new Consumer < GroupedObservable < Integer , Object > > ( ) @ Override public void accept ( GroupedObservable < Integer , Object > g ) throws Throwable g . subscribe ( to2 ) ; ) . subscribe ( to1 ) ; to1 . assertValueCount ( 1 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; to2 . assertFailure ( TestException . class ) ; 
TestObserver < Object > to1 = new TestObserver < > ( ) ; final TestObserver < Object > to2 = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . groupBy ( Functions . justFunction ( 1 ) , new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Throwable if ( v == 2 ) throw new TestException ( ) ; return v ; ) . doOnNext ( new Consumer < GroupedObservable < Integer , Object > > ( ) @ Override public void accept ( GroupedObservable < Integer , Object > g ) throws Throwable g . subscribe ( to2 ) ; ) . subscribe ( to1 ) ; to1 . assertValueCount ( 1 ) . assertError ( TestException . class ) . assertNotComplete ( ) ; to2 . assertFailure ( TestException . class , 1 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . groupBy ( v -> v ) ) ; 
Observable . just ( 1 ) . groupBy ( v -> null ) . flatMap ( v -> v . take ( 1 ) ) . test ( ) . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) BehaviorSubject < Integer > bs = BehaviorSubject . createDefault ( 1 ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; bs . groupBy ( v -> 1 ) . doOnNext ( g -> TestHelper . raceOther ( ( ) -> g . test ( ) ; , cdl ) ; ) . test ( ) ; cdl . await ( ) ; 
AtomicReference < Observable < Integer > > ref = new AtomicReference < > ( ) ; Observable . just ( 1 ) . groupBy ( v -> 1 ) . doOnNext ( ref :: set ) . test ( ) ; ref . get ( ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . groupBy ( v -> 1 , true ) . flatMap ( g -> g . doOnNext ( v -> if ( v == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; ) ) . test ( ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 , 2 ) ; 
final AtomicReference < Throwable > receivedException = new AtomicReference < > ( ) ; Observable < String > w = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onError ( new Throwable ( "injected failure" ) ) ; observer . onNext ( "two" ) ; observer . onNext ( "three" ) ; ) ; Function < Throwable , Observable < String > > resume = new Function < Throwable , Observable < String > > ( ) @ Override public Observable < String > apply ( Throwable t1 ) receivedException . set ( t1 ) ; return Observable . just ( "twoResume" , "threeResume" ) ; ; Observable < String > observable = w . onErrorResumeNext ( resume ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( observer , times ( 1 ) ) . onNext ( "threeResume" ) ; assertNotNull ( receivedException . get ( ) ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onError ( new Throwable ( "injected failure" ) ) ; observer . onNext ( "two" ) ; observer . onNext ( "three" ) ; 
final AtomicReference < Throwable > receivedException = new AtomicReference < > ( ) ; Subscription s = mock ( Subscription . class ) ; TestObservable w = new TestObservable ( s , "one" ) ; Function < Throwable , Observable < String > > resume = new Function < Throwable , Observable < String > > ( ) @ Override public Observable < String > apply ( Throwable t1 ) receivedException . set ( t1 ) ; return Observable . just ( "twoResume" , "threeResume" ) ; ; Observable < String > o = Observable . unsafeCreate ( w ) . onErrorResumeNext ( resume ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; try w . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( observer , times ( 1 ) ) . onNext ( "threeResume" ) ; assertNotNull ( receivedException . get ( ) ) ; 
Subscription s = mock ( Subscription . class ) ; TestObservable w = new TestObservable ( s , "one" ) ; Function < Throwable , Observable < String > > resume = new Function < Throwable , Observable < String > > ( ) @ Override public Observable < String > apply ( Throwable t1 ) throw new RuntimeException ( "exception from function" ) ; ; Observable < String > o = Observable . unsafeCreate ( w ) . onErrorResumeNext ( resume ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; try w . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 0 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; w = w . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; System . out . println ( "BadMapper:" + s ) ; return s ; ) ; Observable < String > o = w . onErrorResumeNext ( new Function < Throwable , Observable < String > > ( ) @ Override public Observable < String > apply ( Throwable t1 ) return Observable . just ( "twoResume" , "threeResume" ) . subscribeOn ( Schedulers . computation ( ) ) ; ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; o . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( observer , times ( 1 ) ) . onNext ( "threeResume" ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 0 , 100000 ) . onErrorResumeNext ( new Function < Throwable , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Throwable t1 ) return Observable . just ( 1 ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t1 ) if ( c ++ <= 1 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > o ) throws Exception return Observable . error ( new IOException ( ) ) . onErrorResumeNext ( Functions . justFunction ( o ) ) ; , false , 1 , 1 , 1 ) ; 
final AtomicLong counter = new AtomicLong ( ) ; final Integer [ ] numbers = new Integer [ 5000 ] ; for ( int i = 0 ; i < numbers . length ; i ++ ) numbers [ i ] = i + 1 ; final int NITERS = 250 ; final CountDownLatch latch = new CountDownLatch ( NITERS ) ; for ( int iters = 0 ; iters < NITERS ; iters ++ ) final CountDownLatch innerLatch = new CountDownLatch ( 1 ) ; final PublishSubject < Void > s = PublishSubject . create ( ) ; final AtomicBoolean completed = new AtomicBoolean ( ) ; Observable . fromArray ( numbers ) . takeUntil ( s ) . window ( 50 ) . flatMap ( new Function < Observable < Integer > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Integer > integerObservable ) return integerObservable . subscribeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer integer ) if ( integer >= 5 && completed . compareAndSet ( false , true ) ) s . onComplete ( ) ; Math . pow ( Math . random ( ) , Math . random ( ) ) ; return integer * 2 ; ) ; ) . toList ( ) . doOnSuccess ( new Consumer < List < Object > > ( ) @ Override public void accept ( List < Object > integers ) counter . incrementAndGet ( ) ; latch . countDown ( ) ; innerLatch . countDown ( ) ; ) . subscribe ( ) ; if ( ! innerLatch . await ( 30 , TimeUnit . SECONDS ) ) Assert . fail ( "Failed inner latch wait, iteration " + iters ) ; if ( ! latch . await ( 30 , TimeUnit . SECONDS ) ) Assert . fail ( "Incomplete! Went through " + latch . getCount ( ) + " iterations" ) ; else Assert . assertEquals ( NITERS , counter . get ( ) ) ; 
final List < Object > list = new ArrayList < > ( ) ; Observable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) . forEachWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v < 3 ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 ) , list ) ; 
final List < Object > list = new ArrayList < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception list . add ( v ) ; ) . forEachWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return true ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( 100 ) ; ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 100 ) , list ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > f ) throws Exception return f . forEachWhile ( Functions . alwaysTrue ( ) ) ; , false , 1 , 1 , ( Object [ ] ) null ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Disposable d = ps . forEachWhile ( Functions . alwaysTrue ( ) ) ; assertFalse ( d . isDisposed ( ) ) ; d . dispose ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . just ( 1 ) . forEachWhile ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) ; TestHelper . assertError ( errors , 0 , OnErrorNotImplementedException . class ) ; Throwable c = errors . get ( 0 ) . getCause ( ) ; assertTrue ( "" + c , c instanceof TestException ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . < Integer > error ( new TestException ( "Outer" ) ) . forEachWhile ( Functions . alwaysTrue ( ) , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable v ) throws Exception throw new TestException ( "Inner" ) ; ) ; TestHelper . assertError ( errors , 0 , CompositeException . class ) ; List < Throwable > ce = TestHelper . compositeList ( errors . get ( 0 ) ) ; TestHelper . assertError ( ce , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( ce , 1 , TestException . class , "Inner" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . just ( 1 ) . forEachWhile ( Functions . alwaysTrue ( ) , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observer < Integer > observer = TestHelper . mockObserver ( ) ; Observable . just ( 1 , 2 , 3 ) . observeOn ( ImmediateThinScheduler . INSTANCE ) . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onNext ( 3 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > obs = Observable . just ( "one" , "null" , "two" , "three" , "four" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer ) ; TestObserverEx < String > to = new TestObserverEx < > ( observer ) ; obs . observeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 1000 , TimeUnit . MILLISECONDS ) ; if ( to . errors ( ) . size ( ) > 0 ) for ( Throwable t : to . errors ( ) ) t . printStackTrace ( ) ; fail ( "failed with exception" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "null" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "four" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
System . out . println ( "Main Thread: " + Thread . currentThread ( ) . getName ( ) ) ; Observable < String > obs = Observable . just ( "one" , "null" , "two" , "three" , "four" ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; final String parentThreadName = Thread . currentThread ( ) . getName ( ) ; final CountDownLatch completedLatch = new CountDownLatch ( 1 ) ; obs = obs . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String s ) String threadName = Thread . currentThread ( ) . getName ( ) ; System . out . println ( "Source ThreadName: " + threadName + "  Expected => " + parentThreadName ) ; assertEquals ( parentThreadName , threadName ) ; ) ; obs . observeOn ( Schedulers . newThread ( ) ) . doOnNext ( new Consumer < String > ( ) @ Override public void accept ( String t1 ) String threadName = Thread . currentThread ( ) . getName ( ) ; boolean correctThreadName = threadName . startsWith ( "RxNewThreadScheduler" ) ; System . out . println ( "ObserveOn ThreadName: " + threadName + "  Correct => " + correctThreadName ) ; assertTrue ( correctThreadName ) ; ) . doAfterTerminate ( new Action ( ) @ Override public void run ( ) completedLatch . countDown ( ) ; ) . subscribe ( observer ) ; if ( ! completedLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "timed out waiting" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 5 ) ) . onNext ( any ( String . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Scheduler scheduler = ImmediateThinScheduler . INSTANCE ; Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) ; Observable < Integer > o2 = o . observeOn ( scheduler ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; Observer < Object > observer2 = TestHelper . mockObserver ( ) ; InOrder inOrder1 = inOrder ( observer1 ) ; InOrder inOrder2 = inOrder ( observer2 ) ; o2 . subscribe ( observer1 ) ; o2 . subscribe ( observer2 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder1 . verifyNoMoreInteractions ( ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 1 ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 3 ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; verify ( observer2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder2 . verifyNoMoreInteractions ( ) ; 
TestScheduler scheduler1 = new TestScheduler ( ) ; TestScheduler scheduler2 = new TestScheduler ( ) ; Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) ; Observable < Integer > o1 = o . observeOn ( scheduler1 ) ; Observable < Integer > o2 = o . observeOn ( scheduler2 ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; Observer < Object > observer2 = TestHelper . mockObserver ( ) ; InOrder inOrder1 = inOrder ( observer1 ) ; InOrder inOrder2 = inOrder ( observer2 ) ; o1 . subscribe ( observer1 ) ; o2 . subscribe ( observer2 ) ; scheduler1 . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; scheduler2 . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder1 . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder1 . verifyNoMoreInteractions ( ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 1 ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 3 ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; verify ( observer2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder2 . verifyNoMoreInteractions ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final int _multiple = 99 ; Observable . range ( 1 , 100000 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * _multiple ; ) . observeOn ( Schedulers . newThread ( ) ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) assertEquals ( count . incrementAndGet ( ) * _multiple , t1 . intValue ( ) ) ; String name = Thread . currentThread ( ) . getName ( ) ; assertFalse ( "Wrong thread name: " + name , name . startsWith ( "Rx" ) ) ; ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final int _multiple = 99 ; Observable . range ( 1 , 100000 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * _multiple ; ) . observeOn ( Schedulers . computation ( ) ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) assertEquals ( count . incrementAndGet ( ) * _multiple , t1 . intValue ( ) ) ; String name = Thread . currentThread ( ) . getName ( ) ; assertFalse ( "Wrong thread name: " + name , name . startsWith ( "Rx" ) ) ; ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; final int _multiple = 99 ; Observable . range ( 1 , 10000 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) if ( randomIntFrom0to100 ( ) > 98 ) try Thread . sleep ( 2 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 * _multiple ; ) . observeOn ( Schedulers . computation ( ) ) . blockingForEach ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) assertEquals ( count . incrementAndGet ( ) * _multiple , t1 . intValue ( ) ) ; String name = Thread . currentThread ( ) . getName ( ) ; assertFalse ( "Wrong thread name: " + name , name . startsWith ( "Rx" ) ) ; ) ; 
final CountDownLatch completedLatch = new CountDownLatch ( 1 ) ; final CountDownLatch nextLatch = new CountDownLatch ( 1 ) ; final AtomicLong completeTime = new AtomicLong ( ) ; Observable . range ( 1 , 2 ) . subscribeOn ( Schedulers . newThread ( ) ) . observeOn ( Schedulers . newThread ( ) ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onComplete ( ) System . out . println ( "onComplete" ) ; completeTime . set ( System . nanoTime ( ) ) ; completedLatch . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) try if ( ! nextLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ) throw new RuntimeException ( "it shouldn't have timed out" ) ; catch ( InterruptedException e ) throw new RuntimeException ( "it shouldn't have failed" ) ; ) ; long afterSubscribeTime = System . nanoTime ( ) ; System . out . println ( "After subscribe: " + completedLatch . getCount ( ) ) ; assertEquals ( 1 , completedLatch . getCount ( ) ) ; nextLatch . countDown ( ) ; completedLatch . await ( 1000 , TimeUnit . MILLISECONDS ) ; assertTrue ( completeTime . get ( ) > afterSubscribeTime ) ; System . out . println ( "onComplete nanos after subscribe: " + ( completeTime . get ( ) - afterSubscribeTime ) ) ; 
System . out . println ( "onComplete" ) ; completeTime . set ( System . nanoTime ( ) ) ; completedLatch . countDown ( ) ; 
long x = System . nanoTime ( ) ; x ^= ( x << 21 ) ; x ^= ( x > > > 35 ) ; x ^= ( x << 4 ) ; return Math . abs ( ( int ) x % 100 ) ; 
TestScheduler testScheduler = new TestScheduler ( ) ; Observable < Integer > source = Observable . concat ( Observable . < Integer > error ( new TestException ( ) ) , Observable . just ( 1 ) ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . observeOn ( testScheduler ) . subscribe ( o ) ; inOrder . verify ( o , never ( ) ) . onError ( any ( TestException . class ) ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verify ( o , never ( ) ) . onNext ( anyInt ( ) ) ; inOrder . verify ( o , never ( ) ) . onComplete ( ) ; 
final TestScheduler testScheduler = new TestScheduler ( ) ; final Observer < Integer > observer = TestHelper . mockObserver ( ) ; TestObserver < Integer > to = new TestObserver < > ( observer ) ; Observable . just ( 1 , 2 , 3 ) . observeOn ( testScheduler ) . subscribe ( to ) ; to . dispose ( ) ; testScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; final InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyInt ( ) ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Exception . class ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; 
final AtomicInteger generated = new AtomicInteger ( ) ; Observable < Integer > o = Observable . fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public void remove ( ) @ Override public Integer next ( ) return generated . getAndIncrement ( ) ; @ Override public boolean hasNext ( ) return true ; ; ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; o . take ( 7 ) . observeOn ( Schedulers . newThread ( ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertValues ( 0 , 1 , 2 , 3 , 4 , 5 , 6 ) ; assertEquals ( 7 , generated . get ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 0 , 100000 ) . observeOn ( Schedulers . newThread ( ) ) . observeOn ( Schedulers . newThread ( ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; 
Observable . range ( 1 , 5 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . observeOn ( Schedulers . computation ( ) , true ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( v == 1 ) Thread . sleep ( 100 ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Observable . just ( 1 ) . observeOn ( Schedulers . trampoline ( ) ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . observeOn ( new TestScheduler ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . observeOn ( new TestScheduler ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try TestScheduler scheduler = new TestScheduler ( ) ; TestObserver < Integer > to = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . observeOn ( scheduler ) . test ( ) ; scheduler . triggerActions ( ) ; to . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . range ( 1 , 5 ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . observeOn ( Schedulers . single ( ) ) . test ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . observeOn ( Schedulers . single ( ) ) . test ( ) ; us . onError ( new TestException ( ) ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . observeOn ( Schedulers . single ( ) , true ) . test ( ) ; us . onError ( new TestException ( ) ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Observable . range ( 1 , 5 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Observable . range ( 1 , 5 ) . hide ( ) . observeOn ( Schedulers . single ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . observeOn ( Schedulers . single ( ) ) . subscribe ( to ) ; us . onError ( new TestException ( ) ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . observeOn ( Schedulers . single ( ) , true ) . subscribe ( to ) ; us . onError ( new TestException ( ) ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
final UnicastSubject < Integer > us = UnicastSubject . create ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; us . observeOn ( Schedulers . single ( ) ) . subscribe ( new Observer < Integer > ( ) Disposable upstream ; int count ; @ Override public void onSubscribe ( Disposable d ) this . upstream = d ; ( ( QueueDisposable < ? > ) d ) . requestFusion ( QueueFuseable . ANY ) ; @ Override public void onNext ( Integer value ) if ( ++ count == 1 ) us . onNext ( 2 ) ; upstream . dispose ( ) ; cdl . countDown ( ) ; @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) ) ; us . onNext ( 1 ) ; cdl . await ( ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; @ SuppressWarnings ( "unchecked" ) ObserveOnObserver < Integer > oo = ( ObserveOnObserver < Integer > ) observer ; oo . queue = new SimpleQueue < Integer > ( ) @ Override public boolean offer ( Integer value ) return false ; @ Override public boolean offer ( Integer v1 , Integer v2 ) return false ; @ Nullable @ Override public Integer poll ( ) throws Exception throw new TestException ( ) ; @ Override public boolean isEmpty ( ) return false ; @ Override public void clear ( ) ; oo . clear ( ) ; oo . schedule ( ) ; . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
final BehaviorSubject < Integer > bs = BehaviorSubject . createDefault ( 1 ) ; bs . observeOn ( ImmediateThinScheduler . INSTANCE ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . just ( v + 1 ) ; ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 2 ) bs . onNext ( 2 ) ; ) . assertValuesOnly ( 2 , 3 ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; Observable . concat ( Observable . just ( 1 ) . hide ( ) . observeOn ( s ) , Observable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; Observable . concat ( Observable . just ( 1 ) . observeOn ( s ) , Observable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . onNext ( 1 ) ; us . onComplete ( ) ; Observable . concat ( us . observeOn ( s ) , Observable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
DisposeTrackingScheduler s = new DisposeTrackingScheduler ( ) ; TestObserverEx < Integer > to = new TestObserverFusedCanceling ( ) ; Observable . just ( 1 ) . hide ( ) . observeOn ( s ) . subscribe ( to ) ; assertEquals ( 1 , s . disposedCount . get ( ) ) ; 
for ( int j = 0 ; j < TestHelper . RACE_LONG_LOOPS ; j ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestObserver < Integer > to = us . hide ( ) . observeOn ( Schedulers . io ( ) ) . observeOn ( Schedulers . single ( ) ) . unsubscribeOn ( Schedulers . computation ( ) ) . firstOrError ( ) . test ( ) ; for ( int i = 0 ; us . hasObservers ( ) && i < 10000 ; i ++ ) us . onNext ( i ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; if ( ! errors . isEmpty ( ) ) throw new CompositeException ( errors ) ; to . assertResult ( 0 ) ; finally RxJavaPlugins . reset ( ) ; 
observer = TestHelper . mockObserver ( ) ; scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
Observable < String > source = Observable . empty ( ) ; Observable < List < String > > buffered = source . buffer ( 3 , 3 ) ; buffered . subscribe ( observer ) ; Mockito . verify ( observer , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; Mockito . verify ( observer , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; Mockito . verify ( observer , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onNext ( "two" ) ; observer . onNext ( "three" ) ; observer . onNext ( "four" ) ; observer . onNext ( "five" ) ; ) ; Observable < List < String > > buffered = source . buffer ( 3 , 1 ) ; buffered . subscribe ( observer ) ; InOrder inOrder = Mockito . inOrder ( observer ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" , "three" ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "two" , "three" , "four" ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "three" , "four" , "five" ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "one" , "two" , "three" , "four" , "five" ) ; Observable < List < String > > buffered = source . buffer ( 3 , 3 ) ; buffered . subscribe ( observer ) ; InOrder inOrder = Mockito . inOrder ( observer ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" , "three" ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "four" , "five" ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . just ( "one" , "two" , "three" , "four" , "five" ) ; Observable < List < String > > buffered = source . buffer ( 2 , 3 ) ; buffered . subscribe ( observer ) ; InOrder inOrder = Mockito . inOrder ( observer ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "four" , "five" ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; push ( observer , "one" , 10 ) ; push ( observer , "two" , 90 ) ; push ( observer , "three" , 110 ) ; push ( observer , "four" , 190 ) ; push ( observer , "five" , 210 ) ; complete ( observer , 250 ) ; ) ; Observable < List < String > > buffered = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler , 2 ) ; buffered . subscribe ( observer ) ; InOrder inOrder = Mockito . inOrder ( observer ) ; scheduler . advanceTimeTo ( 100 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" ) ) ; scheduler . advanceTimeTo ( 200 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "three" , "four" ) ) ; scheduler . advanceTimeTo ( 300 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "five" ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; push ( observer , "one" , 97 ) ; push ( observer , "two" , 98 ) ; push ( observer , "three" , 99 ) ; push ( observer , "four" , 101 ) ; push ( observer , "five" , 102 ) ; complete ( observer , 150 ) ; ) ; Observable < List < String > > buffered = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; buffered . subscribe ( observer ) ; InOrder inOrder = Mockito . inOrder ( observer ) ; scheduler . advanceTimeTo ( 101 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "one" , "two" , "three" ) ) ; scheduler . advanceTimeTo ( 201 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "four" , "five" ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onComplete ( ) ; 
Observable < String > source = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; push ( observer , "one" , 10 ) ; push ( observer , "two" , 60 ) ; push ( observer , "three" , 110 ) ; push ( observer , "four" , 160 ) ; push ( observer , "five" , 210 ) ; complete ( observer , 500 ) ; ) ; Observable < Object > openings = Observable . unsafeCreate ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; push ( observer , new Object ( ) , 50 ) ; push ( observer , new Object ( ) , 200 ) ; complete ( observer , 250 ) ; ) ; Function < Object , Observable < Object > > closer = new Function < Object , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Object opening ) return Observable . unsafeCreate ( new ObservableSource < Object > ( ) @ Override public void subscribe ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; push ( observer , new Object ( ) , 100 ) ; complete ( observer , 101 ) ; ) ; ; Observable < List < String > > buffered = source . buffer ( openings , closer ) ; buffered . subscribe ( observer ) ; InOrder inOrder = Mockito . inOrder ( observer ) ; scheduler . advanceTimeTo ( 500 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "two" , "three" ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onNext ( list ( "five" ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onNext ( Mockito . < String > anyList ( ) ) ; inOrder . verify ( observer , Mockito . never ( ) ) . onError ( Mockito . any ( Throwable . class ) ) ; inOrder . verify ( observer , Mockito . times ( 1 ) ) . onComplete ( ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; LongTimeAction action = new LongTimeAction ( latch ) ; Observable . just ( 1 ) . buffer ( 10 , TimeUnit . MILLISECONDS , 10 ) . subscribe ( action ) ; latch . await ( ) ; assertFalse ( action . fail ) ; 
try if ( fail ) return ; Thread . sleep ( 200 ) ; catch ( InterruptedException e ) fail = true ; finally latch . countDown ( ) ; 
Observable < Integer > source = Observable . never ( ) ; Observer < List < Integer > > o = TestHelper . mockObserver ( ) ; TestObserver < List < Integer > > to = new TestObserver < > ( o ) ; source . buffer ( 100 , 200 , TimeUnit . MILLISECONDS , scheduler ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > pv ) System . out . println ( pv ) ; ) . subscribe ( to ) ; InOrder inOrder = Mockito . inOrder ( o ) ; scheduler . advanceTimeBy ( 1001 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( o , times ( 5 ) ) . onNext ( Arrays . < Integer > asList ( ) ) ; to . dispose ( ) ; scheduler . advanceTimeBy ( 999 , TimeUnit . MILLISECONDS ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = Mockito . inOrder ( o ) ; source . buffer ( boundary ) . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; boundary . onNext ( 1 ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( Arrays . asList ( 1 , 2 , 3 ) ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; boundary . onNext ( 2 ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( Arrays . asList ( 4 , 5 ) ) ; source . onNext ( 6 ) ; boundary . onComplete ( ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( Arrays . asList ( 6 ) ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = Mockito . inOrder ( o ) ; source . buffer ( boundary ) . subscribe ( o ) ; boundary . onComplete ( ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( Arrays . asList ( ) ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = Mockito . inOrder ( o ) ; source . buffer ( boundary ) . subscribe ( o ) ; source . onComplete ( ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( Arrays . asList ( ) ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = Mockito . inOrder ( o ) ; source . buffer ( boundary ) . subscribe ( o ) ; source . onComplete ( ) ; boundary . onComplete ( ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( Arrays . asList ( ) ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . buffer ( boundary ) . subscribe ( o ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > boundary = PublishSubject . create ( ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . buffer ( boundary ) . subscribe ( o ) ; source . onNext ( 1 ) ; boundary . onError ( new TestException ( ) ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) . repeat ( ) ; Observable < List < Integer > > result = source . buffer ( 2 ) . take ( 1 ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 1 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) . repeat ( ) ; Observable < List < Integer > > result = source . buffer ( 2 , 3 ) . take ( 1 ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( Arrays . asList ( 1 , 1 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Long > source = Observable . interval ( 40 , 40 , TimeUnit . MILLISECONDS , scheduler ) ; Observable < List < Long > > result = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler ) . take ( 1 ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; verify ( o ) . onNext ( Arrays . asList ( 0L , 1L ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Long > source = Observable . interval ( 40 , 40 , TimeUnit . MILLISECONDS , scheduler ) ; Observable < List < Long > > result = source . buffer ( 100 , 60 , TimeUnit . MILLISECONDS , scheduler ) . take ( 2 ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 0L , 1L ) ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 1L , 2L ) ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Long > boundary = Observable . interval ( 60 , 60 , TimeUnit . MILLISECONDS , scheduler ) ; Observable < Long > source = Observable . interval ( 40 , 40 , TimeUnit . MILLISECONDS , scheduler ) ; Observable < List < Long > > result = source . buffer ( boundary ) . take ( 2 ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 0L ) ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 1L ) ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Long > start = Observable . interval ( 61 , 61 , TimeUnit . MILLISECONDS , scheduler ) ; Function < Long , Observable < Long > > end = new Function < Long , Observable < Long > > ( ) @ Override public Observable < Long > apply ( Long t1 ) return Observable . interval ( 100 , 100 , TimeUnit . MILLISECONDS , scheduler ) ; ; Observable < Long > source = Observable . interval ( 40 , 40 , TimeUnit . MILLISECONDS , scheduler ) ; Observable < List < Long > > result = source . buffer ( start , end ) . take ( 2 ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . doOnNext ( new Consumer < List < Long > > ( ) @ Override public void accept ( List < Long > pv ) System . out . println ( pv ) ; ) . subscribe ( o ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 1L , 2L , 3L ) ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 3L , 4L ) ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < List < Integer > > result = source . buffer ( 2 ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 1 , 2 ) ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( Arrays . asList ( 3 ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < List < Integer > > result = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 1 , 2 ) ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( Arrays . asList ( 3 ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observable < Long > source = Observable . interval ( 30 , 30 , TimeUnit . MILLISECONDS , scheduler ) ; Observable < List < Long > > result = source . buffer ( 100 , TimeUnit . MILLISECONDS , scheduler , 2 ) . take ( 3 ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; scheduler . advanceTimeBy ( 5 , TimeUnit . SECONDS ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 0L , 1L ) ) ; inOrder . verify ( o ) . onNext ( Arrays . asList ( 2L ) ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > start = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > end = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return Observable . never ( ) ; ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < List < Integer > > result = source . buffer ( start , end ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; start . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; start . onError ( new TestException ( ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
PublishSubject < Integer > start = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > end = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < List < Integer > > result = source . buffer ( start , end ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; start . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
PublishSubject < Integer > start = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > end = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return Observable . error ( new TestException ( ) ) ; ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < List < Integer > > result = source . buffer ( start , end ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; start . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
final Observer < Object > o = TestHelper . mockObserver ( ) ; final CountDownLatch cdl = new CountDownLatch ( 1 ) ; DisposableObserver < Object > observer = new DisposableObserver < Object > ( ) @ Override public void onNext ( Object t ) o . onNext ( t ) ; @ Override public void onError ( Throwable e ) o . onError ( e ) ; cdl . countDown ( ) ; @ Override public void onComplete ( ) o . onComplete ( ) ; cdl . countDown ( ) ; ; Observable . range ( 1 , 1 ) . delay ( 1 , TimeUnit . SECONDS ) . buffer ( 2 , TimeUnit . SECONDS ) . subscribe ( observer ) ; cdl . await ( ) ; verify ( o ) . onNext ( Arrays . asList ( 1 ) ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; assertFalse ( observer . isDisposed ( ) ) ; 
Observable . range ( 1 , 5 ) . buffer ( 1 , 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Observable . range ( 1 , 5 ) . buffer ( Observable . timer ( 1 , TimeUnit . MINUTES ) , 2 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Observable . just ( 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 ) . buffer ( 3 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception return new HashSet < > ( ) ; ) . test ( ) . assertResult ( set ( 1 , 2 ) , set ( 2 , 3 ) , set ( 4 ) ) ; 
Observable . just ( 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 ) . buffer ( 3 , 3 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception return new HashSet < > ( ) ; ) . test ( ) . assertResult ( set ( 1 , 2 ) , set ( 2 , 3 ) , set ( 4 ) ) ; 
Observable . just ( 1 ) . buffer ( 1 , TimeUnit . SECONDS , Schedulers . single ( ) , Integer . MAX_VALUE , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; , false ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . buffer ( 1 , TimeUnit . SECONDS , Schedulers . single ( ) , 10 , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; , false ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . buffer ( 2 , 1 , TimeUnit . SECONDS , Schedulers . single ( ) , new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , Integer . MAX_VALUE , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) throw new TestException ( ) ; else return new ArrayList < > ( ) ; , false ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , 10 , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) throw new TestException ( ) ; else return new ArrayList < > ( ) ; , false ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > never ( ) . buffer ( 2 , 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) throw new TestException ( ) ; else return new ArrayList < > ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , Integer . MAX_VALUE , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) return null ; else return new ArrayList < > ( ) ; , false ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( NullPointerException . class ) ; 
Observable . < Integer > never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , 10 , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) return null ; else return new ArrayList < > ( ) ; , false ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( NullPointerException . class ) ; 
Observable . < Integer > never ( ) . buffer ( 2 , 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) , new Supplier < Collection < Integer > > ( ) int count ; @ Override public Collection < Integer > get ( ) throws Exception if ( count ++ == 1 ) return null ; else return new ArrayList < > ( ) ; ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( NullPointerException . class ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . buffer ( 1 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . buffer ( 2 , 1 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . buffer ( 1 , 2 , TimeUnit . DAYS , Schedulers . single ( ) ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . buffer ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , Functions . < Integer > createArrayList ( 16 ) , true ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . buffer ( 1 ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . buffer ( 2 , 1 ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . buffer ( 1 , 2 ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . buffer ( Observable . never ( ) ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . buffer ( Observable . never ( ) , Functions . justFunction ( Observable . never ( ) ) ) ) ; 
Observable . range ( 1 , 5 ) . buffer ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , 2 , Functions . < Integer > createArrayList ( 16 ) , true ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 ) , Arrays . asList ( 3 , 4 ) , Arrays . asList ( 5 ) ) ; 
Observable . range ( 1 , 2 ) . buffer ( 1 , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; ) . test ( ) . assertFailure ( TestException . class , Arrays . asList ( 1 ) ) ; 
Observable . range ( 1 , 2 ) . buffer ( 2 , 1 , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > error ( new TestException ( ) ) . buffer ( 2 , 1 ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 5 ) . buffer ( 5 , 1 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , Arrays . asList ( 2 , 3 , 4 , 5 ) , Arrays . asList ( 3 , 4 , 5 ) , Arrays . asList ( 4 , 5 ) , Arrays . asList ( 5 ) ) ; 
Observable . error ( new TestException ( ) ) . buffer ( 1 , TimeUnit . DAYS ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . buffer ( 1 , 2 , TimeUnit . DAYS ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . buffer ( 2 , 1 , TimeUnit . DAYS ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . empty ( ) . buffer ( 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Observable . empty ( ) . buffer ( 1 , 2 , TimeUnit . DAYS ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
Observable . empty ( ) . buffer ( 2 , 1 , TimeUnit . DAYS ) . test ( ) . assertResult ( Collections . emptyList ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = ps . buffer ( 1 , TimeUnit . MILLISECONDS , scheduler , 1 , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; , true ) . test ( ) ; ps . onNext ( 1 ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; ps . onNext ( 2 ) ; to . assertFailure ( TestException . class , Arrays . asList ( 1 ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = ps . buffer ( 1 , TimeUnit . MILLISECONDS , scheduler , 1 , Functions . < Integer > createArrayList ( 16 ) , true ) . test ( ) ; ps . onError ( new TestException ( ) ) ; to . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestScheduler scheduler = new TestScheduler ( ) ; final PublishSubject < Object > ps = PublishSubject . create ( ) ; TestObserver < List < Object > > to = ps . buffer ( 1 , TimeUnit . SECONDS , scheduler , 5 ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; ps . onNext ( 3 ) ; ps . onNext ( 4 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 5 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; ps . onComplete ( ) ; int items = 0 ; for ( List < Object > o : to . values ( ) ) items += o . size ( ) ; assertEquals ( "Round: " + i , 5 , items ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable . < Integer > empty ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) . buffer ( 5 , TimeUnit . SECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( Collections . < Integer > emptyList ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable . < Integer > empty ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) . buffer ( 5 , 10 , TimeUnit . SECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( Collections . < Integer > emptyList ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable . < Integer > empty ( ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) . buffer ( 10 , 5 , TimeUnit . SECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( Collections . < Integer > emptyList ( ) ) ; assertEquals ( 0 , counter . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > openIndicator = PublishSubject . create ( ) ; PublishSubject < Integer > closeIndicator = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . test ( ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( openIndicator . hasObservers ( ) ) ; assertFalse ( closeIndicator . hasObservers ( ) ) ; openIndicator . onNext ( 1 ) ; assertTrue ( openIndicator . hasObservers ( ) ) ; assertTrue ( closeIndicator . hasObservers ( ) ) ; source . onComplete ( ) ; to . assertResult ( Collections . < Integer > emptyList ( ) ) ; assertFalse ( openIndicator . hasObservers ( ) ) ; assertFalse ( closeIndicator . hasObservers ( ) ) ; 
Observable . range ( 1 , 50 ) . zipWith ( Observable . interval ( 5 , TimeUnit . MILLISECONDS ) , new BiFunction < Integer , Long , Integer > ( ) @ Override public Integer apply ( Integer integer , Long aLong ) return integer ; ) . buffer ( Observable . interval ( 0 , 200 , TimeUnit . MILLISECONDS ) , new Function < Long , Observable < ? > > ( ) @ Override public Observable < ? > apply ( Long a ) return Observable . just ( a ) . delay ( 100 , TimeUnit . MILLISECONDS ) ; ) . to ( TestHelper . < List < Integer > > testConsumer ( ) ) . assertSubscribed ( ) . awaitDone ( 3 , TimeUnit . SECONDS ) . assertComplete ( ) ; 
Observable . range ( 1 , 50 ) . zipWith ( Observable . interval ( 5 , TimeUnit . MILLISECONDS ) , new BiFunction < Integer , Long , Integer > ( ) @ Override public Integer apply ( Integer integer , Long aLong ) return integer ; ) . buffer ( Observable . interval ( 0 , 100 , TimeUnit . MILLISECONDS ) , new Function < Long , Observable < ? > > ( ) @ Override public Observable < ? > apply ( Long a ) return Observable . just ( a ) . delay ( 200 , TimeUnit . MILLISECONDS ) ; ) . to ( TestHelper . < List < Integer > > testConsumer ( ) ) . assertSubscribed ( ) . awaitDone ( 3 , TimeUnit . SECONDS ) . assertComplete ( ) ; 
Observable . error ( new TestException ( ) ) . buffer ( Observable . never ( ) , Functions . justFunction ( Observable . never ( ) ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) Disposable bs1 = Disposable . empty ( ) ; Disposable bs2 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertFalse ( bs2 . isDisposed ( ) ) ; observer . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertTrue ( bs2 . isDisposed ( ) ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; . buffer ( Observable . never ( ) , Functions . justFunction ( Observable . never ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > openIndicator = PublishSubject . create ( ) ; PublishSubject < Integer > closeIndicator = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . test ( ) ; openIndicator . onNext ( 1 ) ; assertTrue ( closeIndicator . hasObservers ( ) ) ; openIndicator . onComplete ( ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( closeIndicator . hasObservers ( ) ) ; closeIndicator . onComplete ( ) ; assertFalse ( source . hasObservers ( ) ) ; to . assertResult ( Collections . < Integer > emptyList ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > openIndicator = PublishSubject . create ( ) ; PublishSubject < Integer > closeIndicator = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . test ( ) ; openIndicator . onNext ( 1 ) ; assertTrue ( closeIndicator . hasObservers ( ) ) ; closeIndicator . onComplete ( ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( openIndicator . hasObservers ( ) ) ; openIndicator . onComplete ( ) ; assertFalse ( source . hasObservers ( ) ) ; to . assertResult ( Collections . < Integer > emptyList ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > openIndicator = PublishSubject . create ( ) ; PublishSubject < Integer > closeIndicator = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = source . buffer ( openIndicator , Functions . justFunction ( closeIndicator ) ) . take ( 1 ) . test ( ) ; openIndicator . onNext ( 1 ) ; closeIndicator . onComplete ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( openIndicator . hasObservers ( ) ) ; assertFalse ( closeIndicator . hasObservers ( ) ) ; to . assertResult ( Collections . < Integer > emptyList ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . never ( ) . buffer ( new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; Disposable bs1 = Disposable . empty ( ) ; Disposable bs2 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertFalse ( bs2 . isDisposed ( ) ) ; observer . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertTrue ( bs2 . isDisposed ( ) ) ; observer . onError ( new IOException ( ) ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; , Functions . justFunction ( Observable . never ( ) ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . never ( ) . buffer ( Observable . just ( 1 ) . concatWith ( Observable . < Integer > never ( ) ) , Functions . justFunction ( new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; Disposable bs1 = Disposable . empty ( ) ; Disposable bs2 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertFalse ( bs2 . isDisposed ( ) ) ; observer . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertTrue ( bs2 . isDisposed ( ) ) ; observer . onError ( new IOException ( ) ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; ) ) . test ( ) . assertFailure ( IOException . class ) ; TestHelper . assertError ( errors , 0 , ProtocolViolationException . class ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < List < Object > > > ( ) @ Override public ObservableSource < List < Object > > apply ( Observable < Object > f ) throws Exception return f . buffer ( Observable . never ( ) ) ; ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; PublishSubject < Integer > b = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = ps . buffer ( b , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) throw new TestException ( ) ; return new ArrayList < > ( ) ; ) . test ( ) ; b . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; 
Observable < Integer > ps = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; ; final AtomicReference < Observer < ? super Integer > > ref = new AtomicReference < > ( ) ; Observable < Integer > b = new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; ref . set ( observer ) ; ; TestObserver < List < Integer > > to = ps . buffer ( b ) . test ( ) ; ref . get ( ) . onNext ( 1 ) ; to . assertResult ( Collections . < Integer > emptyList ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < List < Object > > > ( ) @ Override public Observable < List < Object > > apply ( Observable < Object > f ) throws Exception return f . buffer ( 1 , TimeUnit . SECONDS ) ; ) ; 
TestScheduler sch = new TestScheduler ( ) ; TestObserver < List < Object > > to = Observable . never ( ) . buffer ( 1 , TimeUnit . MILLISECONDS , sch ) . test ( true ) ; sch . advanceTimeBy ( 1 , TimeUnit . MILLISECONDS ) ; to . assertEmpty ( ) ; 
TestScheduler sch = new TestScheduler ( ) ; TestObserver < List < Integer > > to = new TestObserver < > ( ) ; BufferExactUnboundedObserver < Integer , List < Integer > > sub = new BufferExactUnboundedObserver < > ( to , Functions . justSupplier ( ( List < Integer > ) new ArrayList < Integer > ( ) ) , 1 , TimeUnit . SECONDS , sch ) ; sub . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( sub . isDisposed ( ) ) ; sub . onError ( new TestException ( ) ) ; sub . onNext ( 1 ) ; sub . onComplete ( ) ; sub . run ( ) ; sub . dispose ( ) ; assertTrue ( sub . isDisposed ( ) ) ; sub . buffer = new ArrayList < > ( ) ; sub . enter ( ) ; sub . onComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < List < Object > > > ( ) @ Override public Observable < List < Object > > apply ( Observable < Object > f ) throws Exception return f . buffer ( 2 , 1 , TimeUnit . SECONDS ) ; ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < List < Object > > > ( ) @ Override public Observable < List < Object > > apply ( Observable < Object > f ) throws Exception return f . buffer ( 2 , TimeUnit . SECONDS , 10 ) ; ) ; 
TestScheduler sch = new TestScheduler ( ) ; TestObserver < List < Integer > > to = new TestObserver < > ( ) ; BufferSkipBoundedObserver < Integer , List < Integer > > sub = new BufferSkipBoundedObserver < > ( to , Functions . justSupplier ( ( List < Integer > ) new ArrayList < Integer > ( ) ) , 1 , 1 , TimeUnit . SECONDS , sch . createWorker ( ) ) ; sub . onSubscribe ( Disposable . empty ( ) ) ; sub . enter ( ) ; sub . onComplete ( ) ; sub . dispose ( ) ; sub . run ( ) ; 
TestScheduler sch = new TestScheduler ( ) ; final TestObserver < List < Integer > > to = new TestObserver < > ( ) ; BufferSkipBoundedObserver < Integer , List < Integer > > sub = new BufferSkipBoundedObserver < > ( to , new Supplier < List < Integer > > ( ) int calls ; @ Override public List < Integer > get ( ) throws Exception if ( ++ calls == 2 ) to . dispose ( ) ; return new ArrayList < > ( ) ; , 1 , 1 , TimeUnit . SECONDS , sch . createWorker ( ) ) ; sub . onSubscribe ( Disposable . empty ( ) ) ; sub . run ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; TestObserver < List < Integer > > to = new TestObserver < > ( ) ; BufferExactBoundedObserver < Integer , List < Integer > > sub = new BufferExactBoundedObserver < > ( to , Functions . justSupplier ( ( List < Integer > ) new ArrayList < Integer > ( ) ) , 1 , TimeUnit . SECONDS , 1 , false , sch . createWorker ( ) ) ; Disposable bs = Disposable . empty ( ) ; sub . onSubscribe ( bs ) ; sub . producerIndex ++ ; sub . run ( ) ; assertFalse ( sub . isDisposed ( ) ) ; sub . enter ( ) ; sub . onComplete ( ) ; sub . dispose ( ) ; assertTrue ( sub . isDisposed ( ) ) ; sub . run ( ) ; sub . onNext ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < List < Object > > > ( ) @ Override public ObservableSource < List < Object > > apply ( Observable < Object > o ) throws Exception return o . buffer ( 1 ) ; ) ; 
TestObserver < List < Integer > > to = new TestObserver < > ( ) ; BufferExactObserver < Integer , List < Integer > > sub = new BufferExactObserver < > ( to , 1 , Functions . justSupplier ( ( List < Integer > ) new ArrayList < Integer > ( ) ) ) ; sub . onComplete ( ) ; sub . onNext ( 1 ) ; sub . onComplete ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < List < Object > > > ( ) @ Override public ObservableSource < List < Object > > apply ( Observable < Object > o ) throws Exception return o . buffer ( 1 , 2 ) ; ) ; 
Observable . empty ( ) . buffer ( 1 , TimeUnit . SECONDS , Schedulers . computation ( ) , 10 , new Supplier < List < Object > > ( ) @ Override public List < Object > get ( ) throws Exception throw new TestException ( ) ; , false ) . test ( ) . awaitDone ( 1 , TimeUnit . SECONDS ) . assertFailure ( TestException . class ) ; 
Observable . never ( ) . buffer ( 1 , TimeUnit . SECONDS ) . test ( true ) . assertEmpty ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) BehaviorSubject < Integer > bs = BehaviorSubject . createDefault ( 1 ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < List < Integer > > to = bs . buffer ( BehaviorSubject . createDefault ( 0 ) , v -> ps ) . test ( ) ; TestHelper . race ( ( ) -> bs . onComplete ( ) , ( ) -> ps . onComplete ( ) ) ; to . assertResult ( Arrays . asList ( 1 ) ) ; 
Observable < Notification < Integer > > notifications = Observable . just ( 1 , 2 ) . materialize ( ) ; Observable < Integer > dematerialize = notifications . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; dematerialize . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable . just ( 1 , 2 ) . materialize ( ) . dematerialize ( new Function < Notification < Integer > , Notification < Object > > ( ) @ Override public Notification < Object > apply ( Notification < Integer > v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 , 2 ) . materialize ( ) . dematerialize ( new Function < Notification < Integer > , Notification < Object > > ( ) @ Override public Notification < Object > apply ( Notification < Integer > v ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable < Notification < Integer > > notifications = Observable . just ( 1 , 2 ) . materialize ( ) ; Observable < Integer > dematerialize = notifications . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; dematerialize . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Throwable exception = new Throwable ( "test" ) ; Observable < Integer > o = Observable . error ( exception ) ; Observable < Integer > dematerialize = o . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; dematerialize . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onError ( exception ) ; verify ( observer , times ( 0 ) ) . onComplete ( ) ; verify ( observer , times ( 0 ) ) . onNext ( any ( Integer . class ) ) ; 
Exception exception = new Exception ( "test" ) ; Observable < Integer > o = Observable . error ( exception ) ; Observable < Integer > dematerialize = o . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; dematerialize . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onError ( exception ) ; verify ( observer , times ( 0 ) ) . onComplete ( ) ; verify ( observer , times ( 0 ) ) . onNext ( any ( Integer . class ) ) ; 
Exception exception = new Exception ( "test" ) ; Observable < Notification < Integer > > o = Observable . error ( exception ) ; Observable < Integer > dematerialize = o . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; dematerialize . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onError ( exception ) ; verify ( observer , times ( 0 ) ) . onComplete ( ) ; verify ( observer , times ( 0 ) ) . onNext ( any ( Integer . class ) ) ; 
Observable < Notification < Integer > > o = Observable . empty ( ) ; Observable < Integer > dematerialize = o . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( observer ) ; dematerialize . subscribe ( to ) ; System . out . println ( to . errors ( ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 0 ) ) . onNext ( any ( Integer . class ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) ; Observable < Integer > result = source . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > source = Observable . error ( new TestException ( ) ) ; Observable < Integer > result = source . materialize ( ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; verify ( o , never ( ) ) . onNext ( any ( Integer . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
TestHelper . checkDisposed ( Observable . just ( Notification . < Integer > createOnComplete ( ) ) . dematerialize ( Functions . < Notification < Integer > > identity ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Notification < Object > > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Notification < Object > > o ) throws Exception return o . dematerialize ( Functions . < Notification < Object > > identity ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Notification < Object > > ( ) @ Override protected void subscribeActual ( Observer < ? super Notification < Object > > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( Notification . createOnComplete ( ) ) ; observer . onNext ( Notification . < Object > createOnNext ( 1 ) ) ; observer . onNext ( Notification . createOnError ( new TestException ( "First" ) ) ) ; observer . onError ( new TestException ( "Second" ) ) ; . dematerialize ( Functions . < Notification < Object > > identity ( ) ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 1 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( Notification . createOnComplete ( ) ) ; observer . onNext ( 1 ) ; . dematerialize ( v -> ( Notification < Object > ) v ) . test ( ) . assertResult ( ) ; 
Observable . intervalRange ( 5 , 5 , 50 , 50 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 5L , 6L , 7L , 8L , 9L ) ; 
Observable . intervalRange ( 1 , 5 , 1 , 1 , TimeUnit . MILLISECONDS , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1L , 2L , 3L , 4L , 5L ) ; 
Observable . intervalRange ( 1 , 0 , 1 , 1 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
try Observable . intervalRange ( 1 , - 1 , 1 , 1 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "count >= 0 required but it was -1" , ex . getMessage ( ) ) ; 
Observable . intervalRange ( Long . MAX_VALUE - 1 , 2 , 1 , 1 , TimeUnit . MILLISECONDS ) ; Observable . intervalRange ( Long . MIN_VALUE , Long . MAX_VALUE , 1 , 1 , TimeUnit . MILLISECONDS ) ; try Observable . intervalRange ( Long . MAX_VALUE - 1 , 3 , 1 , 1 , TimeUnit . MILLISECONDS ) ; fail ( "Should have thrown!" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "Overflow! start + count is bigger than Long.MAX_VALUE" , ex . getMessage ( ) ) ; 
TestHelper . checkDisposed ( Observable . intervalRange ( 1 , 2 , 1 , 1 , TimeUnit . MILLISECONDS ) ) ; 
Observable . intervalRange ( 0 , 20 , 1 , 1 , TimeUnit . MILLISECONDS , Schedulers . trampoline ( ) ) . take ( 10 ) . test ( ) . assertResult ( 0L , 1L , 2L , 3L , 4L , 5L , 6L , 7L , 8L , 9L ) ; 
Observable . intervalRange ( 0 , 2 , 1 , 1 , TimeUnit . MILLISECONDS , Schedulers . trampoline ( ) ) . take ( 2 ) . test ( ) . assertResult ( 0L , 1L ) ; 
observer = TestHelper . mockObserver ( ) ; singleObserver = TestHelper . mockSingleObserver ( ) ; 
Observable < Integer > result = Observable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sum ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) . toObservable ( ) ; result . subscribe ( observer ) ; verify ( observer ) . onNext ( 1 + 2 + 3 + 4 + 5 ) ; verify ( observer ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > result = Observable . concat ( Observable . just ( 1 , 2 , 3 , 4 , 5 ) , Observable . < Integer > error ( new TestException ( ) ) ) . reduce ( 0 , sum ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) . toObservable ( ) ; result . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
BiFunction < Integer , Integer , Integer > sumErr = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throw new TestException ( ) ; ; Observable < Integer > result = Observable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sumErr ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) . toObservable ( ) ; result . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Function < Integer , Integer > error = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new TestException ( ) ; ; Observable < Integer > result = Observable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sum ) . toObservable ( ) . map ( error ) ; result . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Observable < Integer > source = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Observable < Integer > reduced = source . reduce ( sum ) . toObservable ( ) ; Integer r = reduced . blockingFirst ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Observable < Integer > reduced = source . reduce ( 0 , sum ) . toObservable ( ) ; Integer r = reduced . blockingFirst ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Single < Integer > result = Observable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sum ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( singleObserver ) ; verify ( singleObserver ) . onSuccess ( 1 + 2 + 3 + 4 + 5 ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Single < Integer > result = Observable . concat ( Observable . just ( 1 , 2 , 3 , 4 , 5 ) , Observable . < Integer > error ( new TestException ( ) ) ) . reduce ( 0 , sum ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( any ( ) ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
BiFunction < Integer , Integer , Integer > sumErr = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throw new TestException ( ) ; ; Single < Integer > result = Observable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sumErr ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) return v ; ) ; result . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( any ( ) ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Function < Integer , Integer > error = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) throw new TestException ( ) ; ; Single < Integer > result = Observable . just ( 1 , 2 , 3 , 4 , 5 ) . reduce ( 0 , sum ) . map ( error ) ; result . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onSuccess ( any ( ) ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; 
Observable < Integer > source = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Maybe < Integer > reduced = source . reduce ( sum ) ; Integer r = reduced . blockingGet ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) ; Single < Integer > reduced = source . reduce ( 0 , sum ) ; Integer r = reduced . blockingGet ( ) ; assertEquals ( 21 , r . intValue ( ) ) ; 
Observable . range ( 1 , 5 ) . reduceWith ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception return 0 ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertResult ( 15 ) ; 
TestHelper . checkDoubleOnSubscribeObservableToMaybe ( new Function < Observable < Object > , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Observable < Object > o ) throws Exception return o . reduce ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ; ) ; 
TestHelper . checkDisposed ( Observable . just ( new Object ( ) ) . reduce ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Object > ( ) @ Override protected void subscribeActual ( Observer < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . reduce ( new BiFunction < Object , Object , Object > ( ) @ Override public Object apply ( Object a , Object b ) throws Exception return a ; ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Integer > , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Observable < Integer > o ) throws Exception return o . reduce ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a ; ) ; ) ; 
TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . reduce ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a ; ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onComplete ( ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . reduce ( 0 , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a ; ) . test ( ) . assertResult ( 0 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
observer = TestHelper . mockObserver ( ) ; observer2 = TestHelper . mockObserver ( ) ; scheduler = new TestScheduler ( ) ; 
Observable < Long > source = Observable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . take ( 3 ) ; Observable < Long > delayed = source . delay ( 500L , TimeUnit . MILLISECONDS , scheduler ) ; delayed . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 1499L , TimeUnit . MILLISECONDS ) ; verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 1500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 0L ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2400L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1L ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3400L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2L ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Long > source = Observable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . take ( 3 ) ; Observable < Long > delayed = source . delay ( 5L , TimeUnit . SECONDS , scheduler ) ; delayed . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 5999L , TimeUnit . MILLISECONDS ) ; verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 6000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 0L ) ; scheduler . advanceTimeTo ( 6999L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; scheduler . advanceTimeTo ( 7000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1L ) ; scheduler . advanceTimeTo ( 7999L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; scheduler . advanceTimeTo ( 8000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2L ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Long > source = Observable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long value ) if ( value == 1L ) throw new RuntimeException ( "error!" ) ; return value ; ) ; Observable < Long > delayed = source . delay ( 1L , TimeUnit . SECONDS , scheduler ) ; delayed . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 1999L , TimeUnit . MILLISECONDS ) ; verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; scheduler . advanceTimeTo ( 5000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
Observable < Long > source = Observable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . take ( 3 ) ; Observable < Long > delayed = source . delay ( 500L , TimeUnit . MILLISECONDS , scheduler ) ; delayed . subscribe ( observer ) ; delayed . subscribe ( observer2 ) ; InOrder inOrder = inOrder ( observer ) ; InOrder inOrder2 = inOrder ( observer2 ) ; scheduler . advanceTimeTo ( 1499L , TimeUnit . MILLISECONDS ) ; verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer2 , never ( ) ) . onNext ( anyLong ( ) ) ; scheduler . advanceTimeTo ( 1500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 0L ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 0L ) ; scheduler . advanceTimeTo ( 2499L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder2 . verify ( observer2 , never ( ) ) . onNext ( anyLong ( ) ) ; scheduler . advanceTimeTo ( 2500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1L ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 1L ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer2 , never ( ) ) . onComplete ( ) ; scheduler . advanceTimeTo ( 3500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2L ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onNext ( 2L ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder2 . verify ( observer2 , never ( ) ) . onNext ( anyLong ( ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder2 . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > result = Observable . just ( 1 , 2 , 3 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; inOrder . verify ( o , never ( ) ) . onNext ( any ( ) ) ; inOrder . verify ( o , never ( ) ) . onComplete ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( o , times ( 1 ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > result = Observable . just ( 1 , 2 , 3 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; TestObserver < Object > to = new TestObserver < > ( o ) ; result . subscribe ( to ) ; to . dispose ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final List < PublishSubject < Integer > > delays = new ArrayList < > ( ) ; final int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) PublishSubject < Integer > delay = PublishSubject . create ( ) ; delays . add ( delay ) ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return delays . get ( t1 ) ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( delayFunc ) . subscribe ( o ) ; for ( int i = 0 ; i < n ; i ++ ) source . onNext ( i ) ; delays . get ( i ) . onNext ( i ) ; inOrder . verify ( o ) . onNext ( i ) ; source . onComplete ( ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > delay = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return delay ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; delay . onNext ( 1 ) ; delay . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > delay = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return delay ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; delay . onNext ( 1 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > delay = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return delay ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; delay . onError ( new TestException ( ) ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > delay = PublishSubject . create ( ) ; Supplier < Observable < Integer > > subFunc = new Supplier < Observable < Integer > > ( ) @ Override public Observable < Integer > get ( ) return delay ; ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return delay ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( Observable . defer ( subFunc ) , delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; delay . onNext ( 1 ) ; source . onNext ( 2 ) ; delay . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > delay = PublishSubject . create ( ) ; Supplier < Observable < Integer > > subFunc = new Supplier < Observable < Integer > > ( ) @ Override public Observable < Integer > get ( ) throw new TestException ( ) ; ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return delay ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( Observable . defer ( subFunc ) , delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; delay . onNext ( 1 ) ; source . onNext ( 2 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > delay = PublishSubject . create ( ) ; Supplier < Observable < Integer > > subFunc = new Supplier < Observable < Integer > > ( ) @ Override public Observable < Integer > get ( ) return delay ; ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return delay ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( Observable . defer ( subFunc ) , delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; delay . onError ( new TestException ( ) ) ; source . onNext ( 2 ) ; inOrder . verify ( o ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return Observable . empty ( ) ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > sdelay = PublishSubject . create ( ) ; final PublishSubject < Integer > delay = PublishSubject . create ( ) ; Supplier < Observable < Integer > > subFunc = new Supplier < Observable < Integer > > ( ) @ Override public Observable < Integer > get ( ) return sdelay ; ; Function < Integer , Observable < Integer > > delayFunc = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return delay ; ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; source . delay ( Observable . defer ( subFunc ) , delayFunc ) . subscribe ( o ) ; source . onNext ( 1 ) ; sdelay . onComplete ( ) ; source . onNext ( 2 ) ; delay . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observable < Long > source = Observable . interval ( 1L , TimeUnit . SECONDS , scheduler ) . take ( 3 ) ; final Observable < Long > delayer = Observable . timer ( 500L , TimeUnit . MILLISECONDS , scheduler ) ; Function < Long , Observable < Long > > delayFunc = new Function < Long , Observable < Long > > ( ) @ Override public Observable < Long > apply ( Long t1 ) return delayer ; ; Observable < Long > delayed = source . delay ( delayFunc ) ; delayed . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 1499L , TimeUnit . MILLISECONDS ) ; verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 1500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 0L ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2400L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1L ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3400L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3500L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2L ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
int n = 3 ; PublishSubject < Integer > source = PublishSubject . create ( ) ; final List < PublishSubject < Integer > > subjects = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) subjects . add ( PublishSubject . < Integer > create ( ) ) ; Observable < Integer > result = source . delay ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return subjects . get ( t1 ) ; ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; for ( int i = 0 ; i < n ; i ++ ) source . onNext ( i ) ; source . onComplete ( ) ; inOrder . verify ( o , never ( ) ) . onNext ( anyInt ( ) ) ; inOrder . verify ( o , never ( ) ) . onComplete ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) subjects . get ( i ) . onComplete ( ) ; inOrder . verify ( o ) . onNext ( i ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > source = Observable . range ( 1 , 5 ) ; Observable < Integer > delayed = source . delay ( 500L , TimeUnit . MILLISECONDS , scheduler ) ; delayed = delayed . doOnEach ( new Consumer < Notification < Integer > > ( ) @ Override public void accept ( Notification < Integer > t1 ) System . out . println ( t1 ) ; ) ; TestObserver < Integer > observer = new TestObserver < > ( ) ; delayed . subscribe ( observer ) ; scheduler . advanceTimeBy ( 500L , TimeUnit . MILLISECONDS ) ; observer . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . delay ( 100 , TimeUnit . MILLISECONDS ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t ) if ( c ++ <= 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) return t ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . delaySubscription ( 100 , TimeUnit . MILLISECONDS ) . delay ( 100 , TimeUnit . MILLISECONDS ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t ) if ( c ++ <= 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) return t ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . delay ( new Function < Integer , Observable < Long > > ( ) @ Override public Observable < Long > apply ( Integer i ) return Observable . timer ( 100 , TimeUnit . MILLISECONDS ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t ) if ( c ++ <= 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) return t ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , to . values ( ) . size ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . delay ( Observable . timer ( 500 , TimeUnit . MILLISECONDS ) , new Function < Integer , Observable < Long > > ( ) @ Override public Observable < Long > apply ( Integer i ) return Observable . timer ( 100 , TimeUnit . MILLISECONDS ) ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t ) if ( c ++ <= 0 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) return t ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 2 , to . values ( ) . size ( ) ) ; 
TestScheduler test = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; ps . delay ( 1 , TimeUnit . SECONDS , test ) . subscribe ( to ) ; ps . onNext ( 1 ) ; test . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; ps . onError ( new TestException ( ) ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observable < Integer > source = Observable . range ( 1 , 5 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . delaySubscription ( ps ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; ps . onNext ( 1 ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observable < Integer > source = Observable . range ( 1 , 5 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . delaySubscription ( ps ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; ps . onComplete ( ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observable < Integer > source = Observable . range ( 1 , 5 ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . delaySubscription ( ps ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; ps . onError ( new TestException ( ) ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( TestException . class ) ; 
Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . delay ( 100 , TimeUnit . MILLISECONDS , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertFailure ( TestException . class , 1 ) ; 
final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Thread > thread = new AtomicReference < > ( ) ; Observable . < String > error ( new Exception ( ) ) . delay ( 0 , TimeUnit . MILLISECONDS , Schedulers . newThread ( ) ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable throwable ) throws Exception thread . set ( Thread . currentThread ( ) ) ; latch . countDown ( ) ; ) . onErrorResumeWith ( Observable . < String > empty ( ) ) . subscribe ( ) ; latch . await ( ) ; assertNotEquals ( Thread . currentThread ( ) , thread . get ( ) ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . delay ( 1 , TimeUnit . SECONDS ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . delay ( Functions . justFunction ( Observable . never ( ) ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . delay ( 1 , TimeUnit . SECONDS ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . delay ( Functions . justFunction ( Observable . never ( ) ) ) ; ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable . empty ( ) . delay ( 1 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( new DisposableObserver < Object > ( ) @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) @ Override public void onComplete ( ) throw new TestException ( ) ; ) ; try scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) 
TestScheduler scheduler = new TestScheduler ( ) ; Observable . error ( new TestException ( ) ) . delay ( 1 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( new DisposableObserver < Object > ( ) @ Override public void onNext ( Object value ) @ Override public void onError ( Throwable e ) throw new TestException ( ) ; @ Override public void onComplete ( ) ) ; try scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) 
Observable . just ( 1 ) . delay ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer t ) throws Exception return null ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The itemDelay returned a null ObservableSource" ) ; 
Observable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . empty ( ) ; ) . test ( ) . assertResult ( ) ; 
Observable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; , true ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( to , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( TestException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return null ; ) . test ( ) ; assertTrue ( ps . hasObservers ( ) ) ; ps . onNext ( 1 ) ; to . assertFailure ( NullPointerException . class ) ; assertFalse ( ps . hasObservers ( ) ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . error ( new TestException ( ) ) ; , true ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . compositeList ( to . errors ( ) . get ( 0 ) ) ; for ( int i = 0 ; i < 11 ; i ++ ) TestHelper . assertError ( errors , i , TestException . class ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 2 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 2 ) . assertNoErrors ( ) . assertComplete ( ) ; TestHelper . assertValueSet ( to , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable . range ( 1 , 10 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( v ) ; ) . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . fromArray ( new String [ ] "1" , "a" , "2" ) . flatMapMaybe ( new Function < String , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( final String s ) throws NumberFormatException return Maybe . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws NumberFormatException return Integer . valueOf ( s ) ; ) ; ) . test ( ) . assertFailure ( NumberFormatException . class , 1 ) ; 
Observable . range ( 1 , 1000 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 500 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
Observable . range ( 1 , 1000 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . < Integer > empty ( ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . take ( 500 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . range ( 1 , 2 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) return ps . singleElement ( ) ; return Maybe . error ( new TestException ( ) ) ; , true ) . test ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class , 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . range ( 1 , 2 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception if ( v == 2 ) return ps . singleElement ( ) ; return Maybe . error ( new TestException ( ) ) ; , true ) . test ( ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( PublishSubject . < Integer > create ( ) . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) throws Exception return Maybe . < Integer > empty ( ) ; ) ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( 1 ) . flatMapMaybe ( Functions . justFunction ( ps . singleElement ( ) ) ) . test ( ) ; ps . onNext ( 2 ) ; ps . onComplete ( ) ; to . assertResult ( 2 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Object > f ) throws Exception return f . flatMapMaybe ( Functions . justFunction ( Maybe . just ( 2 ) ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onError ( new TestException ( "Second" ) ) ; . flatMapMaybe ( Functions . justFunction ( Maybe . just ( 2 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . just ( 1 ) . flatMapMaybe ( Functions . justFunction ( new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onError ( new TestException ( "Second" ) ) ; ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps2 . onNext ( 2 ) ; ps2 . onComplete ( ) ; ; Observable . just ( ps1 , ps2 ) . flatMapMaybe ( new Function < PublishSubject < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( PublishSubject < Integer > v ) throws Exception return v . singleElement ( ) ; ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; ps1 . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps3 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps2 . onNext ( 2 ) ; ps2 . onComplete ( ) ; ; Observable . just ( ps1 , ps2 , ps3 ) . flatMapMaybe ( new Function < PublishSubject < Integer > , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( PublishSubject < Integer > v ) throws Exception return v . singleElement ( ) ; ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; ps1 . onComplete ( ) ; ps3 . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . flatMapMaybe ( new Function < Integer , MaybeSource < Object > > ( ) @ Override public MaybeSource < Object > apply ( Integer v ) throws Exception return new Maybe < Object > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Object > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; to . dispose ( ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . flatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . flatMapMaybe ( new Function < Integer , Maybe < Integer > > ( ) @ Override public Maybe < Integer > apply ( Integer v ) throws Throwable return Maybe . just ( v ) . hide ( ) ; , true ) ; ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; ps1 . flatMapMaybe ( v -> TestHelper . raceOther ( ( ) -> to . dispose ( ) ; , cdl ) ; return Maybe . just ( 1 ) ; ) . subscribe ( to ) ; ps1 . onNext ( 1 ) ; cdl . await ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) MaybeSubject < Integer > ms1 = MaybeSubject . create ( ) ; MaybeSubject < Integer > ms2 = MaybeSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( 1 , 2 ) . flatMapMaybe ( v -> v == 1 ? ms1 : ms2 ) . test ( ) ; TestHelper . race ( ( ) -> ms1 . onComplete ( ) , ( ) -> ms2 . onSuccess ( 1 ) ) ; to . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_LONG_LOOPS ; i ++ ) MaybeSubject < Integer > ms1 = MaybeSubject . create ( ) ; MaybeSubject < Integer > ms2 = MaybeSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( 1 , 2 ) . flatMapMaybe ( v -> v == 1 ? ms1 : ms2 ) . test ( ) ; TestHelper . race ( ( ) -> ms2 . onSuccess ( 1 ) , ( ) -> ms1 . onComplete ( ) ) ; to . assertResult ( 1 ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; final List < Integer > list = Arrays . asList ( 1 , 2 , 3 ) ; Function < Integer , List < Integer > > func = new Function < Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 ) return list ; ; BiFunction < Integer , Integer , Integer > resFunc = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 | t2 ; ; List < Integer > source = Arrays . asList ( 16 , 32 , 64 ) ; Observable . fromIterable ( source ) . flatMapIterable ( func , resFunc ) . subscribe ( o ) ; for ( Integer s : source ) for ( Integer v : list ) verify ( o ) . onNext ( s | v ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Function < Integer , List < Integer > > func = new Function < Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 ) throw new TestException ( ) ; ; BiFunction < Integer , Integer , Integer > resFunc = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 | t2 ; ; List < Integer > source = Arrays . asList ( 16 , 32 , 64 ) ; Observable . fromIterable ( source ) . flatMapIterable ( func , resFunc ) . subscribe ( o ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; final List < Integer > list = Arrays . asList ( 1 , 2 , 3 ) ; Function < Integer , List < Integer > > func = new Function < Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer t1 ) return list ; ; BiFunction < Integer , Integer , Integer > resFunc = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) throw new TestException ( ) ; ; List < Integer > source = Arrays . asList ( 16 , 32 , 64 ) ; Observable . fromIterable ( source ) . flatMapIterable ( func , resFunc ) . subscribe ( o ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
Observer < Object > o = TestHelper . mockObserver ( ) ; Function < Integer , Observable < Integer > > func = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return Observable . error ( new TestException ( ) ) ; ; BiFunction < Integer , Integer , Integer > resFunc = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 | t2 ; ; List < Integer > source = Arrays . asList ( 16 , 32 , 64 ) ; Observable . fromIterable ( source ) . flatMap ( func , resFunc ) . subscribe ( o ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
Observable < Integer > onNext = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; Observable < Integer > onComplete = Observable . fromIterable ( Arrays . asList ( 4 ) ) ; Observable < Integer > onError = Observable . fromIterable ( Arrays . asList ( 5 ) ) ; Observable < Integer > source = Observable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . flatMap ( just ( onNext ) , just ( onError ) , just0 ( onComplete ) ) . subscribe ( o ) ; verify ( o , times ( 3 ) ) . onNext ( 1 ) ; verify ( o , times ( 3 ) ) . onNext ( 2 ) ; verify ( o , times ( 3 ) ) . onNext ( 3 ) ; verify ( o ) . onNext ( 4 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( 5 ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > onNext = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; Observable < Integer > onComplete = Observable . fromIterable ( Arrays . asList ( 4 ) ) ; Observable < Integer > onError = Observable . fromIterable ( Arrays . asList ( 5 ) ) ; Observable < Integer > source = Observable . concat ( Observable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) , Observable . < Integer > error ( new RuntimeException ( "Forced failure!" ) ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . flatMap ( just ( onNext ) , just ( onError ) , just0 ( onComplete ) ) . subscribe ( o ) ; verify ( o , times ( 3 ) ) . onNext ( 1 ) ; verify ( o , times ( 3 ) ) . onNext ( 2 ) ; verify ( o , times ( 3 ) ) . onNext ( 3 ) ; verify ( o ) . onNext ( 5 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( 4 ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > onComplete = Observable . fromIterable ( Arrays . asList ( 4 ) ) ; Observable < Integer > onError = Observable . fromIterable ( Arrays . asList ( 5 ) ) ; Observable < Integer > source = Observable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . flatMap ( funcThrow ( 1 , onError ) , just ( onError ) , just0 ( onComplete ) ) . subscribe ( o ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observable < Integer > onNext = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; Observable < Integer > onComplete = Observable . fromIterable ( Arrays . asList ( 4 ) ) ; Observable < Integer > onError = Observable . fromIterable ( Arrays . asList ( 5 ) ) ; Observable < Integer > source = Observable . error ( new TestException ( ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . flatMap ( just ( onNext ) , funcThrow ( ( Throwable ) null , onError ) , just0 ( onComplete ) ) . subscribe ( o ) ; verify ( o ) . onError ( any ( CompositeException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observable < Integer > onNext = Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) ; Observable < Integer > onComplete = Observable . fromIterable ( Arrays . asList ( 4 ) ) ; Observable < Integer > onError = Observable . fromIterable ( Arrays . asList ( 5 ) ) ; Observable < Integer > source = Observable . fromIterable ( Arrays . < Integer > asList ( ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . flatMap ( just ( onNext ) , just ( onError ) , funcThrow0 ( onComplete ) ) . subscribe ( o ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
Observable < Integer > onNext = Observable . error ( new TestException ( ) ) ; Observable < Integer > onComplete = Observable . fromIterable ( Arrays . asList ( 4 ) ) ; Observable < Integer > onError = Observable . fromIterable ( Arrays . asList ( 5 ) ) ; Observable < Integer > source = Observable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; source . flatMap ( just ( onNext ) , just ( onError ) , funcThrow0 ( onComplete ) ) . subscribe ( o ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
final int m = 4 ; final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; Observable < Integer > source = Observable . range ( 1 , 10 ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return composer ( Observable . range ( t1 * 10 , 2 ) , subscriptionCount , m ) . subscribeOn ( Schedulers . computation ( ) ) ; , m ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; Set < Integer > expected = new HashSet < > ( Arrays . asList ( 10 , 11 , 20 , 21 , 30 , 31 , 40 , 41 , 50 , 51 , 60 , 61 , 70 , 71 , 80 , 81 , 90 , 91 , 100 , 101 ) ) ; Assert . assertEquals ( expected . size ( ) , to . values ( ) . size ( ) ) ; Assert . assertTrue ( expected . containsAll ( to . values ( ) ) ) ; 
final int m = 4 ; final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; Observable < Integer > source = Observable . range ( 1 , 10 ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t1 ) return composer ( Observable . range ( t1 * 10 , 2 ) , subscriptionCount , m ) . subscribeOn ( Schedulers . computation ( ) ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 , Integer t2 ) return t1 * 1000 + t2 ; , m ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; Set < Integer > expected = new HashSet < > ( Arrays . asList ( 1010 , 1011 , 2020 , 2021 , 3030 , 3031 , 4040 , 4041 , 5050 , 5051 , 6060 , 6061 , 7070 , 7071 , 8080 , 8081 , 9090 , 9091 , 10100 , 10101 ) ) ; Assert . assertEquals ( expected . size ( ) , to . values ( ) . size ( ) ) ; System . out . println ( "--> testFlatMapSelectorMaxConcurrent: " + to . values ( ) ) ; Assert . assertTrue ( expected . containsAll ( to . values ( ) ) ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) if ( i % 100 == 0 ) System . out . println ( "testFlatMapTransformsMaxConcurrentNormalLoop => " + i ) ; flatMapTransformsMaxConcurrentNormal ( ) ; 
final int m = 2 ; final AtomicInteger subscriptionCount = new AtomicInteger ( ) ; Observable < Integer > onNext = composer ( Observable . fromIterable ( Arrays . asList ( 1 , 2 , 3 ) ) . observeOn ( Schedulers . computation ( ) ) , subscriptionCount , m ) . subscribeOn ( Schedulers . computation ( ) ) ; Observable < Integer > onComplete = composer ( Observable . fromIterable ( Arrays . asList ( 4 ) ) , subscriptionCount , m ) . subscribeOn ( Schedulers . computation ( ) ) ; Observable < Integer > onError = Observable . fromIterable ( Arrays . asList ( 5 ) ) ; Observable < Integer > source = Observable . fromIterable ( Arrays . asList ( 10 , 20 , 30 ) ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; TestObserverEx < Object > to = new TestObserverEx < > ( o ) ; Function < Throwable , Observable < Integer > > just = just ( onError ) ; source . flatMap ( just ( onNext ) , just , just0 ( onComplete ) , m ) . subscribe ( to ) ; to . awaitDone ( 1 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; verify ( o , times ( 3 ) ) . onNext ( 1 ) ; verify ( o , times ( 3 ) ) . onNext ( 2 ) ; verify ( o , times ( 3 ) ) . onNext ( 3 ) ; verify ( o ) . onNext ( 4 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( 5 ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
for ( int i = 0 ; i < 2000 ; i ++ ) if ( i % 10 == 0 ) System . out . println ( "flatMapRangeAsyncLoop > " + i ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . range ( 0 , 1000 ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) final Random rnd = new Random ( ) ; @ Override public Observable < Integer > apply ( Integer t ) Observable < Integer > r = Observable . just ( t ) ; if ( rnd . nextBoolean ( ) ) r = r . hide ( ) ; return r ; ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 2500 , TimeUnit . MILLISECONDS ) ; if ( to . completions ( ) == 0 ) System . out . println ( to . values ( ) . size ( ) ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; List < Integer > list = to . values ( ) ; if ( list . size ( ) < 1000 ) Set < Integer > set = new HashSet < > ( list ) ; for ( int j = 0 ; j < 1000 ; j ++ ) if ( ! set . contains ( j ) ) System . out . println ( j + " missing" ) ; assertEquals ( 1000 , list . size ( ) ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 1000 ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return Observable . just ( 1 ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; to . assertValueCount ( 1000 ) ; 
for ( final int n : new int [ ] 1 , 1000 , 1000000 ) TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 , 2 ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return Observable . range ( 1 , n ) ; ) . subscribe ( to ) ; System . out . println ( "flatMapTwoNestedSync >> @ " + n ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; to . assertValueCount ( n * 2 ) ; 
Observable . just ( 1 ) . flatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . just ( v * 10 ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true ) . test ( ) . assertResult ( 11 ) ; 
Observable . just ( 1 ) . flatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . just ( v * 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true ) . test ( ) . assertFailure ( TestException . class , 11 ) ; 
Observable . just ( 1 , 2 ) . flatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . just ( v * 10 ) ; , new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) throws Exception return a + b ; , true , 1 ) . test ( ) . assertResult ( 11 , 22 ) ; 
assertSame ( Observable . empty ( ) , Observable . empty ( ) . flatMap ( new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object v ) throws Exception return Observable . just ( v ) ; ) ) ; 
Observable . merge ( Observable . just ( Observable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . merge ( Observable . just ( Observable . just ( 1 ) ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . merge ( Observable . just ( Observable . empty ( ) ) . hide ( ) ) . test ( ) . assertResult ( ) ; 
Observable . merge ( Observable . just ( Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
final PublishSubject < Observable < Integer > > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( Observable . just ( 2 ) ) ; ; Observable . merge ( ps ) . subscribe ( to ) ; ps . onNext ( Observable . just ( 1 ) ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
final PublishSubject < Observable < Integer > > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( Observable . just ( 2 ) ) ; ; Observable . merge ( ps , 2 ) . subscribe ( to ) ; ps . onNext ( Observable . just ( 1 ) ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = Observable . merge ( Observable . just ( ps ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Observable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer v ) throws Exception return Observable . range ( 1 , 2 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer w ) throws Exception throw new TestException ( ) ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
TestObserverEx < Integer > to = Observable . range ( 1 , 2 ) . hide ( ) . flatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( 1 , 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer w ) throws Exception throw new TestException ( ) ; ) ; , true ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; List < Throwable > errors = TestHelper . errorList ( to ) ; TestHelper . assertError ( errors , 0 , TestException . class ) ; TestHelper . assertError ( errors , 1 , TestException . class ) ; 
for ( int i = 0 ; i < 500 ; i ++ ) TestObserver < Object > to = Observable . merge ( Observable . just ( 1 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return Thread . currentThread ( ) . getName ( ) . substring ( 0 , 4 ) ; ) , Observable . just ( 1 ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception return Thread . currentThread ( ) . getName ( ) . substring ( 0 , 4 ) ; ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 2 ) ; List < Object > list = to . values ( ) ; assertTrue ( list . toString ( ) , list . contains ( "RxSi" ) ) ; assertTrue ( list . toString ( ) , list . contains ( "RxCo" ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Observable < Integer > > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) for ( int j = 1 ; j < 50 ; j += 5 ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Observable < Integer > > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . flatMap ( Functions . < Observable < Integer > > identity ( ) ) . test ( ) ; final PublishSubject < Integer > just = PublishSubject . create ( ) ; final PublishSubject < Integer > just2 = PublishSubject . create ( ) ; ps . onNext ( just ) ; ps . onNext ( just2 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) just2 . onNext ( 1 ) ; to . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) just . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . just ( 1 ) . flatMapIterable ( new Function < Integer , Iterable < Object > > ( ) @ Override public Iterable < Object > apply ( Integer v ) throws Exception return null ; , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer v , Object w ) throws Exception return v ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The mapper returned a null Iterable" ) ; 
Observable . just ( 1 ) . flatMap ( new Function < Integer , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Integer v ) throws Exception return null ; , new BiFunction < Integer , Object , Object > ( ) @ Override public Object apply ( Integer v , Object w ) throws Exception return v ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The mapper returned a null ObservableSource" ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception counter . getAndIncrement ( ) ; ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . < Integer > fromIterable ( new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , counter . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . just ( v + 1 ) ; , 1 ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) for ( int i = 1 ; i < 10 ; i ++ ) ps . onNext ( i ) ; ps . onComplete ( ) ; ) ; ps . onNext ( 0 ) ; if ( ! errors . isEmpty ( ) ) to . onError ( new CompositeException ( errors ) ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; finally RxJavaPlugins . reset ( ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . just ( v + 1 ) . hide ( ) ; , 1 ) . subscribeWith ( new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) for ( int i = 1 ; i < 10 ; i ++ ) ps . onNext ( i ) ; ps . onComplete ( ) ; ) ; ps . onNext ( 0 ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
final UnicastSubject < Integer > fusedSource = UnicastSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; ObservableFlatMap . MergeObserver < Integer , Integer > merger = new ObservableFlatMap . MergeObserver < > ( to , new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) throws Exception if ( t == 0 ) return fusedSource . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > observableStripBoundary ( ) ) ; return Observable . range ( 10 * t , 5 ) ; , true , Integer . MAX_VALUE , 128 ) ; merger . onSubscribe ( Disposable . empty ( ) ) ; merger . getAndIncrement ( ) ; merger . onNext ( 0 ) ; merger . onNext ( 1 ) ; merger . onNext ( 2 ) ; assertTrue ( fusedSource . hasObservers ( ) ) ; fusedSource . onNext ( - 1 ) ; merger . drainLoop ( ) ; to . assertValuesOnly ( 10 , 11 , 12 , 13 , 14 , 20 , 21 , 22 , 23 , 24 ) ; 
final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; PublishSubject < Integer > ps3 = PublishSubject . create ( ) ; PublishSubject < Integer > ps4 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( ps1 , ps2 , ps3 , ps4 ) . flatMap ( new Function < PublishSubject < Integer > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( PublishSubject < Integer > v ) throws Exception return v ; , 2 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception if ( v == 1 ) ps1 . onComplete ( ) ; ps2 . onComplete ( ) ; ) . test ( ) ; ps1 . onNext ( 1 ) ; assertFalse ( ps1 . hasObservers ( ) ) ; assertFalse ( ps2 . hasObservers ( ) ) ; assertTrue ( ps3 . hasObservers ( ) ) ; assertTrue ( ps4 . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps3 . hasObservers ( ) ) ; assertFalse ( ps4 . hasObservers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; , true ) ; ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; ps1 . flatMap ( v -> ps2 ) . test ( ) ; ps1 . onNext ( 1 ) ; assertTrue ( "No subscribers?" , ps2 . hasObservers ( ) ) ; ps1 . onError ( new TestException ( ) ) ; assertFalse ( "Has subscribers?" , ps2 . hasObservers ( ) ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; ps1 . flatMap ( v -> ps2 ) . test ( ) ; ps1 . onNext ( 1 ) ; assertTrue ( "No subscribers?" , ps2 . hasObservers ( ) ) ; ps2 . onError ( new TestException ( ) ) ; assertFalse ( "Has subscribers?" , ps1 . hasObservers ( ) ) ; 
TestHelper . withErrorTracking ( errors -> new Observable < Integer > ( ) @ Override protected void subscribeActual ( @ NonNull Observer < ? super @ NonNull Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onComplete ( ) ; observer . onError ( new IOException ( ) ) ; . flatMap ( v -> throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; ps . flatMap ( v -> Observable . just ( v ) ) . doOnNext ( v -> if ( v == 1 ) ps . onNext ( 2 ) ; ps . onNext ( 3 ) ; ) . take ( 2 ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 , 2 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; CountDownLatch cdl = new CountDownLatch ( 1 ) ; ps . flatMap ( v -> Observable . just ( v ) ) . doOnNext ( v -> if ( v == 1 ) ps . onNext ( 2 ) ; TestHelper . raceOther ( ( ) -> ps . onComplete ( ) , cdl ) ; ) . subscribe ( to ) ; ps . onNext ( 1 ) ; cdl . await ( ) ; to . assertResult ( 1 , 2 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( ps , us . map ( v -> if ( v == 10 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . observableStripBoundary ( ) ) ) . flatMap ( v -> v , true ) . doOnNext ( v -> if ( v == 1 ) ps . onNext ( 2 ) ; us . onNext ( 10 ) ; ) . test ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class , 1 , 2 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . just ( us . map ( v -> if ( v == 10 ) throw new TestException ( ) ; return v ; ) . compose ( TestHelper . observableStripBoundary ( ) ) , ps ) . flatMap ( v -> v , true ) . doOnNext ( v -> if ( v == 1 ) ps . onNext ( 2 ) ; us . onNext ( 10 ) ; ) . test ( ) ; ps . onNext ( 1 ) ; ps . onComplete ( ) ; to . assertFailure ( TestException . class , 1 , 2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) Observable . range ( 0 , 20 ) . flatMap ( integer -> if ( integer % 5 != 0 ) return Observable . just ( integer ) ; return Observable . just ( - integer ) . observeOn ( Schedulers . computation ( ) ) ; , false , 1 ) . ignoreElements ( ) . blockingAwait ( ) ; 
Observable . just ( 1 ) . throttleLatest ( 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( 1 ) ; 
Observable . range ( 1 , 5 ) . throttleLatest ( 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( 1 ) ; 
Observable . range ( 1 , 5 ) . throttleLatest ( 1 , TimeUnit . MINUTES , true ) . test ( ) . assertResult ( 1 , 5 ) ; 
Observable . error ( new TestException ( ) ) . throttleLatest ( 1 , TimeUnit . MINUTES ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . throttleLatest ( 1 , TimeUnit . MINUTES ) ; ) ; 
TestHelper . checkDisposed ( Observable . never ( ) . throttleLatest ( 1 , TimeUnit . MINUTES ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . throttleLatest ( 1 , TimeUnit . SECONDS , sch ) . test ( ) ; ps . onNext ( 1 ) ; to . assertValuesOnly ( 1 ) ; ps . onNext ( 2 ) ; to . assertValuesOnly ( 1 ) ; ps . onNext ( 3 ) ; to . assertValuesOnly ( 1 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertValuesOnly ( 1 , 3 ) ; ps . onNext ( 4 ) ; to . assertValuesOnly ( 1 , 3 ) ; ps . onNext ( 5 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertValuesOnly ( 1 , 3 , 5 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertValuesOnly ( 1 , 3 , 5 ) ; ps . onNext ( 6 ) ; to . assertValuesOnly ( 1 , 3 , 5 , 6 ) ; ps . onNext ( 7 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 3 , 5 , 6 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertResult ( 1 , 3 , 5 , 6 ) ; 
TestScheduler sch = new TestScheduler ( ) ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . throttleLatest ( 1 , TimeUnit . SECONDS , sch , true ) . test ( ) ; ps . onNext ( 1 ) ; to . assertValuesOnly ( 1 ) ; ps . onNext ( 2 ) ; to . assertValuesOnly ( 1 ) ; ps . onNext ( 3 ) ; to . assertValuesOnly ( 1 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertValuesOnly ( 1 , 3 ) ; ps . onNext ( 4 ) ; to . assertValuesOnly ( 1 , 3 ) ; ps . onNext ( 5 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertValuesOnly ( 1 , 3 , 5 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertValuesOnly ( 1 , 3 , 5 ) ; ps . onNext ( 6 ) ; to . assertValuesOnly ( 1 , 3 , 5 , 6 ) ; ps . onNext ( 7 ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 3 , 5 , 6 , 7 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertResult ( 1 , 3 , 5 , 6 , 7 ) ; 
Action onCancel = mock ( Action . class ) ; Observable . range ( 1 , 5 ) . doOnDispose ( onCancel ) . throttleLatest ( 1 , TimeUnit . MINUTES ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; verify ( onCancel ) . run ( ) ; 
TestScheduler sch = new TestScheduler ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onNext ( 2 ) ; if ( t == 2 ) ps . onComplete ( ) ; ; ps . throttleLatest ( 1 , TimeUnit . SECONDS , sch ) . subscribe ( to ) ; ps . onNext ( 1 ) ; sch . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; to . assertResult ( 1 , 2 ) ; 
Observable . fromSingle ( Single . just ( 1 ) . hide ( ) ) . test ( ) . assertResult ( 1 ) ; 
Observable . fromSingle ( Single . error ( new TestException ( ) ) . hide ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
SingleSubject < Integer > ms = SingleSubject . create ( ) ; TestObserver < Integer > to = Observable . fromSingle ( ms ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ms . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ms . hasObservers ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Observable . fromSingle ( Single . just ( 1 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . SYNC ) ; Observable . fromSingle ( Single . just ( 1 ) ) . subscribe ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 ) ; 
Observable . range ( 1 , 10 ) . onErrorComplete ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable . empty ( ) . onErrorComplete ( ) . test ( ) . assertResult ( ) ; 
TestHelper . withErrorTracking ( errors -> Observable . error ( new TestException ( ) ) . onErrorComplete ( ) . test ( ) . assertResult ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Observable . error ( new TestException ( ) ) . onErrorComplete ( error -> error instanceof TestException ) . test ( ) . assertResult ( ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Observable . error ( new IOException ( ) ) . onErrorComplete ( error -> error instanceof TestException ) . test ( ) . assertFailure ( IOException . class ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> TestObserverEx < Object > to = Observable . error ( new IOException ( ) ) . onErrorComplete ( error -> throw new TestException ( ) ; ) . subscribeWith ( new TestObserverEx < > ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( to , 0 , IOException . class ) ; TestHelper . assertError ( to , 1 , TestException . class ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
TestHelper . withErrorTracking ( errors -> Observable . range ( 1 , 5 ) . map ( v -> 4 / ( 3 - v ) ) . onErrorComplete ( ) . test ( ) . assertResult ( 2 , 4 ) ; assertTrue ( "" + errors , errors . isEmpty ( ) ) ; ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . onErrorComplete ( ) . test ( ) ; assertTrue ( "No subscribers?!" , ps . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( "Still subscribers?!" , ps . hasObservers ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( f -> f . onErrorComplete ( ) ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . onErrorComplete ( ) ) ; 
observer = TestHelper . mockObserver ( ) ; observer2 = TestHelper . mockObserver ( ) ; scheduler = new TestScheduler ( ) ; 
Observable . timer ( 100 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( observer ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; verify ( observer , times ( 1 ) ) . onNext ( 0L ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestObserver < Long > to = new TestObserver < > ( ) ; Observable . interval ( 100 , 100 , TimeUnit . MILLISECONDS , scheduler ) . subscribe ( to ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValue ( 0L ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValues ( 0L , 1L ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValues ( 0L , 1L , 2L ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValues ( 0L , 1L , 2L , 3L ) ; to . dispose ( ) ; scheduler . advanceTimeBy ( 100 , TimeUnit . MILLISECONDS ) ; to . assertValues ( 0L , 1L , 2L , 3L ) ; to . assertNotComplete ( ) ; to . assertNoErrors ( ) ; 
Observable < Long > w = Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) ; TestObserver < Long > to = new TestObserver < > ( ) ; w . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; to . assertValues ( 0L , 1L ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; to . dispose ( ) ; scheduler . advanceTimeTo ( 4 , TimeUnit . SECONDS ) ; to . assertValues ( 0L , 1L ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; 
Observable < Long > w = Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) ; TestObserver < Long > to1 = new TestObserver < > ( ) ; TestObserver < Long > to2 = new TestObserver < > ( ) ; w . subscribe ( to1 ) ; w . subscribe ( to2 ) ; to1 . assertNoValues ( ) ; to2 . assertNoValues ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; to1 . assertValues ( 0L , 1L ) ; to1 . assertNoErrors ( ) ; to1 . assertNotComplete ( ) ; to2 . assertValues ( 0L , 1L ) ; to2 . assertNoErrors ( ) ; to2 . assertNotComplete ( ) ; to1 . dispose ( ) ; to2 . dispose ( ) ; scheduler . advanceTimeTo ( 4 , TimeUnit . SECONDS ) ; to1 . assertValues ( 0L , 1L ) ; to1 . assertNoErrors ( ) ; to1 . assertNotComplete ( ) ; to2 . assertValues ( 0L , 1L ) ; to2 . assertNoErrors ( ) ; to2 . assertNotComplete ( ) ; 
Observable < Long > w = Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) ; TestObserver < Long > to1 = new TestObserver < > ( ) ; w . subscribe ( to1 ) ; to1 . assertNoErrors ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; TestObserver < Long > to2 = new TestObserver < > ( ) ; w . subscribe ( to2 ) ; to1 . assertValues ( 0L , 1L ) ; to1 . assertNoErrors ( ) ; to1 . assertNotComplete ( ) ; to2 . assertNoValues ( ) ; scheduler . advanceTimeTo ( 4 , TimeUnit . SECONDS ) ; to1 . assertValues ( 0L , 1L , 2L , 3L ) ; to2 . assertValues ( 0L , 1L ) ; to1 . dispose ( ) ; to2 . dispose ( ) ; to1 . assertValues ( 0L , 1L , 2L , 3L ) ; to1 . assertNoErrors ( ) ; to1 . assertNotComplete ( ) ; to2 . assertValues ( 0L , 1L ) ; to2 . assertNoErrors ( ) ; to2 . assertNotComplete ( ) ; 
ConnectableObservable < Long > w = Observable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . publish ( ) ; TestObserver < Long > to1 = new TestObserver < > ( ) ; w . subscribe ( to1 ) ; w . connect ( ) ; to1 . assertNoValues ( ) ; scheduler . advanceTimeTo ( 2 , TimeUnit . SECONDS ) ; TestObserver < Long > to2 = new TestObserver < > ( ) ; w . subscribe ( to2 ) ; to1 . assertValues ( 0L , 1L ) ; to1 . assertNoErrors ( ) ; to1 . assertNotComplete ( ) ; to2 . assertNoValues ( ) ; scheduler . advanceTimeTo ( 4 , TimeUnit . SECONDS ) ; to1 . assertValues ( 0L , 1L , 2L , 3L ) ; to2 . assertValues ( 2L , 3L ) ; to1 . dispose ( ) ; to2 . dispose ( ) ; to1 . assertValues ( 0L , 1L , 2L , 3L ) ; to1 . assertNoErrors ( ) ; to1 . assertNotComplete ( ) ; to2 . assertValues ( 2L , 3L ) ; to2 . assertNoErrors ( ) ; to2 . assertNotComplete ( ) ; 
Observable < Long > source = Observable . timer ( 100 , TimeUnit . MILLISECONDS , scheduler ) ; source . safeSubscribe ( new DefaultObserver < Long > ( ) @ Override public void onNext ( Long t ) throw new TestException ( ) ; @ Override public void onError ( Throwable e ) observer . onError ( e ) ; @ Override public void onComplete ( ) observer . onComplete ( ) ; ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( observer ) . onError ( any ( TestException . class ) ) ; verify ( observer , never ( ) ) . onNext ( anyLong ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
Observable < Long > source = Observable . interval ( 100 , 100 , TimeUnit . MILLISECONDS , scheduler ) ; InOrder inOrder = inOrder ( observer ) ; source . safeSubscribe ( new DefaultObserver < Long > ( ) @ Override public void onNext ( Long t ) if ( t > 0 ) throw new TestException ( ) ; observer . onNext ( t ) ; @ Override public void onError ( Throwable e ) observer . onError ( e ) ; @ Override public void onComplete ( ) observer . onComplete ( ) ; ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; inOrder . verify ( observer ) . onNext ( 0L ) ; inOrder . verify ( observer ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
TestHelper . checkDisposed ( Observable . timer ( 1 , TimeUnit . DAYS ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try for ( int i = 0 ; i < 1000 ; i ++ ) Observable . timer ( 0 , TimeUnit . MILLISECONDS ) . blockingFirst ( ) ; assertTrue ( errors . toString ( ) , errors . isEmpty ( ) ) ; finally RxJavaPlugins . reset ( ) ; 
ScheduledExecutorService exec = Executors . newSingleThreadScheduledExecutor ( ) ; try for ( Scheduler s : new Scheduler [ ] Schedulers . single ( ) , Schedulers . computation ( ) , Schedulers . newThread ( ) , Schedulers . io ( ) , Schedulers . from ( exec , true ) ) final AtomicBoolean interrupted = new AtomicBoolean ( ) ; TestObserver < Long > to = Observable . timer ( 1 , TimeUnit . MILLISECONDS , s ) . map ( new Function < Long , Long > ( ) @ Override public Long apply ( Long v ) throws Exception try Thread . sleep ( 3000 ) ; catch ( InterruptedException ex ) interrupted . set ( true ) ; return v ; ) . test ( ) ; Thread . sleep ( 500 ) ; to . dispose ( ) ; Thread . sleep ( 500 ) ; assertTrue ( s . getClass ( ) . getSimpleName ( ) , interrupted . get ( ) ) ; finally exec . shutdown ( ) ; 
TestObserver < Long > to = new TestObserver < > ( ) ; to . onSubscribe ( Disposable . empty ( ) ) ; TimerObserver tm = new TimerObserver ( to ) ; tm . dispose ( ) ; tm . run ( ) ; to . assertEmpty ( ) ; 
Observable < String > w = Observable . empty ( ) ; Observable < String > take = w . takeLast ( 2 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; take . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . just ( "one" , "two" , "three" ) ; Observable < String > take = w . takeLast ( 2 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer ) ; take . subscribe ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "two" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "three" ) ; verify ( observer , never ( ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . just ( "one" ) ; Observable < String > take = w . takeLast ( 10 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; take . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . just ( "one" ) ; Observable < String > take = w . takeLast ( 0 ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; take . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( "one" ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable . just ( "one" ) . takeLast ( - 1 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 100000 ) . takeLast ( 1 ) . observeOn ( Schedulers . newThread ( ) ) . map ( newSlowProcessor ( ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertValue ( 100000 ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 100000 ) . takeLast ( Flowable . bufferSize ( ) * 4 ) . observeOn ( Schedulers . newThread ( ) ) . map ( newSlowProcessor ( ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; assertEquals ( Flowable . bufferSize ( ) * 4 , to . values ( ) . size ( ) ) ; 
return new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer i ) if ( c ++ < 100 ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) return i ; ; 
assertNull ( Observable . empty ( ) . count ( ) . filter ( new Predicate < Long > ( ) @ Override public boolean test ( Long v ) return false ; ) . blockingGet ( ) ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable . range ( 0 , 100000 ) . takeLast ( 100000 ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onStart ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer integer ) count . incrementAndGet ( ) ; cancel ( ) ; ) ; assertEquals ( 1 , count . get ( ) ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 10 ) . takeLast ( 5 ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . takeLast ( 5 ) ; ) ; 
Observable . error ( new TestException ( ) ) . takeLast ( 5 ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 10 ) . takeLast ( 5 ) . take ( 2 ) . test ( ) . assertResult ( 6 , 7 ) ; 
Observer < String > consumer = TestHelper . mockObserver ( ) ; Observable < String > producer = Observable . unsafeCreate ( new ObservableSource < String > ( ) private AtomicInteger count = new AtomicInteger ( 4 ) ; long last = System . currentTimeMillis ( ) ; @ Override public void subscribe ( Observer < ? super String > t1 ) t1 . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( count . get ( ) + " @ " + String . valueOf ( last - System . currentTimeMillis ( ) ) ) ; last = System . currentTimeMillis ( ) ; if ( count . getAndDecrement ( ) == 0 ) t1 . onNext ( "hello" ) ; t1 . onComplete ( ) ; else t1 . onError ( new RuntimeException ( ) ) ; ) ; TestObserver < String > to = new TestObserver < > ( consumer ) ; producer . retryWhen ( new Function < Observable < ? extends Throwable > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < ? extends Throwable > attempts ) return attempts . map ( new Function < Throwable , Tuple > ( ) @ Override public Tuple apply ( Throwable n ) return new Tuple ( 1L , n ) ; ) . scan ( new BiFunction < Tuple , Tuple , Tuple > ( ) @ Override public Tuple apply ( Tuple t , Tuple n ) return new Tuple ( t . count + n . count , n . n ) ; ) . flatMap ( new Function < Tuple , Observable < Long > > ( ) @ Override public Observable < Long > apply ( Tuple t ) System . out . println ( "Retry # " + t . count ) ; return t . count > 20 ? Observable . < Long > error ( t . n ) : Observable . timer ( t . count * 1L , TimeUnit . MILLISECONDS ) ; ) . cast ( Object . class ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; InOrder inOrder = inOrder ( consumer ) ; inOrder . verify ( consumer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( consumer , times ( 1 ) ) . onNext ( "hello" ) ; inOrder . verify ( consumer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
t1 . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( count . get ( ) + " @ " + String . valueOf ( last - System . currentTimeMillis ( ) ) ) ; last = System . currentTimeMillis ( ) ; if ( count . getAndDecrement ( ) == 0 ) t1 . onNext ( "hello" ) ; t1 . onComplete ( ) ; else t1 . onError ( new RuntimeException ( ) ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; int numRetries = 20 ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( numRetries ) ) ; origin . retry ( ) . subscribe ( new TestObserver < > ( observer ) ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( numRetries + 1 ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; int numRetries = 2 ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( numRetries ) ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; origin . retryWhen ( new Function < Observable < ? extends Throwable > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < ? extends Throwable > t1 ) return t1 . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Throwable , Object > ( ) @ Override public Object apply ( Throwable t1 ) return 1 ; ) . startWithItem ( 1 ) ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) e . printStackTrace ( ) ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 + numRetries ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; int numRetries = 2 ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( numRetries ) ) ; origin . retryWhen ( new Function < Observable < ? extends Throwable > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < ? extends Throwable > t1 ) return t1 . map ( new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable t1 ) return 0 ; ) . startWithItem ( 0 ) . cast ( Object . class ) ; ) . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( numRetries + 1 ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( 1 ) ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; origin . retryWhen ( new Function < Observable < ? extends Throwable > , Observable < ? > > ( ) @ Override public Observable < ? > apply ( Observable < ? extends Throwable > t1 ) return Observable . empty ( ) ; ) . subscribe ( to ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Exception . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( 2 ) ) ; origin . retryWhen ( new Function < Observable < ? extends Throwable > , Observable < ? > > ( ) @ Override public Observable < ? > apply ( Observable < ? extends Throwable > t1 ) return Observable . error ( new RuntimeException ( ) ) ; ) . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onSubscribe ( ( Disposable ) notNull ( ) ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final AtomicInteger inc = new AtomicInteger ( 0 ) ; ObservableSource < Integer > onSubscribe = new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; final int emit = inc . incrementAndGet ( ) ; observer . onNext ( emit ) ; observer . onComplete ( ) ; ; int first = Observable . unsafeCreate ( onSubscribe ) . retryWhen ( new Function < Observable < ? extends Throwable > , Observable < ? > > ( ) @ Override public Observable < ? > apply ( Observable < ? extends Throwable > attempt ) return attempt . zipWith ( Observable . just ( 1 ) , new BiFunction < Throwable , Integer , Void > ( ) @ Override public Void apply ( Throwable o , Integer integer ) return null ; ) ; ) . blockingFirst ( ) ; assertEquals ( "Observer did not receive the expected output" , 1 , first ) ; assertEquals ( "Subscribe was not called once" , 1 , inc . get ( ) ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; final int emit = inc . incrementAndGet ( ) ; observer . onNext ( emit ) ; observer . onComplete ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( 1 ) ) ; origin . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; 
int numRetries = 1 ; int numFailures = 2 ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( numFailures ) ) ; origin . retry ( numRetries ) . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 + numRetries ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verify ( observer , never ( ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
int numFailures = 1 ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( numFailures ) ) ; origin . retry ( 3 ) . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 + numFailures ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
int numFailures = 20 ; Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( numFailures ) ) ; origin . retry ( ) . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 + numFailures ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Consumer < Integer > record = mock ( Consumer . class ) ; InOrder inOrder = inOrder ( record ) ; Consumer < Integer > throwException = mock ( Consumer . class ) ; doThrow ( new RuntimeException ( ) ) . when ( throwException ) . accept ( Mockito . anyInt ( ) ) ; PublishSubject < Integer > subject = PublishSubject . create ( ) ; subject . doOnNext ( record ) . doOnNext ( throwException ) . retry ( ) . subscribe ( ) ; inOrder . verifyNoMoreInteractions ( ) ; subject . onNext ( 1 ) ; inOrder . verify ( record ) . accept ( 1 ) ; subject . onNext ( 2 ) ; inOrder . verify ( record ) . accept ( 2 ) ; subject . onNext ( 3 ) ; inOrder . verify ( record ) . accept ( 3 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishSubject < Integer > subject = PublishSubject . create ( ) ; final AtomicInteger count = new AtomicInteger ( 0 ) ; Disposable sub = subject . retry ( ) . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer n ) count . incrementAndGet ( ) ; ) ; subject . onNext ( 1 ) ; sub . dispose ( ) ; subject . onNext ( 2 ) ; assertEquals ( 1 , count . get ( ) ) ; 
final AtomicInteger subsCount = new AtomicInteger ( 0 ) ; ObservableSource < String > onSubscribe = new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) subsCount . incrementAndGet ( ) ; observer . onSubscribe ( Disposable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) subsCount . decrementAndGet ( ) ; ) ) ; ; Observable < String > stream = Observable . unsafeCreate ( onSubscribe ) ; Observable < String > streamWithRetry = stream . retry ( ) ; Disposable sub = streamWithRetry . subscribe ( ) ; assertEquals ( 1 , subsCount . get ( ) ) ; sub . dispose ( ) ; assertEquals ( 0 , subsCount . get ( ) ) ; streamWithRetry . subscribe ( ) ; assertEquals ( 1 , subsCount . get ( ) ) ; 
final AtomicInteger subsCount = new AtomicInteger ( 0 ) ; final TestObserver < String > to = new TestObserver < > ( ) ; ObservableSource < String > onSubscribe = new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) BooleanSubscription bs = new BooleanSubscription ( ) ; if ( ! bs . isCancelled ( ) ) subsCount . incrementAndGet ( ) ; observer . onError ( new RuntimeException ( "failed" ) ) ; bs . cancel ( ) ; else observer . onError ( new RuntimeException ( ) ) ; ; Observable . unsafeCreate ( onSubscribe ) . retry ( 3 ) . subscribe ( to ) ; assertEquals ( 4 , subsCount . get ( ) ) ; 
final AtomicInteger subsCount = new AtomicInteger ( 0 ) ; final TestObserver < String > to = new TestObserver < > ( ) ; ObservableSource < String > onSubscribe = new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; subsCount . incrementAndGet ( ) ; observer . onError ( new RuntimeException ( "failed" ) ) ; ; Observable . unsafeCreate ( onSubscribe ) . retry ( 1 ) . subscribe ( to ) ; assertEquals ( 2 , subsCount . get ( ) ) ; 
final AtomicInteger subsCount = new AtomicInteger ( 0 ) ; final TestObserver < String > to = new TestObserver < > ( ) ; ObservableSource < String > onSubscribe = new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; subsCount . incrementAndGet ( ) ; observer . onError ( new RuntimeException ( "failed" ) ) ; ; Observable . unsafeCreate ( onSubscribe ) . retry ( 0 ) . subscribe ( to ) ; assertEquals ( 1 , subsCount . get ( ) ) ; 
try latch . await ( ) ; catch ( InterruptedException e ) fail ( "Test interrupted" ) ; 
target . onComplete ( ) ; latch . countDown ( ) ; 
target . onError ( t ) ; latch . countDown ( ) ; 
Observer < Long > observer = TestHelper . mockObserver ( ) ; SlowObservable so = new SlowObservable ( 100 , 0 , "testUnsubscribeAfterError" ) ; Observable < Long > o = Observable . unsafeCreate ( so ) . retry ( 5 ) ; AsyncObserver < Long > async = new AsyncObserver < > ( observer ) ; o . subscribe ( async ) ; async . await ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; assertEquals ( "Start 6 threads, retry 5 then fail on 6" , 6 , so . efforts . get ( ) ) ; assertEquals ( "Only 1 active subscription" , 1 , so . maxActive . get ( ) ) ; 
Observer < Long > observer = TestHelper . mockObserver ( ) ; SlowObservable so = new SlowObservable ( 100 , 10 , "testTimeoutWithRetry" ) ; Observable < Long > o = Observable . unsafeCreate ( so ) . timeout ( 80 , TimeUnit . MILLISECONDS ) . retry ( 5 ) ; AsyncObserver < Long > async = new AsyncObserver < > ( observer ) ; o . subscribe ( async ) ; async . await ( ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , never ( ) ) . onComplete ( ) ; assertEquals ( "Start 6 threads, retry 5 then fail on 6" , 6 , so . efforts . get ( ) ) ; 
final int NUM_LOOPS = 1 ; for ( int j = 0 ; j < NUM_LOOPS ; j ++ ) final int NUM_RETRIES = Flowable . bufferSize ( ) * 2 ; for ( int i = 0 ; i < 400 ; i ++ ) Observer < String > observer = TestHelper . mockObserver ( ) ; Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( NUM_RETRIES ) ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; origin . retry ( ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; InOrder inOrder = inOrder ( observer ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( NUM_RETRIES + 1 ) ) . onNext ( "beginningEveryTime" ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( "onSuccessOnly" ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
final int NUM_LOOPS = 1 ; final int NUM_RETRIES = Flowable . bufferSize ( ) * 2 ; int ncpu = Runtime . getRuntime ( ) . availableProcessors ( ) ; ExecutorService exec = Executors . newFixedThreadPool ( Math . max ( ncpu / 2 , 2 ) ) ; try for ( int r = 0 ; r < NUM_LOOPS ; r ++ ) if ( r % 10 == 0 ) System . out . println ( "testRetryWithBackpressureParallelLoop -> " + r ) ; final AtomicInteger timeouts = new AtomicInteger ( ) ; final Map < Integer , List < String > > data = new ConcurrentHashMap < > ( ) ; int m = 5000 ; final CountDownLatch cdl = new CountDownLatch ( m ) ; for ( int i = 0 ; i < m ; i ++ ) final int j = i ; exec . execute ( new Runnable ( ) @ Override public void run ( ) final AtomicInteger nexts = new AtomicInteger ( ) ; try Observable < String > origin = Observable . unsafeCreate ( new FuncWithErrors ( NUM_RETRIES ) ) ; TestObserverEx < String > to = new TestObserverEx < > ( ) ; origin . retry ( ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 2500 , TimeUnit . MILLISECONDS ) ; List < String > onNextEvents = new ArrayList < > ( to . values ( ) ) ; if ( onNextEvents . size ( ) != NUM_RETRIES + 2 ) for ( Throwable t : to . errors ( ) ) onNextEvents . add ( t . toString ( ) ) ; for ( long err = to . completions ( ) ; err != 0 ; err -- ) onNextEvents . add ( "onComplete" ) ; data . put ( j , onNextEvents ) ; catch ( Throwable t ) timeouts . incrementAndGet ( ) ; System . out . println ( j + " | " + cdl . getCount ( ) + " !!! " + nexts . get ( ) ) ; cdl . countDown ( ) ; ) ; cdl . await ( ) ; assertEquals ( 0 , timeouts . get ( ) ) ; if ( data . size ( ) > 0 ) fail ( "Data content mismatch: " + allSequenceFrequency ( data ) ) ; finally exec . shutdown ( ) ; 
StringBuilder b = new StringBuilder ( ) ; for ( Map . Entry < Integer , List < T > > e : its . entrySet ( ) ) if ( b . length ( ) > 0 ) b . append ( ", " ) ; b . append ( e . getKey ( ) ) . append ( "={" ) ; b . append ( sequenceFrequency ( e . getValue ( ) ) ) ; b . append ( "}" ) ; return b ; 
StringBuilder sb = new StringBuilder ( ) ; Object prev = null ; int cnt = 0 ; for ( Object curr : it ) if ( sb . length ( ) > 0 ) if ( ! curr . equals ( prev ) ) if ( cnt > 1 ) sb . append ( " x " ) . append ( cnt ) ; cnt = 1 ; sb . append ( ", " ) ; sb . append ( curr ) ; else cnt ++ ; else sb . append ( curr ) ; cnt ++ ; prev = curr ; if ( cnt > 1 ) sb . append ( " x " ) . append ( cnt ) ; return sb ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; final int NUM_MSG = 1034 ; final AtomicInteger count = new AtomicInteger ( ) ; Observable < String > origin = Observable . range ( 0 , NUM_MSG ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t1 ) return "msg: " + count . incrementAndGet ( ) ; ) ; origin . retry ( ) . groupBy ( new Function < String , String > ( ) @ Override public String apply ( String t1 ) return t1 ; ) . flatMap ( new Function < GroupedObservable < String , String > , Observable < String > > ( ) @ Override public Observable < String > apply ( GroupedObservable < String , String > t1 ) return t1 . take ( 1 ) ; ) . subscribe ( new TestObserver < > ( observer ) ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( NUM_MSG ) ) . onNext ( any ( java . lang . String . class ) ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observer < String > observer = TestHelper . mockObserver ( ) ; final int NUM_MSG = 1034 ; final AtomicInteger count = new AtomicInteger ( ) ; Observable < String > origin = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > o ) o . onSubscribe ( Disposable . empty ( ) ) ; for ( int i = 0 ; i < NUM_MSG ; i ++ ) o . onNext ( "msg:" + count . incrementAndGet ( ) ) ; o . onComplete ( ) ; ) ; origin . retry ( ) . groupBy ( new Function < String , String > ( ) @ Override public String apply ( String t1 ) return t1 ; ) . flatMap ( new Function < GroupedObservable < String , String > , Observable < String > > ( ) @ Override public Observable < String > apply ( GroupedObservable < String , String > t1 ) return t1 . take ( 1 ) ; ) . subscribe ( new TestObserver < > ( observer ) ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( NUM_MSG ) ) . onNext ( any ( java . lang . String . class ) ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . retry ( new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable v ) throws Exception return true ; ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . retryUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) . take ( 5 ) . test ( ) . assertResult ( 1 , 1 , 1 , 1 , 1 ) ; 
try Observable . just ( 1 ) . retry ( - 99 , new Predicate < Throwable > ( ) @ Override public boolean test ( Throwable e ) throws Exception return true ; ) ; fail ( "Should have thrown" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "times >= 0 required but it was -99" , ex . getMessage ( ) ) ; 
final PublishSubject < Object > subject = PublishSubject . create ( ) ; final Disposable disposable = Observable . error ( new RuntimeException ( "Leak" ) ) . retryWhen ( new Function < Observable < Throwable > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Throwable > errors ) throws Exception return errors . switchMap ( new Function < Throwable , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Throwable ignore ) throws Exception return subject ; ) ; ) . subscribe ( ) ; assertTrue ( subject . hasObservers ( ) ) ; disposable . dispose ( ) ; assertFalse ( subject . hasObservers ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Observable < Integer > source = Observable . defer ( new Supplier < ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > get ( ) throws Exception if ( times . getAndIncrement ( ) < 4 ) return Observable . error ( new TestException ( ) ) ; return Observable . just ( 1 ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retry ( 5 ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Observable < Integer > source = Observable . defer ( new Supplier < ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > get ( ) throws Exception if ( times . getAndIncrement ( ) < 4 ) return Observable . error ( new TestException ( ) ) ; return Observable . just ( 1 ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retry ( 5 , Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Observable < Integer > source = Observable . defer ( new Supplier < ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > get ( ) throws Exception if ( times . getAndIncrement ( ) < 4 ) return Observable . error ( new TestException ( ) ) ; return Observable . just ( 1 ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retry ( new BiPredicate < Integer , Throwable > ( ) @ Override public boolean test ( Integer a , Throwable b ) throws Exception return a < 5 ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Observable < Integer > source = Observable . defer ( new Supplier < ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > get ( ) throws Exception if ( times . getAndIncrement ( ) < 4 ) return Observable . error ( new TestException ( ) ) ; return Observable . just ( 1 ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retryUntil ( new BooleanSupplier ( ) @ Override public boolean getAsBoolean ( ) throws Exception return false ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Observable < Integer > source = Observable . defer ( new Supplier < ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > get ( ) throws Exception if ( times . get ( ) < 4 ) return Observable . error ( new TestException ( ) ) ; return Observable . just ( 1 ) ; ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retryWhen ( new Function < Observable < Throwable > , ObservableSource < ? > > ( ) @ Override public ObservableSource < ? > apply ( Observable < Throwable > e ) throws Exception return e . takeWhile ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) throws Exception return times . getAndIncrement ( ) < 4 ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicInteger times = new AtomicInteger ( ) ; Observable < Integer > source = Observable . < Integer > error ( new TestException ( ) ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; source . retryWhen ( new Function < Observable < Throwable > , ObservableSource < ? > > ( ) @ Override public ObservableSource < ? > apply ( Observable < Throwable > e ) throws Exception return e . takeWhile ( new Predicate < Object > ( ) @ Override public boolean test ( Object v ) throws Exception return times . getAndIncrement ( ) < 4 ; ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 0 , counter . get ( ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; final TestException error = new TestException ( ) ; try final PublishSubject < Integer > source = PublishSubject . create ( ) ; final PublishSubject < Integer > signaller = PublishSubject . create ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) TestObserver < Integer > to = source . take ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw error ; ) . retryWhen ( new Function < Observable < Throwable > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Throwable > v ) throws Exception return signaller ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) source . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) signaller . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . dispose ( ) ; if ( ! errors . isEmpty ( ) ) for ( Throwable e : errors ) e . printStackTrace ( ) ; fail ( errors + "" ) ; finally RxJavaPlugins . reset ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observer < Integer > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; inOrder . verify ( o , never ( ) ) . onNext ( anyInt ( ) ) ; other . onNext ( 1 ) ; inOrder . verify ( o , never ( ) ) . onNext ( anyInt ( ) ) ; source . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( ( 2 << 8 ) + 1 ) ; other . onNext ( 2 ) ; inOrder . verify ( o , never ( ) ) . onNext ( anyInt ( ) ) ; other . onComplete ( ) ; inOrder . verify ( o , never ( ) ) . onComplete ( ) ; source . onNext ( 3 ) ; inOrder . verify ( o ) . onNext ( ( 3 << 8 ) + 2 ) ; source . onComplete ( ) ; inOrder . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; result . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( 1 ) ; source . onComplete ( ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; result . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; source . onNext ( 1 ) ; source . onComplete ( ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; result . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( 1 ) ; source . onNext ( 1 ) ; to . dispose ( ) ; to . assertValue ( ( 1 << 8 ) + 1 ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; result . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( 1 ) ; source . onNext ( 1 ) ; source . onError ( new TestException ( ) ) ; to . assertTerminated ( ) ; to . assertValue ( ( 1 << 8 ) + 1 ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; result . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( 1 ) ; source . onNext ( 1 ) ; other . onError ( new TestException ( ) ) ; to . assertTerminated ( ) ; to . assertValue ( ( 1 << 8 ) + 1 ) ; to . assertNotComplete ( ) ; to . assertError ( TestException . class ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER_ERROR ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; result . subscribe ( to ) ; assertTrue ( source . hasObservers ( ) ) ; assertTrue ( other . hasObservers ( ) ) ; other . onNext ( 1 ) ; source . onNext ( 1 ) ; to . assertTerminated ( ) ; to . assertNotComplete ( ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; assertFalse ( source . hasObservers ( ) ) ; assertFalse ( other . hasObservers ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > other = PublishSubject . create ( ) ; Observable < Integer > result = source . withLatestFrom ( other , COMBINER ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; result . subscribe ( to ) ; source . onComplete ( ) ; 
PublishSubject < String > ps1 = PublishSubject . create ( ) ; PublishSubject < String > ps2 = PublishSubject . create ( ) ; PublishSubject < String > ps3 = PublishSubject . create ( ) ; PublishSubject < String > main = PublishSubject . create ( ) ; TestObserver < String > to = new TestObserver < > ( ) ; main . withLatestFrom ( new Observable [ ] ps1 , ps2 , ps3 , toArray ) . subscribe ( to ) ; main . onNext ( "1" ) ; to . assertNoValues ( ) ; ps1 . onNext ( "a" ) ; to . assertNoValues ( ) ; ps2 . onNext ( "A" ) ; to . assertNoValues ( ) ; ps3 . onNext ( "=" ) ; to . assertNoValues ( ) ; main . onNext ( "2" ) ; to . assertValues ( "[2, a, A, =]" ) ; ps2 . onNext ( "B" ) ; to . assertValues ( "[2, a, A, =]" ) ; ps3 . onComplete ( ) ; to . assertValues ( "[2, a, A, =]" ) ; ps1 . onNext ( "b" ) ; main . onNext ( "3" ) ; to . assertValues ( "[2, a, A, =]" , "[3, b, B, =]" ) ; main . onComplete ( ) ; to . assertValues ( "[2, a, A, =]" , "[3, b, B, =]" ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; assertFalse ( "ps1 has subscribers?" , ps1 . hasObservers ( ) ) ; assertFalse ( "ps2 has subscribers?" , ps2 . hasObservers ( ) ) ; assertFalse ( "ps3 has subscribers?" , ps3 . hasObservers ( ) ) ; 
PublishSubject < String > ps1 = PublishSubject . create ( ) ; PublishSubject < String > ps2 = PublishSubject . create ( ) ; PublishSubject < String > ps3 = PublishSubject . create ( ) ; PublishSubject < String > main = PublishSubject . create ( ) ; TestObserver < String > to = new TestObserver < > ( ) ; main . withLatestFrom ( Arrays . < Observable < ? > > asList ( ps1 , ps2 , ps3 ) , toArray ) . subscribe ( to ) ; main . onNext ( "1" ) ; to . assertNoValues ( ) ; ps1 . onNext ( "a" ) ; to . assertNoValues ( ) ; ps2 . onNext ( "A" ) ; to . assertNoValues ( ) ; ps3 . onNext ( "=" ) ; to . assertNoValues ( ) ; main . onNext ( "2" ) ; to . assertValues ( "[2, a, A, =]" ) ; ps2 . onNext ( "B" ) ; to . assertValues ( "[2, a, A, =]" ) ; ps3 . onComplete ( ) ; to . assertValues ( "[2, a, A, =]" ) ; ps1 . onNext ( "b" ) ; main . onNext ( "3" ) ; to . assertValues ( "[2, a, A, =]" , "[3, b, B, =]" ) ; main . onComplete ( ) ; to . assertValues ( "[2, a, A, =]" , "[3, b, B, =]" ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; assertFalse ( "ps1 has subscribers?" , ps1 . hasObservers ( ) ) ; assertFalse ( "ps2 has subscribers?" , ps2 . hasObservers ( ) ) ; assertFalse ( "ps3 has subscribers?" , ps3 . hasObservers ( ) ) ; 
for ( String val : new String [ ] "1" ) int n = 35 ; for ( int i = 0 ; i < n ; i ++ ) List < Observable < ? > > sources = new ArrayList < > ( ) ; List < String > expected = new ArrayList < > ( ) ; expected . add ( val ) ; for ( int j = 0 ; j < i ; j ++ ) sources . add ( Observable . just ( val ) ) ; expected . add ( String . valueOf ( val ) ) ; TestObserver < String > to = new TestObserver < > ( ) ; PublishSubject < String > main = PublishSubject . create ( ) ; main . withLatestFrom ( sources , toArray ) . subscribe ( to ) ; to . assertNoValues ( ) ; main . onNext ( val ) ; main . onComplete ( ) ; to . assertValue ( expected . toString ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < String > to = new TestObserver < > ( ) ; Observable . range ( 1 , 3 ) . withLatestFrom ( new Observable < ? > [ ] Observable . just ( 1 ) , Observable . empty ( ) , toArray ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < String > to = new TestObserver < > ( ) ; Observable . range ( 1 , 3 ) . withLatestFrom ( new Observable < ? > [ ] Observable . just ( 1 ) , Observable . error ( new TestException ( ) ) , toArray ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
TestObserver < String > to = new TestObserver < > ( ) ; Observable . error ( new TestException ( ) ) . withLatestFrom ( new Observable < ? > [ ] Observable . just ( 1 ) , Observable . just ( 1 ) , toArray ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
Observable < Integer > just = Observable . just ( 1 ) ; TestObserver < List < Integer > > to = new TestObserver < > ( ) ; just . withLatestFrom ( just , just , new Function3 < Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer a , Integer b , Integer c ) return Arrays . asList ( a , b , c ) ; ) . subscribe ( to ) ; to . assertValue ( Arrays . asList ( 1 , 1 , 1 ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable < Integer > just = Observable . just ( 1 ) ; TestObserver < List < Integer > > to = new TestObserver < > ( ) ; just . withLatestFrom ( just , just , just , new Function4 < Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer a , Integer b , Integer c , Integer d ) return Arrays . asList ( a , b , c , d ) ; ) . subscribe ( to ) ; to . assertValue ( Arrays . asList ( 1 , 1 , 1 , 1 ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable < Integer > just = Observable . just ( 1 ) ; TestObserver < List < Integer > > to = new TestObserver < > ( ) ; just . withLatestFrom ( just , just , just , just , new Function5 < Integer , Integer , Integer , Integer , Integer , List < Integer > > ( ) @ Override public List < Integer > apply ( Integer a , Integer b , Integer c , Integer d , Integer e ) return Arrays . asList ( a , b , c , d , e ) ; ) . subscribe ( to ) ; to . assertValue ( Arrays . asList ( 1 , 1 , 1 , 1 , 1 ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . withLatestFrom ( Observable . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a ; ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . withLatestFrom ( Observable . just ( 2 ) , Observable . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception return a ; ) ) ; 
Observable . just ( 1 ) . withLatestFrom ( new CrashingMappedIterable < > ( 1 , 100 , 100 , new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . just ( 2 ) ; ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] a ) throws Exception return a ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "iterator()" ) ; 
Observable . just ( 1 ) . withLatestFrom ( Observable . just ( 2 ) , Observable . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; . withLatestFrom ( Observable . just ( 2 ) , Observable . just ( 3 ) , new Function3 < Integer , Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b , Integer c ) throws Exception return a ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . just ( 1 ) . withLatestFrom ( Observable . just ( 2 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . just ( 1 ) . withLatestFrom ( Arrays . asList ( Observable . just ( 2 ) , Observable . just ( 3 ) ) , new Function < Object [ ] , Object > ( ) @ Override public Object apply ( Object [ ] o ) throws Exception return null ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . just ( 1 ) . withLatestFrom ( new Observable [ 0 ] , Functions . justFunction ( null ) ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The combiner returned a null value" ) ; 
Observable . just ( "one" ) . takeLast ( - 1 , 1 , TimeUnit . SECONDS ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Object > source = PublishSubject . create ( ) ; Observable < Object > result = source . takeLast ( 1000 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( o , times ( 1 ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Object > source = PublishSubject . create ( ) ; Observable < Object > result = source . takeLast ( 1000 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 1250 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; inOrder . verify ( o , times ( 1 ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Object > source = PublishSubject . create ( ) ; Observable < Object > result = source . takeLast ( 2 , 1000 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( o , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verify ( o , times ( 1 ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Object > source = PublishSubject . create ( ) ; Observable < Object > result = source . takeLast ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onError ( new TestException ( ) ) ; inOrder . verify ( o , times ( 1 ) ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Object > source = PublishSubject . create ( ) ; Observable < Object > result = source . takeLast ( 0 , 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( o ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 250 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; inOrder . verify ( o , times ( 1 ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable . just ( 1 , 2 ) . takeLast ( 1 , 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( 2 ) ; 
Observable . just ( 1 , 2 ) . takeLast ( 1 , TimeUnit . MINUTES ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . just ( 1 , 2 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . takeLast ( 1 , TimeUnit . MINUTES , true ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Observable . just ( 1 , 2 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . takeLast ( 1 , TimeUnit . MINUTES , Schedulers . io ( ) , true ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . takeLast ( 1 , TimeUnit . MINUTES ) ) ; 
Observable . range ( 1 , 1000 ) . takeLast ( 1 , TimeUnit . DAYS ) . take ( 500 ) . observeOn ( Schedulers . single ( ) , true , 1 ) . to ( TestHelper . < Integer > testConsumer ( ) ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertNoErrors ( ) . assertComplete ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . takeLast ( 1 , TimeUnit . DAYS ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TimesteppingScheduler scheduler = new TimesteppingScheduler ( ) ; scheduler . stepEnabled = false ; PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . takeLast ( 2 , TimeUnit . SECONDS , scheduler ) . test ( ) ; ps . onNext ( 1 ) ; ps . onNext ( 2 ) ; ps . onNext ( 3 ) ; ps . onNext ( 4 ) ; scheduler . stepEnabled = true ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 , 4 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . takeLast ( 1 , TimeUnit . SECONDS ) ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Maybe . < Integer > fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . onNext ( 100 ) ; ) ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Maybe . just ( 100 ) ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . < Integer > error ( new TestException ( ) ) . concatWith ( Maybe . < Integer > fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . onNext ( 100 ) ; ) ) . subscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Maybe . < Integer > error ( new TestException ( ) ) ) . subscribe ( to ) ; to . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Maybe . < Integer > fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . onNext ( 100 ) ; ) ) . take ( 3 ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 ) ; 
MaybeSubject < Object > other = MaybeSubject . create ( ) ; TestObserver < Object > to = Observable . empty ( ) . concatWith ( other ) . test ( ) ; assertTrue ( other . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( other . hasObservers ( ) ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) Disposable bs1 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onNext ( 1 ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; assertTrue ( bs1 . isDisposed ( ) ) ; . concatWith ( Maybe . just ( 100 ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) Disposable bs1 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; Disposable bs2 = Disposable . empty ( ) ; observer . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertTrue ( bs2 . isDisposed ( ) ) ; observer . onComplete ( ) ; . concatWith ( Maybe . < Integer > empty ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . empty ( ) . concatWith ( new Maybe < Integer > ( ) @ Override protected void subscribeActual ( MaybeObserver < ? super Integer > observer ) Disposable bs1 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; Disposable bs2 = Disposable . empty ( ) ; observer . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertTrue ( bs2 . isDisposed ( ) ) ; observer . onComplete ( ) ; ) . test ( ) . assertResult ( ) ; 
Observable < String > obs = Observable . just ( "one" , "two" , "three" ) ; Iterator < String > it = obs . blockingIterable ( ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "two" , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "three" , it . next ( ) ) ; assertFalse ( it . hasNext ( ) ) ; 
Observable < String > obs = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "one" ) ; observer . onError ( new TestException ( ) ) ; ) ; Iterator < String > it = obs . blockingIterable ( ) . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( "one" , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; it . next ( ) ; 
BlockingObservableIterator < Integer > it = new BlockingObservableIterator < > ( 128 ) ; assertFalse ( it . isDisposed ( ) ) ; it . dispose ( ) ; assertTrue ( it . isDisposed ( ) ) ; 
BlockingObservableIterator < Integer > it = new BlockingObservableIterator < > ( 128 ) ; try Thread . currentThread ( ) . interrupt ( ) ; it . hasNext ( ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; 
BlockingObservableIterator < Integer > it = new BlockingObservableIterator < > ( 128 ) ; it . onComplete ( ) ; it . next ( ) ; 
BlockingObservableIterator < Integer > it = new BlockingObservableIterator < > ( 128 ) ; it . remove ( ) ; 
Iterator < Integer > it = PublishSubject . < Integer > create ( ) . blockingIterable ( ) . iterator ( ) ; ( ( Disposable ) it ) . dispose ( ) ; assertFalse ( it . hasNext ( ) ) ; it . next ( ) ; 
final Iterator < Integer > it = PublishSubject . < Integer > create ( ) . blockingIterable ( ) . iterator ( ) ; Schedulers . single ( ) . scheduleDirect ( new Runnable ( ) @ Override public void run ( ) ( ( Disposable ) it ) . dispose ( ) ; , 1 , TimeUnit . SECONDS ) ; assertFalse ( it . hasNext ( ) ) ; 
Iterator < Object > it = Observable . error ( new TestException ( ) ) . blockingIterable ( ) . iterator ( ) ; ( ( Disposable ) it ) . dispose ( ) ; it . hasNext ( ) ; 
Observable < String > w = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Observable < List < String > > observable = w . toList ( ) . toObservable ( ) ; Observer < List < String > > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( Arrays . asList ( "one" , "two" , "three" ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Observable < List < String > > observable = w . toList ( ) . toObservable ( ) ; Observer < List < String > > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( Arrays . asList ( "one" , "two" , "three" ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Observable < List < String > > observable = w . toList ( ) . toObservable ( ) ; Observer < List < String > > o1 = TestHelper . mockObserver ( ) ; observable . subscribe ( o1 ) ; Observer < List < String > > o2 = TestHelper . mockObserver ( ) ; observable . subscribe ( o2 ) ; List < String > expected = Arrays . asList ( "one" , "two" , "three" ) ; verify ( o1 , times ( 1 ) ) . onNext ( expected ) ; verify ( o1 , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o1 , times ( 1 ) ) . onComplete ( ) ; verify ( o2 , times ( 1 ) ) . onNext ( expected ) ; verify ( o2 , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o2 , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > o = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; List < String > actual = o . toList ( ) . toObservable ( ) . blockingFirst ( ) ; Assert . assertEquals ( Arrays . asList ( "one" , "two" , "three" ) , actual ) ; 
Observable . range ( 1 , 10 ) . toList ( 4 ) . toObservable ( ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) ; 
Observable < String > w = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Single < List < String > > single = w . toList ( ) ; SingleObserver < List < String > > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( Arrays . asList ( "one" , "two" , "three" ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > w = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Single < List < String > > single = w . toList ( ) ; SingleObserver < List < String > > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( Arrays . asList ( "one" , "two" , "three" ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > w = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; Single < List < String > > single = w . toList ( ) ; SingleObserver < List < String > > o1 = TestHelper . mockSingleObserver ( ) ; single . subscribe ( o1 ) ; SingleObserver < List < String > > o2 = TestHelper . mockSingleObserver ( ) ; single . subscribe ( o2 ) ; List < String > expected = Arrays . asList ( "one" , "two" , "three" ) ; verify ( o1 , times ( 1 ) ) . onSuccess ( expected ) ; verify ( o1 , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( o2 , times ( 1 ) ) . onSuccess ( expected ) ; verify ( o2 , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > o = Observable . fromIterable ( Arrays . asList ( "one" , "two" , "three" ) ) ; List < String > actual = o . toList ( ) . blockingGet ( ) ; Assert . assertEquals ( Arrays . asList ( "one" , "two" , "three" ) , actual ) ; 
try cb . await ( ) ; catch ( InterruptedException ex ) ex . printStackTrace ( ) ; catch ( BrokenBarrierException ex ) ex . printStackTrace ( ) ; 
Observable . range ( 1 , 10 ) . toList ( 4 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . toList ( ) . toObservable ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . toList ( ) ) ; 
Observable . error ( new TestException ( ) ) . toList ( ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . toList ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception return null ; ) . toObservable ( ) . to ( TestHelper . < Collection < Integer > > testConsumer ( ) ) . assertFailure ( NullPointerException . class ) . assertErrorMessage ( ExceptionHelper . nullWarning ( "The collectionSupplier returned a null Collection." ) ) ; 
Observable . just ( 1 ) . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . toList ( new Supplier < Collection < Integer > > ( ) @ Override public Collection < Integer > get ( ) throws Exception return null ; ) . to ( TestHelper . < Collection < Integer > > testConsumer ( ) ) . assertFailure ( NullPointerException . class ) . assertErrorMessage ( ExceptionHelper . nullWarning ( "The collectionSupplier returned a null Collection." ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < List < Object > > > ( ) @ Override public Observable < List < Object > > apply ( Observable < Object > f ) throws Exception return f . toList ( ) . toObservable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Object > , Single < List < Object > > > ( ) @ Override public Single < List < Object > > apply ( Observable < Object > f ) throws Exception return f . toList ( ) ; ) ; 
TestObservable f = new TestObservable ( "one" ) ; Observable < String > w = Observable . unsafeCreate ( f ) ; final AtomicReference < Throwable > capturedException = new AtomicReference < > ( ) ; Observable < String > observable = w . onErrorReturn ( new Function < Throwable , String > ( ) @ Override public String apply ( Throwable e ) capturedException . set ( e ) ; return "failure" ; ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; try f . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onNext ( "failure" ) ; assertNotNull ( capturedException . get ( ) ) ; 
TestObservable f = new TestObservable ( "one" ) ; Observable < String > w = Observable . unsafeCreate ( f ) ; final AtomicReference < Throwable > capturedException = new AtomicReference < > ( ) ; Observable < String > observable = w . onErrorReturn ( new Function < Throwable , String > ( ) @ Override public String apply ( Throwable e ) capturedException . set ( e ) ; throw new RuntimeException ( "exception from function" ) ; ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; try f . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 0 ) ) . onComplete ( ) ; assertNotNull ( capturedException . get ( ) ) ; 
Observable < String > w = Observable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; w = w . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; System . out . println ( "BadMapper:" + s ) ; return s ; ) ; Observable < String > observable = w . onErrorReturn ( new Function < Throwable , String > ( ) @ Override public String apply ( Throwable t1 ) return "resume" ; ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; TestObserver < String > to = new TestObserver < > ( observer ) ; observable . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onNext ( "resume" ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 0 , 100000 ) . onErrorReturn ( new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable t1 ) return 1 ; ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t1 ) if ( c ++ <= 1 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; System . out . println ( "TestObservable subscribed to ..." ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestObservable thread" ) ; for ( String s : values ) System . out . println ( "TestObservable onNext: " + s ) ; observer . onNext ( s ) ; throw new RuntimeException ( "Forced Failure" ) ; catch ( Throwable e ) observer . onError ( e ) ; ) ; System . out . println ( "starting TestObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestObservable thread" ) ; 
Observable . error ( new TestException ( ) ) . onErrorReturnItem ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . onErrorReturnItem ( 1 ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > f ) throws Exception return f . onErrorReturnItem ( 1 ) ; ) ; 
Observable < Integer > source = Observable . just ( 1 , 2 , 3 ) ; Observable < Integer > observable = source . defaultIfEmpty ( 10 ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( 10 ) ; verify ( observer ) . onNext ( 1 ) ; verify ( observer ) . onNext ( 2 ) ; verify ( observer ) . onNext ( 3 ) ; verify ( observer ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > source = Observable . empty ( ) ; Observable < Integer > observable = source . defaultIfEmpty ( 10 ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer ) . onNext ( 10 ) ; verify ( observer ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable . range ( 1 , 5 ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer t ) return Observable . range ( t , 2 ) ; ) . test ( ) . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
Observable . range ( 1 , 5 ) . concatMapEagerDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer t ) return Observable . range ( t , 2 ) ; , false ) . test ( ) . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
Observable . range ( 1 , 5 ) . concatMapEagerDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer t ) return Observable . range ( t , 2 ) ; , true ) . test ( ) . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; final PublishSubject < Integer > inner = PublishSubject . create ( ) ; TestObserverEx < Integer > to = main . concatMapEagerDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer t ) return inner ; , false ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; main . onNext ( 1 ) ; inner . onNext ( 2 ) ; to . assertValue ( 2 ) ; main . onError ( new TestException ( "Forced failure" ) ) ; to . assertNoErrors ( ) ; inner . onNext ( 3 ) ; inner . onComplete ( ) ; to . assertFailureAndMessage ( TestException . class , "Forced failure" , 2 , 3 ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; final PublishSubject < Integer > inner = PublishSubject . create ( ) ; TestObserverEx < Integer > to = main . concatMapEagerDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer t ) return inner ; , true ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; main . onNext ( 1 ) ; main . onNext ( 2 ) ; inner . onNext ( 2 ) ; to . assertValue ( 2 ) ; main . onError ( new TestException ( "Forced failure" ) ) ; to . assertNoErrors ( ) ; inner . onNext ( 3 ) ; inner . onComplete ( ) ; to . assertFailureAndMessage ( TestException . class , "Forced failure" , 2 , 3 , 2 , 3 ) ; 
PublishSubject < Integer > main = PublishSubject . create ( ) ; final PublishSubject < Integer > inner = PublishSubject . create ( ) ; TestObserverEx < Integer > to = main . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer t ) return inner ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; main . onNext ( 1 ) ; main . onNext ( 2 ) ; inner . onNext ( 2 ) ; to . assertValue ( 2 ) ; main . onError ( new TestException ( "Forced failure" ) ) ; assertFalse ( "inner has subscribers?" , inner . hasObservers ( ) ) ; inner . onNext ( 3 ) ; inner . onComplete ( ) ; to . assertFailureAndMessage ( TestException . class , "Forced failure" , 2 ) ; 
Observable . range ( 1 , 2 * Observable . bufferSize ( ) ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) return Observable . just ( 1 ) ; ) . test ( ) . assertValueCount ( 2 * Observable . bufferSize ( ) ) . assertNoErrors ( ) . assertComplete ( ) ; 
to = new TestObserver < > ( ) ; 
Observable . range ( 1 , 100 ) . concatMapEager ( toJust ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertValueCount ( 100 ) ; to . assertComplete ( ) ; 
Observable . range ( 1 , 100 ) . concatMapEager ( toRange ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertValueCount ( 200 ) ; to . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Observable . concatArrayEager ( source , source ) . subscribe ( to ) ; Assert . assertEquals ( 2 , count . get ( ) ) ; to . assertValueCount ( count . get ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Observable . concatArrayEager ( source , source , source ) . subscribe ( to ) ; Assert . assertEquals ( 3 , count . get ( ) ) ; to . assertValueCount ( count . get ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Observable . concatArrayEager ( source , source , source , source ) . subscribe ( to ) ; Assert . assertEquals ( 4 , count . get ( ) ) ; to . assertValueCount ( count . get ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Observable . concatArrayEager ( source , source , source , source , source ) . subscribe ( to ) ; Assert . assertEquals ( 5 , count . get ( ) ) ; to . assertValueCount ( count . get ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Observable . concatArrayEager ( source , source , source , source , source , source ) . subscribe ( to ) ; Assert . assertEquals ( 6 , count . get ( ) ) ; to . assertValueCount ( count . get ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Observable . concatArrayEager ( source , source , source , source , source , source , source ) . subscribe ( to ) ; Assert . assertEquals ( 7 , count . get ( ) ) ; to . assertValueCount ( count . get ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Observable . concatArrayEager ( source , source , source , source , source , source , source , source ) . subscribe ( to ) ; Assert . assertEquals ( 8 , count . get ( ) ) ; to . assertValueCount ( count . get ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Observable . concatArrayEager ( source , source , source , source , source , source , source , source , source ) . subscribe ( to ) ; Assert . assertEquals ( 9 , count . get ( ) ) ; to . assertValueCount ( count . get ( ) ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable . < Integer > error ( new TestException ( ) ) . concatMapEager ( toJust ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; Observable . concatArrayEager ( Observable . just ( 1 ) , ps ) . subscribe ( to ) ; ps . onError ( new TestException ( ) ) ; to . assertValue ( 1 ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
Observable . concatArrayEager ( Observable . empty ( ) , Observable . empty ( ) ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable . just ( 1 ) . concatMapEager ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) throw new TestException ( ) ; ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( TestException . class ) ; 
Observable . just ( 1 ) . concatMapEager ( toJust , 0 , Observable . bufferSize ( ) ) ; 
Observable . just ( 1 ) . concatMapEager ( toJust , Observable . bufferSize ( ) , 0 ) ; 
Observable . range ( 1 , 2 ) . concatMapEager ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return Observable . range ( 1 , 1000 ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . observeOn ( Schedulers . newThread ( ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertValueCount ( 2000 ) ; 
final PublishSubject < Integer > subject = PublishSubject . create ( ) ; final AtomicBoolean once = new AtomicBoolean ( ) ; subject . concatMapEager ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return Observable . just ( t ) ; ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) if ( once . compareAndSet ( false , true ) ) subject . onNext ( 2 ) ; ) . subscribe ( to ) ; subject . onNext ( 1 ) ; to . assertNoErrors ( ) ; to . assertNotComplete ( ) ; to . assertValues ( 1 , 2 ) ; 
for ( int i = 2 ; i < 10 ; i ++ ) Observable < Integer > [ ] obs = new Observable [ i ] ; Arrays . fill ( obs , Observable . just ( 1 ) ) ; Integer [ ] expected = new Integer [ i ] ; Arrays . fill ( expected , 1 ) ; Method m = Observable . class . getMethod ( "concatArrayEager" , ObservableSource [ ] . class ) ; TestObserver < Integer > to = TestObserver . create ( ) ; ( ( Observable < Integer > ) m . invoke ( null , new Object [ ] obs ) ) . subscribe ( to ) ; to . assertValues ( expected ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable < Integer > source = Observable . just ( 1 ) ; TestObserver < Integer > to = TestObserver . create ( ) ; Observable . concatEager ( Arrays . asList ( source , source , source ) , 1 , 1 ) . subscribe ( to ) ; to . assertValues ( 1 , 1 , 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable < Integer > source = Observable . just ( 1 ) ; TestObserver < Integer > to = TestObserver . create ( ) ; Observable . concatEager ( Observable . just ( source , source , source ) ) . subscribe ( to ) ; to . assertValues ( 1 , 1 , 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable < Integer > source = Observable . just ( 1 ) ; TestObserver < Integer > to = TestObserver . create ( ) ; Observable . concatEager ( Observable . just ( source , source , source ) , 1 , 1 ) . subscribe ( to ) ; to . assertValues ( 1 , 1 , 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
Observable < Integer > source = Observable . just ( 1 ) ; try Observable . concatEager ( Arrays . asList ( source , source , source ) , 1 , - 99 ) ; catch ( IllegalArgumentException ex ) assertEquals ( "bufferSize > 0 required but it was -99" , ex . getMessage ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) ; try Observable . just ( source , source , source ) . concatMapEager ( ( Function ) Functions . identity ( ) , 10 , - 99 ) ; catch ( IllegalArgumentException ex ) assertEquals ( "bufferSize > 0 required but it was -99" , ex . getMessage ( ) ) ; 
Observable . concatEager ( Arrays . asList ( Observable . just ( 1 ) , Observable . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( 1 , 2 ) ; ) ) ; 
Observable . < Integer > empty ( ) . hide ( ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( 1 , 2 ) ; ) . test ( ) . assertResult ( ) ; 
Observable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . error ( new TestException ( ) ) ; , 1 , 128 ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception throw new TestException ( ) ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserverEx < Integer > to = ps1 . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return ps2 ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; ps1 . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ps2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertSubscribed ( ) . assertNoValues ( ) . assertNotComplete ( ) ; Throwable ex = to . errors ( ) . get ( 0 ) ; if ( ex instanceof CompositeException ) List < Throwable > es = TestHelper . errorList ( to ) ; TestHelper . assertError ( es , 0 , TestException . class ) ; TestHelper . assertError ( es , 1 , TestException . class ) ; else to . assertError ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps1 . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . never ( ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps1 . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertEmpty ( ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception to . dispose ( ) ; return Observable . never ( ) ; , 1 , 128 ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
Observable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . range ( 1 , 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . onNext ( 1 ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; us . onError ( new TestException ( ) ) ; ; Observable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return us ; , 1 , 128 ) . subscribe ( to ) ; to . assertFailure ( TestException . class , 1 ) ; 
UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . onNext ( 1 ) ; us . onComplete ( ) ; us . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . just ( 1 ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . concatMapEager ( new Function < Object , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Object v ) throws Exception return Observable . just ( v ) ; ) ; ) ; 
Observable . just ( 1 , 2 , 3 , 4 , 5 ) . concatMapEager ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer i ) throws Exception return i == 3 ? Observable . just ( i ) : Observable . just ( i ) . delay ( 1 , TimeUnit . MILLISECONDS , Schedulers . io ( ) ) ; ) . observeOn ( Schedulers . io ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
List < Integer > [ ] list = new ArrayList [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) List < Integer > lst = new ArrayList < > ( ) ; list [ i ] = lst ; for ( int k = 1 ; k <= 10 ; k ++ ) lst . add ( ( i ) * 10 + k ) ; Observable . range ( 1 , 1000 ) . buffer ( 10 ) . concatMapEager ( new Function < List < Integer > , ObservableSource < List < Integer > > > ( ) @ Override public ObservableSource < List < Integer > > apply ( List < Integer > v ) throws Exception return Observable . just ( v ) . subscribeOn ( Schedulers . io ( ) ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception Thread . sleep ( new Random ( ) . nextInt ( 20 ) ) ; ) ; , 2 , 3 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( list ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; PublishSubject < Integer > ps3 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . concatArrayEagerDelayError ( ps1 , ps2 , ps3 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps1 . hasObservers ( ) ) ; assertTrue ( ps2 . hasObservers ( ) ) ; assertTrue ( ps3 . hasObservers ( ) ) ; ps2 . onNext ( 2 ) ; ps2 . onComplete ( ) ; to . assertEmpty ( ) ; ps1 . onNext ( 1 ) ; to . assertValuesOnly ( 1 ) ; ps1 . onComplete ( ) ; to . assertValuesOnly ( 1 , 2 ) ; ps3 . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; PublishSubject < Integer > ps3 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . concatArrayEagerDelayError ( 2 , 2 , ps1 , ps2 , ps3 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps1 . hasObservers ( ) ) ; assertTrue ( ps2 . hasObservers ( ) ) ; assertFalse ( ps3 . hasObservers ( ) ) ; ps2 . onNext ( 2 ) ; ps2 . onComplete ( ) ; to . assertEmpty ( ) ; ps1 . onNext ( 1 ) ; to . assertValuesOnly ( 1 ) ; ps1 . onComplete ( ) ; assertTrue ( ps3 . hasObservers ( ) ) ; to . assertValuesOnly ( 1 , 2 ) ; ps3 . onComplete ( ) ; to . assertResult ( 1 , 2 ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; PublishSubject < Integer > ps3 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . concatArrayEagerDelayError ( 2 , 2 , ps1 , ps2 , ps3 ) . test ( ) ; to . assertEmpty ( ) ; assertTrue ( ps1 . hasObservers ( ) ) ; assertTrue ( ps2 . hasObservers ( ) ) ; assertFalse ( ps3 . hasObservers ( ) ) ; ps2 . onNext ( 2 ) ; ps2 . onError ( new TestException ( ) ) ; to . assertEmpty ( ) ; ps1 . onNext ( 1 ) ; to . assertValuesOnly ( 1 ) ; ps1 . onComplete ( ) ; assertTrue ( ps3 . hasObservers ( ) ) ; to . assertValuesOnly ( 1 , 2 ) ; ps3 . onComplete ( ) ; to . assertFailure ( TestException . class , 1 , 2 ) ; 
PublishSubject < Integer > ps1 = PublishSubject . create ( ) ; PublishSubject < Integer > ps2 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . concatEager ( Observable . just ( ps1 , ps2 ) ) . test ( ) ; assertTrue ( ps1 . hasObservers ( ) ) ; assertTrue ( ps2 . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps1 . hasObservers ( ) ) ; assertFalse ( ps2 . hasObservers ( ) ) ; 
PublishSubject < Observable < Integer > > ps1 = PublishSubject . create ( ) ; TestObserver < Integer > to = Observable . concatEager ( ps1 ) . test ( ) ; assertTrue ( ps1 . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( ps1 . hasObservers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapEager ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapEagerDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; , false ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapEagerDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; , true ) ; ) ; 
Observable . concatEagerDelayError ( Arrays . asList ( Observable . range ( 1 , 2 ) , Observable . error ( new TestException ( ) ) , Observable . range ( 3 , 3 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Observable . concatEagerDelayError ( Arrays . asList ( Observable . range ( 1 , 2 ) , Observable . error ( new TestException ( ) ) , Observable . range ( 3 , 3 ) ) , 1 , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Observable . concatEagerDelayError ( Observable . fromArray ( Observable . range ( 1 , 2 ) , Observable . error ( new TestException ( ) ) , Observable . range ( 3 , 3 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Observable . concatEagerDelayError ( Observable . fromArray ( Observable . range ( 1 , 2 ) , Observable . error ( new TestException ( ) ) , Observable . range ( 3 , 3 ) ) , 1 , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapEager ( v -> TestHelper . rejectObservableFusion ( ) ) . test ( ) . assertEmpty ( ) ; 
Observable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 10 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onNext ( s ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception ) . take ( 5 ) . test ( ) . assertResult ( 10 , 10 , 10 , 10 , 10 ) ; 
Observable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw new TestException ( ) ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onNext ( s ) ; , Functions . emptyConsumer ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception throw new TestException ( ) ; , Functions . emptyConsumer ( ) ) . test ( ) . assertFailure ( TestException . class ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onComplete ( ) ; , new Consumer < Object > ( ) @ Override public void accept ( Object d ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDisposed ( Observable . generate ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; , new BiConsumer < Object , Emitter < Object > > ( ) @ Override public void accept ( Object s , Emitter < Object > e ) throws Exception e . onComplete ( ) ; , Functions . emptyConsumer ( ) ) ) ; 
final int [ ] call = 0 ; Observable . generate ( Functions . justSupplier ( 1 ) , new BiConsumer < Integer , Emitter < Object > > ( ) @ Override public void accept ( Integer s , Emitter < Object > e ) throws Exception try e . onError ( null ) ; catch ( NullPointerException ex ) call [ 0 ] ++ ; , Functions . emptyConsumer ( ) ) . test ( ) . assertFailure ( NullPointerException . class ) ; assertEquals ( 0 , call [ 0 ] ) ; 
Observable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > e ) throws Exception e . onNext ( 1 ) ; e . onNext ( 2 ) ; ) . test ( ) . assertFailure ( IllegalStateException . class , 1 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > e ) throws Exception e . onError ( new TestException ( "First" ) ) ; e . onError ( new TestException ( "Second" ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > e ) throws Exception e . onComplete ( ) ; e . onComplete ( ) ; ) . test ( ) . assertResult ( ) ; 
Observable . generate ( new Consumer < Emitter < Object > > ( ) @ Override public void accept ( Emitter < Object > e ) throws Exception e . onComplete ( ) ; e . onNext ( 1 ) ; ) . test ( ) . assertResult ( ) ; 
TestHelper . checkUtilityClass ( ObservableInternalHelper . class ) ; 
assertNotNull ( ObservableInternalHelper . MapToInt . values ( ) [ 0 ] ) ; assertNotNull ( ObservableInternalHelper . MapToInt . valueOf ( "INSTANCE" ) ) ; 
assertEquals ( 0 , ObservableInternalHelper . MapToInt . INSTANCE . apply ( null ) ) ; 
Observable < Integer > o = Observable . just ( 1 ) ; assertSame ( o , ( ( HasUpstreamObservableSource < Integer > ) o . map ( Functions . < Integer > identity ( ) ) ) . source ( ) ) ; 
final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable ( "one" , "two" , null , "three" ) ; TestLocalObserver observer = new TestLocalObserver ( ) ; Observable < Notification < String > > m = Observable . unsafeCreate ( o1 ) . materialize ( ) ; m . subscribe ( observer ) ; try o1 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertFalse ( observer . onError ) ; assertTrue ( observer . onComplete ) ; assertEquals ( 3 , observer . notifications . size ( ) ) ; assertTrue ( observer . notifications . get ( 0 ) . isOnNext ( ) ) ; assertEquals ( "one" , observer . notifications . get ( 0 ) . getValue ( ) ) ; assertTrue ( observer . notifications . get ( 1 ) . isOnNext ( ) ) ; assertEquals ( "two" , observer . notifications . get ( 1 ) . getValue ( ) ) ; assertTrue ( observer . notifications . get ( 2 ) . isOnError ( ) ) ; assertEquals ( NullPointerException . class , observer . notifications . get ( 2 ) . getError ( ) . getClass ( ) ) ; 
final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable ( "one" , "two" , "three" ) ; TestLocalObserver observer = new TestLocalObserver ( ) ; Observable < Notification < String > > m = Observable . unsafeCreate ( o1 ) . materialize ( ) ; m . subscribe ( observer ) ; try o1 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; assertFalse ( observer . onError ) ; assertTrue ( observer . onComplete ) ; assertEquals ( 4 , observer . notifications . size ( ) ) ; assertTrue ( observer . notifications . get ( 0 ) . isOnNext ( ) ) ; assertEquals ( "one" , observer . notifications . get ( 0 ) . getValue ( ) ) ; assertTrue ( observer . notifications . get ( 1 ) . isOnNext ( ) ) ; assertEquals ( "two" , observer . notifications . get ( 1 ) . getValue ( ) ) ; assertTrue ( observer . notifications . get ( 2 ) . isOnNext ( ) ) ; assertEquals ( "three" , observer . notifications . get ( 2 ) . getValue ( ) ) ; assertTrue ( observer . notifications . get ( 3 ) . isOnComplete ( ) ) ; 
final TestAsyncErrorObservable o = new TestAsyncErrorObservable ( "one" , "two" , null , "three" ) ; Observable < Notification < String > > m = Observable . unsafeCreate ( o ) . materialize ( ) ; assertEquals ( 3 , m . toList ( ) . toFuture ( ) . get ( ) . size ( ) ) ; assertEquals ( 3 , m . toList ( ) . toFuture ( ) . get ( ) . size ( ) ) ; 
TestObserverEx < Notification < Integer > > to = new TestObserverEx < > ( ) ; final RuntimeException ex = new RuntimeException ( "boo" ) ; Observable . < Integer > empty ( ) . materialize ( ) . doOnNext ( new Consumer < Object > ( ) @ Override public void accept ( Object t ) throw ex ; ) . subscribe ( to ) ; to . assertError ( ex ) ; to . assertNoValues ( ) ; to . assertTerminated ( ) ; 
this . onComplete = true ; 
this . onError = true ; 
this . notifications . add ( value ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) for ( String s : valuesToReturn ) if ( s == null ) System . out . println ( "throwing exception" ) ; try Thread . sleep ( 100 ) ; catch ( Throwable e ) observer . onError ( new NullPointerException ( ) ) ; return ; else observer . onNext ( s ) ; System . out . println ( "subscription complete" ) ; observer . onComplete ( ) ; ) ; t . start ( ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . materialize ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Notification < Object > > > ( ) @ Override public ObservableSource < Notification < Object > > apply ( Observable < Object > o ) throws Exception return o . materialize ( ) ; ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Observable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Runnable run = new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ; Observable . fromRunnable ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; Observable . fromRunnable ( run ) . test ( ) . assertResult ( ) ; assertEquals ( 2 , atomicInteger . get ( ) ) ; 
final AtomicInteger atomicInteger = new AtomicInteger ( ) ; Observable < Object > source = Observable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) atomicInteger . incrementAndGet ( ) ; ) ; assertEquals ( 0 , atomicInteger . get ( ) ) ; source . test ( ) . assertResult ( ) ; assertEquals ( 1 , atomicInteger . get ( ) ) ; 
Observable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) throw new UnsupportedOperationException ( ) ; ) . test ( ) . assertFailure ( UnsupportedOperationException . class ) ; 
final int [ ] counter = 0 ; Observable < Void > m = Observable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) counter [ 0 ] ++ ; ) ; assertTrue ( m . getClass ( ) . toString ( ) , m instanceof Supplier ) ; assertNull ( ( ( Supplier < Void > ) m ) . get ( ) ) ; assertEquals ( 1 , counter [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final CountDownLatch cdl1 = new CountDownLatch ( 1 ) ; final CountDownLatch cdl2 = new CountDownLatch ( 1 ) ; TestObserver < Object > to = Observable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) cdl1 . countDown ( ) ; try cdl2 . await ( 5 , TimeUnit . SECONDS ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; throw new TestException ( e ) ; ) . subscribeOn ( Schedulers . single ( ) ) . test ( ) ; assertTrue ( cdl1 . await ( 5 , TimeUnit . SECONDS ) ) ; to . dispose ( ) ; int timeout = 10 ; while ( timeout -- > 0 && errors . isEmpty ( ) ) Thread . sleep ( 100 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Runnable run = mock ( Runnable . class ) ; Observable . fromRunnable ( run ) . test ( true ) . assertEmpty ( ) ; verify ( run , never ( ) ) . run ( ) ; 
final TestObserver < Object > to = new TestObserver < > ( ) ; Observable . fromRunnable ( new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ) . subscribeWith ( to ) . assertEmpty ( ) ; assertTrue ( to . isDisposed ( ) ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Runnable action = mock ( Runnable . class ) ; Observable . fromRunnable ( action ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . SYNC ) ; Runnable action = mock ( Runnable . class ) ; Observable . fromRunnable ( action ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( ) ; verify ( action ) . run ( ) ; 
stringObserver = TestHelper . mockObserver ( ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestErrorObservable ( "four" , null , "six" ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestErrorObservable ( "one" , "two" , "three" ) ) ; Observable < String > m = Observable . mergeDelayError ( o1 , o2 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "five" ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestErrorObservable ( "one" , "two" , "three" ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestErrorObservable ( "four" , null , "six" ) ) ; final Observable < String > o3 = Observable . unsafeCreate ( new TestErrorObservable ( "seven" , "eight" , null ) ) ; final Observable < String > o4 = Observable . unsafeCreate ( new TestErrorObservable ( "nine" ) ) ; Observable < String > m = Observable . mergeDelayError ( o1 , o2 , o3 , o4 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( CompositeException . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "five" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "seven" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "eight" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "nine" ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestErrorObservable ( "one" , "two" , "three" ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestErrorObservable ( "four" , "five" , "six" ) ) ; final Observable < String > o3 = Observable . unsafeCreate ( new TestErrorObservable ( "seven" , "eight" , null ) ) ; final Observable < String > o4 = Observable . unsafeCreate ( new TestErrorObservable ( "nine" ) ) ; Observable < String > m = Observable . mergeDelayError ( o1 , o2 , o3 , o4 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "five" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "six" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "seven" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "eight" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "nine" ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestErrorObservable ( "one" , "two" , "three" ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestErrorObservable ( "four" , "five" , "six" ) ) ; final Observable < String > o3 = Observable . unsafeCreate ( new TestErrorObservable ( "seven" , "eight" ) ) ; final Observable < String > o4 = Observable . unsafeCreate ( new TestErrorObservable ( "nine" , null ) ) ; Observable < String > m = Observable . mergeDelayError ( o1 , o2 , o3 , o4 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "five" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "six" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "seven" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "eight" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "nine" ) ; 
final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable ( "one" , "two" , "three" ) ; final TestAsyncErrorObservable o2 = new TestAsyncErrorObservable ( "four" , "five" , "six" ) ; final TestAsyncErrorObservable o3 = new TestAsyncErrorObservable ( "seven" , "eight" ) ; final TestAsyncErrorObservable o4 = new TestAsyncErrorObservable ( "nine" , null ) ; Observable < String > m = Observable . mergeDelayError ( Observable . unsafeCreate ( o1 ) , Observable . unsafeCreate ( o2 ) , Observable . unsafeCreate ( o3 ) , Observable . unsafeCreate ( o4 ) ) ; m . subscribe ( stringObserver ) ; try o1 . t . join ( ) ; o2 . t . join ( ) ; o3 . t . join ( ) ; o4 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "three" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "five" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "six" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "seven" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "eight" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "nine" ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestErrorObservable ( "four" , null , "six" ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestErrorObservable ( "one" , "two" , null ) ) ; Observable < String > m = Observable . mergeDelayError ( o1 , o2 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "two" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "three" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "four" ) ; verify ( stringObserver , times ( 0 ) ) . onNext ( "five" ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestErrorObservable ( "four" , null , "six" ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestErrorObservable ( "one" , "two" , null ) ) ; Observable < String > m = Observable . mergeDelayError ( o1 , o2 ) ; CaptureObserver w = new CaptureObserver ( ) ; m . subscribe ( w ) ; assertNotNull ( w . e ) ; assertEquals ( 2 , ( ( CompositeException ) w . e ) . size ( ) ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; Observable < Observable < String > > observableOfObservables = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( o1 ) ; observer . onNext ( o2 ) ; observer . onComplete ( ) ; ) ; Observable < String > m = Observable . mergeDelayError ( observableOfObservables ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( o1 ) ; observer . onNext ( o2 ) ; observer . onComplete ( ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; Observable < String > m = Observable . mergeDelayError ( o1 , o2 ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; 
final Observable < String > o1 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; final Observable < String > o2 = Observable . unsafeCreate ( new TestSynchronousObservable ( ) ) ; List < Observable < String > > listOfObservables = new ArrayList < > ( ) ; listOfObservables . add ( o1 ) ; listOfObservables . add ( o2 ) ; Observable < String > m = Observable . mergeDelayError ( Observable . fromIterable ( listOfObservables ) ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; 
final TestASynchronousObservable o1 = new TestASynchronousObservable ( ) ; final TestASynchronousObservable o2 = new TestASynchronousObservable ( ) ; Observable < String > m = Observable . mergeDelayError ( Observable . unsafeCreate ( o1 ) , Observable . unsafeCreate ( o2 ) ) ; m . subscribe ( stringObserver ) ; try o1 . t . join ( ) ; o2 . t . join ( ) ; catch ( InterruptedException e ) throw new RuntimeException ( e ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; 
final Observable < Observable < String > > o1 = Observable . error ( new RuntimeException ( "unit test" ) ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; Observable . mergeDelayError ( o1 ) . subscribe ( new DefaultObserver < String > ( ) @ Override public void onComplete ( ) fail ( "Expected onError path" ) ; @ Override public void onError ( Throwable e ) latch . countDown ( ) ; @ Override public void onNext ( String s ) fail ( "Expected onError path" ) ; ) ; try latch . await ( ) ; catch ( InterruptedException ex ) fail ( "interrupted" ) ; 
fail ( "Expected onError path" ) ; 
latch . countDown ( ) ; 
fail ( "Expected onError path" ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( "hello" ) ; observer . onComplete ( ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) observer . onNext ( "hello" ) ; observer . onComplete ( ) ; ) ; t . start ( ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; boolean errorThrown = false ; for ( String s : valuesToReturn ) if ( s == null ) System . out . println ( "throwing exception" ) ; observer . onError ( new NullPointerException ( ) ) ; errorThrown = true ; else observer . onNext ( s ) ; if ( ! errorThrown ) observer . onComplete ( ) ; 
observer . onSubscribe ( Disposable . empty ( ) ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) for ( String s : valuesToReturn ) if ( s == null ) System . out . println ( "throwing exception" ) ; try Thread . sleep ( 100 ) ; catch ( Throwable e ) observer . onError ( new NullPointerException ( ) ) ; return ; else observer . onNext ( s ) ; System . out . println ( "subscription complete" ) ; observer . onComplete ( ) ; ) ; t . start ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . mergeDelayError ( Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . startWithItem ( Observable . < Integer > error ( new RuntimeException ( ) ) ) ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertTerminated ( ) ; to . assertValues ( 1 , 2 ) ; assertEquals ( 1 , to . errors ( ) . size ( ) ) ; 
for ( int i = 0 ; i < 50 ; i ++ ) final TestASynchronous1sDelayedObservable o1 = new TestASynchronous1sDelayedObservable ( ) ; final TestASynchronous1sDelayedObservable o2 = new TestASynchronous1sDelayedObservable ( ) ; Observable < Observable < String > > parentObservable = Observable . unsafeCreate ( new ObservableSource < Observable < String > > ( ) @ Override public void subscribe ( Observer < ? super Observable < String > > op ) op . onSubscribe ( Disposable . empty ( ) ) ; op . onNext ( Observable . unsafeCreate ( o1 ) ) ; op . onNext ( Observable . unsafeCreate ( o2 ) ) ; op . onError ( new NullPointerException ( "throwing exception in parent" ) ) ; ) ; Observer < String > stringObserver = TestHelper . mockObserver ( ) ; TestObserverEx < String > to = new TestObserverEx < > ( stringObserver ) ; Observable < String > m = Observable . mergeDelayError ( parentObservable ) ; m . subscribe ( to ) ; System . out . println ( "testErrorInParentObservableDelayed | " + i ) ; to . awaitDone ( 2000 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; verify ( stringObserver , times ( 2 ) ) . onNext ( "hello" ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( NullPointerException . class ) ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; 
Observable . mergeDelayError ( Arrays . asList ( Observable . just ( 1 ) , Observable . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . mergeArrayDelayError ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . mergeDelayError ( Arrays . asList ( Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Observable . mergeDelayError ( Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . mergeDelayError ( Observable . just ( Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 2 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Observable . mergeDelayError ( Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . mergeDelayError ( Observable . just ( Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Observable . mergeDelayError ( Arrays . asList ( Observable . just ( 1 ) , Observable . just ( 2 ) ) , 1 ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . mergeDelayError ( Arrays . asList ( Observable . just ( 1 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 2 ) ) , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 ) ; 
Observable . mergeDelayError ( Observable . just ( 1 ) , Observable . just ( 2 ) , Observable . just ( 3 ) ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
Observable . mergeDelayError ( Observable . just ( 1 ) , Observable . just ( 2 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) , Observable . just ( 3 ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Single . just ( 100 ) ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . < Integer > error ( new TestException ( ) ) . concatWith ( Single . just ( 100 ) ) . subscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Single . < Integer > error ( new TestException ( ) ) ) . subscribe ( to ) ; to . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Single . just ( 100 ) ) . take ( 3 ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 ) ; 
SingleSubject < Object > other = SingleSubject . create ( ) ; TestObserver < Object > to = Observable . empty ( ) . concatWith ( other ) . test ( ) ; assertTrue ( other . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( other . hasObservers ( ) ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) Disposable bs1 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onNext ( 1 ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; assertTrue ( bs1 . isDisposed ( ) ) ; . concatWith ( Single . just ( 100 ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) Disposable bs1 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; Disposable bs2 = Disposable . empty ( ) ; observer . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertTrue ( bs2 . isDisposed ( ) ) ; observer . onComplete ( ) ; . concatWith ( Single . < Integer > just ( 100 ) ) . test ( ) . assertResult ( 100 ) ; 
Flowable . empty ( ) . concatWith ( new Single < Integer > ( ) @ Override protected void subscribeActual ( SingleObserver < ? super Integer > observer ) Disposable bs1 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; Disposable bs2 = Disposable . empty ( ) ; observer . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertTrue ( bs2 . isDisposed ( ) ) ; observer . onSuccess ( 100 ) ; ) . test ( ) . assertResult ( 100 ) ; 
UIEventLoopScheduler uiEventLoop = new UIEventLoopScheduler ( ) ; try final ThreadSubscription subscription = new ThreadSubscription ( ) ; final AtomicReference < Thread > subscribeThread = new AtomicReference < > ( ) ; Observable < Integer > w = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > t1 ) subscribeThread . set ( Thread . currentThread ( ) ) ; t1 . onSubscribe ( subscription ) ; t1 . onNext ( 1 ) ; t1 . onNext ( 2 ) ; ) ; TestObserverEx < Integer > observer = new TestObserverEx < > ( ) ; w . subscribeOn ( uiEventLoop ) . observeOn ( Schedulers . computation ( ) ) . unsubscribeOn ( uiEventLoop ) . take ( 2 ) . subscribe ( observer ) ; observer . awaitDone ( 5 , TimeUnit . SECONDS ) ; Thread unsubscribeThread = subscription . getThread ( ) ; assertNotNull ( unsubscribeThread ) ; assertNotSame ( Thread . currentThread ( ) , unsubscribeThread ) ; assertNotNull ( subscribeThread . get ( ) ) ; assertNotSame ( Thread . currentThread ( ) , subscribeThread . get ( ) ) ; System . out . println ( "unsubscribeThread: " + unsubscribeThread ) ; System . out . println ( "subscribeThread.get(): " + subscribeThread . get ( ) ) ; assertSame ( unsubscribeThread . toString ( ) , unsubscribeThread , uiEventLoop . getThread ( ) ) ; observer . assertValues ( 1 , 2 ) ; observer . assertTerminated ( ) ; finally uiEventLoop . shutdown ( ) ; 
UIEventLoopScheduler uiEventLoop = new UIEventLoopScheduler ( ) ; try final ThreadSubscription subscription = new ThreadSubscription ( ) ; final AtomicReference < Thread > subscribeThread = new AtomicReference < > ( ) ; Observable < Integer > w = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > t1 ) subscribeThread . set ( Thread . currentThread ( ) ) ; t1 . onSubscribe ( subscription ) ; t1 . onNext ( 1 ) ; t1 . onNext ( 2 ) ; ) ; TestObserverEx < Integer > observer = new TestObserverEx < > ( ) ; w . subscribeOn ( Schedulers . newThread ( ) ) . observeOn ( Schedulers . computation ( ) ) . unsubscribeOn ( uiEventLoop ) . take ( 2 ) . subscribe ( observer ) ; observer . awaitDone ( 1 , TimeUnit . SECONDS ) ; Thread unsubscribeThread = subscription . getThread ( ) ; assertNotNull ( unsubscribeThread ) ; assertNotSame ( Thread . currentThread ( ) , unsubscribeThread ) ; assertNotNull ( subscribeThread . get ( ) ) ; assertNotSame ( Thread . currentThread ( ) , subscribeThread . get ( ) ) ; System . out . println ( "UI Thread: " + uiEventLoop . getThread ( ) ) ; System . out . println ( "unsubscribeThread: " + unsubscribeThread ) ; System . out . println ( "subscribeThread.get(): " + subscribeThread . get ( ) ) ; assertSame ( unsubscribeThread , uiEventLoop . getThread ( ) ) ; observer . assertValues ( 1 , 2 ) ; observer . assertTerminated ( ) ; finally uiEventLoop . shutdown ( ) ; 
set ( true ) ; System . out . println ( "unsubscribe invoked: " + Thread . currentThread ( ) ) ; thread = Thread . currentThread ( ) ; latch . countDown ( ) ; 
return get ( ) ; 
latch . await ( ) ; return thread ; 
return eventLoop . createWorker ( ) ; 
return t ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . unsubscribeOn ( Schedulers . single ( ) ) ) ; 
final int [ ] calls = 0 ; Observable . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception calls [ 0 ] ++ ; ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Observable . error ( new TestException ( ) ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception calls [ 0 ] ++ ; ) . unsubscribeOn ( Schedulers . single ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 0 , calls [ 0 ] ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . unsubscribeOn ( Schedulers . single ( ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . unsubscribeOn ( ImmediateThinScheduler . INSTANCE ) ) ; 
w = TestHelper . mockObserver ( ) ; wo = TestHelper . mockSingleObserver ( ) ; wm = TestHelper . mockMaybeObserver ( ) ; 
Observable < String > src = Observable . empty ( ) ; src . first ( "default" ) . toObservable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyString ( ) ) ; verify ( w , times ( 1 ) ) . onNext ( "default" ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" ) ; src . first ( "default" ) . toObservable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyString ( ) ) ; verify ( w , times ( 1 ) ) . onNext ( "a" ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" ) ; src . filter ( IS_D ) . first ( "default" ) . toObservable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyString ( ) ) ; verify ( w , times ( 1 ) ) . onNext ( "default" ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" , "d" , "e" , "f" ) ; src . filter ( IS_D ) . first ( "default" ) . toObservable ( ) . subscribe ( w ) ; verify ( w , times ( 1 ) ) . onNext ( anyString ( ) ) ; verify ( w , times ( 1 ) ) . onNext ( "d" ) ; verify ( w , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( w , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) . firstElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 ) . firstElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . < Integer > empty ( ) . firstElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer ) . onComplete ( ) ; inOrder . verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 ) . first ( 4 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 ) . first ( 2 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . < Integer > empty ( ) . first ( 1 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 8 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 4 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 2 ) . toObservable ( ) ; Observer < Integer > observer = TestHelper . mockObserver ( ) ; o . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < String > src = Observable . empty ( ) ; src . first ( "default" ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyString ( ) ) ; verify ( wo , times ( 1 ) ) . onSuccess ( "default" ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" ) ; src . first ( "default" ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyString ( ) ) ; verify ( wo , times ( 1 ) ) . onSuccess ( "a" ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" ) ; src . filter ( IS_D ) . first ( "default" ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyString ( ) ) ; verify ( wo , times ( 1 ) ) . onSuccess ( "default" ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < String > src = Observable . just ( "a" , "b" , "c" , "d" , "e" , "f" ) ; src . filter ( IS_D ) . first ( "default" ) . subscribe ( wo ) ; verify ( wo , times ( 1 ) ) . onSuccess ( anyString ( ) ) ; verify ( wo , times ( 1 ) ) . onSuccess ( "d" ) ; verify ( wo , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 , 3 ) . firstElement ( ) ; o . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 ) . firstElement ( ) ; o . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . < Integer > empty ( ) . firstElement ( ) ; o . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( wm , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) ; o . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) ; o . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Maybe < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . firstElement ( ) ; o . subscribe ( wm ) ; InOrder inOrder = inOrder ( wm ) ; inOrder . verify ( wm , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( wm , never ( ) ) . onError ( any ( Throwable . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 , 3 ) . first ( 4 ) ; o . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 ) . first ( 2 ) ; o . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . < Integer > empty ( ) . first ( 1 ) ; o . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 1 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 , 3 , 4 , 5 , 6 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 8 ) ; o . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 , 2 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 4 ) ; o . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Single < Integer > o = Observable . just ( 1 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 % 2 == 0 ; ) . first ( 2 ) ; o . subscribe ( wo ) ; InOrder inOrder = inOrder ( wo ) ; inOrder . verify ( wo , times ( 1 ) ) . onSuccess ( 2 ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable . empty ( ) . firstOrError ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Observable . just ( 1 ) . firstOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Observable . just ( 1 , 2 , 3 ) . firstOrError ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Observable . error ( new RuntimeException ( "error" ) ) . firstOrError ( ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
Observable . empty ( ) . firstOrError ( ) . toObservable ( ) . test ( ) . assertNoValues ( ) . assertError ( NoSuchElementException . class ) ; 
Observable . just ( 1 ) . firstOrError ( ) . toObservable ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Observable . just ( 1 , 2 , 3 ) . firstOrError ( ) . toObservable ( ) . test ( ) . assertNoErrors ( ) . assertValue ( 1 ) ; 
Observable . error ( new RuntimeException ( "error" ) ) . firstOrError ( ) . toObservable ( ) . to ( TestHelper . testConsumer ( ) ) . assertNoValues ( ) . assertErrorMessage ( "error" ) . assertError ( RuntimeException . class ) ; 
Supplier < Object > func = mock ( Supplier . class ) ; when ( func . get ( ) ) . thenReturn ( new Object ( ) ) ; Observable < Object > fromSupplierObservable = Observable . fromSupplier ( func ) ; verifyNoInteractions ( func ) ; fromSupplierObservable . subscribe ( ) ; verify ( func ) . get ( ) ; 
Supplier < String > func = mock ( Supplier . class ) ; when ( func . get ( ) ) . thenReturn ( "test_value" ) ; Observable < String > fromSupplierObservable = Observable . fromSupplier ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; fromSupplierObservable . subscribe ( observer ) ; verify ( observer ) . onNext ( "test_value" ) ; verify ( observer ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Supplier < Object > func = mock ( Supplier . class ) ; Throwable throwable = new IllegalStateException ( "Test exception" ) ; when ( func . get ( ) ) . thenThrow ( throwable ) ; Observable < Object > fromSupplierObservable = Observable . fromSupplier ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; fromSupplierObservable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer ) . onError ( throwable ) ; 
Supplier < String > func = mock ( Supplier . class ) ; final CountDownLatch funcLatch = new CountDownLatch ( 1 ) ; final CountDownLatch observerLatch = new CountDownLatch ( 1 ) ; when ( func . get ( ) ) . thenAnswer ( new Answer < String > ( ) @ Override public String answer ( InvocationOnMock invocation ) throws Throwable observerLatch . countDown ( ) ; try funcLatch . await ( ) ; catch ( InterruptedException e ) Thread . currentThread ( ) . interrupt ( ) ; return "should_not_be_delivered" ; ) ; Observable < String > fromSupplierObservable = Observable . fromSupplier ( func ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; TestObserver < String > outer = new TestObserver < > ( observer ) ; fromSupplierObservable . subscribeOn ( Schedulers . computation ( ) ) . subscribe ( outer ) ; observerLatch . await ( ) ; outer . dispose ( ) ; funcLatch . countDown ( ) ; verify ( func ) . get ( ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verifyNoMoreInteractions ( observer ) ; 
final Exception checkedException = new Exception ( "test exception" ) ; Observable < Object > fromSupplierObservable = Observable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception throw checkedException ; ) ; Observer < Object > observer = TestHelper . mockObserver ( ) ; fromSupplierObservable . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( any ( Disposable . class ) ) ; verify ( observer ) . onError ( checkedException ) ; verifyNoMoreInteractions ( observer ) ; 
final int [ ] calls = 0 ; Observable . just ( 1 ) . flatMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return ++ calls [ 0 ] ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
final int [ ] calls = 0 ; Observable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return ++ calls [ 0 ] ; ) ; ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls [ 0 ] ) ; 
Observable . just ( 1 ) . flatMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return null ; ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
Observable . just ( 1 ) . hide ( ) . flatMap ( new Function < Integer , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( Integer v ) throws Exception return Observable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return null ; ) ; ) . test ( ) . assertFailure ( NullPointerException . class ) ; 
final int [ ] count = 0 ; Observable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception count [ 0 ] ++ ; return 1 ; ) . test ( true ) . assertEmpty ( ) ; assertEquals ( 0 , count [ 0 ] ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception to . dispose ( ) ; return 1 ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . fromSupplier ( new Supplier < Integer > ( ) @ Override public Integer get ( ) throws Exception to . dispose ( ) ; throw new TestException ( ) ; ) . subscribe ( to ) ; to . assertEmpty ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . fromSupplier ( new Supplier < Object > ( ) @ Override public Object get ( ) throws Exception return 1 ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
ObservableCache < Integer > source = new ObservableCache < > ( Observable . range ( 0 , 1000 ) , 16 ) ; assertFalse ( "Source is connected!" , source . isConnected ( ) ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; source . subscribe ( to ) ; assertTrue ( "Source is not connected!" , source . isConnected ( ) ) ; assertFalse ( "Subscribers retained!" , source . hasObservers ( ) ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; List < Integer > onNextEvents = to . values ( ) ; assertEquals ( 1000 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < String > o = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; System . out . println ( "published Observable being executed" ) ; observer . onNext ( "one" ) ; observer . onComplete ( ) ; ) . start ( ) ; ) . cache ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
Action unsubscribe = mock ( Action . class ) ; Observable < Integer > o = Observable . just ( 1 ) . doOnDispose ( unsubscribe ) . cache ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; verify ( unsubscribe , never ( ) ) . run ( ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; ObservableCache < Integer > cached = new ObservableCache < > ( Observable . range ( 1 , 1000 ) , 16 ) ; cached . take ( 10 ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; assertFalse ( cached . hasObservers ( ) ) ; 
Observable < Integer > source = Observable . range ( 1 , 10000 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestObserver < Integer > to1 = new TestObserver < > ( ) ; ObservableCache < Integer > cached = new ObservableCache < > ( source , 16 ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( to1 ) ; to1 . awaitDone ( 2 , TimeUnit . SECONDS ) ; to1 . assertNoErrors ( ) ; to1 . assertComplete ( ) ; assertEquals ( 10000 , to1 . values ( ) . size ( ) ) ; TestObserver < Integer > to2 = new TestObserver < > ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( to2 ) ; to2 . awaitDone ( 2 , TimeUnit . SECONDS ) ; to2 . assertNoErrors ( ) ; to2 . assertComplete ( ) ; assertEquals ( 10000 , to2 . values ( ) . size ( ) ) ; 
Observable < Long > source = Observable . interval ( 1 , 1 , TimeUnit . MILLISECONDS ) . take ( 1000 ) . subscribeOn ( Schedulers . io ( ) ) ; ObservableCache < Long > cached = new ObservableCache < > ( source , 16 ) ; Observable < Long > output = cached . observeOn ( Schedulers . computation ( ) ) ; List < TestObserver < Long > > list = new ArrayList < > ( 100 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestObserver < Long > to = new TestObserver < > ( ) ; list . add ( to ) ; output . skip ( i * 10 ) . take ( 10 ) . subscribe ( to ) ; List < Long > expected = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) expected . add ( ( long ) ( i - 10 ) ) ; int j = 0 ; for ( TestObserver < Long > to : list ) to . awaitDone ( 3 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; for ( int i = j * 10 ; i < j * 10 + 10 ; i ++ ) expected . set ( i - j * 10 , ( long ) i ) ; to . assertValueSequence ( expected ) ; j ++ ; 
final int m = 4 * 1000 * 1000 ; Observable < Integer > firehose = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > t ) t . onSubscribe ( Disposable . empty ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) t . onNext ( i ) ; t . onComplete ( ) ; ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; firehose . cache ( ) . observeOn ( Schedulers . computation ( ) ) . takeLast ( 100 ) . subscribe ( to ) ; to . awaitDone ( 3 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; assertEquals ( 100 , to . values ( ) . size ( ) ) ; 
Observable < Integer > source = Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . cache ( ) ; TestObserver < Integer > to = new TestObserver < > ( ) ; source . subscribe ( to ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; to . assertNotComplete ( ) ; to . assertError ( TestException . class ) ; TestObserver < Integer > to2 = new TestObserver < > ( ) ; source . subscribe ( to2 ) ; to2 . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; to2 . assertNotComplete ( ) ; to2 . assertError ( TestException . class ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ObservableCache < Integer > cache = ( ObservableCache < Integer > ) Observable . range ( 1 , 5 ) . concatWith ( ps ) . cache ( ) ; assertFalse ( cache . hasObservers ( ) ) ; assertEquals ( 0 , cache . cachedEventCount ( ) ) ; TestObserver < Integer > to = cache . test ( ) ; assertTrue ( cache . hasObservers ( ) ) ; assertEquals ( 5 , cache . cachedEventCount ( ) ) ; ps . onComplete ( ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . range ( 1 , 5 ) . cache ( ) . test ( true ) . assertEmpty ( ) ; 
Observable < Integer > o = PublishSubject . < Integer > create ( ) . cache ( ) ; o . test ( ) ; o . test ( true ) . assertEmpty ( ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . cache ( ) ) ; 
Observable < Integer > cache = Observable . range ( 1 , 5 ) . cache ( ) ; cache . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; cache . take ( 3 ) . test ( ) . assertResult ( 1 , 2 , 3 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . < Integer > create ( ) ; final Observable < Integer > cache = ps . cache ( ) ; cache . test ( ) ; final TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) cache . subscribe ( to ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 500 ; j ++ ) ps . onNext ( j ) ; ps . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) . assertSubscribed ( ) . assertValueCount ( 500 ) . assertComplete ( ) . assertNoErrors ( ) ; 
final AtomicInteger call = new AtomicInteger ( ) ; Observable < Object > f = Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception return call . incrementAndGet ( ) ; ) . concatWith ( Observable . never ( ) ) . cache ( ) ; f . test ( ) . assertValuesOnly ( 1 ) ; f . test ( true ) . assertEmpty ( ) ; assertEquals ( 1 , call . get ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) Observable < Object > o = Observable . never ( ) . cache ( ) ; TestObserver < Object > to = o . test ( ) ; TestHelper . race ( ( ) -> to . dispose ( ) , ( ) -> o . test ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = source . replay ( 3 , true ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; ConnectableObservable < Integer > co = source . replay ( 3 , 100 , TimeUnit . MILLISECONDS , scheduler , true ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 10 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; scheduler . advanceTimeBy ( 90 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 5 ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = source . replay ( 100 , TimeUnit . MILLISECONDS , scheduler , true ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Observable < Integer > , Observable < Integer > > selector = new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > t1 ) return t1 . map ( dbl ) ; ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > co = source . replay ( selector ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 8 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Observable < Integer > , Observable < Integer > > selector = new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > t1 ) return t1 . map ( dbl ) ; ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > co = source . replay ( selector , 3 ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 6 ) ; source . onNext ( 4 ) ; source . onComplete ( ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 8 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
final Function < Integer , Integer > dbl = new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer t1 ) return t1 * 2 ; ; Function < Observable < Integer > , Observable < Integer > > selector = new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > t1 ) return t1 . map ( dbl ) ; ; TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > co = source . replay ( selector , 100 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 6 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = source . replay ( 3 , true ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; source . onNext ( 4 ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onComplete ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onComplete ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = source . replay ( 100 , TimeUnit . MILLISECONDS , scheduler , true ) ; co . connect ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; source . onNext ( 1 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; source . onError ( new RuntimeException ( "Forced failure" ) ) ; scheduler . advanceTimeBy ( 60 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onComplete ( ) ; Observer < Object > observer1 = TestHelper . mockObserver ( ) ; InOrder inOrder = inOrder ( observer1 ) ; co . subscribe ( observer1 ) ; inOrder . verify ( observer1 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( observer1 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( observer1 , never ( ) ) . onComplete ( ) ; 
final AtomicInteger effectCounter = new AtomicInteger ( ) ; Observable < Integer > source = Observable . just ( 1 , 2 , 3 , 4 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) effectCounter . incrementAndGet ( ) ; System . out . println ( "Sideeffect #" + v ) ; ) ; Observable < Integer > result = source . replay ( new Function < Observable < Integer > , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > o ) return o . take ( 2 ) ; ) ; for ( int i = 1 ; i < 3 ; i ++ ) effectCounter . set ( 0 ) ; System . out . printf ( "- %d -%n" , i ) ; result . subscribe ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) System . out . println ( t1 ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) t1 . printStackTrace ( ) ; , new Action ( ) @ Override public void run ( ) System . out . println ( "Done" ) ; ) ; assertEquals ( 2 , effectCounter . get ( ) ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; Observer < Integer > spiedSubscriberBeforeConnect = TestHelper . mockObserver ( ) ; Observer < Integer > spiedSubscriberAfterConnect = TestHelper . mockObserver ( ) ; Observable < Integer > source = Observable . just ( 1 , 2 ) ; ConnectableObservable < Integer > replay = source . doOnNext ( sourceNext ) . doOnDispose ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . replay ( ) ; replay . subscribe ( spiedSubscriberBeforeConnect ) ; replay . subscribe ( spiedSubscriberBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( spiedSubscriberAfterConnect ) ; replay . subscribe ( spiedSubscriberAfterConnect ) ; verify ( spiedSubscriberBeforeConnect , times ( 2 ) ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( spiedSubscriberAfterConnect , times ( 2 ) ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 2 ) ; verify ( sourceCompleted , times ( 1 ) ) . run ( ) ; verifyObserverMock ( spiedSubscriberBeforeConnect , 2 , 4 ) ; verifyObserverMock ( spiedSubscriberAfterConnect , 2 , 4 ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( spiedSubscriberBeforeConnect ) ; verifyNoMoreInteractions ( spiedSubscriberAfterConnect ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; final TestScheduler mockScheduler = new TestScheduler ( ) ; Observer < Integer > mockObserverBeforeConnect = TestHelper . mockObserver ( ) ; Observer < Integer > mockObserverAfterConnect = TestHelper . mockObserver ( ) ; ConnectableObservable < Integer > replay = Observable . just ( 1 , 2 , 3 ) . doOnNext ( sourceNext ) . doOnDispose ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . subscribeOn ( mockScheduler ) . replay ( ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( mockObserverAfterConnect ) ; verify ( mockObserverBeforeConnect ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( mockObserverAfterConnect ) . onSubscribe ( ( Disposable ) any ( ) ) ; mockScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 2 ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 3 ) ; verify ( sourceCompleted , times ( 1 ) ) . run ( ) ; verifyObserverMock ( mockObserverBeforeConnect , 1 , 3 ) ; verifyObserverMock ( mockObserverAfterConnect , 1 , 3 ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( mockObserverBeforeConnect ) ; verifyNoMoreInteractions ( mockObserverAfterConnect ) ; 
Consumer < Integer > sourceNext = mock ( Consumer . class ) ; Action sourceCompleted = mock ( Action . class ) ; Consumer < Throwable > sourceError = mock ( Consumer . class ) ; Action sourceUnsubscribed = mock ( Action . class ) ; final TestScheduler mockScheduler = new TestScheduler ( ) ; Observer < Integer > mockObserverBeforeConnect = TestHelper . mockObserver ( ) ; Observer < Integer > mockObserverAfterConnect = TestHelper . mockObserver ( ) ; Function < Integer , Integer > mockFunc = mock ( Function . class ) ; IllegalArgumentException illegalArgumentException = new IllegalArgumentException ( ) ; when ( mockFunc . apply ( 1 ) ) . thenReturn ( 1 ) ; when ( mockFunc . apply ( 2 ) ) . thenThrow ( illegalArgumentException ) ; ConnectableObservable < Integer > replay = Observable . just ( 1 , 2 , 3 ) . map ( mockFunc ) . doOnNext ( sourceNext ) . doOnDispose ( sourceUnsubscribed ) . doOnComplete ( sourceCompleted ) . doOnError ( sourceError ) . subscribeOn ( mockScheduler ) . replay ( ) ; replay . subscribe ( mockObserverBeforeConnect ) ; replay . connect ( ) ; replay . subscribe ( mockObserverAfterConnect ) ; verify ( mockObserverBeforeConnect ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( mockObserverAfterConnect ) . onSubscribe ( ( Disposable ) any ( ) ) ; mockScheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; verify ( sourceNext , times ( 1 ) ) . accept ( 1 ) ; verify ( sourceError , times ( 1 ) ) . accept ( illegalArgumentException ) ; verifyObserver ( mockObserverBeforeConnect , 1 , 1 , illegalArgumentException ) ; verifyObserver ( mockObserverAfterConnect , 1 , 1 , illegalArgumentException ) ; verifyNoMoreInteractions ( sourceNext ) ; verifyNoMoreInteractions ( sourceCompleted ) ; verifyNoMoreInteractions ( sourceError ) ; verifyNoMoreInteractions ( sourceUnsubscribed ) ; verifyNoMoreInteractions ( mockObserverBeforeConnect ) ; verifyNoMoreInteractions ( mockObserverAfterConnect ) ; 
return spy ( new InprocessWorker ( mockDisposable ) ) ; 
action . run ( ) ; return mockDisposable ; 
unsubscribed = true ; 
return unsubscribed ; 
BoundedReplayBuffer < Integer > buf = new BoundedReplayBuffer < Integer > ( false ) private static final long serialVersionUID = - 5182053207244406872L ; @ Override void truncate ( ) ; buf . addLast ( new Node ( 1 ) ) ; buf . addLast ( new Node ( 2 ) ) ; buf . addLast ( new Node ( 3 ) ) ; buf . addLast ( new Node ( 4 ) ) ; buf . addLast ( new Node ( 5 ) ) ; List < Integer > values = new ArrayList < > ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , values ) ; buf . removeSome ( 2 ) ; buf . removeFirst ( ) ; buf . removeSome ( 2 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; buf . addLast ( new Node ( 5 ) ) ; buf . addLast ( new Node ( 6 ) ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 , 6 ) , values ) ; 
TestScheduler test = new TestScheduler ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = new SizeAndTimeBoundReplayBuffer < > ( 2 , 2000 , TimeUnit . MILLISECONDS , test , false ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . next ( 2 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . complete ( ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; Assert . assertEquals ( 1 , buf . size ) ; Assert . assertTrue ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; 
TestScheduler test = new TestScheduler ( ) ; SizeAndTimeBoundReplayBuffer < Integer > buf = new SizeAndTimeBoundReplayBuffer < > ( 2 , 2000 , TimeUnit . MILLISECONDS , test , false ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . next ( 2 ) ; test . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; test . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; buf . error ( new TestException ( ) ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertTrue ( values . isEmpty ( ) ) ; Assert . assertEquals ( 1 , buf . size ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; Assert . assertTrue ( buf . hasError ( ) ) ; 
SizeBoundReplayBuffer < Integer > buf = new SizeBoundReplayBuffer < > ( 2 , false ) ; List < Integer > values = new ArrayList < > ( ) ; buf . next ( 1 ) ; buf . next ( 2 ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 1 , 2 ) , values ) ; buf . next ( 3 ) ; buf . next ( 4 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 3 , 4 ) , values ) ; buf . next ( 5 ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 4 , 5 ) , values ) ; Assert . assertFalse ( buf . hasCompleted ( ) ) ; buf . complete ( ) ; values . clear ( ) ; buf . collect ( values ) ; Assert . assertEquals ( Arrays . asList ( 4 , 5 ) , values ) ; Assert . assertEquals ( 3 , buf . size ) ; Assert . assertTrue ( buf . hasCompleted ( ) ) ; Assert . assertFalse ( buf . hasError ( ) ) ; 
Observable < Integer > source = Observable . range ( 0 , 1000 ) . replay ( ) . autoConnect ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; source . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; List < Integer > onNextEvents = to . values ( ) ; assertEquals ( 1000 , onNextEvents . size ( ) ) ; for ( int i = 0 ; i < 1000 ; i ++ ) assertEquals ( ( Integer ) i , onNextEvents . get ( i ) ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable < String > o = Observable . unsafeCreate ( new ObservableSource < String > ( ) @ Override public void subscribe ( final Observer < ? super String > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; new Thread ( new Runnable ( ) @ Override public void run ( ) counter . incrementAndGet ( ) ; System . out . println ( "published Observable being executed" ) ; observer . onNext ( "one" ) ; observer . onComplete ( ) ; ) . start ( ) ; ) . replay ( ) . autoConnect ( ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; o . subscribe ( new Consumer < String > ( ) @ Override public void accept ( String v ) assertEquals ( "one" , v ) ; System . out . println ( "v: " + v ) ; latch . countDown ( ) ; ) ; if ( ! latch . await ( 1000 , TimeUnit . MILLISECONDS ) ) fail ( "subscriptions did not receive values" ) ; assertEquals ( 1 , counter . get ( ) ) ; 
Action unsubscribe = mock ( Action . class ) ; Observable < Integer > o = Observable . just ( 1 ) . doOnDispose ( unsubscribe ) . replay ( ) . autoConnect ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; o . subscribe ( ) ; verify ( unsubscribe , never ( ) ) . run ( ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable < Integer > cached = Observable . range ( 1 , 100 ) . replay ( ) . autoConnect ( ) ; cached . take ( 10 ) . subscribe ( to ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
Observable < Integer > source = Observable . range ( 1 , 10000 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestObserverEx < Integer > to1 = new TestObserverEx < > ( ) ; Observable < Integer > cached = source . replay ( ) . autoConnect ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( to1 ) ; to1 . awaitDone ( 2 , TimeUnit . SECONDS ) ; to1 . assertNoErrors ( ) ; to1 . assertTerminated ( ) ; assertEquals ( 10000 , to1 . values ( ) . size ( ) ) ; TestObserverEx < Integer > to2 = new TestObserverEx < > ( ) ; cached . observeOn ( Schedulers . computation ( ) ) . subscribe ( to2 ) ; to2 . awaitDone ( 2 , TimeUnit . SECONDS ) ; to2 . assertNoErrors ( ) ; to2 . assertTerminated ( ) ; assertEquals ( 10000 , to2 . values ( ) . size ( ) ) ; 
Observable < Long > source = Observable . interval ( 1 , 1 , TimeUnit . MILLISECONDS ) . take ( 1000 ) . subscribeOn ( Schedulers . io ( ) ) ; Observable < Long > cached = source . replay ( ) . autoConnect ( ) ; Observable < Long > output = cached . observeOn ( Schedulers . computation ( ) ) ; List < TestObserverEx < Long > > list = new ArrayList < > ( 100 ) ; for ( int i = 0 ; i < 100 ; i ++ ) TestObserverEx < Long > to = new TestObserverEx < > ( ) ; list . add ( to ) ; output . skip ( i * 10 ) . take ( 10 ) . subscribe ( to ) ; List < Long > expected = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) expected . add ( ( long ) ( i - 10 ) ) ; int j = 0 ; for ( TestObserverEx < Long > to : list ) to . awaitDone ( 3 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; for ( int i = j * 10 ; i < j * 10 + 10 ; i ++ ) expected . set ( i - j * 10 , ( long ) i ) ; to . assertValueSequence ( expected ) ; j ++ ; 
final int m = 4 * 1000 * 1000 ; Observable < Integer > firehose = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > t ) t . onSubscribe ( Disposable . empty ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) t . onNext ( i ) ; t . onComplete ( ) ; ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; firehose . replay ( ) . autoConnect ( ) . observeOn ( Schedulers . computation ( ) ) . takeLast ( 100 ) . subscribe ( to ) ; to . awaitDone ( 3 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; to . assertTerminated ( ) ; assertEquals ( 100 , to . values ( ) . size ( ) ) ; 
Observable < Integer > source = Observable . range ( 1 , 10 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) . replay ( ) . autoConnect ( ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; source . subscribe ( to ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; to . assertNotComplete ( ) ; Assert . assertEquals ( 1 , to . errors ( ) . size ( ) ) ; TestObserverEx < Integer > to2 = new TestObserverEx < > ( ) ; source . subscribe ( to2 ) ; to2 . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; to2 . assertNotComplete ( ) ; Assert . assertEquals ( 1 , to2 . errors ( ) . size ( ) ) ; 
Observable . just ( 1 ) . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) , true ) . autoConnect ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . replay ( 1 , 1 , TimeUnit . MILLISECONDS , Schedulers . computation ( ) , true ) . autoConnect ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . replay ( Functions . < Observable < Integer > > identity ( ) , 1 , TimeUnit . MINUTES ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . range ( 1 , 2 ) . replay ( Integer . MAX_VALUE , true ) . autoConnect ( ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable < Integer > source = Observable . range ( 1 , 3 ) ; assertSame ( source , ( ( ( HasUpstreamObservableSource < ? > ) source . replay ( ) ) ) . source ( ) ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . range ( 1 , 3 ) . replay ( ) ; Runnable r = new Runnable ( ) @ Override public void run ( ) co . connect ( ) ; ; TestHelper . race ( r , r ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . range ( 1 , 3 ) . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; final TestObserver < Integer > to2 = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . range ( 1 , 3 ) . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; final TestObserver < Integer > to2 = new TestObserver < > ( ) ; co . subscribe ( to1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to2 ) ; ; TestHelper . race ( r1 , r2 ) ; 
Observable . range ( 1 , 2 ) . replay ( Integer . MAX_VALUE , true ) . autoConnect ( ) . test ( true ) . assertEmpty ( ) ; 
ConnectableObservable < Integer > co = PublishSubject . < Integer > create ( ) . replay ( Integer . MAX_VALUE , true ) ; co . test ( ) ; co . autoConnect ( ) . test ( true ) . assertEmpty ( ) ; 
ConnectableObservable < Integer > co = Observable . range ( 1 , 2 ) . replay ( ) ; try co . connect ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable t ) throws Exception throw new TestException ( ) ; ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) co . test ( ) . assertEmpty ( ) . dispose ( ) ; co . connect ( ) ; co . test ( ) . assertResult ( 1 , 2 ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; . replay ( ) . autoConnect ( ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final ConnectableObservable < Integer > co = ps . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) ps . onNext ( j ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final ConnectableObservable < Integer > co = ps . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; co . subscribe ( to1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) for ( int j = 0 ; j < 1000 ; j ++ ) ps . onNext ( j ) ; ; TestHelper . race ( r1 , r2 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final ConnectableObservable < Integer > co = Observable . range ( 1 , 1000 ) . replay ( ) ; final TestObserver < Integer > to1 = new TestObserver < > ( ) ; co . connect ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) co . subscribe ( to1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to1 . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; super . onNext ( t ) ; ; ps . replay ( ) . autoConnect ( ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 , 2 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) ps . onNext ( 2 ) ; ps . onComplete ( ) ; super . onNext ( t ) ; ; ps . replay ( 10 , true ) . autoConnect ( ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertResult ( 1 , 2 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) ps . onNext ( 2 ) ; dispose ( ) ; super . onNext ( t ) ; ; ps . replay ( ) . autoConnect ( ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertValues ( 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = new TestObserver < Integer > ( ) @ Override public void onNext ( Integer t ) if ( t == 1 ) ps . onNext ( 2 ) ; dispose ( ) ; super . onNext ( t ) ; ; ps . replay ( 10 , true ) . autoConnect ( ) . subscribe ( to ) ; ps . onNext ( 1 ) ; to . assertValues ( 1 ) ; 
final Observer < ? > [ ] sub = null ; new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) sub [ 0 ] = observer ; . replay ( ) . connect ( ) . dispose ( ) ; Disposable bs = Disposable . empty ( ) ; sub [ 0 ] . onSubscribe ( bs ) ; assertTrue ( bs . isDisposed ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Observable < Integer > source = Observable . just ( 1 ) . replay ( 2 , TimeUnit . SECONDS , scheduler , true ) . autoConnect ( ) ; source . test ( ) . assertResult ( 1 ) ; source . test ( ) . assertResult ( 1 ) ; scheduler . advanceTimeBy ( 3 , TimeUnit . SECONDS ) ; source . test ( ) . assertResult ( ) ; 
Observable . just ( 1 ) . replay ( new Function < Observable < Integer > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Integer > v ) throws Exception return null ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The selector returned a null ObservableSource" ) ; 
ObservableReplay . multicastSelector ( Functions . justSupplier ( ( ConnectableObservable < Integer > ) null ) , Functions . justFunction ( Observable . just ( 1 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( NullPointerException . class , "The connectableFactory returned a null ConnectableObservable" ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , true ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , true ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , true ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; assertNull ( buf . get ( ) . value ) ; buf . trimHead ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) , true ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onComplete ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , TimeUnit . MINUTES , Schedulers . computation ( ) , true ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
TestScheduler sch = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; ObservableReplay < Integer > co = ( ObservableReplay < Integer > ) source . replay ( 1 , TimeUnit . MILLISECONDS , sch , true ) ; co . connect ( ) ; BoundedReplayBuffer < Integer > buf = ( BoundedReplayBuffer < Integer > ) ( co . current . get ( ) . buffer ) ; source . onNext ( 1 ) ; sch . advanceTimeBy ( 2 , TimeUnit . MILLISECONDS ) ; source . onNext ( 2 ) ; assertNull ( buf . get ( ) . value ) ; buf . trimHead ( ) ; assertNull ( buf . get ( ) . value ) ; Object o = buf . get ( ) ; buf . trimHead ( ) ; assertSame ( o , buf . get ( ) ) ; 
Observable < byte [ ] > source = Observable . range ( 1 , 200 ) . map ( new Function < Integer , byte [ ] > ( ) @ Override public byte [ ] apply ( Integer v ) throws Exception return new byte [ 1024 * 1024 ] ; ) . replay ( new Function < Observable < byte [ ] > , Observable < byte [ ] > > ( ) @ Override public Observable < byte [ ] > apply ( final Observable < byte [ ] > o ) throws Exception return o . take ( 1 ) . concatMap ( new Function < byte [ ] , Observable < byte [ ] > > ( ) @ Override public Observable < byte [ ] > apply ( byte [ ] v ) throws Exception return o ; ) ; , 1 ) . takeLast ( 1 ) ; System . out . println ( "Bounded Replay Leak check: Wait before GC" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check: GC" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; MemoryUsage memHeap = memoryMXBean . getHeapMemoryUsage ( ) ; long initial = memHeap . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; final AtomicLong after = new AtomicLong ( ) ; source . subscribe ( new Consumer < byte [ ] > ( ) @ Override public void accept ( byte [ ] v ) throws Exception System . out . println ( "Bounded Replay Leak check: Wait before GC 2" ) ; Thread . sleep ( 1000 ) ; System . out . println ( "Bounded Replay Leak check:  GC 2" ) ; System . gc ( ) ; Thread . sleep ( 500 ) ; after . set ( memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ) ; ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after . get ( ) / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after . get ( ) ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after . get ( ) / 1024.0 / 1024.0 ) ; 
PublishSubject < int [ ] > ps = PublishSubject . create ( ) ; ConnectableObservable < int [ ] > co = ps . replay ( 1 , true ) ; TestObserver < int [ ] > to = co . test ( ) ; co . connect ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; ps . onNext ( new int [ 100 * 1024 * 1024 ] ) ; to . assertValueCount ( 1 ) ; to . values ( ) . clear ( ) ; ps . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; to . dispose ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishSubject < int [ ] > ps = PublishSubject . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; ConnectableObservable < int [ ] > co = ps . replay ( 1 , TimeUnit . SECONDS , scheduler , true ) ; TestObserver < int [ ] > to = co . test ( ) ; co . connect ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; ps . onNext ( new int [ 100 * 1024 * 1024 ] ) ; to . assertValueCount ( 1 ) ; to . values ( ) . clear ( ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ps . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; to . dispose ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishSubject < int [ ] > ps = PublishSubject . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; ConnectableObservable < int [ ] > co = ps . replay ( 1 , 5 , TimeUnit . SECONDS , scheduler , true ) ; TestObserver < int [ ] > to = co . test ( ) ; co . connect ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; ps . onNext ( new int [ 100 * 1024 * 1024 ] ) ; to . assertValueCount ( 1 ) ; to . values ( ) . clear ( ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ps . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; to . dispose ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishSubject < int [ ] > ps = PublishSubject . create ( ) ; Observable < int [ ] > co = ps . replay ( Functions . < Observable < int [ ] > > identity ( ) , 1 , true ) ; TestObserver < int [ ] > to = co . test ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; ps . onNext ( new int [ 100 * 1024 * 1024 ] ) ; to . assertValueCount ( 1 ) ; to . values ( ) . clear ( ) ; ps . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; to . dispose ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishSubject < int [ ] > ps = PublishSubject . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; Observable < int [ ] > co = ps . replay ( Functions . < Observable < int [ ] > > identity ( ) , 1 , TimeUnit . SECONDS , scheduler , true ) ; TestObserver < int [ ] > to = co . test ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; ps . onNext ( new int [ 100 * 1024 * 1024 ] ) ; to . assertValueCount ( 1 ) ; to . values ( ) . clear ( ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ps . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; to . dispose ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
PublishSubject < int [ ] > ps = PublishSubject . create ( ) ; TestScheduler scheduler = new TestScheduler ( ) ; Observable < int [ ] > co = ps . replay ( Functions . < Observable < int [ ] > > identity ( ) , 1 , 5 , TimeUnit . SECONDS , scheduler , true ) ; TestObserver < int [ ] > to = co . test ( ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; final MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long initial = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; System . out . printf ( "Bounded Replay Leak check: Starting: %.3f MB%n" , initial / 1024.0 / 1024.0 ) ; ps . onNext ( new int [ 100 * 1024 * 1024 ] ) ; to . assertValueCount ( 1 ) ; to . values ( ) . clear ( ) ; scheduler . advanceTimeBy ( 2 , TimeUnit . SECONDS ) ; ps . onNext ( new int [ 0 ] ) ; Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; long after = memoryMXBean . getHeapMemoryUsage ( ) . getUsed ( ) ; to . dispose ( ) ; System . out . printf ( "Bounded Replay Leak check: After: %.3f MB%n" , after / 1024.0 / 1024.0 ) ; if ( initial + 100 * 1024 * 1024 < after ) Assert . fail ( "Bounded Replay Leak check: Memory leak detected: " + ( initial / 1024.0 / 1024.0 ) + " -> " + after / 1024.0 / 1024.0 ) ; 
Observable . just ( 1 ) . replay ( 1 , 1 , TimeUnit . SECONDS , new TimesteppingScheduler ( ) , true ) . autoConnect ( ) . test ( ) . assertComplete ( ) . assertNoErrors ( ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = ps . replay ( 10 , true ) ; TestObserver < Integer > to = co . test ( ) ; Disposable d = co . connect ( ) ; ps . onNext ( 1 ) ; d . dispose ( ) ; to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertEmpty ( ) ; ps . onNext ( 2 ) ; to . assertValuesOnly ( 2 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = ps . replay ( 10 , TimeUnit . MINUTES , Schedulers . single ( ) , true ) ; TestObserver < Integer > to = co . test ( ) ; Disposable d = co . connect ( ) ; ps . onNext ( 1 ) ; d . dispose ( ) ; to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertEmpty ( ) ; ps . onNext ( 2 ) ; to . assertValuesOnly ( 2 ) ; 
PublishSubject < Integer > ps = PublishSubject . create ( ) ; ConnectableObservable < Integer > co = ps . replay ( 10 , 10 , TimeUnit . MINUTES , Schedulers . single ( ) , true ) ; TestObserver < Integer > to = co . test ( ) ; Disposable d = co . connect ( ) ; ps . onNext ( 1 ) ; d . dispose ( ) ; to = co . test ( ) ; to . assertEmpty ( ) ; co . connect ( ) ; to . assertEmpty ( ) ; ps . onNext ( 2 ) ; to . assertValuesOnly ( 2 ) ; 
calls ++ ; 
Observable . just ( 1 ) . doFinally ( this ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls ) ; 
Observable . empty ( ) . doFinally ( this ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls ) ; 
Observable . error ( new TestException ( ) ) . doFinally ( this ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls ) ; 
Observable . range ( 1 , 10 ) . doFinally ( this ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . doFinally ( ObservableDoFinallyTest . this ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > f ) throws Exception return f . doFinally ( ObservableDoFinallyTest . this ) . filter ( Functions . alwaysTrue ( ) ) ; ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Observable . range ( 1 , 5 ) . doFinally ( this ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC | QueueFuseable . BOUNDARY ) ; Observable . range ( 1 , 5 ) . doFinally ( this ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . doFinally ( this ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . doFinally ( this ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
Observable . just ( 1 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) ; assertEquals ( 1 , calls ) ; 
Observable . empty ( ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( ) ; assertEquals ( 1 , calls ) ; 
Observable . error ( new TestException ( ) ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , calls ) ; 
Observable . range ( 1 , 10 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Observable . range ( 1 , 5 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Observable . range ( 1 , 5 ) . hide ( ) . doFinally ( this ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC ) ; Observable . range ( 1 , 5 ) . hide ( ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . SYNC | QueueFuseable . BOUNDARY ) ; Observable . range ( 1 , 5 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ASYNC | QueueFuseable . BOUNDARY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; us . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 1 , calls ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . just ( 1 ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertResult ( 1 ) . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Observable . just ( 1 ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception throw new TestException ( ) ; ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 ) . dispose ( ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Observable . range ( 1 , 5 ) . doFinally ( this ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < Integer > qd = ( QueueDisposable < Integer > ) d ; qd . requestFusion ( QueueFuseable . ANY ) ; assertFalse ( qd . isEmpty ( ) ) ; try assertEquals ( 1 , qd . poll ( ) . intValue ( ) ) ; catch ( Throwable ex ) throw new RuntimeException ( ex ) ; assertFalse ( qd . isEmpty ( ) ) ; qd . clear ( ) ; assertTrue ( qd . isEmpty ( ) ) ; qd . dispose ( ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; assertEquals ( 1 , calls ) ; 
Observable . range ( 1 , 5 ) . doFinally ( this ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( new Observer < Integer > ( ) @ Override public void onSubscribe ( Disposable d ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < Integer > qd = ( QueueDisposable < Integer > ) d ; qd . requestFusion ( QueueFuseable . ANY ) ; assertFalse ( qd . isEmpty ( ) ) ; assertFalse ( qd . isDisposed ( ) ) ; try assertEquals ( 1 , qd . poll ( ) . intValue ( ) ) ; catch ( Throwable ex ) throw new RuntimeException ( ex ) ; assertFalse ( qd . isEmpty ( ) ) ; qd . clear ( ) ; assertTrue ( qd . isEmpty ( ) ) ; qd . dispose ( ) ; assertTrue ( qd . isDisposed ( ) ) ; @ Override public void onNext ( Integer t ) @ Override public void onError ( Throwable t ) @ Override public void onComplete ( ) ) ; assertEquals ( 1 , calls ) ; 
final List < String > list = new ArrayList < > ( ) ; Observable . error ( new TestException ( ) ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "dispose" ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "finally" ) ; ) . subscribe ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( "onNext" ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( "onError" ) ; , new Action ( ) @ Override public void run ( ) throws Exception list . add ( "onComplete" ) ; ) ; assertEquals ( Arrays . asList ( "onError" , "finally" ) , list ) ; 
final List < String > list = new ArrayList < > ( ) ; Observable . just ( 1 ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "dispose" ) ; ) . doFinally ( new Action ( ) @ Override public void run ( ) throws Exception list . add ( "finally" ) ; ) . subscribe ( new Consumer < Object > ( ) @ Override public void accept ( Object v ) throws Exception list . add ( "onNext" ) ; , new Consumer < Throwable > ( ) @ Override public void accept ( Throwable e ) throws Exception list . add ( "onError" ) ; , new Action ( ) @ Override public void run ( ) throws Exception list . add ( "onComplete" ) ; ) ; assertEquals ( Arrays . asList ( "onNext" , "onComplete" , "finally" ) , list ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; to . setInitialFusionMode ( QueueFuseable . ANY ) ; TestHelper . rejectObservableFusion ( ) . doFinally ( ( ) -> ) . subscribeWith ( to ) ; to . assertFuseable ( ) . assertFusionMode ( QueueFuseable . NONE ) ; 
PublishSubject < Integer > src = PublishSubject . create ( ) ; Observable < Integer > dst = src . hide ( ) ; assertFalse ( dst instanceof PublishSubject ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; dst . subscribe ( o ) ; src . onNext ( 1 ) ; src . onComplete ( ) ; verify ( o ) . onNext ( 1 ) ; verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > src = PublishSubject . create ( ) ; Observable < Integer > dst = src . hide ( ) ; assertFalse ( dst instanceof PublishSubject ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; dst . subscribe ( o ) ; src . onError ( new TestException ( ) ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . hide ( ) ; ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . hide ( ) ) ; 
Observer < Long > observer = TestHelper . mockObserver ( ) ; Observable . rangeLong ( 2 , 3 ) . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 2L ) ; verify ( observer , times ( 1 ) ) . onNext ( 3L ) ; verify ( observer , times ( 1 ) ) . onNext ( 4L ) ; verify ( observer , never ( ) ) . onNext ( 5L ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observer < Long > observer = TestHelper . mockObserver ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . rangeLong ( 1 , 1000 ) . doOnNext ( new Consumer < Long > ( ) @ Override public void accept ( Long t1 ) count . incrementAndGet ( ) ; ) . take ( 3 ) . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 1L ) ; verify ( observer , times ( 1 ) ) . onNext ( 2L ) ; verify ( observer , times ( 1 ) ) . onNext ( 3L ) ; verify ( observer , never ( ) ) . onNext ( 4L ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; assertEquals ( 3 , count . get ( ) ) ; 
Observable . rangeLong ( 1L , 0L ) ; 
Observable . rangeLong ( Long . MAX_VALUE , 0L ) ; 
Observable . rangeLong ( 1L , Long . MAX_VALUE ) ; 
Observable . rangeLong ( 2L , Long . MAX_VALUE ) ; 
assertFalse ( Observable . rangeLong ( Long . MIN_VALUE , 0 ) . blockingIterable ( ) . iterator ( ) . hasNext ( ) ) ; 
ArrayList < Long > list = new ArrayList < > ( Flowable . bufferSize ( ) * 2 ) ; for ( long i = 1 ; i <= Flowable . bufferSize ( ) * 2 + 1 ; i ++ ) list . add ( i ) ; Observable < Long > o = Observable . rangeLong ( 1 , list . size ( ) ) ; TestObserverEx < Long > to = new TestObserverEx < > ( ) ; o . subscribe ( to ) ; to . assertValueSequence ( list ) ; to . assertTerminated ( ) ; 
final AtomicBoolean completed = new AtomicBoolean ( false ) ; Observable . rangeLong ( 1L , 0L ) . subscribe ( new DefaultObserver < Long > ( ) @ Override public void onStart ( ) @ Override public void onComplete ( ) completed . set ( true ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long t ) ) ; assertTrue ( completed . get ( ) ) ; 
TestObserver < Long > to = new TestObserver < > ( ) ; Observable . rangeLong ( Long . MAX_VALUE - 1L , 2L ) . subscribe ( to ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; to . assertValues ( Long . MAX_VALUE - 1 , Long . MAX_VALUE ) ; 
try Observable . rangeLong ( 1L , - 1L ) ; fail ( "Should have thrown IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "count >= 0 required but it was -1" , ex . getMessage ( ) ) ; 
Observable . rangeLong ( 5495454L , 1L ) . test ( ) . assertResult ( 5495454L ) ; 
Observable . rangeLong ( Long . MAX_VALUE - 1 , 2 ) ; Observable . rangeLong ( Long . MIN_VALUE , 2 ) ; Observable . rangeLong ( Long . MIN_VALUE , Long . MAX_VALUE ) ; 
TestObserverEx < Long > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Observable . rangeLong ( 1 , 2 ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1L , 2L ) ; 
TestObserverEx < Long > to = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; Observable . rangeLong ( 1 , 2 ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1L , 2L ) ; 
TestHelper . checkDisposed ( Observable . rangeLong ( 1 , 2 ) ) ; 
TestHelper . checkFusedIsEmptyClear ( Observable . rangeLong ( 1 , 2 ) ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . flatMapIterable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Arrays . asList ( 10 , 20 ) ; ) ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > o ) throws Exception return o . flatMapIterable ( new Function < Object , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Object v ) throws Exception return Arrays . asList ( 10 , 20 ) ; ) ; , false , 1 , 1 , 10 , 20 ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable . range ( 1 , 5 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer v ) throws Exception counter . getAndIncrement ( ) ; ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) throws Exception return new Iterable < Integer > ( ) @ Override public Iterator < Integer > iterator ( ) return new Iterator < Integer > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public Integer next ( ) throw new TestException ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( ) ; ; ; ) . test ( ) . assertFailure ( TestException . class ) ; assertEquals ( 1 , counter . get ( ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . flatMapIterable ( v -> Collections . singletonList ( v ) ) ) ; 
final AtomicBoolean subscribed = new AtomicBoolean ( false ) ; final Observable < Integer > o = Observable . just ( 4 ) . switchIfEmpty ( Observable . just ( 2 ) . doOnSubscribe ( new Consumer < Disposable > ( ) @ Override public void accept ( Disposable d ) subscribed . set ( true ) ; ) ) ; assertEquals ( 4 , o . blockingSingle ( ) . intValue ( ) ) ; assertFalse ( subscribed . get ( ) ) ; 
final Observable < Integer > o = Observable . < Integer > empty ( ) . switchIfEmpty ( Observable . fromIterable ( Arrays . asList ( 42 ) ) ) ; assertEquals ( 42 , o . blockingSingle ( ) . intValue ( ) ) ; 
final Disposable d = Disposable . empty ( ) ; Observable < Long > withProducer = Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( final Observer < ? super Long > observer ) observer . onSubscribe ( d ) ; observer . onNext ( 42L ) ; ) ; Observable . < Long > empty ( ) . switchIfEmpty ( withProducer ) . lift ( new ObservableOperator < Long , Long > ( ) @ Override public Observer < ? super Long > apply ( final Observer < ? super Long > child ) return new DefaultObserver < Long > ( ) @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) @ Override public void onNext ( Long aLong ) cancel ( ) ; ; ) . subscribe ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
final Disposable d = Disposable . empty ( ) ; Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( final Observer < ? super Long > observer ) observer . onSubscribe ( d ) ; observer . onComplete ( ) ; ) . switchIfEmpty ( Observable . < Long > never ( ) ) . subscribe ( ) ; assertTrue ( d . isDisposed ( ) ) ; 
Observable . range ( 1 , 10000 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) throws Exception String name = Thread . currentThread ( ) . getName ( ) ; if ( name . contains ( "RxSingleScheduler" ) ) return "RxSingleScheduler" ; return name ; ) . concatMap ( new Function < String , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( String v ) throws Exception return Observable . just ( v ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( "RxSingleScheduler" ) ; 
Observable . range ( 1 , 10000 ) . observeOn ( Schedulers . single ( ) ) . map ( new Function < Integer , String > ( ) @ Override public String apply ( Integer t ) throws Exception String name = Thread . currentThread ( ) . getName ( ) ; if ( name . contains ( "RxSingleScheduler" ) ) return "RxSingleScheduler" ; return name ; ) . concatMapDelayError ( new Function < String , ObservableSource < ? extends Object > > ( ) @ Override public ObservableSource < ? extends Object > apply ( String v ) throws Exception return Observable . just ( v ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . observeOn ( Schedulers . computation ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( "RxSingleScheduler" ) ; 
Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > observableStripBoundary ( ) ) . concatMap ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . just ( v ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . compose ( TestHelper . < Integer > observableStripBoundary ( ) ) . concatMapDelayError ( new Function < Integer , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Integer v ) throws Exception return Observable . just ( v ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
final AtomicInteger counter = new AtomicInteger ( ) ; Observable . range ( 1 , 5 ) . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Exception return Observable . just ( v ) . doOnDispose ( new Action ( ) @ Override public void run ( ) throws Exception counter . getAndIncrement ( ) ; ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; assertEquals ( 0 , counter . get ( ) ) ; 
Observable . just ( 1 , 2 , 3 , 101 , 102 , 23 , 890 , 120 , 32 ) . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( final Integer integer ) throws Exception return Observable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception if ( integer >= 100 ) throw new NullPointerException ( "test null exp" ) ; return integer ; ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( CompositeException . class , 1 , 2 , 3 , 23 , 32 ) ; 
Observable . just ( 1 , 2 , 3 , 101 , 102 , 23 , 890 , 120 , 32 ) . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( final Integer integer ) throws Exception return Observable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception if ( integer >= 100 ) throw new NullPointerException ( "test null exp" ) ; return integer ; ) ; , false , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( NullPointerException . class , 1 , 2 , 3 ) ; 
TestObserver < String > to = Observable . just ( 1 ) . concatMap ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) ; , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestObserver < String > to = Observable . just ( 1 ) . concatMap ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) . hide ( ) ; , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestObserver < String > to = Observable . just ( 1 ) . concatMapDelayError ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) ; , false , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestObserver < String > to = Observable . just ( 1 ) . concatMapDelayError ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) . hide ( ) ; , false , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestObserver < String > to = Observable . just ( 1 ) . concatMapDelayError ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) ; , true , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestObserver < String > to = Observable . just ( 1 ) . concatMapDelayError ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) . hide ( ) ; , true , 2 , Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
final ExecutorService executor = Executors . newFixedThreadPool ( 2 ) ; final Scheduler sch = Schedulers . from ( executor ) ; Function < Integer , Observable < Integer > > func = new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) Observable < Integer > flowable = Observable . just ( t ) . subscribeOn ( sch ) ; Subject < Integer > processor = UnicastSubject . create ( ) ; flowable . subscribe ( processor ) ; return processor ; ; int n = 5000 ; final AtomicInteger counter = new AtomicInteger ( ) ; Observable . range ( 1 , n ) . concatMap ( func , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onNext ( Integer t ) try Thread . sleep ( 1 ) ; catch ( InterruptedException e ) if ( counter . getAndIncrement ( ) % 100 == 0 ) System . out . print ( "testIssue2890NoStackoverflow -> " ) ; System . out . println ( counter . get ( ) ) ; ; @ Override public void onComplete ( ) executor . shutdown ( ) ; @ Override public void onError ( Throwable e ) executor . shutdown ( ) ; ) ; long awaitTerminationTimeout = 100_000 ; if ( ! executor . awaitTermination ( awaitTerminationTimeout , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( "Completed " + counter . get ( ) + "/" + n + " before timed out after " + awaitTerminationTimeout + " milliseconds." ) ; assertEquals ( n , counter . get ( ) ) ; 
final long durationSeconds = 2 ; final long startTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; ; i ++ ) if ( System . currentTimeMillis ( ) - startTime > TimeUnit . SECONDS . toMillis ( durationSeconds ) ) return ; if ( i % 1000 == 0 ) System . out . println ( "concatMapRangeAsyncLoop > " + i ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; Observable . range ( 0 , 1000 ) . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return Observable . fromIterable ( Arrays . asList ( t ) ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . observeOn ( Schedulers . computation ( ) ) . subscribe ( to ) ; to . awaitDone ( 2500 , TimeUnit . MILLISECONDS ) ; to . assertTerminated ( ) ; to . assertNoErrors ( ) ; assertEquals ( 1000 , to . values ( ) . size ( ) ) ; assertEquals ( ( Integer ) 999 , to . values ( ) . get ( 999 ) ) ; 
for ( int i = 2 ; i < 10 ; i ++ ) Observable < Integer > [ ] obs = new Observable [ i ] ; Arrays . fill ( obs , Observable . just ( 1 ) ) ; Integer [ ] expected = new Integer [ i ] ; Arrays . fill ( expected , 1 ) ; Method m = Observable . class . getMethod ( "concatArray" , ObservableSource [ ] . class ) ; TestObserver < Integer > to = TestObserver . create ( ) ; ( ( Observable < Integer > ) m . invoke ( null , new Object [ ] obs ) ) . subscribe ( to ) ; to . assertValues ( expected ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; Observable . just ( Observable . just ( 1 ) ) . concatMap ( ( Function ) Functions . identity ( ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; Observable . just ( Observable . range ( 1 , 5 ) ) . concatMap ( ( Function ) Functions . identity ( ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; Observable . just ( Observable . just ( 1 ) ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertValue ( 1 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; Observable . just ( Observable . range ( 1 , 5 ) ) . concatMapDelayError ( ( Function ) Functions . identity ( ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertValues ( 1 , 2 , 3 , 4 , 5 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
for ( int i = 2 ; i < 10 ; i ++ ) Object [ ] obs = new Object [ i ] ; Arrays . fill ( obs , 1 ) ; Integer [ ] expected = new Integer [ i ] ; Arrays . fill ( expected , 1 ) ; Method m = Observable . class . getMethod ( "startWithArray" , Object [ ] . class ) ; TestObserver < Integer > to = TestObserver . create ( ) ; ( ( Observable < Integer > ) m . invoke ( Observable . empty ( ) , new Object [ ] obs ) ) . subscribe ( to ) ; to . assertValues ( expected ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
return true ; 
return count ++ ; 
$EMPTY$
return this ; 
Observable . just ( Observable . just ( 1 ) , Observable . just ( 2 ) ) . concatMapDelayError ( Functions . < Observable < Integer > > identity ( ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 , 2 ) ; 
Observable . just ( 0 ) . concatMapDelayError ( new Function < Object , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , true , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 ) ; 
Observable . just ( 0 ) . hide ( ) . concatMap ( new Function < Object , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 ) ; 
Observable . just ( 0 ) . hide ( ) . concatMapDelayError ( new Function < Object , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Object v ) throws Exception return Observable . just ( 1 ) ; , false , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Observable . empty ( ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Observable . empty ( ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Object > f ) throws Exception return f . concatMap ( Functions . justFunction ( Observable . just ( 2 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Integer > > ( ) @ Override public ObservableSource < Integer > apply ( Observable < Object > f ) throws Exception return f . concatMapDelayError ( Functions . justFunction ( Observable . just ( 2 ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserverEx < Integer > to = new TestObserverEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onError ( new TestException ( "First" ) ) ; ; ps . concatMap ( Functions . justFunction ( Observable . just ( 1 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; ps . onNext ( 1 ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; 
final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserverEx < Integer > to = new TestObserverEx < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) ps . onError ( new TestException ( "First" ) ) ; ; ps . concatMap ( Functions . justFunction ( Observable . just ( 1 ) . hide ( ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; ps . onNext ( 1 ) ; assertFalse ( ps . hasObservers ( ) ) ; to . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; 
Observable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Observable . error ( new TestException ( ) ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Observable . error ( new TestException ( ) ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > f ) throws Exception return f . concatMap ( Functions . justFunction ( Observable . just ( 1 ) . hide ( ) ) , 2 , ImmediateThinScheduler . INSTANCE ) ; , true , 1 , 1 , 1 ) ; 
@ SuppressWarnings ( "rawtypes" ) final Observer [ ] ts0 = null ; TestObserverEx < Integer > to = Observable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > o ) ts0 [ 0 ] = o ; o . onSubscribe ( Disposable . empty ( ) ) ; o . onError ( new TestException ( "First" ) ) ; ) , 2 , ImmediateThinScheduler . INSTANCE ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertFailureAndMessage ( TestException . class , "First" ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ts0 [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
ts0 [ 0 ] = o ; o . onSubscribe ( Disposable . empty ( ) ) ; o . onError ( new TestException ( "First" ) ) ; 
@ SuppressWarnings ( "rawtypes" ) final Observer [ ] ts0 = null ; TestObserverEx < Integer > to = Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > o ) ts0 [ 0 ] = o ; o . onSubscribe ( Disposable . empty ( ) ) ; o . onError ( new TestException ( "First" ) ) ; ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; to . assertFailureAndMessage ( TestException . class , "First" ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ts0 [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Integer > , Object > ( ) @ Override public Object apply ( Observable < Integer > f ) throws Exception return f . concatMapDelayError ( Functions . justFunction ( Observable . just ( 1 ) . hide ( ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) ; , true , 1 , 1 , 1 ) ; 
Observable . range ( 1 , 2 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMap ( Functions . justFunction ( Observable . just ( 1 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 2 ) . map ( new Function < Integer , Object > ( ) @ Override public Object apply ( Integer v ) throws Exception throw new TestException ( ) ; ) . concatMapDelayError ( Functions . justFunction ( Observable . just ( 1 ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . hide ( ) . concatMap ( Functions . justFunction ( Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ) , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( Functions . justFunction ( Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) throws Exception throw new TestException ( ) ; ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 2 ) . concatMap ( Functions . justFunction ( Observable . just ( 1 ) ) , 2 , ImmediateThinScheduler . INSTANCE ) ) ; TestHelper . checkDisposed ( Observable . range ( 1 , 2 ) . concatMapDelayError ( Functions . justFunction ( Observable . just ( 1 ) ) , true , 2 , ImmediateThinScheduler . INSTANCE ) ) ; 
Observable . range ( 1 , 2 ) . concatMapDelayError ( Functions . justFunction ( Observable . error ( new TestException ( ) ) ) , false , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . error ( new TestException ( ) ) . concatMapDelayError ( Functions . justFunction ( Observable . just ( 2 ) ) , false , 16 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . range ( 1 , 2 ) . concatMap ( new Function < Integer , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Integer v ) throws Exception throw new TestException ( ) ; , 2 , ImmediateThinScheduler . INSTANCE ) . test ( ) . assertFailure ( TestException . class ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; TestObserver < Integer > to = TestObserver . create ( ) ; source . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . range ( v , 2 ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onError ( new TestException ( ) ) ; to . assertValues ( 1 , 2 , 2 , 3 ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
final Observable < Integer > inner = Observable . range ( 1 , 2 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) ; TestObserver < Integer > to = TestObserver . create ( ) ; Observable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return inner ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertValues ( 1 , 2 , 1 , 2 , 1 , 2 ) ; to . assertError ( CompositeException . class ) ; to . assertNotComplete ( ) ; 
final Observable < Integer > inner = Observable . range ( 1 , 2 ) . concatWith ( Observable . < Integer > error ( new TestException ( ) ) ) ; TestObserver < Integer > to = TestObserver . create ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return inner ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertValues ( 1 , 2 ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return null ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertError ( NullPointerException . class ) ; to . assertNotComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throw new TestException ( ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertNoValues ( ) ; to . assertError ( TestException . class ) ; to . assertNotComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; Observable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return v == 2 ? Observable . < Integer > empty ( ) : Observable . range ( 1 , 2 ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertValues ( 1 , 2 , 1 , 2 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < Integer > to = TestObserver . create ( ) ; Observable . range ( 1 , 3 ) . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return v == 2 ? Observable . just ( 3 ) : Observable . range ( 1 , 2 ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertValues ( 1 , 2 , 3 , 1 , 2 ) ; to . assertNoErrors ( ) ; to . assertComplete ( ) ; 
TestObserver < String > to = Observable . range ( 1 , 1000 ) . hide ( ) . observeOn ( Schedulers . computation ( ) ) . concatMap ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) . repeat ( 1000 ) . observeOn ( Schedulers . io ( ) ) ; , 2 , Schedulers . single ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestObserver < String > to = Observable . range ( 1 , 1000 ) . hide ( ) . observeOn ( Schedulers . computation ( ) ) . concatMapDelayError ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) . repeat ( 1000 ) . observeOn ( Schedulers . io ( ) ) ; , false , 2 , Schedulers . single ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestObserver < String > to = Observable . range ( 1 , 1000 ) . hide ( ) . observeOn ( Schedulers . computation ( ) ) . concatMapDelayError ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer t ) throws Throwable return Observable . just ( Thread . currentThread ( ) . getName ( ) ) . repeat ( 1000 ) . observeOn ( Schedulers . io ( ) ) ; , true , 2 , Schedulers . single ( ) ) . distinct ( ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertValueCount ( 1 ) . assertNoErrors ( ) . assertComplete ( ) ; assertTrue ( to . values ( ) . toString ( ) , to . values ( ) . get ( 0 ) . startsWith ( "RxSingleScheduler-" ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; , false , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new ObservableConverter < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Observable < Integer > upstream ) return upstream . concatMapDelayError ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) throws Throwable return Observable . just ( v ) . hide ( ) ; , true , 2 , ImmediateThinScheduler . INSTANCE ) ; ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; TestHelper . rejectObservableFusion ( ) . concatMap ( v -> Observable . never ( ) , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; 
TestObserverEx < Object > to = new TestObserverEx < > ( ) ; TestHelper . rejectObservableFusion ( ) . concatMapDelayError ( v -> Observable . never ( ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( v -> Observable . fromCallable ( ( ) -> to . dispose ( ) ; return 1 ; ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
to . dispose ( ) ; return null ; 
TestObserver < Object > to = new TestObserver < > ( ) ; Observable . just ( 1 ) . hide ( ) . concatMapDelayError ( v -> new EmptyDisposingObservable ( to ) , true , 2 , ImmediateThinScheduler . INSTANCE ) . subscribe ( to ) ; to . assertEmpty ( ) ; 
scheduler = new TestScheduler ( ) ; innerScheduler = scheduler . createWorker ( ) ; observer = TestHelper . mockObserver ( ) ; observer2 = TestHelper . mockObserver ( ) ; 
Observable < Long > source = Observable . unsafeCreate ( new ObservableSource < Long > ( ) @ Override public void subscribe ( final Observer < ? super Long > observer1 ) observer1 . onSubscribe ( Disposable . empty ( ) ) ; innerScheduler . schedule ( new Runnable ( ) @ Override public void run ( ) observer1 . onNext ( 1L ) ; , 1 , TimeUnit . SECONDS ) ; innerScheduler . schedule ( new Runnable ( ) @ Override public void run ( ) observer1 . onNext ( 2L ) ; , 2 , TimeUnit . SECONDS ) ; innerScheduler . schedule ( new Runnable ( ) @ Override public void run ( ) observer1 . onComplete ( ) ; , 3 , TimeUnit . SECONDS ) ; ) ; Observable < Long > sampled = source . sample ( 400L , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( observer ) ; InOrder inOrder = inOrder ( observer ) ; scheduler . advanceTimeTo ( 800L , TimeUnit . MILLISECONDS ) ; verify ( observer , never ( ) ) . onNext ( any ( Long . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 1200L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 1L ) ; verify ( observer , never ( ) ) . onNext ( 2L ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 1600L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( 1L ) ; verify ( observer , never ( ) ) . onNext ( 2L ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 2000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( 1L ) ; inOrder . verify ( observer , times ( 1 ) ) . onNext ( 2L ) ; verify ( observer , never ( ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; scheduler . advanceTimeTo ( 3000L , TimeUnit . MILLISECONDS ) ; inOrder . verify ( observer , never ( ) ) . onNext ( 1L ) ; inOrder . verify ( observer , never ( ) ) . onNext ( 2L ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > sampler = PublishSubject . create ( ) ; Observable < Integer > m = source . sample ( sampler ) ; m . subscribe ( observer2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; sampler . onNext ( 1 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; sampler . onNext ( 2 ) ; source . onComplete ( ) ; sampler . onNext ( 3 ) ; InOrder inOrder = inOrder ( observer2 ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > sampler = PublishSubject . create ( ) ; Observable < Integer > m = source . sample ( sampler ) ; m . subscribe ( observer2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; sampler . onNext ( 1 ) ; sampler . onNext ( 1 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; sampler . onNext ( 2 ) ; sampler . onNext ( 2 ) ; source . onComplete ( ) ; sampler . onNext ( 3 ) ; InOrder inOrder = inOrder ( observer2 ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onNext ( 4 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > sampler = PublishSubject . create ( ) ; Observable < Integer > m = source . sample ( sampler ) ; m . subscribe ( observer2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; sampler . onNext ( 1 ) ; sampler . onComplete ( ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; InOrder inOrder = inOrder ( observer2 ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > sampler = PublishSubject . create ( ) ; Observable < Integer > m = source . sample ( sampler ) ; m . subscribe ( observer2 ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; sampler . onNext ( 1 ) ; source . onNext ( 3 ) ; source . onComplete ( ) ; sampler . onNext ( 2 ) ; sampler . onComplete ( ) ; InOrder inOrder = inOrder ( observer2 ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( 1 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onNext ( 2 ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( 3 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; inOrder . verify ( observer2 , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > sampler = PublishSubject . create ( ) ; Observable < Integer > m = source . sample ( sampler ) ; m . subscribe ( observer2 ) ; source . onComplete ( ) ; sampler . onNext ( 1 ) ; InOrder inOrder = inOrder ( observer2 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onComplete ( ) ; verify ( observer2 , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > sampler = PublishSubject . create ( ) ; Observable < Integer > m = source . sample ( sampler ) ; m . subscribe ( observer2 ) ; source . onNext ( 1 ) ; source . onError ( new RuntimeException ( "Forced failure!" ) ) ; sampler . onNext ( 1 ) ; InOrder inOrder = inOrder ( observer2 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer2 , never ( ) ) . onNext ( any ( ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
PublishSubject < Integer > source = PublishSubject . create ( ) ; PublishSubject < Integer > sampler = PublishSubject . create ( ) ; Observable < Integer > m = source . sample ( sampler ) ; m . subscribe ( observer2 ) ; source . onNext ( 1 ) ; sampler . onNext ( 1 ) ; sampler . onError ( new RuntimeException ( "Forced failure!" ) ) ; InOrder inOrder = inOrder ( observer2 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onNext ( 1 ) ; inOrder . verify ( observer2 , times ( 1 ) ) . onError ( any ( RuntimeException . class ) ) ; verify ( observer , never ( ) ) . onComplete ( ) ; 
final Disposable upstream = mock ( Disposable . class ) ; Observable < Integer > o = Observable . unsafeCreate ( new ObservableSource < Integer > ( ) @ Override public void subscribe ( Observer < ? super Integer > observer ) observer . onSubscribe ( upstream ) ; ) ; o . throttleLast ( 1 , TimeUnit . MILLISECONDS ) . subscribe ( ) . dispose ( ) ; verify ( upstream ) . dispose ( ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . sample ( 1 , TimeUnit . SECONDS , new TestScheduler ( ) ) ) ; TestHelper . checkDisposed ( PublishSubject . create ( ) . sample ( Observable . never ( ) ) ) ; 
Observable . error ( new TestException ( ) ) . sample ( 1 , TimeUnit . SECONDS ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . sample ( 1 , TimeUnit . DAYS , true ) . test ( ) . assertResult ( 1 ) ; 
Observable . empty ( ) . sample ( 1 , TimeUnit . DAYS , true ) . test ( ) . assertResult ( ) ; 
Observable . just ( 1 ) . sample ( 1 , TimeUnit . DAYS , Schedulers . single ( ) , true ) . test ( ) . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final TestScheduler scheduler = new TestScheduler ( ) ; final PublishSubject < Integer > ps = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . sample ( 1 , TimeUnit . SECONDS , scheduler , true ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( 1 ) ; 
Observable . just ( 1 ) . sample ( Observable . timer ( 1 , TimeUnit . DAYS ) , true ) . test ( ) . assertResult ( 1 ) ; 
Observable . empty ( ) . sample ( Observable . timer ( 1 , TimeUnit . DAYS ) , true ) . test ( ) . assertResult ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final PublishSubject < Integer > sampler = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . sample ( sampler , true ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sampler . onNext ( 1 ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final PublishSubject < Integer > sampler = PublishSubject . create ( ) ; TestObserver < Integer > to = ps . sample ( sampler , true ) . test ( ) ; ps . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) sampler . onComplete ( ) ; ; TestHelper . race ( r1 , r2 ) ; to . assertResult ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , Observable < Object > > ( ) @ Override public Observable < Object > apply ( Observable < Object > o ) throws Exception return o . sample ( 1 , TimeUnit . SECONDS ) ; ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . sample ( Observable . never ( ) ) ) ; 
Observable < String > obs = Observable . just ( "one" , "two" , "six" ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . toObservable ( ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onNext ( true ) ; verify ( observer ) . onComplete ( ) ; verifyNoMoreInteractions ( observer ) ; 
Observable < String > obs = Observable . just ( "one" , "two" , "three" , "six" ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . toObservable ( ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onNext ( false ) ; verify ( observer ) . onComplete ( ) ; verifyNoMoreInteractions ( observer ) ; 
Observable < String > obs = Observable . empty ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . toObservable ( ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onNext ( true ) ; verify ( observer ) . onComplete ( ) ; verifyNoMoreInteractions ( observer ) ; 
Throwable error = new Throwable ( ) ; Observable < String > obs = Observable . error ( error ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . toObservable ( ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onError ( error ) ; verifyNoMoreInteractions ( observer ) ; 
Observable < Integer > o = Observable . fromArray ( 1 , 3 , 5 , 6 ) ; Observable < Boolean > allOdd = o . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i % 2 == 1 ; ) . toObservable ( ) ; assertFalse ( allOdd . blockingFirst ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return false ; ) . toObservable ( ) . flatMap ( new Function < Boolean , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Boolean t1 ) return Observable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ; ) ; assertEquals ( ( Object ) 2 , source . blockingFirst ( ) ) ; 
TestObserverEx < Boolean > to = new TestObserverEx < > ( ) ; final IllegalArgumentException ex = new IllegalArgumentException ( ) ; Observable . just ( "Boo!" ) . all ( new Predicate < String > ( ) @ Override public boolean test ( String v ) throw ex ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( ex ) ; 
Observable < String > obs = Observable . just ( "one" , "two" , "six" ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onSuccess ( true ) ; verifyNoMoreInteractions ( observer ) ; 
Observable < String > obs = Observable . just ( "one" , "two" , "three" , "six" ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onSuccess ( false ) ; verifyNoMoreInteractions ( observer ) ; 
Observable < String > obs = Observable . empty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onSuccess ( true ) ; verifyNoMoreInteractions ( observer ) ; 
Throwable error = new Throwable ( ) ; Observable < String > obs = Observable . error ( error ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; obs . all ( new Predicate < String > ( ) @ Override public boolean test ( String s ) return s . length ( ) == 3 ; ) . subscribe ( observer ) ; verify ( observer ) . onSubscribe ( ( Disposable ) any ( ) ) ; verify ( observer ) . onError ( error ) ; verifyNoMoreInteractions ( observer ) ; 
Observable < Integer > o = Observable . fromArray ( 1 , 3 , 5 , 6 ) ; Single < Boolean > allOdd = o . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i % 2 == 1 ; ) ; assertFalse ( allOdd . blockingGet ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return false ; ) . flatMapObservable ( new Function < Boolean , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Boolean t1 ) return Observable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ; ) ; assertEquals ( ( Object ) 2 , source . blockingFirst ( ) ) ; 
TestObserverEx < Boolean > to = new TestObserverEx < > ( ) ; final IllegalArgumentException ex = new IllegalArgumentException ( ) ; Observable . just ( "Boo!" ) . all ( new Predicate < String > ( ) @ Override public boolean test ( String v ) throw ex ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( ex ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . all ( Functions . alwaysTrue ( ) ) . toObservable ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . all ( Functions . alwaysTrue ( ) ) ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . all ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
TestHelper . checkDoubleOnSubscribeObservableToSingle ( o -> o . all ( v -> true ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( o -> o . all ( v -> true ) . toObservable ( ) ) ; 
concat2Strings = new BiFunction < String , String , String > ( ) @ Override public String apply ( String t1 , String t2 ) return t1 + "-" + t2 ; ; s1 = PublishSubject . create ( ) ; s2 = PublishSubject . create ( ) ; zipped = Observable . zip ( s1 , s2 , concat2Strings ) ; observer = TestHelper . mockObserver ( ) ; inOrder = inOrder ( observer ) ; zipped . subscribe ( observer ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" , "3" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onNext ( "three-" ) ; r1 . onComplete ( ) ; io . verify ( o ) . onNext ( "one-1" ) ; io . verify ( o ) . onNext ( "two-2" ) ; io . verify ( o ) . onNext ( "three-3" ) ; io . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" , "3" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onComplete ( ) ; io . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = Arrays . asList ( ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onNext ( "three-" ) ; r1 . onComplete ( ) ; io . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" , "3" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onComplete ( ) ; io . verify ( o ) . onNext ( "one-1" ) ; io . verify ( o ) . onNext ( "two-2" ) ; io . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onNext ( "three-" ) ; r1 . onComplete ( ) ; io . verify ( o ) . onNext ( "one-1" ) ; io . verify ( o ) . onNext ( "two-2" ) ; io . verify ( o ) . onComplete ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = Arrays . asList ( "1" , "2" , "3" ) ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onError ( new TestException ( ) ) ; io . verify ( o ) . onNext ( "one-1" ) ; io . verify ( o ) . onNext ( "two-2" ) ; io . verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = new Iterable < String > ( ) @ Override public Iterator < String > iterator ( ) throw new TestException ( ) ; ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onNext ( "one-" ) ; r1 . onNext ( "two-" ) ; r1 . onError ( new TestException ( ) ) ; io . verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( String . class ) ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = new Iterable < String > ( ) @ Override public Iterator < String > iterator ( ) return new Iterator < String > ( ) int count ; @ Override public boolean hasNext ( ) if ( count == 0 ) return true ; throw new TestException ( ) ; @ Override public String next ( ) count ++ ; return "1" ; @ Override public void remove ( ) throw new UnsupportedOperationException ( "Not supported yet." ) ; ; ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onNext ( "one-" ) ; r1 . onError ( new TestException ( ) ) ; io . verify ( o ) . onNext ( "one-1" ) ; io . verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
PublishSubject < String > r1 = PublishSubject . create ( ) ; Observer < String > o = TestHelper . mockObserver ( ) ; InOrder io = inOrder ( o ) ; Iterable < String > r2 = new Iterable < String > ( ) @ Override public Iterator < String > iterator ( ) return new Iterator < String > ( ) @ Override public boolean hasNext ( ) return true ; @ Override public String next ( ) throw new TestException ( ) ; @ Override public void remove ( ) throw new UnsupportedOperationException ( "Not supported yet." ) ; ; ; r1 . zipWith ( r2 , zipr2 ) . subscribe ( o ) ; r1 . onError ( new TestException ( ) ) ; io . verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; 
counter . incrementAndGet ( ) ; System . out . println ( "Omg I'm calculating so hard: " + t1 + "*" + t1 + "=" + ( t1 * t1 ) ) ; return " " + ( t1 * t1 ) ; 
Observable < Integer > o = Observable . just ( 1 , 2 , 3 , 4 , 5 ) ; Iterable < String > it = Arrays . asList ( "a" , "b" , "c" , "d" , "e" ) ; SquareStr squareStr = new SquareStr ( ) ; o . map ( squareStr ) . zipWith ( it , concat2Strings ) . take ( 2 ) . subscribe ( printer ) ; assertEquals ( 2 , squareStr . counter . get ( ) ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . zipWith ( Arrays . asList ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Integer > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Integer > o ) throws Exception return o . zipWith ( Arrays . asList ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) ; ) ; 
Observable . just ( 1 ) . zipWith ( new CrashingIterable ( 100 , 1 , 100 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) . to ( TestHelper . < Object > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "hasNext()" ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onComplete ( ) ; observer . onNext ( 2 ) ; observer . onError ( new TestException ( ) ) ; observer . onComplete ( ) ; . zipWith ( Arrays . asList ( 1 ) , new BiFunction < Integer , Integer , Object > ( ) @ Override public Object apply ( Integer a , Integer b ) throws Exception return a + b ; ) . test ( ) . assertResult ( 2 ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . onNext ( 100 ) ; ) ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 , 4 , 5 , 100 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . < Integer > error ( new TestException ( ) ) . concatWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . onNext ( 100 ) ; ) ) . subscribe ( to ) ; to . assertFailure ( TestException . class ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Completable . error ( new TestException ( ) ) ) . subscribe ( to ) ; to . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
final TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 1 , 5 ) . concatWith ( Completable . fromAction ( new Action ( ) @ Override public void run ( ) throws Exception to . onNext ( 100 ) ; ) ) . take ( 3 ) . subscribe ( to ) ; to . assertResult ( 1 , 2 , 3 ) ; 
CompletableSubject other = CompletableSubject . create ( ) ; TestObserver < Object > to = Observable . empty ( ) . concatWith ( other ) . test ( ) ; assertTrue ( other . hasObservers ( ) ) ; to . dispose ( ) ; assertFalse ( other . hasObservers ( ) ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) Disposable bs1 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; Disposable bs2 = Disposable . empty ( ) ; observer . onSubscribe ( bs2 ) ; assertFalse ( bs1 . isDisposed ( ) ) ; assertTrue ( bs2 . isDisposed ( ) ) ; observer . onComplete ( ) ; . concatWith ( Completable . complete ( ) ) . test ( ) . assertResult ( ) ; 
new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) Disposable bs1 = Disposable . empty ( ) ; observer . onSubscribe ( bs1 ) ; assertFalse ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; observer . onNext ( 1 ) ; assertTrue ( ( ( Disposable ) observer ) . isDisposed ( ) ) ; assertTrue ( bs1 . isDisposed ( ) ) ; . concatWith ( Completable . complete ( ) ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
Disposable upstream = mock ( Disposable . class ) ; TestObservable f = new TestObservable ( upstream , "one" , "fail" , "two" , "three" ) ; Observable < String > w = Observable . unsafeCreate ( f ) ; Observable < String > resume = Observable . just ( "twoResume" , "threeResume" ) ; Observable < String > observable = w . onErrorResumeWith ( resume ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; try f . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( observer , times ( 1 ) ) . onNext ( "threeResume" ) ; 
Disposable sr = mock ( Disposable . class ) ; Observable < String > w = Observable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; TestObservable f = new TestObservable ( sr , "twoResume" , "threeResume" ) ; Observable < String > resume = Observable . unsafeCreate ( f ) ; w = w . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; System . out . println ( "BadMapper:" + s ) ; return s ; ) ; Observable < String > observable = w . onErrorResumeWith ( resume ) ; Observer < String > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; try f . t . join ( ) ; catch ( InterruptedException e ) fail ( e . getMessage ( ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; verify ( observer , times ( 1 ) ) . onNext ( "one" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "two" ) ; verify ( observer , Mockito . never ( ) ) . onNext ( "three" ) ; verify ( observer , times ( 1 ) ) . onNext ( "twoResume" ) ; verify ( observer , times ( 1 ) ) . onNext ( "threeResume" ) ; 
System . out . println ( "TestObservable subscribed to ..." ) ; observer . onSubscribe ( upstream ) ; t = new Thread ( new Runnable ( ) @ Override public void run ( ) try System . out . println ( "running TestObservable thread" ) ; for ( String s : values ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; System . out . println ( "TestObservable onNext: " + s ) ; observer . onNext ( s ) ; System . out . println ( "TestObservable onComplete" ) ; observer . onComplete ( ) ; catch ( Throwable e ) System . out . println ( "TestObservable onError: " + e ) ; observer . onError ( e ) ; ) ; System . out . println ( "starting TestObservable thread" ) ; t . start ( ) ; System . out . println ( "done starting TestObservable thread" ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( 0 , 100000 ) . onErrorResumeWith ( Observable . just ( 1 ) ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) int c ; @ Override public Integer apply ( Integer t1 ) if ( c ++ <= 1 ) try Thread . sleep ( 500 ) ; catch ( InterruptedException e ) e . printStackTrace ( ) ; return t1 ; ) . subscribe ( to ) ; to . awaitDone ( 5 , TimeUnit . SECONDS ) ; to . assertNoErrors ( ) ; 
Observer < Integer > observer = TestHelper . mockObserver ( ) ; Observable . range ( 2 , 3 ) . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onNext ( 3 ) ; verify ( observer , times ( 1 ) ) . onNext ( 4 ) ; verify ( observer , never ( ) ) . onNext ( 5 ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observer < Integer > observer = TestHelper . mockObserver ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Observable . range ( 1 , 1000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . take ( 3 ) . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( 1 ) ; verify ( observer , times ( 1 ) ) . onNext ( 2 ) ; verify ( observer , times ( 1 ) ) . onNext ( 3 ) ; verify ( observer , never ( ) ) . onNext ( 4 ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; assertEquals ( 3 , count . get ( ) ) ; 
Observable . range ( 1 , 0 ) ; 
Observable . range ( Integer . MAX_VALUE , 0 ) ; 
Observable . range ( 1 , Integer . MAX_VALUE ) ; 
Observable . range ( 2 , Integer . MAX_VALUE ) ; 
assertFalse ( Observable . range ( Integer . MIN_VALUE , 0 ) . blockingIterable ( ) . iterator ( ) . hasNext ( ) ) ; 
ArrayList < Integer > list = new ArrayList < > ( Flowable . bufferSize ( ) * 2 ) ; for ( int i = 1 ; i <= Flowable . bufferSize ( ) * 2 + 1 ; i ++ ) list . add ( i ) ; Observable < Integer > o = Observable . range ( 1 , list . size ( ) ) ; TestObserverEx < Integer > to = new TestObserverEx < > ( ) ; o . subscribe ( to ) ; to . assertValueSequence ( list ) ; to . assertTerminated ( ) ; 
final AtomicBoolean completed = new AtomicBoolean ( false ) ; Observable . range ( 1 , 0 ) . subscribe ( new DefaultObserver < Integer > ( ) @ Override public void onStart ( ) @ Override public void onComplete ( ) completed . set ( true ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) ) ; assertTrue ( completed . get ( ) ) ; 
TestObserver < Integer > to = new TestObserver < > ( ) ; Observable . range ( Integer . MAX_VALUE - 1 , 2 ) . subscribe ( to ) ; to . assertComplete ( ) ; to . assertNoErrors ( ) ; to . assertValues ( Integer . MAX_VALUE - 1 , Integer . MAX_VALUE ) ; 
try Observable . range ( 1 , - 1 ) ; fail ( "Should have thrown IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "count >= 0 required but it was -1" , ex . getMessage ( ) ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ASYNC ) ; Observable . range ( 1 , 5 ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
stringObserver = TestHelper . mockObserver ( ) ; stringObserver2 = TestHelper . mockObserver ( ) ; 
Map < String , String > m1 = getMap ( "One" ) ; Map < String , String > m2 = getMap ( "Two" ) ; Observable < Map < String , String > > o = Observable . just ( m1 , m2 ) ; Observable < String > m = o . map ( new Function < Map < String , String > , String > ( ) @ Override public String apply ( Map < String , String > map ) return map . get ( "firstName" ) ; ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "OneFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "TwoFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > ids = Observable . just ( 1 , 2 ) ; Observable < String > m = ids . flatMap ( new Function < Integer , Observable < String > > ( ) @ Override public Observable < String > apply ( Integer id ) Observable < Map < String , String > > subObservable = null ; if ( id == 1 ) Map < String , String > m1 = getMap ( "One" ) ; Map < String , String > m2 = getMap ( "Two" ) ; subObservable = Observable . just ( m1 , m2 ) ; else Map < String , String > m3 = getMap ( "Three" ) ; Map < String , String > m4 = getMap ( "Four" ) ; subObservable = Observable . just ( m3 , m4 ) ; return subObservable . map ( new Function < Map < String , String > , String > ( ) @ Override public String apply ( Map < String , String > map ) return map . get ( "firstName" ) ; ) ; ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "OneFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "TwoFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "ThreeFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "FourFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; 
Map < String , String > m1 = getMap ( "One" ) ; Map < String , String > m2 = getMap ( "Two" ) ; Observable < Map < String , String > > observable1 = Observable . just ( m1 , m2 ) ; Map < String , String > m3 = getMap ( "Three" ) ; Map < String , String > m4 = getMap ( "Four" ) ; Observable < Map < String , String > > observable2 = Observable . just ( m3 , m4 ) ; Observable < Observable < Map < String , String > > > o = Observable . just ( observable1 , observable2 ) ; Observable < String > m = o . flatMap ( new Function < Observable < Map < String , String > > , Observable < String > > ( ) @ Override public Observable < String > apply ( Observable < Map < String , String > > o ) return o . map ( new Function < Map < String , String > , String > ( ) @ Override public String apply ( Map < String , String > map ) return map . get ( "firstName" ) ; ) ; ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "OneFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "TwoFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "ThreeFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "FourFirst" ) ; verify ( stringObserver , times ( 1 ) ) . onComplete ( ) ; 
Observable < String > w = Observable . just ( "one" , "fail" , "two" , "three" , "fail" ) ; Observable < String > m = w . map ( new Function < String , String > ( ) @ Override public String apply ( String s ) if ( "fail" . equals ( s ) ) throw new RuntimeException ( "Forced Failure" ) ; return s ; ) . doOnError ( new Consumer < Throwable > ( ) @ Override public void accept ( Throwable t1 ) t1 . printStackTrace ( ) ; ) ; m . subscribe ( stringObserver ) ; verify ( stringObserver , times ( 1 ) ) . onNext ( "one" ) ; verify ( stringObserver , never ( ) ) . onNext ( "two" ) ; verify ( stringObserver , never ( ) ) . onNext ( "three" ) ; verify ( stringObserver , never ( ) ) . onComplete ( ) ; verify ( stringObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; 
Observable . just ( 1 ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer arg0 ) throw new IllegalArgumentException ( "any error" ) ; ) . blockingSingle ( ) ; 
Observable < String > m = Observable . just ( "one" ) . observeOn ( Schedulers . computation ( ) ) . map ( new Function < String , String > ( ) @ Override public String apply ( String arg0 ) throw new IllegalArgumentException ( "any error" ) ; ) ; m . blockingLast ( ) ; 
assertNull ( Observable . range ( 1 , 0 ) . lastElement ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i ; ) . blockingGet ( ) ) ; 
Observable . error ( new IllegalStateException ( ) ) . map ( new Function < Object , Object > ( ) @ Override public Object apply ( Object i ) return i ; ) . blockingSingle ( ) ; 
Observable . range ( 1 , 1 ) . lastElement ( ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer i ) return i / 0 ; ) . blockingGet ( ) ; 
Map < String , String > m = new HashMap < > ( ) ; m . put ( "firstName" , prefix + "First" ) ; m . put ( "lastName" , prefix + "Last" ) ; return m ; 
TestHelper . checkDisposed ( Observable . range ( 1 , 5 ) . map ( Functions . identity ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . map ( Functions . identity ( ) ) ; ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; Observable . range ( 1 , 5 ) . map ( Functions . < Integer > identity ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY ) ; UnicastSubject < Integer > us = UnicastSubject . create ( ) ; us . map ( Functions . < Integer > identity ( ) ) . subscribe ( to ) ; TestHelper . emit ( us , 1 , 2 , 3 , 4 , 5 ) ; to . assertFusionMode ( QueueFuseable . ASYNC ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestObserverEx < Integer > to = new TestObserverEx < > ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ; Observable . range ( 1 , 5 ) . map ( Functions . < Integer > identity ( ) ) . subscribe ( to ) ; to . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . checkBadSourceObservable ( new Function < Observable < Object > , Object > ( ) @ Override public Object apply ( Observable < Object > o ) throws Exception return o . map ( Functions . identity ( ) ) ; , false , 1 , 1 , 1 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skipLast ( 1000 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; scheduler . advanceTimeBy ( 950 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 4 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 5 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 6 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skipLast ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 1050 , TimeUnit . MILLISECONDS ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skipLast ( 1 , TimeUnit . SECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skipLast ( 1 , TimeUnit . MILLISECONDS , scheduler ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable . just ( 1 ) . concatWith ( Observable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ) . skipLast ( 300 , TimeUnit . MILLISECONDS ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . concatWith ( Observable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ) . skipLast ( 300 , TimeUnit . MILLISECONDS , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
Observable . just ( 1 ) . concatWith ( Observable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ) . skipLast ( 300 , TimeUnit . MILLISECONDS , Schedulers . io ( ) , true ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestHelper . checkDisposed ( PublishSubject . create ( ) . skipLast ( 1 , TimeUnit . DAYS ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Object > > ( ) @ Override public ObservableSource < Object > apply ( Observable < Object > o ) throws Exception return o . skipLast ( 1 , TimeUnit . DAYS ) ; ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . skipLast ( 1 , TimeUnit . DAYS , scheduler ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . skipLast ( 1 , TimeUnit . DAYS , scheduler , true ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
Observable . error ( new TestException ( ) ) . skipLast ( 1 , TimeUnit . DAYS , new TestScheduler ( ) , true ) . test ( ) . assertFailure ( TestException . class ) ; 
Observable . just ( 1 ) . skipLast ( 0 , TimeUnit . SECONDS ) . take ( 1 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . skipLast ( 1 , TimeUnit . DAYS , scheduler ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishSubject < Integer > ps = PublishSubject . create ( ) ; final TestObserver < Integer > to = ps . skipLast ( 1 , TimeUnit . DAYS , scheduler , true ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) ps . onNext ( 1 ) ; ps . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) to . dispose ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skipLast ( 1000 , TimeUnit . MILLISECONDS , scheduler , true ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; scheduler . advanceTimeBy ( 950 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 4 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 5 ) ; inOrder . verify ( o , never ( ) ) . onNext ( 6 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skipLast ( 1 , TimeUnit . SECONDS , scheduler , true ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onError ( new TestException ( ) ) ; scheduler . advanceTimeBy ( 1050 , TimeUnit . MILLISECONDS ) ; verify ( o ) . onError ( any ( TestException . class ) ) ; verify ( o , never ( ) ) . onComplete ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skipLast ( 1 , TimeUnit . SECONDS , scheduler , true ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; verify ( o , never ( ) ) . onNext ( any ( ) ) ; verify ( o , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; PublishSubject < Integer > source = PublishSubject . create ( ) ; Observable < Integer > result = source . skipLast ( 1 , TimeUnit . MILLISECONDS , scheduler , true ) ; Observer < Object > o = TestHelper . mockObserver ( ) ; result . subscribe ( o ) ; source . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; scheduler . advanceTimeBy ( 500 , TimeUnit . MILLISECONDS ) ; source . onComplete ( ) ; InOrder inOrder = inOrder ( o ) ; inOrder . verify ( o ) . onNext ( 1 ) ; inOrder . verify ( o ) . onNext ( 2 ) ; inOrder . verify ( o ) . onNext ( 3 ) ; inOrder . verify ( o ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Observable < Integer > w = Observable . just ( 1 , 3 , 2 , 5 , 4 ) ; Observable < List < Integer > > observable = w . toSortedList ( ) . toObservable ( ) ; Observer < List < Integer > > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . just ( 1 , 3 , 2 , 5 , 4 ) ; Observable < List < Integer > > observable = w . toSortedList ( new Comparator < Integer > ( ) @ Override public int compare ( Integer t1 , Integer t2 ) return t2 - t1 ; ) . toObservable ( ) ; Observer < List < Integer > > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > o = Observable . just ( 1 , 3 , 2 , 5 , 4 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , o . toSortedList ( ) . toObservable ( ) . blockingFirst ( ) ) ; 
try cb . await ( ) ; catch ( InterruptedException ex ) ex . printStackTrace ( ) ; catch ( BrokenBarrierException ex ) ex . printStackTrace ( ) ; 
Observable . just ( 5 , 1 , 2 , 4 , 3 ) . sorted ( ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Observable . just ( 5 , 1 , 2 , 4 , 3 ) . sorted ( new Comparator < Integer > ( ) @ Override public int compare ( Integer a , Integer b ) return b - a ; ) . test ( ) . assertResult ( 5 , 4 , 3 , 2 , 1 ) ; 
Observable . just ( 5 , 1 , 2 , 4 , 3 ) . toSortedList ( 4 ) . toObservable ( ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Observable . just ( 5 , 1 , 2 , 4 , 3 ) . toSortedList ( new Comparator < Integer > ( ) @ Override public int compare ( Integer a , Integer b ) return b - a ; , 4 ) . toObservable ( ) . test ( ) . assertResult ( Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) ; 
Observable < Integer > w = Observable . just ( 1 , 3 , 2 , 5 , 4 ) ; Single < List < Integer > > single = w . toSortedList ( ) ; SingleObserver < List < Integer > > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . just ( 1 , 3 , 2 , 5 , 4 ) ; Single < List < Integer > > single = w . toSortedList ( new Comparator < Integer > ( ) @ Override public int compare ( Integer t1 , Integer t2 ) return t2 - t1 ; ) ; SingleObserver < List < Integer > > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) ; verify ( observer , Mockito . never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . just ( 1 , 3 , 2 , 5 , 4 ) ; assertEquals ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) , o . toSortedList ( ) . blockingGet ( ) ) ; 
Observable . just ( 5 , 1 , 2 , 4 , 3 ) . toSortedList ( 4 ) . test ( ) . assertResult ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ) ; 
Observable . just ( 5 , 1 , 2 , 4 , 3 ) . toSortedList ( new Comparator < Integer > ( ) @ Override public int compare ( Integer a , Integer b ) return b - a ; , 4 ) . test ( ) . assertResult ( Arrays . asList ( 5 , 4 , 3 , 2 , 1 ) ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 ) ; Observable < Boolean > observable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , times ( 1 ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 ) ; Observable < Boolean > observable = w . isEmpty ( ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , times ( 1 ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . just ( 1 ) ; Observable < Boolean > observable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , times ( 1 ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . just ( 1 ) ; Observable < Boolean > observable = w . isEmpty ( ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , times ( 1 ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . empty ( ) ; Observable < Boolean > observable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . empty ( ) ; Observable < Boolean > observable = w . isEmpty ( ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 , 3 ) ; Observable < Boolean > observable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , times ( 1 ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 , 3 ) ; Observable < Boolean > observable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , never ( ) ) . onNext ( false ) ; verify ( observer , times ( 1 ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 , 3 ) ; Observable < Boolean > observable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 1 ; ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > w = Observable . empty ( ) ; Observable < Boolean > observable = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t ) return true ; ) . toObservable ( ) ; Observer < Boolean > observer = TestHelper . mockObserver ( ) ; observable . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onNext ( false ) ; verify ( observer , never ( ) ) . onNext ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( observer , times ( 1 ) ) . onComplete ( ) ; 
Observable < Integer > o = Observable . fromArray ( 1 , 3 , 5 , 6 ) ; Observable < Boolean > anyEven = o . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i % 2 == 0 ; ) . toObservable ( ) ; assertTrue ( anyEven . blockingFirst ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) . isEmpty ( ) . toObservable ( ) . flatMap ( new Function < Boolean , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Boolean t1 ) return Observable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ; ) ; assertEquals ( ( Object ) 2 , source . blockingFirst ( ) ) ; 
TestObserverEx < Boolean > to = new TestObserverEx < > ( ) ; final IllegalArgumentException ex = new IllegalArgumentException ( ) ; Observable . just ( "Boo!" ) . any ( new Predicate < String > ( ) @ Override public boolean test ( String v ) throw ex ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( ex ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 ) ; Single < Boolean > single = w . isEmpty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . just ( 1 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . just ( 1 ) ; Single < Boolean > single = w . isEmpty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . empty ( ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) return true ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . empty ( ) ; Single < Boolean > single = w . isEmpty ( ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 , 3 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 , 3 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 2 ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , never ( ) ) . onSuccess ( false ) ; verify ( observer , times ( 1 ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . just ( 1 , 2 , 3 ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t1 ) return t1 < 1 ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > w = Observable . empty ( ) ; Single < Boolean > single = w . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer t ) return true ; ) ; SingleObserver < Boolean > observer = TestHelper . mockSingleObserver ( ) ; single . subscribe ( observer ) ; verify ( observer , times ( 1 ) ) . onSuccess ( false ) ; verify ( observer , never ( ) ) . onSuccess ( true ) ; verify ( observer , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
Observable < Integer > o = Observable . fromArray ( 1 , 3 , 5 , 6 ) ; Single < Boolean > anyEven = o . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer i ) return i % 2 == 0 ; ) ; assertTrue ( anyEven . blockingGet ( ) ) ; 
Observable < Integer > source = Observable . just ( 1 ) . isEmpty ( ) . flatMapObservable ( new Function < Boolean , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Boolean t1 ) return Observable . just ( 2 ) . delay ( 500 , TimeUnit . MILLISECONDS ) ; ) ; assertEquals ( ( Object ) 2 , source . blockingFirst ( ) ) ; 
TestObserverEx < Boolean > to = new TestObserverEx < > ( ) ; final IllegalArgumentException ex = new IllegalArgumentException ( ) ; Observable . just ( "Boo!" ) . any ( new Predicate < String > ( ) @ Override public boolean test ( String v ) throw ex ; ) . subscribe ( to ) ; to . assertTerminated ( ) ; to . assertNoValues ( ) ; to . assertNotComplete ( ) ; to . assertError ( ex ) ; 
TestHelper . checkDisposed ( Observable . just ( 1 ) . any ( Functions . alwaysTrue ( ) ) . toObservable ( ) ) ; TestHelper . checkDisposed ( Observable . just ( 1 ) . any ( Functions . alwaysTrue ( ) ) ) ; 
TestHelper . checkDoubleOnSubscribeObservable ( new Function < Observable < Object > , ObservableSource < Boolean > > ( ) @ Override public ObservableSource < Boolean > apply ( Observable < Object > o ) throws Exception return o . any ( Functions . alwaysTrue ( ) ) . toObservable ( ) ; ) ; TestHelper . checkDoubleOnSubscribeObservableToSingle ( new Function < Observable < Object > , SingleSource < Boolean > > ( ) @ Override public SingleSource < Boolean > apply ( Observable < Object > o ) throws Exception return o . any ( Functions . alwaysTrue ( ) ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onNext ( 1 ) ; observer . onNext ( 2 ) ; observer . onError ( new IOException ( ) ) ; observer . onComplete ( ) ; . any ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception throw new TestException ( ) ; ) . toObservable ( ) . test ( ) . assertFailure ( TestException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , IOException . class ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try new Observable < Integer > ( ) @ Override protected void subscribeActual ( Observer < ? super Integer > observer ) observer . onSubscribe ( Disposable . empty ( ) ) ; observer . onError ( new TestException ( "First" ) ) ; observer . onNext ( 1 ) ; observer . onError ( new TestException ( "Second" ) ) ; observer . onComplete ( ) ; . any ( Functions . alwaysTrue ( ) ) . to ( TestHelper . < Boolean > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
TestSubscriber < Object > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . flatMap ( new Function < Integer , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Integer item ) return Flowable . just ( ( Object ) ( item + 1 ) ) ; , new Function < Throwable , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Throwable e ) return Flowable . error ( e ) ; , new Supplier < Flowable < Object > > ( ) @ Override public Flowable < Object > get ( ) return Flowable . never ( ) ; ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . assertValue ( 2 ) ; 
TestSubscriber < Object > ts = TestSubscriber . create ( 0L ) ; new FlowableMapNotification < > ( Flowable . range ( 1 , 3 ) , new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer item ) return item + 1 ; , new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable e ) return 0 ; , new Supplier < Integer > ( ) @ Override public Integer get ( ) return 5 ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 3 ) ; ts . assertValues ( 2 , 3 , 4 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . assertValues ( 2 , 3 , 4 , 5 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestSubscriber < Object > ts = TestSubscriber . create ( 0L ) ; PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; new FlowableMapNotification < > ( pp , new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer item ) return item + 1 ; , new Function < Throwable , Integer > ( ) @ Override public Integer apply ( Throwable e ) return 0 ; , new Supplier < Integer > ( ) @ Override public Integer get ( ) return 5 ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; pp . onNext ( 1 ) ; pp . onNext ( 2 ) ; pp . onNext ( 3 ) ; pp . onComplete ( ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . request ( 1 ) ; ts . assertValue ( 0 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
TestHelper . checkDisposed ( new Flowable < Integer > ( ) @ SuppressWarnings ( "rawtypes" , "unchecked" ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > subscriber ) MapNotificationSubscriber mn = new MapNotificationSubscriber ( subscriber , Functions . justFunction ( Flowable . just ( 1 ) ) , Functions . justFunction ( Flowable . just ( 2 ) ) , Functions . justSupplier ( Flowable . just ( 3 ) ) ) ; mn . onSubscribe ( new BooleanSubscription ( ) ) ; ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Object > f ) throws Exception return f . flatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) , Functions . justFunction ( Flowable . just ( 2 ) ) , Functions . justSupplier ( Flowable . just ( 3 ) ) ) ; ) ; 
TestSubscriberEx < Integer > ts = Flowable . < Integer > error ( new TestException ( "Outer" ) ) . flatMap ( Functions . justFunction ( Flowable . just ( 1 ) ) , new Function < Throwable , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Throwable t ) throws Exception throw new TestException ( "Inner" ) ; , Functions . justSupplier ( Flowable . just ( 3 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailure ( CompositeException . class ) ; TestHelper . assertError ( ts , 0 , TestException . class , "Outer" ) ; TestHelper . assertError ( ts , 1 , TestException . class , "Inner" ) ; 
objectSubscriber = TestHelper . mockSubscriber ( ) ; singleObserver = TestHelper . mockSingleObserver ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" ) ; Flowable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc ) . toFlowable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "a" , "b" ) ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , times ( 1 ) ) . onNext ( expected ) ; verify ( objectSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" ) ; Flowable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicate ) . toFlowable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "aa" , "bb" ) ) ; expected . put ( 2 , Arrays . asList ( "cccc" , "dddd" ) ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , times ( 1 ) ) . onNext ( expected ) ; verify ( objectSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" , "eee" , "fff" ) ; Supplier < Map < Integer , Collection < String > > > mapFactory = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new LinkedHashMap < Integer , Collection < String > > ( ) private static final long serialVersionUID = - 2084477070717362859L ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , Collection < String > > eldest ) return size ( ) > 2 ; ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Flowable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapFactory , new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer e ) return new ArrayList < > ( ) ; ) . toFlowable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Arrays . asList ( "eee" , "fff" ) ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , times ( 1 ) ) . onNext ( expected ) ; verify ( objectSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "cc" , "dd" , "eee" , "eee" ) ; Function < Integer , Collection < String > > collectionFactory = new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer t1 ) if ( t1 == 2 ) return new ArrayList < > ( ) ; else return new HashSet < > ( ) ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Supplier < Map < Integer , Collection < String > > > mapSupplier = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new HashMap < > ( ) ; ; Flowable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapSupplier , collectionFactory ) . toFlowable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , new HashSet < > ( Arrays . asList ( "eee" ) ) ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , times ( 1 ) ) . onNext ( expected ) ; verify ( objectSubscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" ) ; Function < String , Integer > lengthFuncErr = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) if ( "b" . equals ( t1 ) ) throw new RuntimeException ( "Forced Failure" ) ; return t1 . length ( ) ; ; Flowable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFuncErr ) . toFlowable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "a" , "b" ) ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , never ( ) ) . onNext ( expected ) ; verify ( objectSubscriber , never ( ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" ) ; Function < String , String > duplicateErr = new Function < String , String > ( ) @ Override public String apply ( String t1 ) if ( "b" . equals ( t1 ) ) throw new RuntimeException ( "Forced failure" ) ; return t1 + t1 ; ; Flowable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicateErr ) . toFlowable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "aa" , "bb" ) ) ; expected . put ( 2 , Arrays . asList ( "cccc" , "dddd" ) ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , never ( ) ) . onNext ( expected ) ; verify ( objectSubscriber , never ( ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" , "eee" , "fff" ) ; Supplier < Map < Integer , Collection < String > > > mapFactory = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) throw new RuntimeException ( "Forced failure" ) ; ; Flowable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) . toFlowable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Arrays . asList ( "eee" , "fff" ) ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , never ( ) ) . onNext ( expected ) ; verify ( objectSubscriber , never ( ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "cc" , "cc" , "eee" , "eee" ) ; Function < Integer , Collection < String > > collectionFactory = new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer t1 ) if ( t1 == 2 ) throw new RuntimeException ( "Forced failure" ) ; else return new HashSet < > ( ) ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Supplier < Map < Integer , Collection < String > > > mapSupplier = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new HashMap < > ( ) ; ; Flowable < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapSupplier , collectionFactory ) . toFlowable ( ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Collections . singleton ( "eee" ) ) ; mapped . subscribe ( objectSubscriber ) ; verify ( objectSubscriber , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( objectSubscriber , never ( ) ) . onNext ( expected ) ; verify ( objectSubscriber , never ( ) ) . onComplete ( ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" ) ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "a" , "b" ) ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" ) ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicate ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "aa" , "bb" ) ) ; expected . put ( 2 , Arrays . asList ( "cccc" , "dddd" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" , "eee" , "fff" ) ; Supplier < Map < Integer , Collection < String > > > mapFactory = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new LinkedHashMap < Integer , Collection < String > > ( ) private static final long serialVersionUID = - 2084477070717362859L ; @ Override protected boolean removeEldestEntry ( Map . Entry < Integer , Collection < String > > eldest ) return size ( ) > 2 ; ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapFactory , new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer e ) return new ArrayList < > ( ) ; ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Arrays . asList ( "eee" , "fff" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "cc" , "dd" , "eee" , "eee" ) ; Function < Integer , Collection < String > > collectionFactory = new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer t1 ) if ( t1 == 2 ) return new ArrayList < > ( ) ; else return new HashSet < > ( ) ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Supplier < Map < Integer , Collection < String > > > mapSupplier = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new HashMap < > ( ) ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapSupplier , collectionFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , new HashSet < > ( Arrays . asList ( "eee" ) ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , times ( 1 ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" ) ; Function < String , Integer > lengthFuncErr = new Function < String , Integer > ( ) @ Override public Integer apply ( String t1 ) if ( "b" . equals ( t1 ) ) throw new RuntimeException ( "Forced Failure" ) ; return t1 . length ( ) ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFuncErr ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "a" , "b" ) ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" ) ; Function < String , String > duplicateErr = new Function < String , String > ( ) @ Override public String apply ( String t1 ) if ( "b" . equals ( t1 ) ) throw new RuntimeException ( "Forced failure" ) ; return t1 + t1 ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , duplicateErr ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 1 , Arrays . asList ( "aa" , "bb" ) ) ; expected . put ( 2 , Arrays . asList ( "cccc" , "dddd" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "a" , "b" , "cc" , "dd" , "eee" , "fff" ) ; Supplier < Map < Integer , Collection < String > > > mapFactory = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) throw new RuntimeException ( "Forced failure" ) ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; , mapFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Arrays . asList ( "eee" , "fff" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; 
Flowable < String > source = Flowable . just ( "cc" , "cc" , "eee" , "eee" ) ; Function < Integer , Collection < String > > collectionFactory = new Function < Integer , Collection < String > > ( ) @ Override public Collection < String > apply ( Integer t1 ) if ( t1 == 2 ) throw new RuntimeException ( "Forced failure" ) ; else return new HashSet < > ( ) ; ; Function < String , String > identity = new Function < String , String > ( ) @ Override public String apply ( String v ) return v ; ; Supplier < Map < Integer , Collection < String > > > mapSupplier = new Supplier < Map < Integer , Collection < String > > > ( ) @ Override public Map < Integer , Collection < String > > get ( ) return new HashMap < > ( ) ; ; Single < Map < Integer , Collection < String > > > mapped = source . toMultimap ( lengthFunc , identity , mapSupplier , collectionFactory ) ; Map < Integer , Collection < String > > expected = new HashMap < > ( ) ; expected . put ( 2 , Arrays . asList ( "cc" , "dd" ) ) ; expected . put ( 3 , Collections . singleton ( "eee" ) ) ; mapped . subscribe ( singleObserver ) ; verify ( singleObserver , times ( 1 ) ) . onError ( any ( Throwable . class ) ) ; verify ( singleObserver , never ( ) ) . onSuccess ( expected ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Long > source = Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 10 ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertTrue ( it . hasNext ( ) ) ; Assert . assertEquals ( Long . valueOf ( i ) , it . next ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertFalse ( it . hasNext ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Long > source = Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 10 ) ; Iterable < Long > iter = source . blockingLatest ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) Iterator < Long > it = iter . iterator ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertTrue ( it . hasNext ( ) ) ; Assert . assertEquals ( Long . valueOf ( i ) , it . next ( ) ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertFalse ( it . hasNext ( ) ) ; 
Flowable < Long > source = Flowable . < Long > empty ( ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; Assert . assertFalse ( it . hasNext ( ) ) ; it . next ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Long > source = Flowable . interval ( 1 , TimeUnit . SECONDS , scheduler ) . take ( 10 ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; Assert . assertEquals ( Long . valueOf ( i ) , it . next ( ) ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Long > source = Flowable . < Long > error ( new RuntimeException ( "Forced failure!" ) ) . subscribeOn ( scheduler ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; it . hasNext ( ) ; 
TestScheduler scheduler = new TestScheduler ( ) ; Flowable < Long > source = Flowable . < Long > error ( new RuntimeException ( "Forced failure!" ) ) . subscribeOn ( scheduler ) ; Iterable < Long > iter = source . blockingLatest ( ) ; Iterator < Long > it = iter . iterator ( ) ; scheduler . advanceTimeBy ( 1 , TimeUnit . SECONDS ) ; it . next ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; Flowable < Integer > blocker = source ; Iterable < Integer > iter = blocker . blockingLatest ( ) ; Iterator < Integer > it = iter . iterator ( ) ; source . onNext ( 1 ) ; Assert . assertEquals ( Integer . valueOf ( 1 ) , it . next ( ) ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; Assert . assertEquals ( Integer . valueOf ( 3 ) , it . next ( ) ) ; source . onNext ( 4 ) ; source . onNext ( 5 ) ; source . onNext ( 6 ) ; Assert . assertEquals ( Integer . valueOf ( 6 ) , it . next ( ) ) ; source . onNext ( 7 ) ; source . onComplete ( ) ; Assert . assertFalse ( it . hasNext ( ) ) ; 
Flowable . never ( ) . blockingLatest ( ) . iterator ( ) . remove ( ) ; 
Iterator < Object > it = Flowable . never ( ) . blockingLatest ( ) . iterator ( ) ; Thread . currentThread ( ) . interrupt ( ) ; try it . hasNext ( ) ; catch ( RuntimeException ex ) assertTrue ( ex . toString ( ) , ex . getCause ( ) instanceof InterruptedException ) ; Thread . interrupted ( ) ; 
Flowable . empty ( ) . blockingLatest ( ) . iterator ( ) . next ( ) ; 
Flowable . error ( new TestException ( ) ) . blockingLatest ( ) . iterator ( ) . next ( ) ; 
Iterator < Object > it = Flowable . error ( new TestException ( ) ) . blockingLatest ( ) . iterator ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) try it . hasNext ( ) ; fail ( "Should have thrown" ) ; catch ( TestException ex ) 
Iterator < Object > it = Flowable . never ( ) . blockingLatest ( ) . iterator ( ) ; List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try ( ( Subscriber < Object > ) it ) . onError ( new TestException ( ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable < String > skip = Flowable . just ( "one" , "two" , "three" ) . skip ( - 99 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; skip . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > skip = Flowable . just ( "one" , "two" , "three" ) . skip ( 0 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; skip . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > skip = Flowable . just ( "one" , "two" , "three" ) . skip ( 1 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; skip . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( "one" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > skip = Flowable . just ( "one" , "two" , "three" ) . skip ( 2 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; skip . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( "one" ) ; verify ( subscriber , never ( ) ) . onNext ( "two" ) ; verify ( subscriber , times ( 1 ) ) . onNext ( "three" ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > w = Flowable . empty ( ) ; Flowable < String > skip = w . skip ( 1 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; skip . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Flowable < String > skip = Flowable . just ( "one" , "two" , "three" ) . skip ( 2 ) ; Subscriber < String > subscriber1 = TestHelper . mockSubscriber ( ) ; skip . subscribe ( subscriber1 ) ; Subscriber < String > subscriber2 = TestHelper . mockSubscriber ( ) ; skip . subscribe ( subscriber2 ) ; verify ( subscriber1 , times ( 1 ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber1 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber1 , times ( 1 ) ) . onComplete ( ) ; verify ( subscriber2 , times ( 1 ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber2 , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber2 , times ( 1 ) ) . onComplete ( ) ; 
Exception e = new Exception ( ) ; Flowable < String > ok = Flowable . just ( "one" ) ; Flowable < String > error = Flowable . error ( e ) ; Flowable < String > skip = Flowable . concat ( ok , error ) . skip ( 100 ) ; Subscriber < String > subscriber = TestHelper . mockSubscriber ( ) ; skip . subscribe ( subscriber ) ; verify ( subscriber , never ( ) ) . onNext ( any ( String . class ) ) ; verify ( subscriber , times ( 1 ) ) . onError ( e ) ; verify ( subscriber , never ( ) ) . onComplete ( ) ; 
final AtomicLong requests = new AtomicLong ( 0 ) ; TestSubscriber < Long > ts = new TestSubscriber < > ( 0L ) ; Flowable . interval ( 100 , TimeUnit . MILLISECONDS ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long n ) requests . addAndGet ( n ) ; ) . skip ( 4 ) . subscribe ( ts ) ; Thread . sleep ( 100 ) ; ts . request ( 1 ) ; ts . request ( 1 ) ; Thread . sleep ( 100 ) ; ts . cancel ( ) ; ts . assertNoErrors ( ) ; assertEquals ( 6 , requests . get ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( Long . MAX_VALUE - 1 ) ; Flowable . range ( 1 , 10 ) . skip ( 5 ) . subscribe ( ts ) ; ts . assertTerminated ( ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; assertEquals ( Arrays . asList ( 6 , 7 , 8 , 9 , 10 ) , ts . values ( ) ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . skip ( 2 ) ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . skip ( 1 ) ; ) ; 
Flowable . range ( 1 , 5 ) . concatMapEager ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return Flowable . range ( t , 2 ) ; ) . test ( ) . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 5 ) . concatMapEager ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return Flowable . range ( t , 2 ) ; ) . test ( 3 ) ; ts . assertValues ( 1 , 2 , 2 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 2 , 3 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 ) ; ts . request ( 5 ) ; ts . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
Flowable . range ( 1 , 5 ) . concatMapEagerDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return Flowable . range ( t , 2 ) ; , false ) . test ( ) . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 5 ) . concatMapEagerDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return Flowable . range ( t , 2 ) ; , false ) . test ( 3 ) ; ts . assertValues ( 1 , 2 , 2 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 2 , 3 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 ) ; ts . request ( 5 ) ; ts . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
Flowable . range ( 1 , 5 ) . concatMapEagerDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return Flowable . range ( t , 2 ) ; , true ) . test ( ) . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
TestSubscriber < Integer > ts = Flowable . range ( 1 , 5 ) . concatMapEagerDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return Flowable . range ( t , 2 ) ; , true ) . test ( 3 ) ; ts . assertValues ( 1 , 2 , 2 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 2 , 3 ) ; ts . request ( 1 ) ; ts . assertValues ( 1 , 2 , 2 , 3 , 3 ) ; ts . request ( 5 ) ; ts . assertResult ( 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; final PublishProcessor < Integer > inner = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = main . concatMapEagerDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return inner ; , false ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; main . onNext ( 1 ) ; inner . onNext ( 2 ) ; ts . assertValue ( 2 ) ; main . onError ( new TestException ( "Forced failure" ) ) ; ts . assertNoErrors ( ) ; inner . onNext ( 3 ) ; inner . onComplete ( ) ; ts . assertFailureAndMessage ( TestException . class , "Forced failure" , 2 , 3 ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; final PublishProcessor < Integer > inner = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = main . concatMapEagerDelayError ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return inner ; , true ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; main . onNext ( 1 ) ; main . onNext ( 2 ) ; inner . onNext ( 2 ) ; ts . assertValue ( 2 ) ; main . onError ( new TestException ( "Forced failure" ) ) ; ts . assertNoErrors ( ) ; inner . onNext ( 3 ) ; inner . onComplete ( ) ; ts . assertFailureAndMessage ( TestException . class , "Forced failure" , 2 , 3 , 2 , 3 ) ; 
PublishProcessor < Integer > main = PublishProcessor . create ( ) ; final PublishProcessor < Integer > inner = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = main . concatMapEager ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer t ) return inner ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; main . onNext ( 1 ) ; main . onNext ( 2 ) ; inner . onNext ( 2 ) ; ts . assertValue ( 2 ) ; main . onError ( new TestException ( "Forced failure" ) ) ; assertFalse ( "inner has subscribers?" , inner . hasSubscribers ( ) ) ; inner . onNext ( 3 ) ; inner . onComplete ( ) ; ts . assertFailureAndMessage ( TestException . class , "Forced failure" , 2 ) ; 
Flowable . range ( 1 , 2 * Flowable . bufferSize ( ) ) . concatMapEager ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . just ( 1 ) ; ) . test ( ) . assertValueCount ( 2 * Flowable . bufferSize ( ) ) . assertNoErrors ( ) . assertComplete ( ) ; 
ts = new TestSubscriber < > ( ) ; tsBp = new TestSubscriber < > ( 0L ) ; 
Flowable . range ( 1 , 100 ) . concatMapEager ( toJust ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 100 ) ; ts . assertComplete ( ) ; 
Flowable . range ( 1 , 100 ) . concatMapEager ( toRange ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 200 ) ; ts . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Flowable . concatArrayEager ( source , source ) . subscribe ( tsBp ) ; Assert . assertEquals ( 2 , count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . assertNoValues ( ) ; tsBp . request ( Long . MAX_VALUE ) ; tsBp . assertValueCount ( count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Flowable . concatArrayEager ( source , source , source ) . subscribe ( tsBp ) ; Assert . assertEquals ( 3 , count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . assertNoValues ( ) ; tsBp . request ( Long . MAX_VALUE ) ; tsBp . assertValueCount ( count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Flowable . concatArrayEager ( source , source , source , source ) . subscribe ( tsBp ) ; Assert . assertEquals ( 4 , count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . assertNoValues ( ) ; tsBp . request ( Long . MAX_VALUE ) ; tsBp . assertValueCount ( count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Flowable . concatArrayEager ( source , source , source , source , source ) . subscribe ( tsBp ) ; Assert . assertEquals ( 5 , count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . assertNoValues ( ) ; tsBp . request ( Long . MAX_VALUE ) ; tsBp . assertValueCount ( count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Flowable . concatArrayEager ( source , source , source , source , source , source ) . subscribe ( tsBp ) ; Assert . assertEquals ( 6 , count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . assertNoValues ( ) ; tsBp . request ( Long . MAX_VALUE ) ; tsBp . assertValueCount ( count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Flowable . concatArrayEager ( source , source , source , source , source , source , source ) . subscribe ( tsBp ) ; Assert . assertEquals ( 7 , count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . assertNoValues ( ) ; tsBp . request ( Long . MAX_VALUE ) ; tsBp . assertValueCount ( count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Flowable . concatArrayEager ( source , source , source , source , source , source , source , source ) . subscribe ( tsBp ) ; Assert . assertEquals ( 8 , count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . assertNoValues ( ) ; tsBp . request ( Long . MAX_VALUE ) ; tsBp . assertValueCount ( count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; Flowable < Integer > source = Flowable . just ( 1 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; Flowable . concatArrayEager ( source , source , source , source , source , source , source , source , source ) . subscribe ( tsBp ) ; Assert . assertEquals ( 9 , count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . assertNoValues ( ) ; tsBp . request ( Long . MAX_VALUE ) ; tsBp . assertValueCount ( count . get ( ) ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
Flowable . < Integer > error ( new TestException ( ) ) . concatMapEager ( toJust ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Flowable . concatArrayEager ( Flowable . just ( 1 ) , Flowable . error ( new TestException ( ) ) ) . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . assertError ( TestException . class ) ; ts . assertNotComplete ( ) ; 
Flowable . concatArrayEager ( Flowable . empty ( ) , Flowable . empty ( ) ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . just ( 1 ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) throw new TestException ( ) ; ) . subscribe ( ts ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; ts . assertError ( TestException . class ) ; 
Flowable . just ( 1 ) . concatMapEager ( toJust , 0 , Flowable . bufferSize ( ) ) ; 
Flowable . just ( 1 ) . concatMapEager ( toJust , Flowable . bufferSize ( ) , 0 ) ; 
Flowable . concatArrayEager ( Flowable . just ( 1 ) , Flowable . just ( 1 ) ) . subscribe ( tsBp ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNoValues ( ) ; tsBp . assertNotComplete ( ) ; tsBp . request ( 1 ) ; tsBp . assertValue ( 1 ) ; tsBp . assertNoErrors ( ) ; tsBp . assertNotComplete ( ) ; tsBp . request ( 1 ) ; tsBp . assertValues ( 1 , 1 ) ; tsBp . assertNoErrors ( ) ; tsBp . assertComplete ( ) ; 
Flowable . range ( 1 , 2 ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return Flowable . range ( 1 , 1000 ) . subscribeOn ( Schedulers . computation ( ) ) ; ) . observeOn ( Schedulers . single ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertNoErrors ( ) . assertValueCount ( 2000 ) . assertComplete ( ) ; 
final PublishProcessor < Integer > processor = PublishProcessor . create ( ) ; final AtomicBoolean once = new AtomicBoolean ( ) ; processor . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return Flowable . just ( t ) ; ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) if ( once . compareAndSet ( false , true ) ) processor . onNext ( 2 ) ; ) . subscribe ( ts ) ; processor . onNext ( 1 ) ; ts . assertNoErrors ( ) ; ts . assertNotComplete ( ) ; ts . assertValues ( 1 , 2 ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; TestSubscriber < Object > ts = TestSubscriber . create ( 0 ) ; Flowable . just ( 1 ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t ) return Flowable . range ( 1 , Flowable . bufferSize ( ) * 2 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t ) count . getAndIncrement ( ) ; ) . hide ( ) ; ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertNoValues ( ) ; ts . assertNotComplete ( ) ; Assert . assertEquals ( Flowable . bufferSize ( ) , count . get ( ) ) ; 
final List < Long > requests = new ArrayList < > ( ) ; Flowable . range ( 1 , 100 ) . doOnRequest ( new LongConsumer ( ) @ Override public void accept ( long reqCount ) requests . add ( reqCount ) ; ) . concatMapEager ( toJust , 5 , Flowable . bufferSize ( ) ) . subscribe ( ts ) ; ts . assertNoErrors ( ) ; ts . assertValueCount ( 100 ) ; ts . assertComplete ( ) ; Assert . assertEquals ( 5 , ( long ) requests . get ( 0 ) ) ; Assert . assertEquals ( 1 , ( long ) requests . get ( 1 ) ) ; Assert . assertEquals ( 1 , ( long ) requests . get ( 2 ) ) ; Assert . assertEquals ( 1 , ( long ) requests . get ( 3 ) ) ; Assert . assertEquals ( 1 , ( long ) requests . get ( 4 ) ) ; Assert . assertEquals ( 1 , ( long ) requests . get ( 5 ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . concatEager ( Arrays . asList ( source , source , source ) , 1 , 1 ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . concatEager ( Flowable . just ( source , source , source ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . concatEager ( Flowable . just ( source , source , source ) , 1 , 1 ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; try Flowable . concatEager ( Arrays . asList ( source , source , source ) , 1 , - 99 ) ; catch ( IllegalArgumentException ex ) assertEquals ( "prefetch > 0 required but it was -99" , ex . getMessage ( ) ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; try Flowable . just ( source , source , source ) . concatMapEager ( ( Function ) Functions . identity ( ) , 10 , - 99 ) ; catch ( IllegalArgumentException ex ) assertEquals ( "prefetch > 0 required but it was -99" , ex . getMessage ( ) ) ; 
Flowable . concatEager ( Collections . < Flowable < Integer > > emptyList ( ) ) . test ( ) . assertResult ( ) ; 
Flowable . concatEager ( Arrays . asList ( Flowable . just ( 1 ) ) ) . test ( ) . assertResult ( 1 ) ; 
Flowable . concatEager ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . concatEager ( Flowable . just ( source , source , source ) ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable < Integer > source = Flowable . just ( 1 ) ; TestSubscriber < Integer > ts = TestSubscriber . create ( ) ; Flowable . concatEager ( Flowable . just ( source , source , source ) , 1 , 1 ) . subscribe ( ts ) ; ts . assertValues ( 1 , 1 , 1 ) ; ts . assertNoErrors ( ) ; ts . assertComplete ( ) ; 
Flowable . concatEager ( Arrays . asList ( Flowable . just ( 1 ) , Flowable . just ( 2 ) ) ) . test ( ) . assertResult ( 1 , 2 ) ; 
Flowable . < Integer > empty ( ) . hide ( ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . range ( 1 , 2 ) ; ) . test ( ) . assertResult ( ) ; 
TestHelper . checkDisposed ( Flowable . just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . range ( 1 , 2 ) ; ) ) ; 
Flowable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . error ( new TestException ( ) ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriberEx < Integer > ts = pp1 . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return pp2 ; ) . to ( TestHelper . < Integer > testConsumer ( ) ) ; final TestException ex1 = new TestException ( ) ; final TestException ex2 = new TestException ( ) ; pp1 . onNext ( 1 ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onError ( ex1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) pp2 . onError ( ex2 ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertSubscribed ( ) . assertNoValues ( ) . assertNotComplete ( ) ; Throwable ex = ts . errors ( ) . get ( 0 ) ; if ( ex instanceof CompositeException ) List < Throwable > es = TestHelper . errorList ( ts ) ; TestHelper . assertError ( es , 0 , TestException . class ) ; TestHelper . assertError ( es , 1 , TestException . class ) ; else ts . assertError ( TestException . class ) ; if ( ! errors . isEmpty ( ) ) TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
Flowable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . error ( new TestException ( ) ) ; , 1 , 128 ) . test ( ) . assertFailure ( TestException . class ) ; 
Flowable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . fromCallable ( new Callable < Integer > ( ) @ Override public Integer call ( ) throws Exception throw new TestException ( ) ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
final UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; up . onError ( new TestException ( ) ) ; ; Flowable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return up ; , 1 , 128 ) . subscribe ( ts ) ; ts . assertFailure ( TestException . class , 1 ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = pp1 . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . never ( ) ; ) . test ( ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp1 . onNext ( 1 ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; ts . assertEmpty ( ) ; 
final TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception ts . cancel ( ) ; return Flowable . never ( ) ; , 1 , 128 ) . subscribe ( ts ) ; ts . assertEmpty ( ) ; 
Flowable . < Integer > just ( 1 ) . hide ( ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . range ( 1 , 2 ) . map ( new Function < Integer , Integer > ( ) @ Override public Integer apply ( Integer v ) throws Exception throw new TestException ( ) ; ) ; ) . test ( ) . assertFailure ( TestException . class ) ; 
UnicastProcessor < Integer > up = UnicastProcessor . create ( ) ; up . onNext ( 1 ) ; up . onComplete ( ) ; up . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Exception return Flowable . just ( 1 ) ; ) . take ( 1 ) . test ( ) . assertResult ( 1 ) ; 
TestHelper . checkDoubleOnSubscribeFlowable ( new Function < Flowable < Object > , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Flowable < Object > f ) throws Exception return f . concatMapEager ( new Function < Object , Flowable < Object > > ( ) @ Override public Flowable < Object > apply ( Object v ) throws Exception return Flowable . just ( v ) ; ) ; ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try @ SuppressWarnings ( "rawtypes" ) final Subscriber [ ] sub = null ; new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) sub [ 0 ] = s ; s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onError ( new TestException ( "First" ) ) ; . concatMapEager ( Functions . justFunction ( Flowable . just ( 1 ) ) ) . to ( TestHelper . < Integer > testConsumer ( ) ) . assertFailureAndMessage ( TestException . class , "First" , 1 ) ; sub [ 0 ] . onError ( new TestException ( "Second" ) ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class , "Second" ) ; finally RxJavaPlugins . reset ( ) ; 
List < Throwable > errors = TestHelper . trackPluginErrors ( ) ; try Flowable . just ( 1 ) . concatMapEager ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return new Flowable < Integer > ( ) @ Override protected void subscribeActual ( Subscriber < ? super Integer > s ) s . onSubscribe ( new BooleanSubscription ( ) ) ; s . onNext ( 1 ) ; s . onNext ( 2 ) ; s . onError ( new TestException ( ) ) ; ; , 1 , 1 ) . test ( 0L ) . assertFailure ( MissingBackpressureException . class ) ; TestHelper . assertUndeliverable ( errors , 0 , TestException . class ) ; finally RxJavaPlugins . reset ( ) ; 
int n = Flowable . bufferSize ( ) * 2 ; Flowable . range ( 1 , n ) . concatMapEager ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) throws Exception return Flowable . just ( 1 ) ; , Integer . MAX_VALUE , 16 ) . test ( ) . assertValueCount ( n ) . assertComplete ( ) . assertNoErrors ( ) ; 
for ( int i = 0 ; i < TestHelper . RACE_DEFAULT_LOOPS ; i ++ ) final PublishProcessor < Integer > pp = PublishProcessor . create ( ) ; final TestSubscriber < Integer > ts = new TestSubscriber < > ( 0L ) ; Flowable . just ( 1 ) . concatMapEager ( Functions . justFunction ( pp ) ) . subscribe ( ts ) ; Runnable r1 = new Runnable ( ) @ Override public void run ( ) pp . onComplete ( ) ; ; Runnable r2 = new Runnable ( ) @ Override public void run ( ) ts . cancel ( ) ; ; TestHelper . race ( r1 , r2 ) ; 
int n = Flowable . bufferSize ( ) * 2 ; Flowable . just ( 1 ) . hide ( ) . concatMapEager ( Functions . justFunction ( Flowable . range ( 1 , n ) . hide ( ) ) ) . rebatchRequests ( 1 ) . test ( ) . assertValueCount ( n ) . assertComplete ( ) . assertNoErrors ( ) ; 
Flowable . just ( 1 , 2 , 3 , 4 , 5 ) . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer i ) throws Exception return i == 3 ? Flowable . just ( i ) : Flowable . just ( i ) . delay ( 1 , TimeUnit . MILLISECONDS , Schedulers . io ( ) ) ; ) . observeOn ( Schedulers . io ( ) ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
List < Integer > [ ] list = new ArrayList [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) List < Integer > lst = new ArrayList < > ( ) ; list [ i ] = lst ; for ( int k = 1 ; k <= 10 ; k ++ ) lst . add ( ( i ) * 10 + k ) ; Flowable . range ( 1 , 1000 ) . buffer ( 10 ) . concatMapEager ( new Function < List < Integer > , Flowable < List < Integer > > > ( ) @ Override public Flowable < List < Integer > > apply ( List < Integer > v ) throws Exception return Flowable . just ( v ) . subscribeOn ( Schedulers . io ( ) ) . doOnNext ( new Consumer < List < Integer > > ( ) @ Override public void accept ( List < Integer > v ) throws Exception Thread . sleep ( new Random ( ) . nextInt ( 20 ) ) ; ) ; , 2 , 3 ) . test ( ) . awaitDone ( 5 , TimeUnit . SECONDS ) . assertResult ( list ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp3 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . concatArrayEagerDelayError ( pp1 , pp2 , pp3 ) . test ( ) ; ts . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; assertTrue ( pp3 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertEmpty ( ) ; pp1 . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; pp1 . onComplete ( ) ; ts . assertValuesOnly ( 1 , 2 ) ; pp3 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp3 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . concatArrayEagerDelayError ( 2 , 2 , pp1 , pp2 , pp3 ) . test ( ) ; ts . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; assertFalse ( pp3 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onComplete ( ) ; ts . assertEmpty ( ) ; pp1 . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; pp1 . onComplete ( ) ; assertTrue ( pp3 . hasSubscribers ( ) ) ; ts . assertValuesOnly ( 1 , 2 ) ; pp3 . onComplete ( ) ; ts . assertResult ( 1 , 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp3 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . concatArrayEagerDelayError ( 2 , 2 , pp1 , pp2 , pp3 ) . test ( ) ; ts . assertEmpty ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; assertFalse ( pp3 . hasSubscribers ( ) ) ; pp2 . onNext ( 2 ) ; pp2 . onError ( new TestException ( ) ) ; ts . assertEmpty ( ) ; pp1 . onNext ( 1 ) ; ts . assertValuesOnly ( 1 ) ; pp1 . onComplete ( ) ; assertTrue ( pp3 . hasSubscribers ( ) ) ; ts . assertValuesOnly ( 1 , 2 ) ; pp3 . onComplete ( ) ; ts . assertFailure ( TestException . class , 1 , 2 ) ; 
PublishProcessor < Integer > pp1 = PublishProcessor . create ( ) ; PublishProcessor < Integer > pp2 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . concatEager ( Flowable . just ( pp1 , pp2 ) ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; assertTrue ( pp2 . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; assertFalse ( pp2 . hasSubscribers ( ) ) ; 
PublishProcessor < Flowable < Integer > > pp1 = PublishProcessor . create ( ) ; TestSubscriber < Integer > ts = Flowable . concatEager ( pp1 ) . test ( ) ; assertTrue ( pp1 . hasSubscribers ( ) ) ; ts . cancel ( ) ; assertFalse ( pp1 . hasSubscribers ( ) ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapEager ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapEagerDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; , false ) ; ) ; 
TestHelper . checkUndeliverableUponCancel ( new FlowableConverter < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Flowable < Integer > upstream ) return upstream . concatMapEagerDelayError ( new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer v ) throws Throwable return Flowable . just ( v ) . hide ( ) ; , true ) ; ) ; 
Flowable . concatEagerDelayError ( Arrays . asList ( Flowable . range ( 1 , 2 ) , Flowable . error ( new TestException ( ) ) , Flowable . range ( 3 , 3 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . concatEagerDelayError ( Arrays . asList ( Flowable . range ( 1 , 2 ) , Flowable . error ( new TestException ( ) ) , Flowable . range ( 3 , 3 ) ) , 1 , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . concatEagerDelayError ( Flowable . fromArray ( Flowable . range ( 1 , 2 ) , Flowable . error ( new TestException ( ) ) , Flowable . range ( 3 , 3 ) ) ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . concatEagerDelayError ( Flowable . fromArray ( Flowable . range ( 1 , 2 ) , Flowable . error ( new TestException ( ) ) , Flowable . range ( 3 , 3 ) ) , 1 , 1 ) . test ( ) . assertFailure ( TestException . class , 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapEagerDelayError ( v -> Flowable . range ( 1 , 10 ) , true , 1 , 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; 
TestHelper . assertBadRequestReported ( Flowable . never ( ) . concatMapEagerDelayError ( v -> Flowable . never ( ) , false ) ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapEagerDelayError ( v -> Flowable . range ( 1 , 5 ) . hide ( ) , true ) . takeUntil ( v -> true ) . test ( ) . assertResult ( 1 ) ; 
Flowable . just ( 1 ) . hide ( ) . concatMapEagerDelayError ( v -> Flowable . fromPublisher ( s -> ) , true ) . test ( 0L ) . assertEmpty ( ) . requestMore ( 1L ) . assertEmpty ( ) ; 
Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; Flowable . range ( 2 , 3 ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 4 ) ; verify ( subscriber , never ( ) ) . onNext ( 5 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; 
Subscriber < Integer > subscriber = TestHelper . mockSubscriber ( ) ; final AtomicInteger count = new AtomicInteger ( ) ; Flowable . range ( 1 , 1000 ) . doOnNext ( new Consumer < Integer > ( ) @ Override public void accept ( Integer t1 ) count . incrementAndGet ( ) ; ) . take ( 3 ) . subscribe ( subscriber ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 1 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 2 ) ; verify ( subscriber , times ( 1 ) ) . onNext ( 3 ) ; verify ( subscriber , never ( ) ) . onNext ( 4 ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; verify ( subscriber , times ( 1 ) ) . onComplete ( ) ; assertEquals ( 3 , count . get ( ) ) ; 
Flowable . range ( 1 , 0 ) ; 
Flowable . range ( Integer . MAX_VALUE , 0 ) ; 
Flowable . range ( 1 , Integer . MAX_VALUE ) ; 
Flowable . range ( 2 , Integer . MAX_VALUE ) ; 
assertFalse ( Flowable . range ( Integer . MIN_VALUE , 0 ) . blockingIterable ( ) . iterator ( ) . hasNext ( ) ) ; 
Flowable < Integer > f = Flowable . range ( 1 , Flowable . bufferSize ( ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; ts . assertNoValues ( ) ; ts . request ( 1 ) ; f . subscribe ( ts ) ; ts . assertValue ( 1 ) ; ts . request ( 2 ) ; ts . assertValues ( 1 , 2 , 3 ) ; ts . request ( 3 ) ; ts . assertValues ( 1 , 2 , 3 , 4 , 5 , 6 ) ; ts . request ( Flowable . bufferSize ( ) ) ; ts . assertTerminated ( ) ; 
ArrayList < Integer > list = new ArrayList < > ( Flowable . bufferSize ( ) * 2 ) ; for ( int i = 1 ; i <= Flowable . bufferSize ( ) * 2 + 1 ; i ++ ) list . add ( i ) ; Flowable < Integer > f = Flowable . range ( 1 , list . size ( ) ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; ts . assertNoValues ( ) ; ts . request ( Long . MAX_VALUE ) ; f . subscribe ( ts ) ; ts . assertValueSequence ( list ) ; ts . assertTerminated ( ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) withBackpressureOneByOne ( i ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) withBackpressureAllAtOnce ( i ) ; 
Flowable < Integer > source = Flowable . range ( 50 , 100 ) ; TestSubscriberEx < Integer > ts = new TestSubscriberEx < > ( 0L ) ; ts . request ( 150 ) ; source . subscribe ( ts ) ; List < Integer > list = new ArrayList < > ( 100 ) ; for ( int i = 0 ; i < 100 ; i ++ ) list . add ( i + 50 ) ; ts . request ( 50 ) ; ts . assertValueSequence ( list ) ; ts . assertTerminated ( ) ; 
final AtomicInteger count = new AtomicInteger ( ) ; int n = 10 ; Flowable . range ( 1 , n ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) request ( 2 ) ; @ Override public void onComplete ( ) @ Override public void onError ( Throwable e ) throw new RuntimeException ( e ) ; @ Override public void onNext ( Integer t ) count . incrementAndGet ( ) ; request ( Long . MAX_VALUE - 1 ) ; ) ; assertEquals ( n , count . get ( ) ) ; 
final AtomicBoolean completed = new AtomicBoolean ( false ) ; Flowable . range ( 1 , 0 ) . subscribe ( new DefaultSubscriber < Integer > ( ) @ Override public void onStart ( ) @ Override public void onComplete ( ) completed . set ( true ) ; @ Override public void onError ( Throwable e ) @ Override public void onNext ( Integer t ) ) ; assertTrue ( completed . get ( ) ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( Integer . MAX_VALUE - 1 , 2 ) . subscribe ( ts ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertValues ( Integer . MAX_VALUE - 1 , Integer . MAX_VALUE ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( 3L ) ; Flowable . range ( Integer . MAX_VALUE - 1 , 2 ) . subscribe ( ts ) ; ts . assertComplete ( ) ; ts . assertNoErrors ( ) ; ts . assertValues ( Integer . MAX_VALUE - 1 , Integer . MAX_VALUE ) ; 
try Flowable . range ( 1 , - 1 ) ; fail ( "Should have thrown IllegalArgumentException" ) ; catch ( IllegalArgumentException ex ) assertEquals ( "count >= 0 required but it was -1" , ex . getMessage ( ) ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . range ( 1 , 5 ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 5495454 , 1 ) . test ( ) . assertResult ( 5495454 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ANY ) ; Flowable . range ( 1 , 2 ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . SYNC ) . assertResult ( 1 , 2 ) ; 
TestSubscriberEx < Integer > ts = new TestSubscriberEx < Integer > ( ) . setInitialFusionMode ( QueueFuseable . ASYNC ) ; Flowable . range ( 1 , 2 ) . subscribe ( ts ) ; ts . assertFusionMode ( QueueFuseable . NONE ) . assertResult ( 1 , 2 ) ; 
TestHelper . checkDisposed ( Flowable . range ( 1 , 2 ) ) ; 
TestHelper . checkFusedIsEmptyClear ( Flowable . range ( 1 , 2 ) ) ; 
Flowable . range ( Integer . MAX_VALUE - 1 , 2 ) ; Flowable . range ( Integer . MIN_VALUE , 2 ) ; Flowable . range ( Integer . MIN_VALUE , Integer . MAX_VALUE ) ; 
Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestHelper . assertBadRequestReported ( Flowable . range ( 1 , 5 ) ) ; TestHelper . assertBadRequestReported ( Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) ) ; 
Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . test ( 5 ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . take ( 5 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
Flowable . range ( 1 , 5 ) . rebatchRequests ( 1 ) . test ( ) . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 2L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 5 ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 5 ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; request ( 1 ) ; ; Flowable . range ( 1 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertResult ( 2 , 4 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 1L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; request ( 1 ) ; ; Flowable . range ( 1 , 5 ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 5L ) cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 5 ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 , 3 , 4 , 5 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 5L ) cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 5 ) . filter ( new Predicate < Integer > ( ) @ Override public boolean test ( Integer v ) throws Exception return v % 2 == 0 ; ) . subscribe ( ts ) ; ts . assertResult ( 2 , 4 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 2L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 1 ) cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 2 ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertResult ( 1 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < Integer > ( 2L ) @ Override public void onNext ( Integer t ) super . onNext ( t ) ; if ( t == 2 ) cancel ( ) ; onComplete ( ) ; ; Flowable . range ( 1 , 2 ) . filter ( Functions . alwaysTrue ( ) ) . subscribe ( ts ) ; ts . assertResult ( 1 , 2 ) ; 
Flowable . range ( 1 , 2 ) . take ( 2 ) . test ( ) . assertResult ( 1 , 2 ) ; 
TestSubscriber < Integer > ts = new TestSubscriber < > ( ) ; Flowable . range ( 1 , 2 ) . compose ( TestHelper . conditional ( ) ) . doOnNext ( v -> if ( v == 2 ) ts . cancel ( ) ; ) . subscribe ( ts ) ; ts . assertValuesOnly ( 1 , 2 ) ; 
scheduler = new TestScheduler ( ) ; Subscriber = TestHelper . mockSubscriber ( ) ; innerScheduler = scheduler . createWorker ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 100 , "one" ) ; publishNext ( subscriber , 400 , "two" ) ; publishNext ( subscriber , 900 , "three" ) ; publishCompleted ( subscriber , 1000 ) ; ) ; Flowable < String > sampled = source . debounce ( 400 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( Subscriber ) ; scheduler . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( Subscriber ) ; scheduler . advanceTimeTo ( 800 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( Subscriber , times ( 1 ) ) . onNext ( "two" ) ; scheduler . advanceTimeTo ( 1000 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( Subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; publishNext ( subscriber , 100 , "a" ) ; publishNext ( subscriber , 200 , "b" ) ; publishNext ( subscriber , 300 , "c" ) ; publishNext ( subscriber , 400 , "d" ) ; publishNext ( subscriber , 500 , "e" ) ; publishNext ( subscriber , 600 , "f" ) ; publishNext ( subscriber , 700 , "g" ) ; publishNext ( subscriber , 800 , "h" ) ; publishCompleted ( subscriber , 900 ) ; ) ; Flowable < String > sampled = source . debounce ( 200 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( Subscriber ) ; scheduler . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( Subscriber ) ; inOrder . verify ( Subscriber , times ( 0 ) ) . onNext ( anyString ( ) ) ; scheduler . advanceTimeTo ( 1000 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( Subscriber , times ( 1 ) ) . onComplete ( ) ; inOrder . verifyNoMoreInteractions ( ) ; 
Flowable < String > source = Flowable . unsafeCreate ( new Publisher < String > ( ) @ Override public void subscribe ( Subscriber < ? super String > subscriber ) subscriber . onSubscribe ( new BooleanSubscription ( ) ) ; Exception error = new TestException ( ) ; publishNext ( subscriber , 100 , "one" ) ; publishNext ( subscriber , 600 , "two" ) ; publishError ( subscriber , 700 , error ) ; ) ; Flowable < String > sampled = source . debounce ( 400 , TimeUnit . MILLISECONDS , scheduler ) ; sampled . subscribe ( Subscriber ) ; scheduler . advanceTimeTo ( 0 , TimeUnit . MILLISECONDS ) ; InOrder inOrder = inOrder ( Subscriber ) ; scheduler . advanceTimeTo ( 500 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( Subscriber ) . onNext ( "one" ) ; scheduler . advanceTimeTo ( 701 , TimeUnit . MILLISECONDS ) ; inOrder . verify ( Subscriber ) . onError ( any ( TestException . class ) ) ; inOrder . verifyNoMoreInteractions ( ) ; 
PublishProcessor < Integer > source = PublishProcessor . create ( ) ; final PublishProcessor < Integer > debouncer = PublishProcessor . create ( ) ; Function < Integer , Flowable < Integer > > debounceSel = new Function < Integer , Flowable < Integer > > ( ) @ Override public Flowable < Integer > apply ( Integer t1 ) return debouncer ; ; Subscriber < Object > subscriber = TestHelper . mockSubscriber ( ) ; InOrder inOrder = inOrder ( subscriber ) ; source . debounce ( debounceSel ) . subscribe ( subscriber ) ; source . onNext ( 1 ) ; debouncer . onNext ( 1 ) ; source . onNext ( 2 ) ; source . onNext ( 3 ) ; source . onNext ( 4 ) ; debouncer . onNext ( 2 ) ; source . onNext ( 5 ) ; source . onComplete ( ) ; inOrder . verify ( subscriber ) . onNext ( 1 ) ; inOrder . verify ( subscriber ) . onNext ( 4 ) ; inOrder . verify ( subscriber ) . onNext ( 5 ) ; inOrder . verify ( subscriber ) . onComplete ( ) ; verify ( subscriber , never ( ) ) . onError ( any ( Throwable . class ) ) ; 
