if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( ! done && errors . tryAddThrowable ( t ) ) if ( ! delayErrors ) disposeInner ( ) ; done = true ; drain ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( ! done ) done = true ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . dispose ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; 
return cancelled ; 
SwitchMapInnerObserver < T , R > a = active . getAndSet ( ( SwitchMapInnerObserver < T , R > ) CANCELLED ) ; if ( a != null ) a . cancel ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; final Observer < ? super R > a = downstream ; final AtomicReference < SwitchMapInnerObserver < T , R > > active = this . active ; final boolean delayErrors = this . delayErrors ; int missing = 1 ; for ( ; ; ) if ( cancelled ) return ; if ( done ) boolean empty = active . get ( ) == null ; if ( delayErrors ) if ( empty ) Throwable ex = errors . get ( ) ; if ( ex != null ) a . onError ( ex ) ; else a . onComplete ( ) ; return ; else Throwable ex = errors . get ( ) ; if ( ex != null ) errors . tryTerminateConsumer ( a ) ; return ; if ( empty ) a . onComplete ( ) ; return ; SwitchMapInnerObserver < T , R > inner = active . get ( ) ; if ( inner != null ) SimpleQueue < R > q = inner . queue ; if ( q != null ) boolean retry = false ; for ( ; ; ) if ( cancelled ) return ; if ( inner != active . get ( ) ) retry = true ; break ; if ( ! delayErrors ) Throwable ex = errors . get ( ) ; if ( ex != null ) errors . tryTerminateConsumer ( a ) ; return ; boolean d = inner . done ; R v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; errors . tryAddThrowableOrReport ( ex ) ; active . compareAndSet ( inner , null ) ; if ( ! delayErrors ) disposeInner ( ) ; upstream . dispose ( ) ; done = true ; else inner . cancel ( ) ; v = null ; retry = true ; boolean empty = v == null ; if ( d && empty ) active . compareAndSet ( inner , null ) ; retry = true ; break ; if ( empty ) break ; a . onNext ( v ) ; if ( retry ) continue ; missing = addAndGet ( - missing ) ; if ( missing == 0 ) break ; 
if ( DisposableHelper . setOnce ( this , d ) ) if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < R > qd = ( QueueDisposable < R > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY | QueueDisposable . BOUNDARY ) ; if ( m == QueueDisposable . SYNC ) queue = qd ; done = true ; parent . drain ( ) ; return ; if ( m == QueueDisposable . ASYNC ) queue = qd ; return ; queue = new SpscLinkedArrayQueue < > ( bufferSize ) ; 
parent . innerError ( this , t ) ; 
if ( index == parent . unique ) done = true ; parent . drain ( ) ; 
DisposableHelper . dispose ( this ) ; 
boolean doConnect = false ; PublishConnection < T > conn ; for ( ; ; ) conn = current . get ( ) ; if ( conn == null || conn . isDisposed ( ) ) PublishConnection < T > fresh = new PublishConnection < > ( current ) ; if ( ! current . compareAndSet ( conn , fresh ) ) continue ; conn = fresh ; doConnect = ! conn . connect . get ( ) && conn . connect . compareAndSet ( false , true ) ; break ; try connection . accept ( conn ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; if ( doConnect ) source . subscribe ( conn ) ; 
PublishConnection < T > conn ; for ( ; ; ) conn = current . get ( ) ; if ( conn == null ) PublishConnection < T > fresh = new PublishConnection < > ( current ) ; if ( ! current . compareAndSet ( conn , fresh ) ) continue ; conn = fresh ; break ; InnerDisposable < T > inner = new InnerDisposable < > ( observer , conn ) ; observer . onSubscribe ( inner ) ; if ( conn . add ( inner ) ) if ( inner . isDisposed ( ) ) conn . remove ( inner ) ; return ; Throwable error = conn . error ; if ( error != null ) observer . onError ( error ) ; else observer . onComplete ( ) ; 
PublishConnection < T > conn = current . get ( ) ; if ( conn != null && conn . isDisposed ( ) ) current . compareAndSet ( conn , null ) ; 
return source ; 
getAndSet ( TERMINATED ) ; current . compareAndSet ( this , null ) ; DisposableHelper . dispose ( upstream ) ; 
return get ( ) == TERMINATED ; 
DisposableHelper . setOnce ( upstream , d ) ; 
if ( upstream . get ( ) != DisposableHelper . DISPOSED ) error = e ; upstream . lazySet ( DisposableHelper . DISPOSED ) ; for ( InnerDisposable < T > inner : getAndSet ( TERMINATED ) ) inner . downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
upstream . lazySet ( DisposableHelper . DISPOSED ) ; for ( InnerDisposable < T > inner : getAndSet ( TERMINATED ) ) inner . downstream . onComplete ( ) ; 
PublishConnection < T > p = getAndSet ( null ) ; if ( p != null ) p . remove ( this ) ; 
return get ( ) == null ; 
source . subscribe ( new PublisherSubscriber < T > ( o ) ) ; 
downstream . onComplete ( ) ; 
downstream . onError ( t ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
SequentialDisposable sa = new SequentialDisposable ( ) ; observer . onSubscribe ( sa ) ; RepeatObserver < T > rs = new RepeatObserver < > ( observer , count , predicate , sa , source ) ; rs . subscribeNext ( ) ; 
upstream . replace ( d ) ; 
long r = remaining ; if ( r != Long . MAX_VALUE ) remaining = r - 1 ; if ( r == 0 ) downstream . onError ( t ) ; else boolean b ; try b = predicate . test ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; if ( ! b ) downstream . onError ( t ) ; return ; subscribeNext ( ) ; 
downstream . onComplete ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; for ( ; ; ) if ( upstream . isDisposed ( ) ) return ; source . subscribe ( this ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
SwitchIfEmptyObserver < T > parent = new SwitchIfEmptyObserver < > ( t , other ) ; t . onSubscribe ( parent . arbiter ) ; source . subscribe ( parent ) ; 
arbiter . update ( d ) ; 
downstream . onError ( t ) ; 
if ( empty ) empty = false ; other . subscribe ( this ) ; else downstream . onComplete ( ) ; 
ScalarDisposable < T > sd = new ScalarDisposable < > ( observer , value ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; 
return value ; 
source . subscribe ( new FlatMapCompletableMainObserver < > ( observer , mapper , delayErrors ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) if ( delayErrors ) if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; else disposed = true ; upstream . dispose ( ) ; set . dispose ( ) ; errors . tryTerminateConsumer ( downstream ) ; 
if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; 
disposed = true ; upstream . dispose ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
return upstream . isDisposed ( ) ; 
return null ; 
return true ; 
$EMPTY$
DisposableHelper . setOnce ( this , d ) ; 
innerComplete ( this ) ; 
innerError ( this , e ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
source . subscribe ( new TakeWhileObserver < > ( t , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
source . subscribe ( new DebounceTimedObserver < > ( new SerializedObserver < > ( t ) , timeout , unit , scheduler . createWorker ( ) ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
gate = false ; 
downstream . onError ( t ) ; worker . dispose ( ) ; 
downstream . onComplete ( ) ; worker . dispose ( ) ; 
upstream . dispose ( ) ; worker . dispose ( ) ; 
return worker . isDisposed ( ) ; 
ObservableSource < ? extends T > pub ; try pub = Objects . requireNonNull ( supplier . get ( ) , "The supplier returned a null ObservableSource" ) ; catch ( Throwable t ) Exceptions . throwIfFatal ( t ) ; EmptyDisposable . error ( t , observer ) ; return ; pub . subscribe ( observer ) ; 
CancellableQueueFuseable < T > qs = new CancellableQueueFuseable < > ( ) ; observer . onSubscribe ( qs ) ; if ( ! qs . isDisposed ( ) ) try run . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! qs . isDisposed ( ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! qs . isDisposed ( ) ) observer . onComplete ( ) ; 
run . run ( ) ; return null ; 
source . subscribe ( new ConcatWithObserver < > ( observer , other ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) && ! inSingle ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
inSingle = true ; DisposableHelper . replace ( this , null ) ; SingleSource < ? extends T > ss = other ; other = null ; ss . subscribe ( this ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
GroupJoinDisposable < TLeft , TRight , TLeftEnd , TRightEnd , R > parent = new GroupJoinDisposable < > ( observer , leftEnd , rightEnd , resultSelector ) ; observer . onSubscribe ( parent ) ; LeftRightObserver left = new LeftRightObserver ( parent , true ) ; parent . disposables . add ( left ) ; LeftRightObserver right = new LeftRightObserver ( parent , false ) ; parent . disposables . add ( right ) ; source . subscribe ( left ) ; other . subscribe ( right ) ; 
if ( cancelled ) return ; cancelled = true ; cancelAll ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
return cancelled ; 
disposables . dispose ( ) ; 
Throwable ex = ExceptionHelper . terminate ( error ) ; for ( UnicastSubject < TRight > up : lefts . values ( ) ) up . onError ( ex ) ; lefts . clear ( ) ; rights . clear ( ) ; a . onError ( ex ) ; 
Exceptions . throwIfFatal ( exc ) ; ExceptionHelper . addThrowable ( error , exc ) ; q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; SpscLinkedArrayQueue < Object > q = queue ; Observer < ? super R > a = downstream ; for ( ; ; ) for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; Throwable ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; boolean d = active . get ( ) == 0 ; Integer mode = ( Integer ) q . poll ( ) ; boolean empty = mode == null ; if ( d && empty ) for ( UnicastSubject < ? > up : lefts . values ( ) ) up . onComplete ( ) ; lefts . clear ( ) ; rights . clear ( ) ; disposables . dispose ( ) ; a . onComplete ( ) ; return ; if ( empty ) break ; Object val = q . poll ( ) ; if ( mode == LEFT_VALUE ) @ SuppressWarnings ( "unchecked" ) TLeft left = ( TLeft ) val ; UnicastSubject < TRight > up = UnicastSubject . create ( ) ; int idx = leftIndex ++ ; lefts . put ( idx , up ) ; ObservableSource < TLeftEnd > p ; try p = Objects . requireNonNull ( leftEnd . apply ( left ) , "The leftEnd returned a null ObservableSource" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; LeftRightEndObserver end = new LeftRightEndObserver ( this , true , idx ) ; disposables . add ( end ) ; p . subscribe ( end ) ; ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; R w ; try w = Objects . requireNonNull ( resultSelector . apply ( left , up ) , "The resultSelector returned a null value" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; a . onNext ( w ) ; for ( TRight right : rights . values ( ) ) up . onNext ( right ) ; else if ( mode == RIGHT_VALUE ) @ SuppressWarnings ( "unchecked" ) TRight right = ( TRight ) val ; int idx = rightIndex ++ ; rights . put ( idx , right ) ; ObservableSource < TRightEnd > p ; try p = Objects . requireNonNull ( rightEnd . apply ( right ) , "The rightEnd returned a null ObservableSource" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; LeftRightEndObserver end = new LeftRightEndObserver ( this , false , idx ) ; disposables . add ( end ) ; p . subscribe ( end ) ; ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; for ( UnicastSubject < TRight > up : lefts . values ( ) ) up . onNext ( right ) ; else if ( mode == LEFT_CLOSE ) LeftRightEndObserver end = ( LeftRightEndObserver ) val ; UnicastSubject < TRight > up = lefts . remove ( end . index ) ; disposables . remove ( end ) ; if ( up != null ) up . onComplete ( ) ; else LeftRightEndObserver end = ( LeftRightEndObserver ) val ; rights . remove ( end . index ) ; disposables . remove ( end ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( ExceptionHelper . addThrowable ( error , ex ) ) active . decrementAndGet ( ) ; drain ( ) ; else RxJavaPlugins . onError ( ex ) ; 
if ( ExceptionHelper . addThrowable ( error , ex ) ) drain ( ) ; else RxJavaPlugins . onError ( ex ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerValue ( isLeft , t ) ; 
parent . innerError ( t ) ; 
parent . innerComplete ( this ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
if ( DisposableHelper . dispose ( this ) ) parent . innerClose ( isLeft , this ) ; 
parent . innerCloseError ( t ) ; 
parent . innerClose ( isLeft , this ) ; 
ObservableSource < ? extends T > [ ] sources = this . sources ; int count = 0 ; if ( sources == null ) sources = new ObservableSource [ 8 ] ; for ( ObservableSource < ? extends T > p : sourcesIterable ) if ( count == sources . length ) ObservableSource < ? extends T > [ ] b = new ObservableSource [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = p ; else count = sources . length ; if ( count == 0 ) EmptyDisposable . complete ( observer ) ; return ; ZipCoordinator < T , R > zc = new ZipCoordinator < > ( observer , zipper , count , delayError ) ; zc . subscribe ( sources , bufferSize ) ; 
if ( ! cancelled ) cancelled = true ; cancelSources ( ) ; if ( getAndIncrement ( ) == 0 ) clear ( ) ; 
return cancelled ; 
clear ( ) ; cancelSources ( ) ; 
for ( ZipObserver < ? , ? > zs : observers ) zs . dispose ( ) ; 
for ( ZipObserver < ? , ? > zs : observers ) zs . queue . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missing = 1 ; final ZipObserver < T , R > [ ] zs = observers ; final Observer < ? super R > a = downstream ; final T [ ] os = row ; final boolean delayError = this . delayError ; for ( ; ; ) for ( ; ; ) int i = 0 ; int emptyCount = 0 ; for ( ZipObserver < T , R > z : zs ) if ( os [ i ] == null ) boolean d = z . done ; T v = z . queue . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , z ) ) return ; if ( ! empty ) os [ i ] = v ; else emptyCount ++ ; else if ( z . done && ! delayError ) Throwable ex = z . error ; if ( ex != null ) cancelled = true ; cancel ( ) ; a . onError ( ex ) ; return ; i ++ ; if ( emptyCount != 0 ) break ; R v ; try v = Objects . requireNonNull ( zipper . apply ( os . clone ( ) ) , "The zipper returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancel ( ) ; a . onError ( ex ) ; return ; a . onNext ( v ) ; Arrays . fill ( os , null ) ; missing = addAndGet ( - missing ) ; if ( missing == 0 ) return ; 
DisposableHelper . setOnce ( this . upstream , d ) ; 
error = t ; done = true ; parent . drain ( ) ; 
done = true ; parent . drain ( ) ; 
DisposableHelper . dispose ( upstream ) ; 
source . subscribe ( new CountObserver ( t ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
count ++ ; 
downstream . onError ( t ) ; 
downstream . onNext ( count ) ; downstream . onComplete ( ) ; 
TimerObserver ios = new TimerObserver ( observer ) ; observer . onSubscribe ( ios ) ; Disposable d = scheduler . scheduleDirect ( ios , delay , unit ) ; ios . setResource ( d ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
if ( ! isDisposed ( ) ) downstream . onNext ( 0L ) ; lazySet ( EmptyDisposable . INSTANCE ) ; downstream . onComplete ( ) ; 
DisposableHelper . trySet ( this , d ) ; 
source . subscribe ( new TimeIntervalObserver < > ( t , unit , scheduler ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; lastTime = scheduler . now ( unit ) ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
IntervalObserver is = new IntervalObserver ( observer ) ; observer . onSubscribe ( is ) ; Scheduler sch = scheduler ; if ( sch instanceof TrampolineScheduler ) Worker worker = sch . createWorker ( ) ; is . setResource ( worker ) ; worker . schedulePeriodically ( is , initialDelay , period , unit ) ; else Disposable d = sch . schedulePeriodicallyDirect ( is , initialDelay , period , unit ) ; is . setResource ( d ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
if ( get ( ) != DisposableHelper . DISPOSED ) downstream . onNext ( count ++ ) ; 
DisposableHelper . setOnce ( this , d ) ; 
CancellableQueueFuseable < T > qs = new CancellableQueueFuseable < > ( ) ; observer . onSubscribe ( qs ) ; if ( ! qs . isDisposed ( ) ) try action . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! qs . isDisposed ( ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! qs . isDisposed ( ) ) observer . onComplete ( ) ; 
action . run ( ) ; return null ; 
Observer < T > observer ; if ( delayError ) observer = ( Observer < T > ) t ; else observer = new SerializedObserver < > ( t ) ; Scheduler . Worker w = scheduler . createWorker ( ) ; source . subscribe ( new DelayObserver < > ( observer , delay , unit , w , delayError ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
w . schedule ( new OnError ( t ) , delayError ? delay : 0 , unit ) ; 
w . schedule ( new OnComplete ( ) , delay , unit ) ; 
upstream . dispose ( ) ; w . dispose ( ) ; 
return w . isDisposed ( ) ; 
downstream . onNext ( t ) ; 
try downstream . onError ( throwable ) ; finally w . dispose ( ) ; 
try downstream . onComplete ( ) ; finally w . dispose ( ) ; 
source . subscribe ( new IgnoreObservable < > ( t ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableIgnoreElements < > ( source ) ) ; 
this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new TakeLastTimedObserver < > ( t , count , time , unit , scheduler , bufferSize , delayError ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
error = t ; drain ( ) ; 
drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . dispose ( ) ; if ( compareAndSet ( false , true ) ) queue . clear ( ) ; 
return cancelled ; 
if ( ! compareAndSet ( false , true ) ) return ; final Observer < ? super T > a = downstream ; final SpscLinkedArrayQueue < Object > q = queue ; final boolean delayError = this . delayError ; final long timestampLimit = scheduler . now ( unit ) - time ; for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; if ( ! delayError ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; return ; Object ts = q . poll ( ) ; boolean empty = ts == null ; if ( empty ) Throwable ex = error ; if ( ex != null ) a . onError ( ex ) ; else a . onComplete ( ) ; return ; @ SuppressWarnings ( "unchecked" ) T o = ( T ) q . poll ( ) ; if ( ( Long ) ts < timestampLimit ) continue ; a . onNext ( o ) ; 
source . subscribe ( new TakeUntilPredicateObserver < > ( observer , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( ! done ) done = true ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onComplete ( ) ; 
source . subscribe ( new LastObserver < > ( observer , defaultItem ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream == DisposableHelper . DISPOSED ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; item = null ; downstream . onError ( t ) ; 
upstream = DisposableHelper . DISPOSED ; T v = item ; if ( v != null ) item = null ; downstream . onSuccess ( v ) ; else v = defaultItem ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onError ( new NoSuchElementException ( ) ) ; 
source . subscribe ( new MaterializeObserver < > ( t ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
Notification < T > v = Notification . createOnError ( t ) ; downstream . onNext ( v ) ; downstream . onComplete ( ) ; 
Notification < T > v = Notification . createOnComplete ( ) ; downstream . onNext ( v ) ; downstream . onComplete ( ) ; 
source . subscribe ( new SerializedObserver < > ( observer ) ) ; 
source . subscribe ( new AnyObserver < > ( t , predicate ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableAny < > ( source , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onSuccess ( false ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new LastObserver < > ( observer ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream == DisposableHelper . DISPOSED ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; item = null ; downstream . onError ( t ) ; 
upstream = DisposableHelper . DISPOSED ; T v = item ; if ( v != null ) item = null ; downstream . onSuccess ( v ) ; else downstream . onComplete ( ) ; 
return new SimpleGenerator < > ( consumer ) ; 
return new SimpleBiGenerator < > ( consumer ) ; 
return new ItemDelayFunction < > ( itemDelay ) ; 
observer . onError ( v ) ; 
observer . onComplete ( ) ; 
return new ObserverOnNext < > ( observer ) ; 
return new ObserverOnError < > ( observer ) ; 
return new ObserverOnComplete < > ( observer ) ; 
return new FlatMapWithCombinerOuter < > ( combiner , mapper ) ; 
return new FlatMapIntoIterable < > ( mapper ) ; 
return 0 ; 
return new ReplaySupplier < > ( parent ) ; 
return parent . replay ( ) ; 
return parent . replay ( bufferSize , eagerTruncate ) ; 
return parent . replay ( bufferSize , time , unit , scheduler , eagerTruncate ) ; 
return parent . replay ( time , unit , scheduler , eagerTruncate ) ; 
Observer < ? super T > liftedObserver ; try liftedObserver = Objects . requireNonNull ( operator . apply ( observer ) , "Operator " + operator + " returned a null Observer" ) ; catch ( NullPointerException e ) throw e ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; NullPointerException npe = new NullPointerException ( "Actually not, but can't throw other exceptions due to RS" ) ; npe . initCause ( e ) ; throw npe ; source . subscribe ( liftedObserver ) ; 
RangeDisposable parent = new RangeDisposable ( o , start , start + count ) ; o . onSubscribe ( parent ) ; parent . run ( ) ; 
if ( fused ) return ; Observer < ? super Long > actual = this . downstream ; long e = end ; for ( long i = index ; i != e && get ( ) == 0 ; i ++ ) actual . onNext ( i ) ; if ( get ( ) == 0 ) lazySet ( 1 ) ; actual . onComplete ( ) ; 
long i = index ; if ( i != end ) index = i + 1 ; return i ; lazySet ( 1 ) ; return null ; 
return index == end ; 
index = end ; lazySet ( 1 ) ; 
set ( 1 ) ; 
return get ( ) != 0 ; 
DeferredScalarDisposable < T > d = new DeferredScalarDisposable < > ( observer ) ; observer . onSubscribe ( d ) ; if ( d . isDisposed ( ) ) return ; T value ; try value = ExceptionHelper . nullCheck ( callable . call ( ) , "Callable returned a null value." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; if ( ! d . isDisposed ( ) ) observer . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; return ; d . complete ( value ) ; 
return ExceptionHelper . nullCheck ( callable . call ( ) , "The Callable returned a null value." ) ; 
source . subscribe ( new CountObserver ( t ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableCount < > ( source ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
count ++ ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( t ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onSuccess ( count ) ; 
source . subscribe ( new ElementAtObserver < > ( t , index , defaultValue , errorOnFewer ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; T v = defaultValue ; if ( v == null && errorOnFewer ) downstream . onError ( new NoSuchElementException ( ) ) ; else if ( v != null ) downstream . onNext ( v ) ; downstream . onComplete ( ) ; 
source . subscribe ( new UnsubscribeObserver < > ( t , scheduler ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( get ( ) ) RxJavaPlugins . onError ( t ) ; return ; downstream . onError ( t ) ; 
if ( ! get ( ) ) downstream . onComplete ( ) ; 
if ( compareAndSet ( false , true ) ) scheduler . scheduleDirect ( new DisposeTask ( ) ) ; 
return get ( ) ; 
upstream . dispose ( ) ; 
source . subscribe ( new DisposableLambdaObserver < > ( observer , onSubscribe , onDispose ) ) ; 
if ( skip == count ) BufferExactObserver < T , U > bes = new BufferExactObserver < > ( t , count , bufferSupplier ) ; if ( bes . createBuffer ( ) ) source . subscribe ( bes ) ; else source . subscribe ( new BufferSkipObserver < > ( t , count , skip , bufferSupplier ) ) ; 
U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "Empty buffer supplied" ) ; catch ( Throwable t ) Exceptions . throwIfFatal ( t ) ; buffer = null ; if ( upstream == null ) EmptyDisposable . error ( t , downstream ) ; else upstream . dispose ( ) ; downstream . onError ( t ) ; return false ; buffer = b ; return true ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
buffer = null ; downstream . onError ( t ) ; 
U b = buffer ; if ( b != null ) buffer = null ; if ( ! b . isEmpty ( ) ) downstream . onNext ( b ) ; downstream . onComplete ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
buffers . clear ( ) ; downstream . onError ( t ) ; 
while ( ! buffers . isEmpty ( ) ) downstream . onNext ( buffers . poll ( ) ) ; downstream . onComplete ( ) ; 
MergeWithObserver < T > parent = new MergeWithObserver < > ( observer ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; other . subscribe ( parent . otherObserver ) ; 
DisposableHelper . setOnce ( mainDisposable , d ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) DisposableHelper . dispose ( otherObserver ) ; drain ( ) ; 
mainDone = true ; drain ( ) ; 
return DisposableHelper . isDisposed ( mainDisposable . get ( ) ) ; 
disposed = true ; DisposableHelper . dispose ( mainDisposable ) ; DisposableHelper . dispose ( otherObserver ) ; errors . tryTerminateAndReport ( ) ; if ( getAndIncrement ( ) == 0 ) queue = null ; singleItem = null ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) DisposableHelper . dispose ( mainDisposable ) ; drain ( ) ; 
SimplePlainQueue < T > q = queue ; if ( q == null ) q = new SpscLinkedArrayQueue < > ( bufferSize ( ) ) ; queue = q ; return q ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
Observer < ? super T > actual = this . downstream ; int missed = 1 ; for ( ; ; ) for ( ; ; ) if ( disposed ) singleItem = null ; queue = null ; return ; if ( errors . get ( ) != null ) singleItem = null ; queue = null ; errors . tryTerminateConsumer ( actual ) ; return ; int os = otherState ; if ( os == OTHER_STATE_HAS_VALUE ) T v = singleItem ; singleItem = null ; otherState = OTHER_STATE_CONSUMED_OR_EMPTY ; os = OTHER_STATE_CONSUMED_OR_EMPTY ; actual . onNext ( v ) ; boolean d = mainDone ; SimplePlainQueue < T > q = queue ; T v = q != null ? q . poll ( ) : null ; boolean empty = v == null ; if ( d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY ) queue = null ; actual . onComplete ( ) ; return ; if ( empty ) break ; actual . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . otherError ( e ) ; 
final SerializedObserver < R > serial = new SerializedObserver < > ( t ) ; final WithLatestFromObserver < T , U , R > wlf = new WithLatestFromObserver < > ( serial , combiner ) ; serial . onSubscribe ( wlf ) ; other . subscribe ( new WithLatestFromOtherObserver ( wlf ) ) ; source . subscribe ( wlf ) ; 
DisposableHelper . setOnce ( this . upstream , d ) ; 
DisposableHelper . dispose ( other ) ; downstream . onError ( t ) ; 
DisposableHelper . dispose ( other ) ; downstream . onComplete ( ) ; 
DisposableHelper . dispose ( upstream ) ; DisposableHelper . dispose ( other ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
return DisposableHelper . setOnce ( other , o ) ; 
DisposableHelper . dispose ( upstream ) ; downstream . onError ( e ) ; 
parent . setOther ( d ) ; 
parent . otherError ( t ) ; 
$EMPTY$
if ( ObservableScalarXMap . tryScalarXMapSubscribe ( source , observer , mapper ) ) return ; if ( delayErrors == ErrorMode . IMMEDIATE ) SerializedObserver < U > serial = new SerializedObserver < > ( observer ) ; source . subscribe ( new SourceObserver < > ( serial , mapper , bufferSize ) ) ; else source . subscribe ( new ConcatMapDelayErrorObserver < > ( observer , mapper , bufferSize , delayErrors == ErrorMode . END ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < T > qd = ( QueueDisposable < T > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY ) ; if ( m == QueueDisposable . SYNC ) fusionMode = m ; queue = qd ; done = true ; downstream . onSubscribe ( this ) ; drain ( ) ; return ; if ( m == QueueDisposable . ASYNC ) fusionMode = m ; queue = qd ; downstream . onSubscribe ( this ) ; return ; queue = new SpscLinkedArrayQueue < > ( bufferSize ) ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; dispose ( ) ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; drain ( ) ; 
active = false ; drain ( ) ; 
return disposed ; 
disposed = true ; inner . dispose ( ) ; upstream . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; for ( ; ; ) if ( disposed ) queue . clear ( ) ; return ; if ( ! active ) boolean d = done ; T t ; try t = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; dispose ( ) ; queue . clear ( ) ; downstream . onError ( ex ) ; return ; boolean empty = t == null ; if ( d && empty ) disposed = true ; downstream . onComplete ( ) ; return ; if ( ! empty ) ObservableSource < ? extends U > o ; try o = Objects . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; dispose ( ) ; queue . clear ( ) ; downstream . onError ( ex ) ; return ; active = true ; o . subscribe ( inner ) ; if ( decrementAndGet ( ) == 0 ) break ; 
DisposableHelper . replace ( this , d ) ; 
parent . dispose ( ) ; downstream . onError ( t ) ; 
parent . innerComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < T > qd = ( QueueDisposable < T > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY ) ; if ( m == QueueDisposable . SYNC ) sourceMode = m ; queue = qd ; done = true ; downstream . onSubscribe ( this ) ; drain ( ) ; return ; if ( m == QueueDisposable . ASYNC ) sourceMode = m ; queue = qd ; downstream . onSubscribe ( this ) ; return ; queue = new SpscLinkedArrayQueue < > ( bufferSize ) ; downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
return cancelled ; 
cancelled = true ; upstream . dispose ( ) ; observer . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; Observer < ? super R > downstream = this . downstream ; SimpleQueue < T > queue = this . queue ; AtomicThrowable errors = this . errors ; for ( ; ; ) if ( ! active ) if ( cancelled ) queue . clear ( ) ; return ; if ( ! tillTheEnd ) Throwable ex = errors . get ( ) ; if ( ex != null ) queue . clear ( ) ; cancelled = true ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelled = true ; this . upstream . dispose ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean empty = v == null ; if ( d && empty ) cancelled = true ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( ! empty ) ObservableSource < ? extends R > o ; try o = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelled = true ; this . upstream . dispose ( ) ; queue . clear ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( o instanceof Supplier ) R w ; try w = ( ( Supplier < R > ) o ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; errors . tryAddThrowableOrReport ( ex ) ; continue ; if ( w != null && ! cancelled ) downstream . onNext ( w ) ; continue ; else active = true ; o . subscribe ( observer ) ; if ( decrementAndGet ( ) == 0 ) break ; 
DisposableHelper . replace ( this , d ) ; 
ConcatMapDelayErrorObserver < ? , R > p = parent ; if ( p . errors . tryAddThrowableOrReport ( e ) ) if ( ! p . tillTheEnd ) p . upstream . dispose ( ) ; p . active = false ; p . drain ( ) ; 
ConcatMapDelayErrorObserver < ? , R > p = parent ; p . active = false ; p . drain ( ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new FlatMapMaybeObserver < > ( observer , mapper , delayErrors ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
active . decrementAndGet ( ) ; if ( errors . tryAddThrowableOrReport ( t ) ) if ( ! delayErrors ) set . dispose ( ) ; drain ( ) ; 
active . decrementAndGet ( ) ; drain ( ) ; 
cancelled = true ; upstream . dispose ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
return cancelled ; 
SpscLinkedArrayQueue < R > current = queue . get ( ) ; if ( current != null ) return current ; current = new SpscLinkedArrayQueue < > ( Observable . bufferSize ( ) ) ; if ( queue . compareAndSet ( null , current ) ) return current ; return queue . get ( ) ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
SpscLinkedArrayQueue < R > q = queue . get ( ) ; if ( q != null ) q . clear ( ) ; 
int missed = 1 ; Observer < ? super R > a = downstream ; AtomicInteger n = active ; AtomicReference < SpscLinkedArrayQueue < R > > qr = queue ; for ( ; ; ) for ( ; ; ) if ( cancelled ) clear ( ) ; return ; if ( ! delayErrors ) Throwable ex = errors . get ( ) ; if ( ex != null ) clear ( ) ; errors . tryTerminateConsumer ( a ) ; return ; boolean d = n . get ( ) == 0 ; SpscLinkedArrayQueue < R > q = qr . get ( ) ; R v = q != null ? q . poll ( ) : null ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( a ) ; return ; if ( empty ) break ; a . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
innerError ( this , e ) ; 
innerComplete ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new SkipLastObserver < > ( observer , skip ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
RangeDisposable parent = new RangeDisposable ( o , start , end ) ; o . onSubscribe ( parent ) ; parent . run ( ) ; 
if ( fused ) return ; Observer < ? super Integer > actual = this . downstream ; long e = end ; for ( long i = index ; i != e && get ( ) == 0 ; i ++ ) actual . onNext ( ( int ) i ) ; if ( get ( ) == 0 ) lazySet ( 1 ) ; actual . onComplete ( ) ; 
long i = index ; if ( i != end ) index = i + 1 ; return ( int ) i ; lazySet ( 1 ) ; return null ; 
return index == end ; 
index = end ; lazySet ( 1 ) ; 
set ( 1 ) ; 
return get ( ) != 0 ; 
U coll ; try coll = ExceptionHelper . nullCheck ( collectionSupplier . get ( ) , "The collectionSupplier returned a null Collection." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , t ) ; return ; source . subscribe ( new ToListObserver < > ( t , coll ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
collection = null ; downstream . onError ( t ) ; 
U c = collection ; collection = null ; downstream . onNext ( c ) ; downstream . onComplete ( ) ; 
source . subscribe ( new DebounceTimedObserver < > ( new SerializedObserver < > ( t ) , timeout , unit , scheduler . createWorker ( ) ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; Disposable d = timer ; if ( d != null ) d . dispose ( ) ; done = true ; downstream . onError ( t ) ; worker . dispose ( ) ; 
if ( done ) return ; done = true ; Disposable d = timer ; if ( d != null ) d . dispose ( ) ; @ SuppressWarnings ( "unchecked" ) DebounceEmitter < T > de = ( DebounceEmitter < T > ) d ; if ( de != null ) de . run ( ) ; downstream . onComplete ( ) ; worker . dispose ( ) ; 
upstream . dispose ( ) ; worker . dispose ( ) ; 
return worker . isDisposed ( ) ; 
if ( once . compareAndSet ( false , true ) ) parent . emit ( idx , value , this ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
DisposableHelper . replace ( this , d ) ; 
SerializedObserver < T > serial = new SerializedObserver < > ( t ) ; if ( emitLast ) source . subscribe ( new SampleTimedEmitLast < > ( serial , period , unit , scheduler ) ) ; else source . subscribe ( new SampleTimedNoLast < > ( serial , period , unit , scheduler ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; Disposable task = scheduler . schedulePeriodicallyDirect ( this , period , period , unit ) ; DisposableHelper . replace ( timer , task ) ; 
cancelTimer ( ) ; downstream . onError ( t ) ; 
cancelTimer ( ) ; complete ( ) ; 
DisposableHelper . dispose ( timer ) ; 
cancelTimer ( ) ; upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
T value = getAndSet ( null ) ; if ( value != null ) downstream . onNext ( value ) ; 
downstream . onComplete ( ) ; 
emit ( ) ; 
emit ( ) ; if ( wip . decrementAndGet ( ) == 0 ) downstream . onComplete ( ) ; 
if ( wip . incrementAndGet ( ) == 2 ) emit ( ) ; if ( wip . decrementAndGet ( ) == 0 ) downstream . onComplete ( ) ; 
Iterator < ? extends T > it ; try it = source . iterator ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; boolean hasNext ; try hasNext = it . hasNext ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; if ( ! hasNext ) EmptyDisposable . complete ( observer ) ; return ; FromIterableDisposable < T > d = new FromIterableDisposable < > ( observer , it ) ; observer . onSubscribe ( d ) ; if ( ! d . fusionMode ) d . run ( ) ; 
boolean hasNext ; do if ( isDisposed ( ) ) return ; T v ; try v = Objects . requireNonNull ( it . next ( ) , "The iterator returned a null value" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; downstream . onNext ( v ) ; if ( isDisposed ( ) ) return ; try hasNext = it . hasNext ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; while ( hasNext ) ; if ( ! isDisposed ( ) ) downstream . onComplete ( ) ; 
if ( done ) return null ; if ( checkNext ) if ( ! it . hasNext ( ) ) done = true ; return null ; else checkNext = true ; return Objects . requireNonNull ( it . next ( ) , "The iterator returned a null value" ) ; 
return done ; 
done = true ; 
disposed = true ; 
return disposed ; 
source . subscribe ( new IgnoreObservable < > ( t ) ) ; 
this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
DeferredScalarDisposable < T > d = new DeferredScalarDisposable < > ( observer ) ; observer . onSubscribe ( d ) ; if ( ! d . isDisposed ( ) ) T v ; try v = ExceptionHelper . nullCheck ( unit != null ? future . get ( timeout , unit ) : future . get ( ) , "Future returned a null value." ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! d . isDisposed ( ) ) observer . onError ( ex ) ; return ; d . complete ( v ) ; 
MergeWithObserver < T > parent = new MergeWithObserver < > ( observer ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; other . subscribe ( parent . otherObserver ) ; 
DisposableHelper . setOnce ( mainDisposable , d ) ; 
DisposableHelper . dispose ( otherObserver ) ; HalfSerializer . onError ( downstream , ex , this , errors ) ; 
mainDone = true ; if ( otherDone ) HalfSerializer . onComplete ( downstream , this , errors ) ; 
return DisposableHelper . isDisposed ( mainDisposable . get ( ) ) ; 
DisposableHelper . dispose ( mainDisposable ) ; DisposableHelper . dispose ( otherObserver ) ; errors . tryTerminateAndReport ( ) ; 
DisposableHelper . dispose ( mainDisposable ) ; HalfSerializer . onError ( downstream , ex , this , errors ) ; 
otherDone = true ; if ( mainDone ) HalfSerializer . onComplete ( downstream , this , errors ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . otherError ( e ) ; 
parent . otherComplete ( ) ; 
source . subscribe ( new WindowBoundaryMainObserver < > ( t , open , closingIndicator , bufferSize ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; open . subscribe ( startObserver ) ; 
startObserver . dispose ( ) ; resources . dispose ( ) ; if ( error . tryAddThrowableOrReport ( t ) ) upstreamDone = true ; drain ( ) ; 
startObserver . dispose ( ) ; resources . dispose ( ) ; upstreamDone = true ; drain ( ) ; 
if ( downstreamDisposed . compareAndSet ( false , true ) ) if ( windowCount . decrementAndGet ( ) == 0 ) upstream . dispose ( ) ; startObserver . dispose ( ) ; resources . dispose ( ) ; error . tryTerminateAndReport ( ) ; upstreamCanceled = true ; drain ( ) ; else startObserver . dispose ( ) ; 
return downstreamDisposed . get ( ) ; 
if ( windowCount . decrementAndGet ( ) == 0 ) upstream . dispose ( ) ; startObserver . dispose ( ) ; resources . dispose ( ) ; error . tryTerminateAndReport ( ) ; upstreamCanceled = true ; drain ( ) ; 
upstream . dispose ( ) ; resources . dispose ( ) ; if ( error . tryAddThrowableOrReport ( t ) ) upstreamDone = true ; drain ( ) ; 
openDone = true ; drain ( ) ; 
upstream . dispose ( ) ; startObserver . dispose ( ) ; resources . dispose ( ) ; if ( error . tryAddThrowableOrReport ( t ) ) upstreamDone = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final Observer < ? super Observable < T > > downstream = this . downstream ; final SimplePlainQueue < Object > queue = this . queue ; final List < UnicastSubject < T > > windows = this . windows ; for ( ; ; ) if ( upstreamCanceled ) queue . clear ( ) ; windows . clear ( ) ; else boolean isDone = upstreamDone ; Object o = queue . poll ( ) ; boolean isEmpty = o == null ; if ( isDone ) if ( isEmpty || error . get ( ) != null ) terminateDownstream ( downstream ) ; upstreamCanceled = true ; continue ; if ( ! isEmpty ) if ( o instanceof WindowStartItem ) if ( ! downstreamDisposed . get ( ) ) @ SuppressWarnings ( "unchecked" ) B startItem = ( ( WindowStartItem < B > ) o ) . item ; ObservableSource < V > endSource ; try endSource = Objects . requireNonNull ( closingIndicator . apply ( startItem ) , "The closingIndicator returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . dispose ( ) ; startObserver . dispose ( ) ; resources . dispose ( ) ; Exceptions . throwIfFatal ( ex ) ; error . tryAddThrowableOrReport ( ex ) ; upstreamDone = true ; continue ; windowCount . getAndIncrement ( ) ; UnicastSubject < T > newWindow = UnicastSubject . create ( bufferSize , this ) ; WindowEndObserverIntercept < T , V > endObserver = new WindowEndObserverIntercept < > ( this , newWindow ) ; downstream . onNext ( endObserver ) ; if ( endObserver . tryAbandon ( ) ) newWindow . onComplete ( ) ; else windows . add ( newWindow ) ; resources . add ( endObserver ) ; endSource . subscribe ( endObserver ) ; else if ( o instanceof WindowEndObserverIntercept ) @ SuppressWarnings ( "unchecked" ) UnicastSubject < T > w = ( ( WindowEndObserverIntercept < T , V > ) o ) . window ; windows . remove ( w ) ; resources . delete ( ( Disposable ) o ) ; w . onComplete ( ) ; else @ SuppressWarnings ( "unchecked" ) T item = ( T ) o ; for ( UnicastSubject < T > w : windows ) w . onNext ( item ) ; continue ; else if ( openDone && windows . size ( ) == 0 ) upstream . dispose ( ) ; startObserver . dispose ( ) ; resources . dispose ( ) ; terminateDownstream ( downstream ) ; upstreamCanceled = true ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
Throwable ex = error . terminate ( ) ; if ( ex == null ) for ( UnicastSubject < T > w : windows ) w . onComplete ( ) ; downstream . onComplete ( ) ; else if ( ex != ExceptionHelper . TERMINATED ) for ( UnicastSubject < T > w : windows ) w . onError ( ex ) ; downstream . onError ( ex ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . openError ( t ) ; 
parent . openComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
DisposableHelper . setOnce ( upstream , d ) ; 
if ( isDisposed ( ) ) RxJavaPlugins . onError ( t ) ; else parent . closeError ( t ) ; 
parent . close ( this ) ; 
DisposableHelper . dispose ( upstream ) ; 
return upstream . get ( ) == DisposableHelper . DISPOSED ; 
window . subscribe ( o ) ; once . set ( true ) ; 
return ! once . get ( ) && once . compareAndSet ( false , true ) ; 
JoinDisposable < TLeft , TRight , TLeftEnd , TRightEnd , R > parent = new JoinDisposable < > ( observer , leftEnd , rightEnd , resultSelector ) ; observer . onSubscribe ( parent ) ; LeftRightObserver left = new LeftRightObserver ( parent , true ) ; parent . disposables . add ( left ) ; LeftRightObserver right = new LeftRightObserver ( parent , false ) ; parent . disposables . add ( right ) ; source . subscribe ( left ) ; other . subscribe ( right ) ; 
if ( ! cancelled ) cancelled = true ; cancelAll ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
return cancelled ; 
disposables . dispose ( ) ; 
Throwable ex = ExceptionHelper . terminate ( error ) ; lefts . clear ( ) ; rights . clear ( ) ; a . onError ( ex ) ; 
Exceptions . throwIfFatal ( exc ) ; ExceptionHelper . addThrowable ( error , exc ) ; q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; SpscLinkedArrayQueue < Object > q = queue ; Observer < ? super R > a = downstream ; for ( ; ; ) for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; Throwable ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; boolean d = active . get ( ) == 0 ; Integer mode = ( Integer ) q . poll ( ) ; boolean empty = mode == null ; if ( d && empty ) lefts . clear ( ) ; rights . clear ( ) ; disposables . dispose ( ) ; a . onComplete ( ) ; return ; if ( empty ) break ; Object val = q . poll ( ) ; if ( mode == LEFT_VALUE ) @ SuppressWarnings ( "unchecked" ) TLeft left = ( TLeft ) val ; int idx = leftIndex ++ ; lefts . put ( idx , left ) ; ObservableSource < TLeftEnd > p ; try p = Objects . requireNonNull ( leftEnd . apply ( left ) , "The leftEnd returned a null ObservableSource" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; LeftRightEndObserver end = new LeftRightEndObserver ( this , true , idx ) ; disposables . add ( end ) ; p . subscribe ( end ) ; ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; for ( TRight right : rights . values ( ) ) R w ; try w = Objects . requireNonNull ( resultSelector . apply ( left , right ) , "The resultSelector returned a null value" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; a . onNext ( w ) ; else if ( mode == RIGHT_VALUE ) @ SuppressWarnings ( "unchecked" ) TRight right = ( TRight ) val ; int idx = rightIndex ++ ; rights . put ( idx , right ) ; ObservableSource < TRightEnd > p ; try p = Objects . requireNonNull ( rightEnd . apply ( right ) , "The rightEnd returned a null ObservableSource" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; LeftRightEndObserver end = new LeftRightEndObserver ( this , false , idx ) ; disposables . add ( end ) ; p . subscribe ( end ) ; ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; for ( TLeft left : lefts . values ( ) ) R w ; try w = Objects . requireNonNull ( resultSelector . apply ( left , right ) , "The resultSelector returned a null value" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; a . onNext ( w ) ; else if ( mode == LEFT_CLOSE ) LeftRightEndObserver end = ( LeftRightEndObserver ) val ; lefts . remove ( end . index ) ; disposables . remove ( end ) ; else LeftRightEndObserver end = ( LeftRightEndObserver ) val ; rights . remove ( end . index ) ; disposables . remove ( end ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( ExceptionHelper . addThrowable ( error , ex ) ) active . decrementAndGet ( ) ; drain ( ) ; else RxJavaPlugins . onError ( ex ) ; 
if ( ExceptionHelper . addThrowable ( error , ex ) ) drain ( ) ; else RxJavaPlugins . onError ( ex ) ; 
source . subscribe ( new DebounceObserver < > ( new SerializedObserver < > ( t ) , debounceSelector ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
DisposableHelper . dispose ( debouncer ) ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; Disposable d = debouncer . get ( ) ; if ( d != DisposableHelper . DISPOSED ) @ SuppressWarnings ( "unchecked" ) DebounceInnerObserver < T , U > dis = ( DebounceInnerObserver < T , U > ) d ; if ( dis != null ) dis . emit ( ) ; DisposableHelper . dispose ( debouncer ) ; downstream . onComplete ( ) ; 
upstream . dispose ( ) ; DisposableHelper . dispose ( debouncer ) ; 
return upstream . isDisposed ( ) ; 
if ( once . compareAndSet ( false , true ) ) parent . emit ( index , value ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; parent . onError ( t ) ; 
if ( done ) return ; done = true ; emit ( ) ; 
source . subscribe ( new ConcatMapEagerMainObserver < > ( observer , mapper , maxConcurrency , prefetch , errorMode ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; if ( d instanceof QueueDisposable ) QueueDisposable < T > qd = ( QueueDisposable < T > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY ) ; if ( m == QueueDisposable . SYNC ) sourceMode = m ; queue = qd ; done = true ; downstream . onSubscribe ( this ) ; drain ( ) ; return ; if ( m == QueueDisposable . ASYNC ) sourceMode = m ; queue = qd ; downstream . onSubscribe ( this ) ; return ; queue = new SpscLinkedArrayQueue < > ( prefetch ) ; downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( cancelled ) return ; cancelled = true ; upstream . dispose ( ) ; errors . tryTerminateAndReport ( ) ; drainAndDispose ( ) ; 
if ( getAndIncrement ( ) == 0 ) do queue . clear ( ) ; disposeAll ( ) ; while ( decrementAndGet ( ) != 0 ) ; 
return cancelled ; 
InnerQueuedObserver < R > inner = current ; if ( inner != null ) inner . dispose ( ) ; for ( ; ; ) inner = observers . poll ( ) ; if ( inner == null ) return ; inner . dispose ( ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) if ( errorMode == ErrorMode . IMMEDIATE ) upstream . dispose ( ) ; inner . setDone ( ) ; drain ( ) ; 
inner . setDone ( ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; SimpleQueue < T > q = queue ; ArrayDeque < InnerQueuedObserver < R > > observers = this . observers ; Observer < ? super R > a = this . downstream ; ErrorMode errorMode = this . errorMode ; outer : for ( ; ; ) int ac = activeCount ; while ( ac != maxConcurrency ) if ( cancelled ) q . clear ( ) ; disposeAll ( ) ; return ; if ( errorMode == ErrorMode . IMMEDIATE ) Throwable ex = errors . get ( ) ; if ( ex != null ) q . clear ( ) ; disposeAll ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; T v ; ObservableSource < ? extends R > source ; try v = q . poll ( ) ; if ( v == null ) break ; source = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . dispose ( ) ; q . clear ( ) ; disposeAll ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; return ; InnerQueuedObserver < R > inner = new InnerQueuedObserver < > ( this , prefetch ) ; observers . offer ( inner ) ; source . subscribe ( inner ) ; ac ++ ; activeCount = ac ; if ( cancelled ) q . clear ( ) ; disposeAll ( ) ; return ; if ( errorMode == ErrorMode . IMMEDIATE ) Throwable ex = errors . get ( ) ; if ( ex != null ) q . clear ( ) ; disposeAll ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; InnerQueuedObserver < R > active = current ; if ( active == null ) if ( errorMode == ErrorMode . BOUNDARY ) Throwable ex = errors . get ( ) ; if ( ex != null ) q . clear ( ) ; disposeAll ( ) ; errors . tryTerminateConsumer ( a ) ; return ; boolean d = done ; active = observers . poll ( ) ; boolean empty = active == null ; if ( d && empty ) Throwable ex = errors . get ( ) ; if ( ex != null ) q . clear ( ) ; disposeAll ( ) ; errors . tryTerminateConsumer ( a ) ; else a . onComplete ( ) ; return ; if ( ! empty ) current = active ; if ( active != null ) SimpleQueue < R > aq = active . queue ( ) ; for ( ; ; ) if ( cancelled ) q . clear ( ) ; disposeAll ( ) ; return ; boolean d = active . isDone ( ) ; if ( errorMode == ErrorMode . IMMEDIATE ) Throwable ex = errors . get ( ) ; if ( ex != null ) q . clear ( ) ; disposeAll ( ) ; errors . tryTerminateConsumer ( a ) ; return ; R w ; try w = aq . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; errors . tryAddThrowableOrReport ( ex ) ; current = null ; activeCount -- ; continue outer ; boolean empty = w == null ; if ( d && empty ) current = null ; activeCount -- ; continue outer ; if ( empty ) break ; a . onNext ( w ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( ObservableScalarXMap . tryScalarXMapSubscribe ( source , t , mapper ) ) return ; source . subscribe ( new MergeObserver < > ( t , mapper , delayErrors , maxConcurrency , bufferSize ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
for ( ; ; ) if ( p instanceof Supplier ) if ( tryEmitScalar ( ( ( Supplier < ? extends U > ) p ) ) && maxConcurrency != Integer . MAX_VALUE ) boolean empty = false ; synchronized ( this ) p = sources . poll ( ) ; if ( p == null ) wip -- ; empty = true ; if ( empty ) drain ( ) ; break ; else break ; else InnerObserver < T , U > inner = new InnerObserver < > ( this , uniqueId ++ ) ; if ( addInner ( inner ) ) p . subscribe ( inner ) ; break ; 
U u ; try u = value . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; errors . tryAddThrowableOrReport ( ex ) ; drain ( ) ; return true ; if ( u == null ) return true ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) downstream . onNext ( u ) ; if ( decrementAndGet ( ) == 0 ) return true ; else SimplePlainQueue < U > q = queue ; if ( q == null ) if ( maxConcurrency == Integer . MAX_VALUE ) q = new SpscLinkedArrayQueue < > ( bufferSize ) ; else q = new SpscArrayQueue < > ( maxConcurrency ) ; queue = q ; q . offer ( u ) ; if ( getAndIncrement ( ) != 0 ) return false ; drainLoop ( ) ; return true ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; if ( errors . tryAddThrowableOrReport ( t ) ) done = true ; drain ( ) ; 
if ( done ) return ; done = true ; drain ( ) ; 
disposed = true ; if ( disposeAll ( ) ) errors . tryTerminateAndReport ( ) ; 
return disposed ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
final Observer < ? super U > child = this . downstream ; int missed = 1 ; for ( ; ; ) if ( checkTerminate ( ) ) return ; int innerCompleted = 0 ; SimplePlainQueue < U > svq = queue ; if ( svq != null ) for ( ; ; ) if ( checkTerminate ( ) ) return ; U o = svq . poll ( ) ; if ( o == null ) break ; child . onNext ( o ) ; innerCompleted ++ ; if ( innerCompleted != 0 ) if ( maxConcurrency != Integer . MAX_VALUE ) subscribeMore ( innerCompleted ) ; innerCompleted = 0 ; continue ; boolean d = done ; svq = queue ; InnerObserver < ? , ? > [ ] inner = observers . get ( ) ; int n = inner . length ; int nSources = 0 ; if ( maxConcurrency != Integer . MAX_VALUE ) synchronized ( this ) nSources = sources . size ( ) ; if ( d && ( svq == null || svq . isEmpty ( ) ) && n == 0 && nSources == 0 ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( n != 0 ) int j = Math . min ( n - 1 , lastIndex ) ; sourceLoop : for ( int i = 0 ; i < n ; i ++ ) if ( checkTerminate ( ) ) return ; @ SuppressWarnings ( "unchecked" ) InnerObserver < T , U > is = ( InnerObserver < T , U > ) inner [ j ] ; SimpleQueue < U > q = is . queue ; if ( q != null ) for ( ; ; ) U o ; try o = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; is . dispose ( ) ; errors . tryAddThrowableOrReport ( ex ) ; if ( checkTerminate ( ) ) return ; removeInner ( is ) ; innerCompleted ++ ; j ++ ; if ( j == n ) j = 0 ; continue sourceLoop ; if ( o == null ) break ; child . onNext ( o ) ; if ( checkTerminate ( ) ) return ; boolean innerDone = is . done ; SimpleQueue < U > innerQueue = is . queue ; if ( innerDone && ( innerQueue == null || innerQueue . isEmpty ( ) ) ) removeInner ( is ) ; innerCompleted ++ ; j ++ ; if ( j == n ) j = 0 ; lastIndex = j ; if ( innerCompleted != 0 ) if ( maxConcurrency != Integer . MAX_VALUE ) subscribeMore ( innerCompleted ) ; innerCompleted = 0 ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( disposed ) return true ; Throwable e = errors . get ( ) ; if ( ! delayErrors && ( e != null ) ) disposeAll ( ) ; errors . tryTerminateConsumer ( downstream ) ; return true ; return false ; 
upstream . dispose ( ) ; InnerObserver < ? , ? > [ ] a = observers . getAndSet ( CANCELLED ) ; if ( a != CANCELLED ) for ( InnerObserver < ? , ? > inner : a ) inner . dispose ( ) ; return true ; return false ; 
if ( DisposableHelper . setOnce ( this , d ) ) if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < U > qd = ( QueueDisposable < U > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY | QueueDisposable . BOUNDARY ) ; if ( m == QueueDisposable . SYNC ) fusionMode = m ; queue = qd ; done = true ; parent . drain ( ) ; return ; if ( m == QueueDisposable . ASYNC ) fusionMode = m ; queue = qd ; 
if ( parent . errors . tryAddThrowableOrReport ( t ) ) if ( ! parent . delayErrors ) parent . disposeAll ( ) ; done = true ; parent . drain ( ) ; 
done = true ; parent . drain ( ) ; 
DisposableHelper . dispose ( this ) ; 
BufferBoundaryObserver < T , U , Open , Close > parent = new BufferBoundaryObserver < > ( t , bufferOpen , bufferClose , bufferSupplier ) ; t . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
if ( DisposableHelper . setOnce ( this . upstream , d ) ) BufferOpenObserver < Open > open = new BufferOpenObserver < > ( this ) ; observers . add ( open ) ; bufferOpen . subscribe ( open ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) observers . dispose ( ) ; synchronized ( this ) buffers = null ; done = true ; drain ( ) ; 
observers . dispose ( ) ; synchronized ( this ) Map < Long , C > bufs = buffers ; if ( bufs == null ) return ; for ( C b : bufs . values ( ) ) queue . offer ( b ) ; buffers = null ; done = true ; drain ( ) ; 
if ( DisposableHelper . dispose ( upstream ) ) cancelled = true ; observers . dispose ( ) ; synchronized ( this ) buffers = null ; if ( getAndIncrement ( ) != 0 ) queue . clear ( ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
DisposableHelper . dispose ( upstream ) ; observers . delete ( observer ) ; onError ( ex ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Observer < ? super C > a = downstream ; SpscLinkedArrayQueue < C > q = queue ; for ( ; ; ) for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; boolean d = done ; if ( d && errors . get ( ) != null ) q . clear ( ) ; errors . tryTerminateConsumer ( a ) ; return ; C v = q . poll ( ) ; boolean empty = v == null ; if ( d && empty ) a . onComplete ( ) ; return ; if ( empty ) break ; a . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
lazySet ( DisposableHelper . DISPOSED ) ; parent . boundaryError ( this , t ) ; 
lazySet ( DisposableHelper . DISPOSED ) ; parent . openComplete ( this ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
DisposableHelper . setOnce ( this , d ) ; 
Disposable upstream = get ( ) ; if ( upstream != DisposableHelper . DISPOSED ) lazySet ( DisposableHelper . DISPOSED ) ; upstream . dispose ( ) ; parent . close ( this , index ) ; 
if ( get ( ) != DisposableHelper . DISPOSED ) lazySet ( DisposableHelper . DISPOSED ) ; parent . boundaryError ( this , t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( get ( ) != DisposableHelper . DISPOSED ) lazySet ( DisposableHelper . DISPOSED ) ; parent . close ( this , index ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
source . subscribe ( new SingleElementObserver < > ( t ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; T v = value ; value = null ; if ( v == null ) downstream . onComplete ( ) ; else downstream . onSuccess ( v ) ; 
PublishSubject < T > subject = PublishSubject . create ( ) ; ObservableSource < ? extends R > target ; try target = Objects . requireNonNull ( selector . apply ( subject ) , "The selector returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; TargetObserver < R > o = new TargetObserver < > ( observer ) ; target . subscribe ( o ) ; source . subscribe ( new SourceObserver < > ( subject , o ) ) ; 
DisposableHelper . setOnce ( target , d ) ; 
subject . onError ( e ) ; 
subject . onComplete ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
DisposableHelper . dispose ( this ) ; downstream . onError ( e ) ; 
DisposableHelper . dispose ( this ) ; downstream . onComplete ( ) ; 
upstream . dispose ( ) ; DisposableHelper . dispose ( this ) ; 
return upstream . isDisposed ( ) ; 
Collection < ? super K > collection ; try collection = ExceptionHelper . nullCheck ( collectionSupplier . get ( ) , "The collectionSupplier returned a null Collection." ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( new DistinctObserver < > ( observer , keySelector , collection ) ) ; 
if ( done ) RxJavaPlugins . onError ( e ) ; else done = true ; collection . clear ( ) ; downstream . onError ( e ) ; 
if ( ! done ) done = true ; collection . clear ( ) ; downstream . onComplete ( ) ; 
for ( ; ; ) T v = qd . poll ( ) ; if ( v == null || collection . add ( Objects . requireNonNull ( keySelector . apply ( v ) , "The keySelector returned a null key" ) ) ) return v ; 
collection . clear ( ) ; super . clear ( ) ; 
window . subscribe ( s ) ; once . set ( true ) ; 
return ! once . get ( ) && once . compareAndSet ( false , true ) ; 
S state ; try state = stateSupplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; GeneratorDisposable < T , S > gd = new GeneratorDisposable < > ( observer , generator , disposeState , state ) ; observer . onSubscribe ( gd ) ; gd . run ( ) ; 
S s = state ; if ( cancelled ) state = null ; dispose ( s ) ; return ; final BiFunction < S , ? super Emitter < T > , S > f = generator ; for ( ; ; ) if ( cancelled ) state = null ; dispose ( s ) ; return ; hasNext = false ; try s = f . apply ( s , this ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; state = null ; cancelled = true ; onError ( ex ) ; dispose ( s ) ; return ; if ( terminate ) cancelled = true ; state = null ; dispose ( s ) ; return ; 
cancelled = true ; 
return cancelled ; 
if ( terminate ) RxJavaPlugins . onError ( t ) ; else if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; terminate = true ; downstream . onError ( t ) ; 
if ( ! terminate ) terminate = true ; downstream . onComplete ( ) ; 
OnErrorNextObserver < T > parent = new OnErrorNextObserver < > ( t , nextSupplier ) ; t . onSubscribe ( parent . arbiter ) ; source . subscribe ( parent ) ; 
arbiter . replace ( d ) ; 
if ( once ) if ( done ) RxJavaPlugins . onError ( t ) ; return ; downstream . onError ( t ) ; return ; once = true ; ObservableSource < ? extends T > p ; try p = nextSupplier . apply ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; if ( p == null ) NullPointerException npe = new NullPointerException ( "Observable is null" ) ; npe . initCause ( t ) ; downstream . onError ( npe ) ; return ; p . subscribe ( this ) ; 
if ( done ) return ; done = true ; once = true ; downstream . onComplete ( ) ; 
IntervalRangeObserver is = new IntervalRangeObserver ( observer , start , end ) ; observer . onSubscribe ( is ) ; Scheduler sch = scheduler ; if ( sch instanceof TrampolineScheduler ) Worker worker = sch . createWorker ( ) ; is . setResource ( worker ) ; worker . schedulePeriodically ( is , initialDelay , period , unit ) ; else Disposable d = sch . schedulePeriodicallyDirect ( is , initialDelay , period , unit ) ; is . setResource ( d ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
if ( ! isDisposed ( ) ) long c = count ; downstream . onNext ( c ) ; if ( c == end ) if ( ! isDisposed ( ) ) downstream . onComplete ( ) ; DisposableHelper . dispose ( this ) ; return ; count = c + 1 ; 
DisposableHelper . setOnce ( this , d ) ; 
U u ; try u = Objects . requireNonNull ( initialSupplier . get ( ) , "The initialSupplier returned a null value" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , t ) ; return ; source . subscribe ( new CollectObserver < > ( t , u , collector ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onNext ( u ) ; downstream . onComplete ( ) ; 
if ( timespan == timeskip && maxSize == Integer . MAX_VALUE ) source . subscribe ( new BufferExactUnboundedObserver < > ( new SerializedObserver < > ( t ) , bufferSupplier , timespan , unit , scheduler ) ) ; return ; Scheduler . Worker w = scheduler . createWorker ( ) ; if ( timespan == timeskip ) source . subscribe ( new BufferExactBoundedObserver < > ( new SerializedObserver < > ( t ) , bufferSupplier , timespan , unit , maxSize , restartTimerOnMaxSize , w ) ) ; return ; source . subscribe ( new BufferSkipBoundedObserver < > ( new SerializedObserver < > ( t ) , bufferSupplier , timespan , timeskip , unit , w ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The buffer supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; dispose ( ) ; EmptyDisposable . error ( e , downstream ) ; return ; buffer = b ; downstream . onSubscribe ( this ) ; if ( ! DisposableHelper . isDisposed ( timer . get ( ) ) ) Disposable task = scheduler . schedulePeriodicallyDirect ( this , timespan , timespan , unit ) ; DisposableHelper . set ( timer , task ) ; 
synchronized ( this ) buffer = null ; downstream . onError ( t ) ; DisposableHelper . dispose ( timer ) ; 
U b ; synchronized ( this ) b = buffer ; buffer = null ; if ( b != null ) queue . offer ( b ) ; done = true ; if ( enter ( ) ) QueueDrainHelper . drainLoop ( queue , downstream , false , null , this ) ; DisposableHelper . dispose ( timer ) ; 
DisposableHelper . dispose ( timer ) ; upstream . dispose ( ) ; 
return timer . get ( ) == DisposableHelper . DISPOSED ; 
U next ; try next = Objects . requireNonNull ( bufferSupplier . get ( ) , "The bufferSupplier returned a null buffer" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; dispose ( ) ; return ; U current ; synchronized ( this ) current = buffer ; if ( current != null ) buffer = next ; if ( current == null ) DisposableHelper . dispose ( timer ) ; return ; fastPathEmit ( current , false , this ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; final U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The buffer supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; d . dispose ( ) ; EmptyDisposable . error ( e , downstream ) ; w . dispose ( ) ; return ; buffers . add ( b ) ; downstream . onSubscribe ( this ) ; w . schedulePeriodically ( this , timeskip , timeskip , unit ) ; w . schedule ( new RemoveFromBufferEmit ( b ) , timespan , unit ) ; 
done = true ; clear ( ) ; downstream . onError ( t ) ; w . dispose ( ) ; 
List < U > bs ; synchronized ( this ) bs = new ArrayList < > ( buffers ) ; buffers . clear ( ) ; for ( U b : bs ) queue . offer ( b ) ; done = true ; if ( enter ( ) ) QueueDrainHelper . drainLoop ( queue , downstream , false , w , this ) ; 
if ( ! cancelled ) cancelled = true ; clear ( ) ; upstream . dispose ( ) ; w . dispose ( ) ; 
return cancelled ; 
synchronized ( this ) buffers . clear ( ) ; 
if ( cancelled ) return ; final U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The bufferSupplier returned a null buffer" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; dispose ( ) ; return ; synchronized ( this ) if ( cancelled ) return ; buffers . add ( b ) ; w . schedule ( new RemoveFromBuffer ( b ) , timespan , unit ) ; 
synchronized ( BufferSkipBoundedObserver . this ) buffers . remove ( b ) ; fastPathOrderedEmit ( b , false , w ) ; 
synchronized ( BufferSkipBoundedObserver . this ) buffers . remove ( buffer ) ; fastPathOrderedEmit ( buffer , false , w ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The buffer supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; d . dispose ( ) ; EmptyDisposable . error ( e , downstream ) ; w . dispose ( ) ; return ; buffer = b ; downstream . onSubscribe ( this ) ; timer = w . schedulePeriodically ( this , timespan , timespan , unit ) ; 
synchronized ( this ) buffer = null ; downstream . onError ( t ) ; w . dispose ( ) ; 
w . dispose ( ) ; U b ; synchronized ( this ) b = buffer ; buffer = null ; if ( b != null ) queue . offer ( b ) ; done = true ; if ( enter ( ) ) QueueDrainHelper . drainLoop ( queue , downstream , false , this , this ) ; 
if ( ! cancelled ) cancelled = true ; upstream . dispose ( ) ; w . dispose ( ) ; synchronized ( this ) buffer = null ; 
return cancelled ; 
U next ; try next = Objects . requireNonNull ( bufferSupplier . get ( ) , "The bufferSupplier returned a null buffer" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; dispose ( ) ; downstream . onError ( e ) ; return ; U current ; synchronized ( this ) current = buffer ; if ( current == null || producerIndex != consumerIndex ) return ; buffer = next ; fastPathOrderedEmit ( current , false , this ) ; 
source . subscribe ( new BufferExactBoundaryObserver < > ( new SerializedObserver < > ( t ) , bufferSupplier , boundary ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The buffer supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; cancelled = true ; d . dispose ( ) ; EmptyDisposable . error ( e , downstream ) ; return ; buffer = b ; BufferBoundaryObserver < T , U , B > bs = new BufferBoundaryObserver < > ( this ) ; other = bs ; downstream . onSubscribe ( this ) ; if ( ! cancelled ) boundary . subscribe ( bs ) ; 
dispose ( ) ; downstream . onError ( t ) ; 
U b ; synchronized ( this ) b = buffer ; if ( b == null ) return ; buffer = null ; queue . offer ( b ) ; done = true ; if ( enter ( ) ) QueueDrainHelper . drainLoop ( queue , downstream , false , this , this ) ; 
if ( ! cancelled ) cancelled = true ; other . dispose ( ) ; upstream . dispose ( ) ; if ( enter ( ) ) queue . clear ( ) ; 
return cancelled ; 
U next ; try next = Objects . requireNonNull ( bufferSupplier . get ( ) , "The buffer supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; dispose ( ) ; downstream . onError ( e ) ; return ; U b ; synchronized ( this ) b = buffer ; if ( b == null ) return ; buffer = next ; fastPathEmit ( b , false , this ) ; 
parent . onError ( t ) ; 
parent . onComplete ( ) ; 
SerializedObserver < T > serial = new SerializedObserver < > ( t ) ; if ( emitLast ) source . subscribe ( new SampleMainEmitLast < > ( serial , other ) ) ; else source . subscribe ( new SampleMainNoLast < > ( serial , other ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; if ( other . get ( ) == null ) sampler . subscribe ( new SamplerObserver < > ( this ) ) ; 
DisposableHelper . dispose ( other ) ; downstream . onError ( t ) ; 
DisposableHelper . dispose ( other ) ; completion ( ) ; 
return DisposableHelper . setOnce ( other , o ) ; 
DisposableHelper . dispose ( other ) ; upstream . dispose ( ) ; 
return other . get ( ) == DisposableHelper . DISPOSED ; 
upstream . dispose ( ) ; downstream . onError ( e ) ; 
upstream . dispose ( ) ; completion ( ) ; 
T value = getAndSet ( null ) ; if ( value != null ) downstream . onNext ( value ) ; 
parent . setOther ( d ) ; 
parent . run ( ) ; 
parent . error ( t ) ; 
parent . complete ( ) ; 
downstream . onComplete ( ) ; 
emit ( ) ; 
done = true ; if ( wip . getAndIncrement ( ) == 0 ) emit ( ) ; downstream . onComplete ( ) ; 
if ( wip . getAndIncrement ( ) == 0 ) do boolean d = done ; emit ( ) ; if ( d ) downstream . onComplete ( ) ; return ; while ( wip . decrementAndGet ( ) != 0 ) ; 
BlockingObservableIterator < T > it = new BlockingObservableIterator < > ( bufferSize ) ; source . subscribe ( it ) ; return it ; 
for ( ; ; ) if ( isDisposed ( ) ) Throwable e = error ; if ( e != null ) throw ExceptionHelper . wrapOrThrow ( e ) ; return false ; boolean d = done ; boolean empty = queue . isEmpty ( ) ; if ( d ) Throwable e = error ; if ( e != null ) throw ExceptionHelper . wrapOrThrow ( e ) ; else if ( empty ) return false ; if ( empty ) try BlockingHelper . verifyNonBlocking ( ) ; lock . lock ( ) ; try while ( ! done && queue . isEmpty ( ) && ! isDisposed ( ) ) condition . await ( ) ; finally lock . unlock ( ) ; catch ( InterruptedException ex ) DisposableHelper . dispose ( this ) ; signalConsumer ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; else return true ; 
if ( hasNext ( ) ) return queue . poll ( ) ; throw new NoSuchElementException ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
error = t ; done = true ; signalConsumer ( ) ; 
done = true ; signalConsumer ( ) ; 
lock . lock ( ) ; try condition . signalAll ( ) ; finally lock . unlock ( ) ; 
throw new UnsupportedOperationException ( "remove" ) ; 
DisposableHelper . dispose ( this ) ; signalConsumer ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( delayErrors == ErrorMode . IMMEDIATE ) SerializedObserver < U > serial = new SerializedObserver < > ( observer ) ; source . subscribe ( new ConcatMapObserver < > ( serial , mapper , bufferSize , scheduler . createWorker ( ) ) ) ; else source . subscribe ( new ConcatMapDelayErrorObserver < > ( observer , mapper , bufferSize , delayErrors == ErrorMode . END , scheduler . createWorker ( ) ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < T > qd = ( QueueDisposable < T > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY ) ; if ( m == QueueDisposable . SYNC ) fusionMode = m ; queue = qd ; done = true ; downstream . onSubscribe ( this ) ; drain ( ) ; return ; if ( m == QueueDisposable . ASYNC ) fusionMode = m ; queue = qd ; downstream . onSubscribe ( this ) ; return ; queue = new SpscLinkedArrayQueue < > ( bufferSize ) ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; dispose ( ) ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; drain ( ) ; 
active = false ; drain ( ) ; 
return disposed ; 
disposed = true ; inner . dispose ( ) ; upstream . dispose ( ) ; worker . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; worker . schedule ( this ) ; 
for ( ; ; ) if ( disposed ) queue . clear ( ) ; return ; if ( ! active ) boolean d = done ; T t ; try t = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; dispose ( ) ; queue . clear ( ) ; downstream . onError ( ex ) ; worker . dispose ( ) ; return ; boolean empty = t == null ; if ( d && empty ) disposed = true ; downstream . onComplete ( ) ; worker . dispose ( ) ; return ; if ( ! empty ) ObservableSource < ? extends U > o ; try o = Objects . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; dispose ( ) ; queue . clear ( ) ; downstream . onError ( ex ) ; worker . dispose ( ) ; return ; active = true ; o . subscribe ( inner ) ; if ( decrementAndGet ( ) == 0 ) break ; 
DisposableHelper . replace ( this , d ) ; 
parent . dispose ( ) ; downstream . onError ( t ) ; 
parent . innerComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < T > qd = ( QueueDisposable < T > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY ) ; if ( m == QueueDisposable . SYNC ) sourceMode = m ; queue = qd ; done = true ; downstream . onSubscribe ( this ) ; drain ( ) ; return ; if ( m == QueueDisposable . ASYNC ) sourceMode = m ; queue = qd ; downstream . onSubscribe ( this ) ; return ; queue = new SpscLinkedArrayQueue < > ( bufferSize ) ; downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
return cancelled ; 
cancelled = true ; upstream . dispose ( ) ; observer . dispose ( ) ; worker . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; worker . schedule ( this ) ; 
Observer < ? super R > downstream = this . downstream ; SimpleQueue < T > queue = this . queue ; AtomicThrowable errors = this . errors ; for ( ; ; ) if ( ! active ) if ( cancelled ) queue . clear ( ) ; return ; if ( ! tillTheEnd ) Throwable ex = errors . get ( ) ; if ( ex != null ) queue . clear ( ) ; cancelled = true ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelled = true ; this . upstream . dispose ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; boolean empty = v == null ; if ( d && empty ) cancelled = true ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; if ( ! empty ) ObservableSource < ? extends R > o ; try o = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null ObservableSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelled = true ; this . upstream . dispose ( ) ; queue . clear ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; if ( o instanceof Supplier ) R w ; try w = ( ( Supplier < R > ) o ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; errors . tryAddThrowableOrReport ( ex ) ; continue ; if ( w != null && ! cancelled ) downstream . onNext ( w ) ; continue ; else active = true ; o . subscribe ( observer ) ; if ( decrementAndGet ( ) == 0 ) break ; 
DisposableHelper . replace ( this , d ) ; 
ConcatMapDelayErrorObserver < ? , R > p = parent ; if ( p . errors . tryAddThrowableOrReport ( e ) ) if ( ! p . tillTheEnd ) p . upstream . dispose ( ) ; p . active = false ; p . drain ( ) ; 
ConcatMapDelayErrorObserver < ? , R > p = parent ; p . active = false ; p . drain ( ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new FlatMapSingleObserver < > ( observer , mapper , delayErrors ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
active . decrementAndGet ( ) ; if ( errors . tryAddThrowableOrReport ( t ) ) if ( ! delayErrors ) set . dispose ( ) ; drain ( ) ; 
active . decrementAndGet ( ) ; drain ( ) ; 
cancelled = true ; upstream . dispose ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
return cancelled ; 
SpscLinkedArrayQueue < R > current = queue . get ( ) ; if ( current != null ) return current ; current = new SpscLinkedArrayQueue < > ( Observable . bufferSize ( ) ) ; if ( queue . compareAndSet ( null , current ) ) return current ; return queue . get ( ) ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
SpscLinkedArrayQueue < R > q = queue . get ( ) ; if ( q != null ) q . clear ( ) ; 
int missed = 1 ; Observer < ? super R > a = downstream ; AtomicInteger n = active ; AtomicReference < SpscLinkedArrayQueue < R > > qr = queue ; for ( ; ; ) for ( ; ; ) if ( cancelled ) clear ( ) ; return ; if ( ! delayErrors ) Throwable ex = errors . get ( ) ; if ( ex != null ) clear ( ) ; errors . tryTerminateConsumer ( a ) ; return ; boolean d = n . get ( ) == 0 ; SpscLinkedArrayQueue < R > q = qr . get ( ) ; R v = q != null ? q . poll ( ) : null ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( empty ) break ; a . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
innerError ( this , e ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . dispose ( this ) ; 
Iterator < U > it ; try it = Objects . requireNonNull ( other . iterator ( ) , "The iterator returned by other is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , t ) ; return ; boolean b ; try b = it . hasNext ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , t ) ; return ; if ( ! b ) EmptyDisposable . complete ( t ) ; return ; source . subscribe ( new ZipIterableObserver < T , U , V > ( t , it , zipper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
done = true ; upstream . dispose ( ) ; downstream . onError ( e ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
source . subscribe ( new DematerializeObserver < > ( observer , selector ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
final SerializedObserver < T > serial = new SerializedObserver < > ( child ) ; final ArrayCompositeDisposable frc = new ArrayCompositeDisposable ( 2 ) ; serial . onSubscribe ( frc ) ; final SkipUntilObserver < T > sus = new SkipUntilObserver < > ( serial , frc ) ; other . subscribe ( new SkipUntil ( frc , sus , serial ) ) ; source . subscribe ( sus ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; frc . setResource ( 0 , d ) ; 
frc . dispose ( ) ; downstream . onError ( t ) ; 
frc . dispose ( ) ; downstream . onComplete ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; frc . setResource ( 1 , d ) ; 
frc . dispose ( ) ; serial . onError ( t ) ; 
sus . notSkipping = true ; 
return RxJavaPlugins . onAssembly ( new MulticastReplay < > ( connectableFactory , selector ) ) ; 
return create ( source , DEFAULT_UNBOUNDED_FACTORY ) ; 
return source ; 
ReplayObserver < T > conn = current . get ( ) ; if ( conn != null && conn . isDisposed ( ) ) current . compareAndSet ( conn , null ) ; 
onSubscribe . subscribe ( observer ) ; 
boolean doConnect ; ReplayObserver < T > ps ; for ( ; ; ) ps = current . get ( ) ; if ( ps == null || ps . isDisposed ( ) ) ReplayBuffer < T > buf = bufferFactory . call ( ) ; ReplayObserver < T > u = new ReplayObserver < > ( buf , current ) ; if ( ! current . compareAndSet ( ps , u ) ) continue ; ps = u ; doConnect = ! ps . shouldConnect . get ( ) && ps . shouldConnect . compareAndSet ( false , true ) ; break ; try connection . accept ( ps ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( doConnect ) ps . shouldConnect . compareAndSet ( true , false ) ; Exceptions . throwIfFatal ( ex ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; if ( doConnect ) source . subscribe ( ps ) ; 
return observers . get ( ) == TERMINATED ; 
observers . set ( TERMINATED ) ; current . compareAndSet ( ReplayObserver . this , null ) ; DisposableHelper . dispose ( this ) ; 
if ( DisposableHelper . setOnce ( this , p ) ) replay ( ) ; 
if ( ! done ) done = true ; buffer . error ( e ) ; replayFinal ( ) ; else RxJavaPlugins . onError ( e ) ; 
if ( ! done ) done = true ; buffer . complete ( ) ; replayFinal ( ) ; 
@ SuppressWarnings ( "unchecked" ) InnerDisposable < T > [ ] a = observers . get ( ) ; for ( InnerDisposable < T > rp : a ) buffer . replay ( rp ) ; 
@ SuppressWarnings ( "unchecked" ) InnerDisposable < T > [ ] a = observers . getAndSet ( TERMINATED ) ; for ( InnerDisposable < T > rp : a ) buffer . replay ( rp ) ; 
return cancelled ; 
if ( ! cancelled ) cancelled = true ; parent . remove ( this ) ; index = null ; 
return ( U ) index ; 
add ( NotificationLite . error ( e ) ) ; size ++ ; 
add ( NotificationLite . complete ( ) ) ; size ++ ; 
Node head = get ( ) ; Node next = head . get ( ) ; size -- ; setFirst ( next ) ; 
Node head = get ( ) ; if ( head . value != null ) Node n = new Node ( null ) ; n . lazySet ( head . get ( ) ) ; set ( n ) ; 
Object o = enterTransform ( NotificationLite . error ( e ) ) ; Node n = new Node ( o ) ; addLast ( n ) ; truncateFinal ( ) ; 
Object o = enterTransform ( NotificationLite . complete ( ) ) ; Node n = new Node ( o ) ; addLast ( n ) ; truncateFinal ( ) ; 
return value ; 
return value ; 
trimHead ( ) ; 
Node n = getHead ( ) ; for ( ; ; ) Node next = n . get ( ) ; if ( next != null ) Object o = next . value ; Object v = leaveTransform ( o ) ; if ( NotificationLite . isComplete ( v ) || NotificationLite . isError ( v ) ) break ; output . add ( NotificationLite . < T > getValue ( v ) ) ; n = next ; else break ; 
return tail . value != null && NotificationLite . isError ( leaveTransform ( tail . value ) ) ; 
return tail . value != null && NotificationLite . isComplete ( leaveTransform ( tail . value ) ) ; 
return get ( ) ; 
if ( size > limit ) removeFirst ( ) ; 
return new Timed < > ( value , scheduler . now ( unit ) , unit ) ; 
return ( ( Timed < ? > ) value ) . value ( ) ; 
long timeLimit = scheduler . now ( unit ) - maxAge ; Node prev = get ( ) ; Node next = prev . get ( ) ; int e = 0 ; for ( ; ; ) if ( size > 1 ) if ( size > limit ) e ++ ; size -- ; prev = next ; next = next . get ( ) ; else Timed < ? > v = ( Timed < ? > ) next . value ; if ( v . time ( ) <= timeLimit ) e ++ ; size -- ; prev = next ; next = next . get ( ) ; else break ; else break ; if ( e != 0 ) setFirst ( prev ) ; 
long timeLimit = scheduler . now ( unit ) - maxAge ; Node prev = get ( ) ; Node next = prev . get ( ) ; int e = 0 ; for ( ; ; ) if ( size > 1 ) Timed < ? > v = ( Timed < ? > ) next . value ; if ( v . time ( ) <= timeLimit ) e ++ ; size -- ; prev = next ; next = next . get ( ) ; else break ; else break ; if ( e != 0 ) setFirst ( prev ) ; 
long timeLimit = scheduler . now ( unit ) - maxAge ; Node prev = get ( ) ; Node next = prev . get ( ) ; for ( ; ; ) if ( next == null ) break ; Timed < ? > v = ( Timed < ? > ) next . value ; if ( NotificationLite . isComplete ( v . value ( ) ) || NotificationLite . isError ( v . value ( ) ) ) break ; if ( v . time ( ) <= timeLimit ) prev = next ; next = next . get ( ) ; else break ; return prev ; 
return new UnboundedReplayBuffer < > ( 16 ) ; 
srw . setResource ( r ) ; 
return new SizeBoundReplayBuffer < > ( bufferSize , eagerTruncate ) ; 
return new SizeAndTimeBoundReplayBuffer < > ( bufferSize , maxAge , unit , scheduler , eagerTruncate ) ; 
for ( ; ; ) ReplayObserver < T > r = curr . get ( ) ; if ( r == null ) ReplayBuffer < T > buf = bufferFactory . call ( ) ; ReplayObserver < T > u = new ReplayObserver < > ( buf , curr ) ; if ( ! curr . compareAndSet ( null , u ) ) continue ; r = u ; InnerDisposable < T > inner = new InnerDisposable < > ( r , child ) ; child . onSubscribe ( inner ) ; r . add ( inner ) ; if ( inner . isDisposed ( ) ) r . remove ( inner ) ; return ; r . buffer . replay ( inner ) ; break ; 
ConnectableObservable < U > co ; ObservableSource < R > observable ; try co = Objects . requireNonNull ( connectableFactory . get ( ) , "The connectableFactory returned a null ConnectableObservable" ) ; observable = Objects . requireNonNull ( selector . apply ( co ) , "The selector returned a null ObservableSource" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , child ) ; return ; final ObserverResourceWrapper < R > srw = new ObserverResourceWrapper < > ( child ) ; observable . subscribe ( srw ) ; co . connect ( new DisposeConsumer < > ( srw ) ) ; 
D resource ; try resource = resourceSupplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; ObservableSource < ? extends T > source ; try source = Objects . requireNonNull ( sourceSupplier . apply ( resource ) , "The sourceSupplier returned a null ObservableSource" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; try disposer . accept ( resource ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( new CompositeException ( e , ex ) , observer ) ; return ; EmptyDisposable . error ( e , observer ) ; return ; UsingObserver < T , D > us = new UsingObserver < > ( observer , resource , disposer , eager ) ; source . subscribe ( us ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( eager ) if ( compareAndSet ( false , true ) ) try disposer . accept ( resource ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; t = new CompositeException ( t , e ) ; downstream . onError ( t ) ; else downstream . onError ( t ) ; disposeResource ( ) ; 
if ( eager ) if ( compareAndSet ( false , true ) ) try disposer . accept ( resource ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; downstream . onComplete ( ) ; else downstream . onComplete ( ) ; disposeResource ( ) ; 
if ( eager ) disposeResource ( ) ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; else upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; disposeResource ( ) ; 
return get ( ) ; 
if ( compareAndSet ( false , true ) ) try disposer . accept ( resource ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
source . subscribe ( new TakeObserver < > ( observer , limit ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) upstream = d ; if ( remaining == 0 ) done = true ; d . dispose ( ) ; EmptyDisposable . complete ( downstream ) ; else downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; upstream . dispose ( ) ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; upstream . dispose ( ) ; downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
DeferredScalarDisposable < T > d = new DeferredScalarDisposable < > ( observer ) ; observer . onSubscribe ( d ) ; if ( d . isDisposed ( ) ) return ; T value ; try value = ExceptionHelper . nullCheck ( supplier . get ( ) , "Supplier returned a null value." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; if ( ! d . isDisposed ( ) ) observer . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; return ; d . complete ( value ) ; 
return ExceptionHelper . nullCheck ( supplier . get ( ) , "The supplier returned a null value." ) ; 
source . subscribe ( new ConcatWithObserver < > ( observer , other ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) && ! inCompletable ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
if ( inCompletable ) downstream . onComplete ( ) ; else inCompletable = true ; DisposableHelper . replace ( this , null ) ; CompletableSource cs = other ; other = null ; cs . subscribe ( this ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
CreateEmitter < T > parent = new CreateEmitter < > ( observer ) ; observer . onSubscribe ( parent ) ; try source . subscribe ( parent ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; parent . onError ( ex ) ; 
if ( ! tryOnError ( t ) ) RxJavaPlugins . onError ( t ) ; 
if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; if ( ! isDisposed ( ) ) try observer . onError ( t ) ; finally dispose ( ) ; return true ; return false ; 
if ( ! isDisposed ( ) ) try observer . onComplete ( ) ; finally dispose ( ) ; 
DisposableHelper . set ( this , d ) ; 
setDisposable ( new CancellableDisposable ( c ) ) ; 
return new SerializedEmitter < > ( this ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
return String . format ( "%s{%s}" , getClass ( ) . getSimpleName ( ) , super . toString ( ) ) ; 
if ( ! tryOnError ( t ) ) RxJavaPlugins . onError ( t ) ; 
if ( done || emitter . isDisposed ( ) ) return false ; if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; if ( errors . tryAddThrowable ( t ) ) done = true ; drain ( ) ; return true ; return false ; 
if ( done || emitter . isDisposed ( ) ) return ; done = true ; drain ( ) ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
ObservableEmitter < T > e = emitter ; SpscLinkedArrayQueue < T > q = queue ; AtomicThrowable errors = this . errors ; int missed = 1 ; for ( ; ; ) for ( ; ; ) if ( e . isDisposed ( ) ) q . clear ( ) ; return ; if ( errors . get ( ) != null ) q . clear ( ) ; errors . tryTerminateConsumer ( e ) ; return ; boolean d = done ; T v = q . poll ( ) ; boolean empty = v == null ; if ( d && empty ) e . onComplete ( ) ; return ; if ( empty ) break ; e . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
emitter . setDisposable ( d ) ; 
emitter . setCancellable ( c ) ; 
return emitter . isDisposed ( ) ; 
return this ; 
return emitter . toString ( ) ; 
source . subscribe ( child ) ; if ( clients . incrementAndGet ( ) == numberOfObservers ) source . connect ( connection ) ; 
source . subscribe ( new SkipLastTimedObserver < > ( t , time , unit , scheduler , bufferSize , delayError ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
return cancelled ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final Observer < ? super T > a = downstream ; final SpscLinkedArrayQueue < Object > q = queue ; final boolean delayError = this . delayError ; final TimeUnit unit = this . unit ; final Scheduler scheduler = this . scheduler ; final long time = this . time ; for ( ; ; ) for ( ; ; ) if ( cancelled ) queue . clear ( ) ; return ; boolean d = done ; Long ts = ( Long ) q . peek ( ) ; boolean empty = ts == null ; long now = scheduler . now ( unit ) ; if ( ! empty && ts > now - time ) empty = true ; if ( d ) if ( delayError ) if ( empty ) Throwable e = error ; if ( e != null ) a . onError ( e ) ; else a . onComplete ( ) ; return ; else Throwable e = error ; if ( e != null ) queue . clear ( ) ; a . onError ( e ) ; return ; else if ( empty ) a . onComplete ( ) ; return ; if ( empty ) break ; q . poll ( ) ; @ SuppressWarnings ( "unchecked" ) T v = ( T ) q . poll ( ) ; a . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
R seed ; try seed = Objects . requireNonNull ( seedSupplier . get ( ) , "The seedSupplier returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( new ReduceSeedObserver < > ( observer , reducer , seed ) ) ; 
source . subscribe ( new AnyObserver < > ( t , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onNext ( false ) ; downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new SkipObserver < > ( observer , n ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new ConcatWithObserver < > ( observer , other ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) && ! inMaybe ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
if ( inMaybe ) downstream . onComplete ( ) ; else inMaybe = true ; DisposableHelper . replace ( this , null ) ; MaybeSource < ? extends T > ms = other ; other = null ; ms . subscribe ( this ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
source . subscribe ( new FlattenIterableObserver < > ( observer , mapper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( upstream == DisposableHelper . DISPOSED ) RxJavaPlugins . onError ( e ) ; return ; upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
if ( upstream == DisposableHelper . DISPOSED ) return ; upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; 
return upstream . isDisposed ( ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
source . subscribe ( new TakeLastOneObserver < > ( observer ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
value = null ; downstream . onError ( t ) ; 
emit ( ) ; 
T v = value ; if ( v != null ) value = null ; downstream . onNext ( v ) ; downstream . onComplete ( ) ; 
value = null ; upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
EqualCoordinator < T > ec = new EqualCoordinator < > ( observer , bufferSize , first , second , comparer ) ; observer . onSubscribe ( ec ) ; ec . subscribe ( ) ; 
EqualObserver < T > [ ] as = observers ; first . subscribe ( as [ 0 ] ) ; second . subscribe ( as [ 1 ] ) ; 
if ( ! cancelled ) cancelled = true ; resources . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) EqualObserver < T > [ ] as = observers ; as [ 0 ] . queue . clear ( ) ; as [ 1 ] . queue . clear ( ) ; 
return cancelled ; 
cancelled = true ; q1 . clear ( ) ; q2 . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; EqualObserver < T > [ ] as = observers ; final EqualObserver < T > observer1 = as [ 0 ] ; final SpscLinkedArrayQueue < T > q1 = observer1 . queue ; final EqualObserver < T > observer2 = as [ 1 ] ; final SpscLinkedArrayQueue < T > q2 = observer2 . queue ; for ( ; ; ) for ( ; ; ) if ( cancelled ) q1 . clear ( ) ; q2 . clear ( ) ; return ; boolean d1 = observer1 . done ; if ( d1 ) Throwable e = observer1 . error ; if ( e != null ) cancel ( q1 , q2 ) ; downstream . onError ( e ) ; return ; boolean d2 = observer2 . done ; if ( d2 ) Throwable e = observer2 . error ; if ( e != null ) cancel ( q1 , q2 ) ; downstream . onError ( e ) ; return ; if ( v1 == null ) v1 = q1 . poll ( ) ; boolean e1 = v1 == null ; if ( v2 == null ) v2 = q2 . poll ( ) ; boolean e2 = v2 == null ; if ( d1 && d2 && e1 && e2 ) downstream . onNext ( true ) ; downstream . onComplete ( ) ; return ; if ( ( d1 && d2 ) && ( e1 != e2 ) ) cancel ( q1 , q2 ) ; downstream . onNext ( false ) ; downstream . onComplete ( ) ; return ; if ( ! e1 && ! e2 ) boolean c ; try c = comparer . test ( v1 , v2 ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancel ( q1 , q2 ) ; downstream . onError ( ex ) ; return ; if ( ! c ) cancel ( q1 , q2 ) ; downstream . onNext ( false ) ; downstream . onComplete ( ) ; return ; v1 = null ; v2 = null ; if ( e1 || e2 ) break ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
parent . setDisposable ( d , index ) ; 
error = t ; done = true ; parent . drain ( ) ; 
done = true ; parent . drain ( ) ; 
if ( other == null ) TimeoutObserver < T > parent = new TimeoutObserver < > ( observer , itemTimeoutIndicator ) ; observer . onSubscribe ( parent ) ; parent . startFirstTimeout ( firstTimeoutIndicator ) ; source . subscribe ( parent ) ; else TimeoutFallbackObserver < T > parent = new TimeoutFallbackObserver < > ( observer , itemTimeoutIndicator , other ) ; observer . onSubscribe ( parent ) ; parent . startFirstTimeout ( firstTimeoutIndicator ) ; source . subscribe ( parent ) ; 
DisposableHelper . setOnce ( upstream , d ) ; 
if ( firstTimeoutIndicator != null ) TimeoutConsumer consumer = new TimeoutConsumer ( 0L , this ) ; if ( task . replace ( consumer ) ) firstTimeoutIndicator . subscribe ( consumer ) ; 
if ( getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onComplete ( ) ; 
DisposableHelper . dispose ( upstream ) ; task . dispose ( ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
DisposableHelper . setOnce ( upstream , d ) ; 
if ( firstTimeoutIndicator != null ) TimeoutConsumer consumer = new TimeoutConsumer ( 0L , this ) ; if ( task . replace ( consumer ) ) firstTimeoutIndicator . subscribe ( consumer ) ; 
if ( index . getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onError ( t ) ; task . dispose ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( index . getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onComplete ( ) ; task . dispose ( ) ; 
DisposableHelper . dispose ( upstream ) ; DisposableHelper . dispose ( this ) ; task . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
Disposable upstream = get ( ) ; if ( upstream != DisposableHelper . DISPOSED ) upstream . dispose ( ) ; lazySet ( DisposableHelper . DISPOSED ) ; parent . onTimeout ( idx ) ; 
if ( get ( ) != DisposableHelper . DISPOSED ) lazySet ( DisposableHelper . DISPOSED ) ; parent . onTimeoutError ( idx , t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( get ( ) != DisposableHelper . DISPOSED ) lazySet ( DisposableHelper . DISPOSED ) ; parent . onTimeout ( idx ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( this . get ( ) ) ; 
return source ; 
final BlockingQueue < Object > queue = new LinkedBlockingQueue < > ( ) ; BlockingObserver < T > bs = new BlockingObserver < > ( queue ) ; observer . onSubscribe ( bs ) ; o . subscribe ( bs ) ; for ( ; ; ) if ( bs . isDisposed ( ) ) break ; Object v = queue . poll ( ) ; if ( v == null ) try v = queue . take ( ) ; catch ( InterruptedException ex ) bs . dispose ( ) ; observer . onError ( ex ) ; return ; if ( bs . isDisposed ( ) || v == BlockingObserver . TERMINATED || NotificationLite . acceptFull ( v , observer ) ) break ; 
BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver ( ) ; LambdaObserver < T > ls = new LambdaObserver < > ( Functions . emptyConsumer ( ) , callback , callback , Functions . emptyConsumer ( ) ) ; o . subscribe ( ls ) ; BlockingHelper . awaitForComplete ( callback , ls ) ; Throwable e = callback . error ; if ( e != null ) throw ExceptionHelper . wrapOrThrow ( e ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; subscribe ( o , new LambdaObserver < T > ( onNext , onError , onComplete , Functions . emptyConsumer ( ) ) ) ; 
source . subscribe ( new ElementAtObserver < > ( t , index , defaultValue ) ) ; 
return RxJavaPlugins . onAssembly ( new ObservableElementAt < > ( source , index , defaultValue , true ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; T v = defaultValue ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onError ( new NoSuchElementException ( ) ) ; 
source . subscribe ( new ThrottleLatestObserver < > ( observer , timeout , unit , scheduler . createWorker ( ) , emitLast ) ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) upstream = d ; downstream . onSubscribe ( this ) ; 
error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
cancelled = true ; upstream . dispose ( ) ; worker . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) latest . lazySet ( null ) ; 
return cancelled ; 
timerFired = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; AtomicReference < T > latest = this . latest ; Observer < ? super T > downstream = this . downstream ; for ( ; ; ) for ( ; ; ) if ( cancelled ) latest . lazySet ( null ) ; return ; boolean d = done ; if ( d && error != null ) latest . lazySet ( null ) ; downstream . onError ( error ) ; worker . dispose ( ) ; return ; T v = latest . get ( ) ; boolean empty = v == null ; if ( d ) v = latest . getAndSet ( null ) ; if ( ! empty && emitLast ) downstream . onNext ( v ) ; downstream . onComplete ( ) ; worker . dispose ( ) ; return ; if ( empty ) if ( timerFired ) timerRunning = false ; timerFired = false ; break ; if ( ! timerRunning || timerFired ) v = latest . getAndSet ( null ) ; downstream . onNext ( v ) ; timerFired = false ; timerRunning = true ; worker . schedule ( this , timeout , unit ) ; else break ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
source . subscribe ( new ReduceObserver < > ( observer , reducer ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( e ) ; return ; done = true ; value = null ; downstream . onError ( e ) ; 
if ( done ) return ; done = true ; T v = value ; value = null ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
EmptyDisposable . complete ( o ) ; 
return null ; 
source . subscribe ( new DistinctUntilChangedObserver < > ( observer , keySelector , comparer ) ) ; 
for ( ; ; ) T v = qd . poll ( ) ; if ( v == null ) return null ; K key = keySelector . apply ( v ) ; if ( ! hasValue ) hasValue = true ; last = key ; return v ; if ( ! comparer . test ( last , key ) ) last = key ; return v ; last = key ; 
if ( timespan == timeskip ) if ( maxSize == Long . MAX_VALUE ) source . subscribe ( new WindowExactUnboundedObserver < > ( downstream , timespan , unit , scheduler , bufferSize ) ) ; return ; source . subscribe ( new WindowExactBoundedObserver < > ( downstream , timespan , unit , scheduler , bufferSize , maxSize , restartTimerOnMaxSize ) ) ; return ; source . subscribe ( new WindowSkipObserver < > ( downstream , timespan , timeskip , unit , scheduler . createWorker ( ) , bufferSize ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; createFirstWindow ( ) ; 
error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( downstreamCancelled . compareAndSet ( false , true ) ) windowDone ( ) ; 
return downstreamCancelled . get ( ) ; 
if ( windowCount . decrementAndGet ( ) == 0 ) cleanupResources ( ) ; upstream . dispose ( ) ; upstreamCancelled = true ; drain ( ) ; 
if ( ! downstreamCancelled . get ( ) ) windowCount . getAndIncrement ( ) ; window = UnicastSubject . create ( bufferSize , windowRunnable ) ; emitted = 1 ; ObservableWindowSubscribeIntercept < T > intercept = new ObservableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; timer . replace ( scheduler . schedulePeriodicallyDirect ( this , timespan , timespan , unit ) ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; 
queue . offer ( NEXT_WINDOW ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; final SimplePlainQueue < Object > queue = this . queue ; final Observer < ? super Observable < T > > downstream = this . downstream ; UnicastSubject < T > window = this . window ; int missed = 1 ; for ( ; ; ) if ( upstreamCancelled ) queue . clear ( ) ; window = null ; this . window = null ; else boolean isDone = done ; Object o = queue . poll ( ) ; boolean isEmpty = o == null ; if ( isDone && isEmpty ) Throwable ex = error ; if ( ex != null ) if ( window != null ) window . onError ( ex ) ; downstream . onError ( ex ) ; else if ( window != null ) window . onComplete ( ) ; downstream . onComplete ( ) ; cleanupResources ( ) ; upstreamCancelled = true ; continue ; else if ( ! isEmpty ) if ( o == NEXT_WINDOW ) if ( window != null ) window . onComplete ( ) ; window = null ; this . window = null ; if ( downstreamCancelled . get ( ) ) timer . dispose ( ) ; else emitted ++ ; windowCount . getAndIncrement ( ) ; window = UnicastSubject . create ( bufferSize , windowRunnable ) ; this . window = window ; ObservableWindowSubscribeIntercept < T > intercept = new ObservableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; else if ( window != null ) @ SuppressWarnings ( "unchecked" ) T item = ( T ) o ; window . onNext ( item ) ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
timer . dispose ( ) ; 
windowDone ( ) ; 
if ( ! downstreamCancelled . get ( ) ) emitted = 1 ; windowCount . getAndIncrement ( ) ; window = UnicastSubject . create ( bufferSize , this ) ; ObservableWindowSubscribeIntercept < T > intercept = new ObservableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; Runnable boundaryTask = new WindowBoundaryRunnable ( this , 1L ) ; if ( restartTimerOnMaxSize ) timer . replace ( worker . schedulePeriodically ( boundaryTask , timespan , timespan , unit ) ) ; else timer . replace ( scheduler . schedulePeriodicallyDirect ( boundaryTask , timespan , timespan , unit ) ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; 
windowDone ( ) ; 
timer . dispose ( ) ; Worker w = worker ; if ( w != null ) w . dispose ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final SimplePlainQueue < Object > queue = this . queue ; final Observer < ? super Observable < T > > downstream = this . downstream ; UnicastSubject < T > window = this . window ; for ( ; ; ) if ( upstreamCancelled ) queue . clear ( ) ; window = null ; this . window = null ; else boolean isDone = done ; Object o = queue . poll ( ) ; boolean isEmpty = o == null ; if ( isDone && isEmpty ) Throwable ex = error ; if ( ex != null ) if ( window != null ) window . onError ( ex ) ; downstream . onError ( ex ) ; else if ( window != null ) window . onComplete ( ) ; downstream . onComplete ( ) ; cleanupResources ( ) ; upstreamCancelled = true ; continue ; else if ( ! isEmpty ) if ( o instanceof WindowBoundaryRunnable ) WindowBoundaryRunnable boundary = ( WindowBoundaryRunnable ) o ; if ( boundary . index == emitted || ! restartTimerOnMaxSize ) this . count = 0 ; window = createNewWindow ( window ) ; else if ( window != null ) @ SuppressWarnings ( "unchecked" ) T item = ( T ) o ; window . onNext ( item ) ; long count = this . count + 1 ; if ( count == maxSize ) this . count = 0 ; window = createNewWindow ( window ) ; else this . count = count ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( window != null ) window . onComplete ( ) ; window = null ; if ( downstreamCancelled . get ( ) ) cleanupResources ( ) ; else long emitted = this . emitted ; this . emitted = ++ emitted ; windowCount . getAndIncrement ( ) ; window = UnicastSubject . create ( bufferSize , this ) ; this . window = window ; ObservableWindowSubscribeIntercept < T > intercept = new ObservableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; if ( restartTimerOnMaxSize ) timer . update ( worker . schedulePeriodically ( new WindowBoundaryRunnable ( this , emitted ) , timespan , timespan , unit ) ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; return window ; 
parent . boundary ( this ) ; 
if ( ! downstreamCancelled . get ( ) ) emitted = 1 ; windowCount . getAndIncrement ( ) ; UnicastSubject < T > window = UnicastSubject . create ( bufferSize , this ) ; windows . add ( window ) ; ObservableWindowSubscribeIntercept < T > intercept = new ObservableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; worker . schedule ( new WindowBoundaryRunnable ( this , false ) , timespan , unit ) ; worker . schedulePeriodically ( new WindowBoundaryRunnable ( this , true ) , timeskip , timeskip , unit ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; windows . remove ( window ) ; 
worker . dispose ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final SimplePlainQueue < Object > queue = this . queue ; final Observer < ? super Observable < T > > downstream = this . downstream ; final List < UnicastSubject < T > > windows = this . windows ; for ( ; ; ) if ( upstreamCancelled ) queue . clear ( ) ; windows . clear ( ) ; else boolean isDone = done ; Object o = queue . poll ( ) ; boolean isEmpty = o == null ; if ( isDone && isEmpty ) Throwable ex = error ; if ( ex != null ) for ( UnicastSubject < T > window : windows ) window . onError ( ex ) ; downstream . onError ( ex ) ; else for ( UnicastSubject < T > window : windows ) window . onComplete ( ) ; downstream . onComplete ( ) ; cleanupResources ( ) ; upstreamCancelled = true ; continue ; else if ( ! isEmpty ) if ( o == WINDOW_OPEN ) if ( ! downstreamCancelled . get ( ) ) long emitted = this . emitted ; this . emitted = ++ emitted ; windowCount . getAndIncrement ( ) ; UnicastSubject < T > window = UnicastSubject . create ( bufferSize , this ) ; windows . add ( window ) ; ObservableWindowSubscribeIntercept < T > intercept = new ObservableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; worker . schedule ( new WindowBoundaryRunnable ( this , false ) , timespan , unit ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; else if ( o == WINDOW_CLOSE ) if ( ! windows . isEmpty ( ) ) windows . remove ( 0 ) . onComplete ( ) ; else @ SuppressWarnings ( "unchecked" ) T item = ( T ) o ; for ( UnicastSubject < T > window : windows ) window . onNext ( item ) ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
windowDone ( ) ; 
parent . boundary ( isOpen ) ; 
return source . parallelism ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onComplete ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onComplete ( ) ; 
return parallelism ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY | QueueSubscription . BOUNDARY ) ; if ( m == QueueSubscription . SYNC ) sourceMode = m ; queue = qs ; done = true ; setupSubscribers ( ) ; drain ( ) ; return ; else if ( m == QueueSubscription . ASYNC ) sourceMode = m ; queue = qs ; setupSubscribers ( ) ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; setupSubscribers ( ) ; s . request ( prefetch ) ; 
Subscriber < ? super T > [ ] subs = subscribers ; final int m = subs . length ; for ( int i = 0 ; i < m ; i ++ ) subscriberCount . lazySet ( i + 1 ) ; subs [ i ] . onSubscribe ( new RailSubscription ( i , m ) ) ; 
if ( requests . compareAndSet ( m + j , 0L , 1L ) ) ParallelDispatcher . this . cancel ( m + m ) ; 
error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
int missed = 1 ; SimpleQueue < T > q = queue ; Subscriber < ? super T > [ ] a = this . subscribers ; AtomicLongArray r = this . requests ; long [ ] e = this . emissions ; int n = e . length ; int idx = index ; int consumed = produced ; for ( ; ; ) int notReady = 0 ; for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; boolean d = done ; if ( d ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; for ( Subscriber < ? super T > s : a ) s . onError ( ex ) ; return ; boolean empty = q . isEmpty ( ) ; if ( d && empty ) for ( Subscriber < ? super T > s : a ) s . onComplete ( ) ; return ; if ( empty ) break ; long requestAtIndex = r . get ( idx ) ; long emissionAtIndex = e [ idx ] ; if ( requestAtIndex != emissionAtIndex && r . get ( n + idx ) == 0 ) T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; for ( Subscriber < ? super T > s : a ) s . onError ( ex ) ; return ; if ( v == null ) break ; a [ idx ] . onNext ( v ) ; e [ idx ] = emissionAtIndex + 1 ; int c = ++ consumed ; if ( c == limit ) consumed = 0 ; upstream . request ( c ) ; notReady = 0 ; else notReady ++ ; idx ++ ; if ( idx == n ) idx = 0 ; if ( notReady == n ) break ; int w = get ( ) ; if ( w == missed ) index = idx ; produced = consumed ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; else missed = w ; 
int missed = 1 ; SimpleQueue < T > q = queue ; Subscriber < ? super T > [ ] a = this . subscribers ; AtomicLongArray r = this . requests ; long [ ] e = this . emissions ; int n = e . length ; int idx = index ; for ( ; ; ) int notReady = 0 ; for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; boolean empty = q . isEmpty ( ) ; if ( empty ) for ( Subscriber < ? super T > s : a ) s . onComplete ( ) ; return ; long requestAtIndex = r . get ( idx ) ; long emissionAtIndex = e [ idx ] ; if ( requestAtIndex != emissionAtIndex && r . get ( n + idx ) == 0 ) T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; for ( Subscriber < ? super T > s : a ) s . onError ( ex ) ; return ; if ( v == null ) for ( Subscriber < ? super T > s : a ) s . onComplete ( ) ; return ; a [ idx ] . onNext ( v ) ; e [ idx ] = emissionAtIndex + 1 ; notReady = 0 ; else notReady ++ ; idx ++ ; if ( idx == n ) idx = 0 ; if ( notReady == n ) break ; int w = get ( ) ; if ( w == missed ) index = idx ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; else missed = w ; 
if ( getAndIncrement ( ) != 0 ) return ; if ( sourceMode == QueueSubscription . SYNC ) drainSync ( ) ; else drainAsync ( ) ; 
return source . parallelism ( ) ; 
try parent . onCancel . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; try parent . onSubscribe . accept ( s ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; s . cancel ( ) ; downstream . onSubscribe ( EmptySubscription . INSTANCE ) ; onError ( ex ) ; return ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; try parent . onError . accept ( t ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; t = new CompositeException ( t , ex ) ; downstream . onError ( t ) ; try parent . onAfterTerminated . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
if ( ! done ) done = true ; try parent . onComplete . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; downstream . onComplete ( ) ; try parent . onAfterTerminated . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
return source . parallelism ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
return source . parallelism ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; collection = null ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; C c = collection ; collection = null ; complete ( c ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
return source . parallelism ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onComplete ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onComplete ( ) ; 
return source . parallelism ( ) ; 
SortedJoinSubscription < T > parent = new SortedJoinSubscription < > ( s , source . parallelism ( ) , comparator ) ; s . onSubscribe ( parent ) ; source . subscribe ( parent . subscribers ) ; 
if ( ! cancelled ) cancelled = true ; cancelAll ( ) ; if ( getAndIncrement ( ) == 0 ) Arrays . fill ( lists , null ) ; 
for ( SortedJoinInnerSubscriber < T > s : subscribers ) s . cancel ( ) ; 
if ( error . compareAndSet ( null , e ) ) drain ( ) ; else if ( e != error . get ( ) ) RxJavaPlugins . onError ( e ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super T > a = downstream ; List < T > [ ] lists = this . lists ; int [ ] indexes = this . indexes ; int n = indexes . length ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) if ( cancelled ) Arrays . fill ( lists , null ) ; return ; Throwable ex = error . get ( ) ; if ( ex != null ) cancelAll ( ) ; Arrays . fill ( lists , null ) ; a . onError ( ex ) ; return ; T min = null ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) List < T > list = lists [ i ] ; int index = indexes [ i ] ; if ( list . size ( ) != index ) if ( min == null ) min = list . get ( index ) ; minIndex = i ; else T b = list . get ( index ) ; boolean smaller ; try smaller = comparator . compare ( min , b ) > 0 ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; cancelAll ( ) ; Arrays . fill ( lists , null ) ; if ( ! error . compareAndSet ( null , exc ) ) RxJavaPlugins . onError ( exc ) ; a . onError ( error . get ( ) ) ; return ; if ( smaller ) min = b ; minIndex = i ; if ( min == null ) Arrays . fill ( lists , null ) ; a . onComplete ( ) ; return ; a . onNext ( min ) ; indexes [ minIndex ] ++ ; e ++ ; if ( cancelled ) Arrays . fill ( lists , null ) ; return ; Throwable ex = error . get ( ) ; if ( ex != null ) cancelAll ( ) ; Arrays . fill ( lists , null ) ; a . onError ( ex ) ; return ; boolean empty = true ; for ( int i = 0 ; i < n ; i ++ ) if ( indexes [ i ] != lists [ i ] . size ( ) ) empty = false ; break ; if ( empty ) Arrays . fill ( lists , null ) ; a . onComplete ( ) ; return ; if ( e != 0 ) BackpressureHelper . produced ( requested , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
parent . innerNext ( t , index ) ; 
parent . innerError ( t ) ; 
$EMPTY$
SubscriptionHelper . cancel ( this ) ; 
JoinSubscriptionBase < T > parent ; if ( delayErrors ) parent = new JoinSubscriptionDelayError < > ( s , source . parallelism ( ) , prefetch ) ; else parent = new JoinSubscription < > ( s , source . parallelism ( ) , prefetch ) ; s . onSubscribe ( parent ) ; source . subscribe ( parent . subscribers ) ; 
if ( ! cancelled ) cancelled = true ; cancelAll ( ) ; if ( getAndIncrement ( ) == 0 ) cleanup ( ) ; 
for ( JoinInnerSubscriber < T > s : subscribers ) s . cancel ( ) ; 
for ( JoinInnerSubscriber < T > s : subscribers ) s . queue = null ; 
if ( errors . compareAndSet ( null , e ) ) cancelAll ( ) ; drain ( ) ; else if ( e != errors . get ( ) ) RxJavaPlugins . onError ( e ) ; 
done . decrementAndGet ( ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; drainLoop ( ) ; 
int missed = 1 ; JoinInnerSubscriber < T > [ ] s = this . subscribers ; int n = s . length ; Subscriber < ? super T > a = this . downstream ; for ( ; ; ) long r = requested . get ( ) ; long e = 0 ; middle : while ( e != r ) if ( cancelled ) cleanup ( ) ; return ; Throwable ex = errors . get ( ) ; if ( ex != null ) cleanup ( ) ; a . onError ( ex ) ; return ; boolean d = done . get ( ) == 0 ; boolean empty = true ; for ( int i = 0 ; i < s . length ; i ++ ) JoinInnerSubscriber < T > inner = s [ i ] ; SimplePlainQueue < T > q = inner . queue ; if ( q != null ) T v = q . poll ( ) ; if ( v != null ) empty = false ; a . onNext ( v ) ; inner . requestOne ( ) ; if ( ++ e == r ) break middle ; if ( d && empty ) a . onComplete ( ) ; return ; if ( empty ) break ; if ( e == r ) if ( cancelled ) cleanup ( ) ; return ; Throwable ex = errors . get ( ) ; if ( ex != null ) cleanup ( ) ; a . onError ( ex ) ; return ; boolean d = done . get ( ) == 0 ; boolean empty = true ; for ( int i = 0 ; i < n ; i ++ ) JoinInnerSubscriber < T > inner = s [ i ] ; SimpleQueue < T > q = inner . queue ; if ( q != null && ! q . isEmpty ( ) ) empty = false ; break ; if ( d && empty ) a . onComplete ( ) ; return ; if ( e != 0 ) BackpressureHelper . produced ( requested , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( errors . tryAddThrowableOrReport ( e ) ) done . decrementAndGet ( ) ; drain ( ) ; 
done . decrementAndGet ( ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; drainLoop ( ) ; 
int missed = 1 ; JoinInnerSubscriber < T > [ ] s = this . subscribers ; int n = s . length ; Subscriber < ? super T > a = this . downstream ; for ( ; ; ) long r = requested . get ( ) ; long e = 0 ; middle : while ( e != r ) if ( cancelled ) cleanup ( ) ; return ; boolean d = done . get ( ) == 0 ; boolean empty = true ; for ( int i = 0 ; i < n ; i ++ ) JoinInnerSubscriber < T > inner = s [ i ] ; SimplePlainQueue < T > q = inner . queue ; if ( q != null ) T v = q . poll ( ) ; if ( v != null ) empty = false ; a . onNext ( v ) ; inner . requestOne ( ) ; if ( ++ e == r ) break middle ; if ( d && empty ) errors . tryTerminateConsumer ( a ) ; return ; if ( empty ) break ; if ( e == r ) if ( cancelled ) cleanup ( ) ; return ; boolean d = done . get ( ) == 0 ; boolean empty = true ; for ( int i = 0 ; i < n ; i ++ ) JoinInnerSubscriber < T > inner = s [ i ] ; SimpleQueue < T > q = inner . queue ; if ( q != null && ! q . isEmpty ( ) ) empty = false ; break ; if ( d && empty ) errors . tryTerminateConsumer ( a ) ; return ; if ( e != 0 ) BackpressureHelper . produced ( requested , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
SubscriptionHelper . setOnce ( this , s , prefetch ) ; 
parent . onError ( t ) ; 
parent . onComplete ( ) ; 
long p = produced + 1 ; if ( p == limit ) produced = 0 ; get ( ) . request ( p ) ; else produced = p ; 
return SubscriptionHelper . cancel ( this ) ; 
SimplePlainQueue < T > q = queue ; if ( q == null ) q = new SpscArrayQueue < > ( prefetch ) ; this . queue = q ; return q ; 
return source . parallelism ( ) ; 
return source . parallelism ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
ParallelReduceFullMainSubscriber < T > parent = new ParallelReduceFullMainSubscriber < > ( s , source . parallelism ( ) , reducer ) ; s . onSubscribe ( parent ) ; source . subscribe ( parent . subscribers ) ; 
for ( ParallelReduceFullInnerSubscriber < T > inner : subscribers ) inner . cancel ( ) ; 
if ( error . compareAndSet ( null , ex ) ) cancel ( ) ; downstream . onError ( ex ) ; else if ( ex != error . get ( ) ) RxJavaPlugins . onError ( ex ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; parent . innerError ( t ) ; 
if ( ! done ) done = true ; parent . innerComplete ( value ) ; 
SubscriptionHelper . cancel ( this ) ; 
for ( ; ; ) int acquired = get ( ) ; if ( acquired >= 2 ) return - 1 ; if ( compareAndSet ( acquired , acquired + 1 ) ) return acquired ; 
return releaseIndex . incrementAndGet ( ) == 2 ; 
return sources . length ; 
return source . parallelism ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; accumulator = null ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; R a = accumulator ; accumulator = null ; complete ( a ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
return source . parallelism ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
return source . parallelism ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; schedule ( ) ; 
if ( done ) return ; done = true ; schedule ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . cancel ( ) ; worker . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) == 0 ) worker . schedule ( this ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; 
int missed = 1 ; int c = consumed ; SpscArrayQueue < T > q = queue ; Subscriber < ? super T > a = downstream ; int lim = limit ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) if ( cancelled ) q . clear ( ) ; return ; boolean d = done ; if ( d ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; T v = q . poll ( ) ; boolean empty = v == null ; if ( d && empty ) a . onComplete ( ) ; worker . dispose ( ) ; return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; int p = ++ c ; if ( p == lim ) c = 0 ; upstream . request ( p ) ; if ( e == r ) if ( cancelled ) q . clear ( ) ; return ; if ( done ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; if ( q . isEmpty ( ) ) a . onComplete ( ) ; worker . dispose ( ) ; return ; if ( e != 0L && r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; int w = get ( ) ; if ( w == missed ) consumed = c ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; else missed = w ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; 
int missed = 1 ; int c = consumed ; SpscArrayQueue < T > q = queue ; ConditionalSubscriber < ? super T > a = downstream ; int lim = limit ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) if ( cancelled ) q . clear ( ) ; return ; boolean d = done ; if ( d ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; T v = q . poll ( ) ; boolean empty = v == null ; if ( d && empty ) a . onComplete ( ) ; worker . dispose ( ) ; return ; if ( empty ) break ; if ( a . tryOnNext ( v ) ) e ++ ; int p = ++ c ; if ( p == lim ) c = 0 ; upstream . request ( p ) ; if ( e == r ) if ( cancelled ) q . clear ( ) ; return ; if ( done ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; if ( q . isEmpty ( ) ) a . onComplete ( ) ; worker . dispose ( ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; consumed = c ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
return source . parallelism ( ) ; 
source . subscribe ( new ElementAtSubscriber < > ( observer , index , defaultValue ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableElementAt < > ( source , index , defaultValue , true ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( index + 1 ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
upstream = SubscriptionHelper . CANCELLED ; if ( ! done ) done = true ; T v = defaultValue ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onError ( new NoSuchElementException ( ) ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
source . subscribe ( new LastSubscriber < > ( observer ) ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
upstream = SubscriptionHelper . CANCELLED ; item = null ; downstream . onError ( t ) ; 
upstream = SubscriptionHelper . CANCELLED ; T v = item ; if ( v != null ) item = null ; downstream . onSuccess ( v ) ; else downstream . onComplete ( ) ; 
source . subscribe ( new SkipSubscriber < > ( s , n ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) long n = remaining ; this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( n ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
source . subscribe ( new SkipLastTimedSubscriber < > ( s , time , unit , scheduler , bufferSize , delayError ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . cancel ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final Subscriber < ? super T > a = downstream ; final SpscLinkedArrayQueue < Object > q = queue ; final boolean delayError = this . delayError ; final TimeUnit unit = this . unit ; final Scheduler scheduler = this . scheduler ; final long time = this . time ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) boolean d = done ; Long ts = ( Long ) q . peek ( ) ; boolean empty = ts == null ; long now = scheduler . now ( unit ) ; if ( ! empty && ts > now - time ) empty = true ; if ( checkTerminated ( d , empty , a , delayError ) ) return ; if ( empty ) break ; q . poll ( ) ; @ SuppressWarnings ( "unchecked" ) T v = ( T ) q . poll ( ) ; a . onNext ( v ) ; e ++ ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
GroupJoinSubscription < TLeft , TRight , TLeftEnd , TRightEnd , R > parent = new GroupJoinSubscription < > ( s , leftEnd , rightEnd , resultSelector ) ; s . onSubscribe ( parent ) ; LeftRightSubscriber left = new LeftRightSubscriber ( parent , true ) ; parent . disposables . add ( left ) ; LeftRightSubscriber right = new LeftRightSubscriber ( parent , false ) ; parent . disposables . add ( right ) ; source . subscribe ( left ) ; other . subscribe ( right ) ; 
if ( cancelled ) return ; cancelled = true ; cancelAll ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
disposables . dispose ( ) ; 
Throwable ex = ExceptionHelper . terminate ( error ) ; for ( UnicastProcessor < TRight > up : lefts . values ( ) ) up . onError ( ex ) ; lefts . clear ( ) ; rights . clear ( ) ; a . onError ( ex ) ; 
Exceptions . throwIfFatal ( exc ) ; ExceptionHelper . addThrowable ( error , exc ) ; q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; SpscLinkedArrayQueue < Object > q = queue ; Subscriber < ? super R > a = downstream ; for ( ; ; ) for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; Throwable ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; boolean d = active . get ( ) == 0 ; Integer mode = ( Integer ) q . poll ( ) ; boolean empty = mode == null ; if ( d && empty ) for ( UnicastProcessor < ? > up : lefts . values ( ) ) up . onComplete ( ) ; lefts . clear ( ) ; rights . clear ( ) ; disposables . dispose ( ) ; a . onComplete ( ) ; return ; if ( empty ) break ; Object val = q . poll ( ) ; if ( mode == LEFT_VALUE ) @ SuppressWarnings ( "unchecked" ) TLeft left = ( TLeft ) val ; UnicastProcessor < TRight > up = UnicastProcessor . create ( ) ; int idx = leftIndex ++ ; lefts . put ( idx , up ) ; Publisher < TLeftEnd > p ; try p = Objects . requireNonNull ( leftEnd . apply ( left ) , "The leftEnd returned a null Publisher" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; LeftRightEndSubscriber end = new LeftRightEndSubscriber ( this , true , idx ) ; disposables . add ( end ) ; p . subscribe ( end ) ; ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; R w ; try w = Objects . requireNonNull ( resultSelector . apply ( left , up ) , "The resultSelector returned a null value" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; if ( requested . get ( ) != 0L ) a . onNext ( w ) ; BackpressureHelper . produced ( requested , 1 ) ; else fail ( new MissingBackpressureException ( "Could not emit value due to lack of requests" ) , a , q ) ; return ; for ( TRight right : rights . values ( ) ) up . onNext ( right ) ; else if ( mode == RIGHT_VALUE ) @ SuppressWarnings ( "unchecked" ) TRight right = ( TRight ) val ; int idx = rightIndex ++ ; rights . put ( idx , right ) ; Publisher < TRightEnd > p ; try p = Objects . requireNonNull ( rightEnd . apply ( right ) , "The rightEnd returned a null Publisher" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; LeftRightEndSubscriber end = new LeftRightEndSubscriber ( this , false , idx ) ; disposables . add ( end ) ; p . subscribe ( end ) ; ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; for ( UnicastProcessor < TRight > up : lefts . values ( ) ) up . onNext ( right ) ; else if ( mode == LEFT_CLOSE ) LeftRightEndSubscriber end = ( LeftRightEndSubscriber ) val ; UnicastProcessor < TRight > up = lefts . remove ( end . index ) ; disposables . remove ( end ) ; if ( up != null ) up . onComplete ( ) ; else LeftRightEndSubscriber end = ( LeftRightEndSubscriber ) val ; rights . remove ( end . index ) ; disposables . remove ( end ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( ExceptionHelper . addThrowable ( error , ex ) ) active . decrementAndGet ( ) ; drain ( ) ; else RxJavaPlugins . onError ( ex ) ; 
if ( ExceptionHelper . addThrowable ( error , ex ) ) drain ( ) ; else RxJavaPlugins . onError ( ex ) ; 
SubscriptionHelper . cancel ( this ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
parent . innerValue ( isLeft , t ) ; 
parent . innerError ( t ) ; 
parent . innerComplete ( this ) ; 
SubscriptionHelper . cancel ( this ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
if ( SubscriptionHelper . cancel ( this ) ) parent . innerClose ( isLeft , this ) ; 
parent . innerCloseError ( t ) ; 
parent . innerClose ( isLeft , this ) ; 
source . subscribe ( new TakeSubscriber < > ( s , limit ) ) ; 
DeferredScalarSubscription < T > deferred = new DeferredScalarSubscription < > ( s ) ; s . onSubscribe ( deferred ) ; T t ; try t = Objects . requireNonNull ( callable . call ( ) , "The callable returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( deferred . isCancelled ( ) ) RxJavaPlugins . onError ( ex ) ; else s . onError ( ex ) ; return ; deferred . complete ( t ) ; 
return Objects . requireNonNull ( callable . call ( ) , "The callable returned a null value" ) ; 
return new SimpleGenerator < > ( consumer ) ; 
return new SimpleBiGenerator < > ( consumer ) ; 
return new ItemDelayFunction < > ( itemDelay ) ; 
subscriber . onError ( v ) ; 
subscriber . onComplete ( ) ; 
return new SubscriberOnNext < > ( subscriber ) ; 
return new SubscriberOnError < > ( subscriber ) ; 
return new SubscriberOnComplete < > ( subscriber ) ; 
return new FlatMapWithCombinerOuter < > ( combiner , mapper ) ; 
return new FlatMapIntoIterable < > ( mapper ) ; 
return new ReplaySupplier < > ( parent ) ; 
t . request ( Long . MAX_VALUE ) ; 
return parent . replay ( ) ; 
return parent . replay ( bufferSize , eagerTruncate ) ; 
return parent . replay ( bufferSize , time , unit , scheduler , eagerTruncate ) ; 
return parent . replay ( time , unit , scheduler , eagerTruncate ) ; 
Worker worker = scheduler . createWorker ( ) ; if ( s instanceof ConditionalSubscriber ) source . subscribe ( new ObserveOnConditionalSubscriber < > ( ( ConditionalSubscriber < ? super T > ) s , worker , delayError , prefetch ) ) ; else source . subscribe ( new ObserveOnSubscriber < > ( s , worker , delayError , prefetch ) ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; trySchedule ( ) ; 
if ( ! done ) done = true ; trySchedule ( ) ; 
if ( cancelled ) return ; cancelled = true ; upstream . cancel ( ) ; worker . dispose ( ) ; if ( ! outputFused && getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; worker . schedule ( this ) ; 
if ( outputFused ) runBackfused ( ) ; else if ( sourceMode == SYNC ) runSync ( ) ; else runAsync ( ) ; 
queue . clear ( ) ; 
return queue . isEmpty ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > f = ( QueueSubscription < T > ) s ; int m = f . requestFusion ( ANY | BOUNDARY ) ; if ( m == SYNC ) sourceMode = SYNC ; queue = f ; done = true ; downstream . onSubscribe ( this ) ; return ; else if ( m == ASYNC ) sourceMode = ASYNC ; queue = f ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; 
int missed = 1 ; final Subscriber < ? super T > a = downstream ; final SimpleQueue < T > q = queue ; long e = produced ; for ( ; ; ) long r = requested . get ( ) ; while ( e != r ) T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelled = true ; upstream . cancel ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; if ( cancelled ) return ; if ( v == null ) cancelled = true ; a . onComplete ( ) ; worker . dispose ( ) ; return ; a . onNext ( v ) ; e ++ ; if ( cancelled ) return ; if ( q . isEmpty ( ) ) cancelled = true ; a . onComplete ( ) ; worker . dispose ( ) ; return ; produced = e ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
int missed = 1 ; final Subscriber < ? super T > a = downstream ; final SimpleQueue < T > q = queue ; long e = produced ; for ( ; ; ) long r = requested . get ( ) ; while ( e != r ) boolean d = done ; T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelled = true ; upstream . cancel ( ) ; q . clear ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a ) ) return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == limit ) if ( r != Long . MAX_VALUE ) r = requested . addAndGet ( - e ) ; upstream . request ( e ) ; e = 0L ; if ( e == r && checkTerminated ( done , q . isEmpty ( ) , a ) ) return ; int w = get ( ) ; if ( missed == w ) produced = e ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; else missed = w ; 
int missed = 1 ; for ( ; ; ) if ( cancelled ) return ; boolean d = done ; downstream . onNext ( null ) ; if ( d ) cancelled = true ; Throwable e = error ; if ( e != null ) downstream . onError ( e ) ; else downstream . onComplete ( ) ; worker . dispose ( ) ; return ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
T v = queue . poll ( ) ; if ( v != null && sourceMode != SYNC ) long p = produced + 1 ; if ( p == limit ) produced = 0 ; upstream . request ( p ) ; else produced = p ; return v ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > f = ( QueueSubscription < T > ) s ; int m = f . requestFusion ( ANY | BOUNDARY ) ; if ( m == SYNC ) sourceMode = SYNC ; queue = f ; done = true ; downstream . onSubscribe ( this ) ; return ; else if ( m == ASYNC ) sourceMode = ASYNC ; queue = f ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; 
int missed = 1 ; final ConditionalSubscriber < ? super T > a = downstream ; final SimpleQueue < T > q = queue ; long e = produced ; for ( ; ; ) long r = requested . get ( ) ; while ( e != r ) T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelled = true ; upstream . cancel ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; if ( cancelled ) return ; if ( v == null ) cancelled = true ; a . onComplete ( ) ; worker . dispose ( ) ; return ; if ( a . tryOnNext ( v ) ) e ++ ; if ( cancelled ) return ; if ( q . isEmpty ( ) ) cancelled = true ; a . onComplete ( ) ; worker . dispose ( ) ; return ; produced = e ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
int missed = 1 ; final ConditionalSubscriber < ? super T > a = downstream ; final SimpleQueue < T > q = queue ; long emitted = produced ; long polled = consumed ; for ( ; ; ) long r = requested . get ( ) ; while ( emitted != r ) boolean d = done ; T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelled = true ; upstream . cancel ( ) ; q . clear ( ) ; a . onError ( ex ) ; worker . dispose ( ) ; return ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a ) ) return ; if ( empty ) break ; if ( a . tryOnNext ( v ) ) emitted ++ ; polled ++ ; if ( polled == limit ) upstream . request ( polled ) ; polled = 0L ; if ( emitted == r && checkTerminated ( done , q . isEmpty ( ) , a ) ) return ; produced = emitted ; consumed = polled ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
int missed = 1 ; for ( ; ; ) if ( cancelled ) return ; boolean d = done ; downstream . onNext ( null ) ; if ( d ) cancelled = true ; Throwable e = error ; if ( e != null ) downstream . onError ( e ) ; else downstream . onComplete ( ) ; worker . dispose ( ) ; return ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
T v = queue . poll ( ) ; if ( v != null && sourceMode != SYNC ) long p = consumed + 1 ; if ( p == limit ) consumed = 0 ; upstream . request ( p ) ; else consumed = p ; return v ; 
source . subscribe ( new FlatMapCompletableMainSubscriber < > ( observer , mapper , delayErrors , maxConcurrency ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableFlatMapCompletable < > ( source , mapper , delayErrors , maxConcurrency ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; int m = maxConcurrency ; if ( m == Integer . MAX_VALUE ) s . request ( Long . MAX_VALUE ) ; else s . request ( m ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) if ( delayErrors ) if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; else if ( maxConcurrency != Integer . MAX_VALUE ) upstream . request ( 1 ) ; else disposed = true ; upstream . cancel ( ) ; set . dispose ( ) ; errors . tryTerminateConsumer ( downstream ) ; 
if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; else if ( maxConcurrency != Integer . MAX_VALUE ) upstream . request ( 1 ) ; 
disposed = true ; upstream . cancel ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
return set . isDisposed ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
innerComplete ( this ) ; 
innerError ( this , e ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
source . subscribe ( child ) ; if ( clients . incrementAndGet ( ) == numberOfSubscribers ) source . connect ( connection ) ; 
source . subscribe ( new IgnoreElementsSubscriber < > ( t ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
return null ; 
return true ; 
$EMPTY$
upstream . cancel ( ) ; 
return source ; 
return RxJavaPlugins . onAssembly ( new FlowableReduce < > ( source , reducer ) ) ; 
source . subscribe ( new ReduceSubscriber < > ( observer , reducer ) ) ; 
upstream . cancel ( ) ; done = true ; 
return done ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; T v = value ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onComplete ( ) ; 
source . subscribe ( new ConcatWithSubscriber < > ( s , other ) ) ; 
DisposableHelper . setOnce ( otherDisposable , d ) ; 
downstream . onError ( t ) ; 
if ( inMaybe ) downstream . onComplete ( ) ; else inMaybe = true ; upstream = SubscriptionHelper . CANCELLED ; MaybeSource < ? extends T > ms = other ; other = null ; ms . subscribe ( this ) ; 
super . cancel ( ) ; DisposableHelper . dispose ( otherDisposable ) ; 
source . subscribe ( new SkipWhileSubscriber < > ( s , predicate ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
SwitchIfEmptySubscriber < T > parent = new SwitchIfEmptySubscriber < > ( s , other ) ; s . onSubscribe ( parent . arbiter ) ; source . subscribe ( parent ) ; 
arbiter . setSubscription ( s ) ; 
downstream . onError ( t ) ; 
if ( empty ) empty = false ; other . subscribe ( this ) ; else downstream . onComplete ( ) ; 
MostRecentSubscriber < T > mostRecentSubscriber = new MostRecentSubscriber < > ( initialValue ) ; source . subscribe ( mostRecentSubscriber ) ; return mostRecentSubscriber . getIterable ( ) ; 
value = NotificationLite . complete ( ) ; 
value = NotificationLite . error ( e ) ; 
return new Iterator ( ) ; 
buf = value ; return ! NotificationLite . isComplete ( buf ) ; 
try if ( buf == null ) buf = value ; if ( NotificationLite . isComplete ( buf ) ) throw new NoSuchElementException ( ) ; if ( NotificationLite . isError ( buf ) ) throw ExceptionHelper . wrapOrThrow ( NotificationLite . getError ( buf ) ) ; return NotificationLite . getValue ( buf ) ; finally buf = null ; 
throw new UnsupportedOperationException ( "Read only iterator" ) ; 
SerializedSubscriber < T > z = new SerializedSubscriber < > ( s ) ; FlowableProcessor < Throwable > processor = UnicastProcessor . < Throwable > create ( 8 ) . toSerialized ( ) ; Publisher < ? > when ; try when = Objects . requireNonNull ( handler . apply ( processor ) , "handler returned a null Publisher" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; WhenReceiver < T , Throwable > receiver = new WhenReceiver < > ( source ) ; RetryWhenSubscriber < T > subscriber = new RetryWhenSubscriber < > ( z , processor , receiver ) ; receiver . subscriber = subscriber ; s . onSubscribe ( subscriber ) ; when . subscribe ( receiver ) ; receiver . onNext ( 0 ) ; 
again ( t ) ; 
receiver . cancel ( ) ; downstream . onComplete ( ) ; 
source . subscribe ( new InnerSubscriber < > ( s , predicate ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( ! done ) done = true ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( ! done ) done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
source . subscribe ( new SerializedSubscriber < > ( s ) ) ; 
source . subscribe ( new TakeLastOneSubscriber < > ( s ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
value = null ; downstream . onError ( t ) ; 
T v = value ; if ( v != null ) complete ( v ) ; else downstream . onComplete ( ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . cancel ( ) ; if ( getAndIncrement ( ) == 0 ) current . lazySet ( null ) ; 
if ( getAndIncrement ( ) != 0 ) return ; final Subscriber < ? super R > a = downstream ; int missed = 1 ; final AtomicLong r = requested ; final AtomicReference < R > q = current ; for ( ; ; ) long e = 0L ; while ( e != r . get ( ) ) boolean d = done ; R v = q . getAndSet ( null ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , q ) ) return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == r . get ( ) && checkTerminated ( done , q . get ( ) == null , a , q ) ) return ; if ( e != 0L ) BackpressureHelper . produced ( r , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
publisher . subscribe ( s ) ; 
SerializedSubscriber < T > serial = new SerializedSubscriber < > ( s ) ; if ( emitLast ) source . subscribe ( new SampleTimedEmitLast < > ( serial , period , unit , scheduler ) ) ; else source . subscribe ( new SampleTimedNoLast < > ( serial , period , unit , scheduler ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; timer . replace ( scheduler . schedulePeriodicallyDirect ( this , period , period , unit ) ) ; s . request ( Long . MAX_VALUE ) ; 
cancelTimer ( ) ; downstream . onError ( t ) ; 
cancelTimer ( ) ; complete ( ) ; 
DisposableHelper . dispose ( timer ) ; 
cancelTimer ( ) ; upstream . cancel ( ) ; 
T value = getAndSet ( null ) ; if ( value != null ) long r = requested . get ( ) ; if ( r != 0L ) downstream . onNext ( value ) ; BackpressureHelper . produced ( requested , 1 ) ; else cancel ( ) ; downstream . onError ( new MissingBackpressureException ( "Couldn't emit value due to lack of requests!" ) ) ; 
downstream . onComplete ( ) ; 
emit ( ) ; 
emit ( ) ; if ( wip . decrementAndGet ( ) == 0 ) downstream . onComplete ( ) ; 
if ( wip . incrementAndGet ( ) == 2 ) emit ( ) ; if ( wip . decrementAndGet ( ) == 0 ) downstream . onComplete ( ) ; 
source . subscribe ( new BackpressureReduceWithSubscriber < > ( s , supplier , reducer ) ) ; 
EqualCoordinator < T > parent = new EqualCoordinator < > ( s , prefetch , comparer ) ; s . onSubscribe ( parent ) ; parent . subscribe ( first , second ) ; 
source1 . subscribe ( first ) ; source2 . subscribe ( second ) ; 
super . cancel ( ) ; first . cancel ( ) ; second . cancel ( ) ; errors . tryTerminateAndReport ( ) ; if ( wip . getAndIncrement ( ) == 0 ) first . clear ( ) ; second . clear ( ) ; 
first . cancel ( ) ; first . clear ( ) ; second . cancel ( ) ; second . clear ( ) ; 
if ( wip . getAndIncrement ( ) != 0 ) return ; int missed = 1 ; for ( ; ; ) SimpleQueue < T > q1 = first . queue ; SimpleQueue < T > q2 = second . queue ; if ( q1 != null && q2 != null ) for ( ; ; ) if ( isCancelled ( ) ) first . clear ( ) ; second . clear ( ) ; return ; Throwable ex = errors . get ( ) ; if ( ex != null ) cancelAndClear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean d1 = first . done ; T a = v1 ; if ( a == null ) try a = q1 . poll ( ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; cancelAndClear ( ) ; errors . tryAddThrowableOrReport ( exc ) ; errors . tryTerminateConsumer ( downstream ) ; return ; v1 = a ; boolean e1 = a == null ; boolean d2 = second . done ; T b = v2 ; if ( b == null ) try b = q2 . poll ( ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; cancelAndClear ( ) ; errors . tryAddThrowableOrReport ( exc ) ; errors . tryTerminateConsumer ( downstream ) ; return ; v2 = b ; boolean e2 = b == null ; if ( d1 && d2 && e1 && e2 ) complete ( true ) ; return ; if ( ( d1 && d2 ) && ( e1 != e2 ) ) cancelAndClear ( ) ; complete ( false ) ; return ; if ( e1 || e2 ) break ; boolean c ; try c = comparer . test ( a , b ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; cancelAndClear ( ) ; errors . tryAddThrowableOrReport ( exc ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( ! c ) cancelAndClear ( ) ; complete ( false ) ; return ; v1 = null ; v2 = null ; first . request ( ) ; second . request ( ) ; else if ( isCancelled ( ) ) first . clear ( ) ; second . clear ( ) ; return ; Throwable ex = errors . get ( ) ; if ( ex != null ) cancelAndClear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( errors . tryAddThrowableOrReport ( t ) ) drain ( ) ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY ) ; if ( m == QueueSubscription . SYNC ) sourceMode = m ; queue = qs ; done = true ; parent . drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) sourceMode = m ; queue = qs ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; s . request ( prefetch ) ; 
parent . innerError ( t ) ; 
done = true ; parent . drain ( ) ; 
if ( sourceMode != QueueSubscription . SYNC ) long p = produced + 1 ; if ( p >= limit ) produced = 0 ; get ( ) . request ( p ) ; else produced = p ; 
SubscriptionHelper . cancel ( this ) ; 
SimpleQueue < T > sq = queue ; if ( sq != null ) sq . clear ( ) ; 
source . subscribe ( new AnySubscriber < > ( s , predicate ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; complete ( false ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
IntervalRangeSubscriber is = new IntervalRangeSubscriber ( s , start , end ) ; s . onSubscribe ( is ) ; Scheduler sch = scheduler ; if ( sch instanceof TrampolineScheduler ) Worker worker = sch . createWorker ( ) ; is . setResource ( worker ) ; worker . schedulePeriodically ( is , initialDelay , period , unit ) ; else Disposable d = sch . schedulePeriodicallyDirect ( is , initialDelay , period , unit ) ; is . setResource ( d ) ; 
DisposableHelper . dispose ( resource ) ; 
if ( resource . get ( ) != DisposableHelper . DISPOSED ) long r = get ( ) ; if ( r != 0L ) long c = count ; downstream . onNext ( c ) ; if ( c == end ) if ( resource . get ( ) != DisposableHelper . DISPOSED ) downstream . onComplete ( ) ; DisposableHelper . dispose ( resource ) ; return ; count = c + 1 ; if ( r != Long . MAX_VALUE ) decrementAndGet ( ) ; else downstream . onError ( new MissingBackpressureException ( "Can't deliver value " + count + " due to lack of requests" ) ) ; DisposableHelper . dispose ( resource ) ; 
DisposableHelper . setOnce ( resource , d ) ; 
if ( s instanceof ConditionalSubscriber ) source . subscribe ( new MapConditionalSubscriber < T , U > ( ( ConditionalSubscriber < ? super U > ) s , mapper ) ) ; else source . subscribe ( new MapSubscriber < T , U > ( s , mapper ) ) ; 
T t = qs . poll ( ) ; return t != null ? Objects . requireNonNull ( mapper . apply ( t ) , "The mapper function returned a null value." ) : null ; 
T t = qs . poll ( ) ; return t != null ? Objects . requireNonNull ( mapper . apply ( t ) , "The mapper function returned a null value." ) : null ; 
source . subscribe ( new TimeIntervalSubscriber < > ( s , unit , scheduler ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) lastTime = scheduler . now ( unit ) ; this . upstream = s ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
final SerializedSubscriber < R > serial = new SerializedSubscriber < > ( s ) ; final WithLatestFromSubscriber < T , U , R > wlf = new WithLatestFromSubscriber < > ( serial , combiner ) ; serial . onSubscribe ( wlf ) ; other . subscribe ( new FlowableWithLatestSubscriber ( wlf ) ) ; source . subscribe ( wlf ) ; 
SubscriptionHelper . deferredSetOnce ( this . upstream , requested , s ) ; 
SubscriptionHelper . cancel ( other ) ; downstream . onError ( t ) ; 
SubscriptionHelper . cancel ( other ) ; downstream . onComplete ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; SubscriptionHelper . cancel ( other ) ; 
return SubscriptionHelper . setOnce ( other , o ) ; 
SubscriptionHelper . cancel ( upstream ) ; downstream . onError ( e ) ; 
if ( wlf . setOther ( s ) ) s . request ( Long . MAX_VALUE ) ; 
wlf . otherError ( t ) ; 
$EMPTY$
switch ( errorMode ) case BOUNDARY : source . subscribe ( new ConcatMapDelayed < > ( s , mapper , prefetch , false , scheduler . createWorker ( ) ) ) ; break ; case END : source . subscribe ( new ConcatMapDelayed < > ( s , mapper , prefetch , true , scheduler . createWorker ( ) ) ) ; break ; default : source . subscribe ( new ConcatMapImmediate < > ( s , mapper , prefetch , scheduler . createWorker ( ) ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > f = ( QueueSubscription < T > ) s ; int m = f . requestFusion ( QueueSubscription . ANY | QueueSubscription . BOUNDARY ) ; if ( m == QueueSubscription . SYNC ) sourceMode = m ; queue = f ; done = true ; subscribeActual ( ) ; schedule ( ) ; return ; if ( m == QueueSubscription . ASYNC ) sourceMode = m ; queue = f ; subscribeActual ( ) ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; subscribeActual ( ) ; s . request ( prefetch ) ; 
done = true ; schedule ( ) ; 
active = false ; schedule ( ) ; 
downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) inner . cancel ( ) ; if ( getAndIncrement ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; 
return get ( ) == 0 && compareAndSet ( 0 , 1 ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) upstream . cancel ( ) ; if ( getAndIncrement ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; 
if ( ! cancelled ) cancelled = true ; inner . cancel ( ) ; upstream . cancel ( ) ; worker . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( wip . getAndIncrement ( ) == 0 ) worker . schedule ( this ) ; 
for ( ; ; ) if ( cancelled ) return ; if ( ! active ) boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; boolean empty = v == null ; if ( d && empty ) downstream . onComplete ( ) ; worker . dispose ( ) ; return ; if ( ! empty ) Publisher < ? extends R > p ; try p = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null Publisher" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; if ( sourceMode != QueueSubscription . SYNC ) int c = consumed + 1 ; if ( c == limit ) consumed = 0 ; upstream . request ( c ) ; else consumed = c ; if ( p instanceof Supplier ) @ SuppressWarnings ( "unchecked" ) Supplier < R > supplier = ( Supplier < R > ) p ; R vr ; try vr = supplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; if ( vr == null || cancelled ) continue ; if ( inner . isUnbounded ( ) ) if ( tryEnter ( ) ) downstream . onNext ( vr ) ; if ( ! compareAndSet ( 1 , 0 ) ) errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; continue ; else active = true ; inner . setSubscription ( new SimpleScalarSubscription < > ( vr , inner ) ) ; else active = true ; p . subscribe ( inner ) ; if ( wip . decrementAndGet ( ) == 0 ) break ; 
downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) done = true ; schedule ( ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) if ( ! veryEnd ) upstream . cancel ( ) ; done = true ; active = false ; schedule ( ) ; 
if ( ! cancelled ) cancelled = true ; inner . cancel ( ) ; upstream . cancel ( ) ; worker . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( getAndIncrement ( ) == 0 ) worker . schedule ( this ) ; 
for ( ; ; ) if ( cancelled ) return ; if ( ! active ) boolean d = done ; if ( d && ! veryEnd ) Throwable ex = errors . get ( ) ; if ( ex != null ) errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; T v ; try v = queue . poll ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; if ( ! empty ) Publisher < ? extends R > p ; try p = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null Publisher" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; if ( sourceMode != QueueSubscription . SYNC ) int c = consumed + 1 ; if ( c == limit ) consumed = 0 ; upstream . request ( c ) ; else consumed = c ; if ( p instanceof Supplier ) @ SuppressWarnings ( "unchecked" ) Supplier < R > supplier = ( Supplier < R > ) p ; R vr ; try vr = supplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; errors . tryAddThrowableOrReport ( e ) ; if ( ! veryEnd ) upstream . cancel ( ) ; errors . tryTerminateConsumer ( downstream ) ; worker . dispose ( ) ; return ; vr = null ; if ( vr == null || cancelled ) continue ; if ( inner . isUnbounded ( ) ) downstream . onNext ( vr ) ; continue ; else active = true ; inner . setSubscription ( new SimpleScalarSubscription < > ( vr , inner ) ) ; else active = true ; p . subscribe ( inner ) ; if ( decrementAndGet ( ) == 0 ) break ; 
this . source . subscribe ( new BackpressureDropSubscriber < > ( s , onDrop ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
source . subscribe ( new FlatMapMaybeSubscriber < > ( s , mapper , delayErrors , maxConcurrency ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; int m = maxConcurrency ; if ( m == Integer . MAX_VALUE ) s . request ( Long . MAX_VALUE ) ; else s . request ( maxConcurrency ) ; 
active . decrementAndGet ( ) ; if ( errors . tryAddThrowableOrReport ( t ) ) if ( ! delayErrors ) set . dispose ( ) ; drain ( ) ; 
active . decrementAndGet ( ) ; drain ( ) ; 
cancelled = true ; upstream . cancel ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
SpscLinkedArrayQueue < R > current = queue . get ( ) ; if ( current != null ) return current ; current = new SpscLinkedArrayQueue < > ( Flowable . bufferSize ( ) ) ; if ( queue . compareAndSet ( null , current ) ) return current ; return queue . get ( ) ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
SpscLinkedArrayQueue < R > q = queue . get ( ) ; if ( q != null ) q . clear ( ) ; 
int missed = 1 ; Subscriber < ? super R > a = downstream ; AtomicInteger n = active ; AtomicReference < SpscLinkedArrayQueue < R > > qr = queue ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) if ( cancelled ) clear ( ) ; return ; if ( ! delayErrors ) Throwable ex = errors . get ( ) ; if ( ex != null ) clear ( ) ; errors . tryTerminateConsumer ( a ) ; return ; boolean d = n . get ( ) == 0 ; SpscLinkedArrayQueue < R > q = qr . get ( ) ; R v = q != null ? q . poll ( ) : null ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( a ) ; return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == r ) if ( cancelled ) clear ( ) ; return ; if ( ! delayErrors ) Throwable ex = errors . get ( ) ; if ( ex != null ) clear ( ) ; errors . tryTerminateConsumer ( a ) ; return ; boolean d = n . get ( ) == 0 ; SpscLinkedArrayQueue < R > q = qr . get ( ) ; boolean empty = q == null || q . isEmpty ( ) ; if ( d && empty ) errors . tryTerminateConsumer ( a ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; if ( maxConcurrency != Integer . MAX_VALUE ) upstream . request ( e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
innerError ( this , e ) ; 
innerComplete ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new ThrottleLatestSubscriber < > ( s , timeout , unit , scheduler . createWorker ( ) , emitLast ) ) ; 
if ( SubscriptionHelper . validate ( upstream , s ) ) upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
cancelled = true ; upstream . cancel ( ) ; worker . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) latest . lazySet ( null ) ; 
timerFired = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; AtomicReference < T > latest = this . latest ; AtomicLong requested = this . requested ; Subscriber < ? super T > downstream = this . downstream ; for ( ; ; ) for ( ; ; ) if ( cancelled ) latest . lazySet ( null ) ; return ; boolean d = done ; if ( d && error != null ) latest . lazySet ( null ) ; downstream . onError ( error ) ; worker . dispose ( ) ; return ; T v = latest . get ( ) ; boolean empty = v == null ; if ( d ) if ( ! empty && emitLast ) v = latest . getAndSet ( null ) ; long e = emitted ; if ( e != requested . get ( ) ) emitted = e + 1 ; downstream . onNext ( v ) ; downstream . onComplete ( ) ; else downstream . onError ( new MissingBackpressureException ( "Could not emit final value due to lack of requests" ) ) ; else latest . lazySet ( null ) ; downstream . onComplete ( ) ; worker . dispose ( ) ; return ; if ( empty ) if ( timerFired ) timerRunning = false ; timerFired = false ; break ; if ( ! timerRunning || timerFired ) v = latest . getAndSet ( null ) ; long e = emitted ; if ( e != requested . get ( ) ) downstream . onNext ( v ) ; emitted = e + 1 ; else upstream . cancel ( ) ; downstream . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests" ) ) ; worker . dispose ( ) ; return ; timerFired = false ; timerRunning = true ; worker . schedule ( this , timeout , unit ) ; else break ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
upstream . subscribe ( new SubscriberObserver < > ( s ) ) ; 
downstream . onComplete ( ) ; 
downstream . onError ( e ) ; 
this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream . dispose ( ) ; 
if ( s instanceof ConditionalSubscriber ) source . subscribe ( new DoFinallyConditionalSubscriber < > ( ( ConditionalSubscriber < ? super T > ) s , onFinally ) ) ; else source . subscribe ( new DoFinallySubscriber < > ( s , onFinally ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) this . qs = ( QueueSubscription < T > ) s ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; runFinally ( ) ; 
downstream . onComplete ( ) ; runFinally ( ) ; 
upstream . cancel ( ) ; runFinally ( ) ; 
qs . clear ( ) ; 
return qs . isEmpty ( ) ; 
T v = qs . poll ( ) ; if ( v == null && syncFused ) runFinally ( ) ; return v ; 
if ( compareAndSet ( 0 , 1 ) ) try onFinally . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) this . qs = ( QueueSubscription < T > ) s ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; runFinally ( ) ; 
downstream . onComplete ( ) ; runFinally ( ) ; 
upstream . cancel ( ) ; runFinally ( ) ; 
qs . clear ( ) ; 
return qs . isEmpty ( ) ; 
T v = qs . poll ( ) ; if ( v == null && syncFused ) runFinally ( ) ; return v ; 
if ( compareAndSet ( 0 , 1 ) ) try onFinally . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
final BlockingQueue < Object > queue = new LinkedBlockingQueue < > ( ) ; BlockingSubscriber < T > bs = new BlockingSubscriber < > ( queue ) ; source . subscribe ( bs ) ; try for ( ; ; ) if ( bs . isCancelled ( ) ) break ; Object v = queue . poll ( ) ; if ( v == null ) if ( bs . isCancelled ( ) ) break ; BlockingHelper . verifyNonBlocking ( ) ; v = queue . take ( ) ; if ( bs . isCancelled ( ) ) break ; if ( v == BlockingSubscriber . TERMINATED || NotificationLite . acceptFull ( v , subscriber ) ) break ; catch ( InterruptedException e ) bs . cancel ( ) ; subscriber . onError ( e ) ; 
BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver ( ) ; LambdaSubscriber < T > ls = new LambdaSubscriber < > ( Functions . emptyConsumer ( ) , callback , callback , Functions . REQUEST_MAX ) ; source . subscribe ( ls ) ; BlockingHelper . awaitForComplete ( callback , ls ) ; Throwable e = callback . error ; if ( e != null ) throw ExceptionHelper . wrapOrThrow ( e ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( onError , "onError is null" ) ; Objects . requireNonNull ( onComplete , "onComplete is null" ) ; subscribe ( o , new LambdaSubscriber < T > ( onNext , onError , onComplete , Functions . REQUEST_MAX ) ) ; 
return source ; 
source . subscribe ( new FromCompletableObserver < T > ( observer ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
U coll ; try coll = ExceptionHelper . nullCheck ( collectionSupplier . get ( ) , "The collectionSupplier returned a null Collection." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; source . subscribe ( new ToListSubscriber < > ( s , coll ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
value = null ; downstream . onError ( t ) ; 
complete ( value ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
R seed ; try seed = Objects . requireNonNull ( seedSupplier . get ( ) , "The seedSupplier returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( new ReduceSeedObserver < > ( observer , reducer , seed ) ) ; 
Iterator < U > it ; try it = Objects . requireNonNull ( other . iterator ( ) , "The iterator returned by other is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , t ) ; return ; boolean b ; try b = it . hasNext ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , t ) ; return ; if ( ! b ) EmptySubscription . complete ( t ) ; return ; source . subscribe ( new ZipIterableSubscriber < T , U , V > ( t , it , zipper ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
Exceptions . throwIfFatal ( e ) ; done = true ; upstream . cancel ( ) ; downstream . onError ( e ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
source . subscribe ( new BackpressureLatestSubscriber < > ( s ) ) ; 
Throwable error ; try error = ExceptionHelper . nullCheck ( errorSupplier . get ( ) , "Callable returned a null Throwable." ) ; catch ( Throwable t ) Exceptions . throwIfFatal ( t ) ; error = t ; EmptySubscription . error ( error , s ) ; 
SerializedSubscriber < T > z = new SerializedSubscriber < > ( s ) ; FlowableProcessor < Object > processor = UnicastProcessor . create ( 8 ) . toSerialized ( ) ; Publisher < ? > when ; try when = Objects . requireNonNull ( handler . apply ( processor ) , "handler returned a null Publisher" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; WhenReceiver < T , Object > receiver = new WhenReceiver < > ( source ) ; RepeatWhenSubscriber < T > subscriber = new RepeatWhenSubscriber < > ( z , processor , receiver ) ; receiver . subscriber = subscriber ; s . onSubscribe ( subscriber ) ; when . subscribe ( receiver ) ; receiver . onNext ( 0 ) ; 
SubscriptionHelper . deferredSetOnce ( upstream , requested , s ) ; 
if ( getAndIncrement ( ) == 0 ) for ( ; ; ) if ( upstream . get ( ) == SubscriptionHelper . CANCELLED ) return ; source . subscribe ( subscriber ) ; if ( decrementAndGet ( ) == 0 ) break ; 
subscriber . cancel ( ) ; subscriber . downstream . onError ( t ) ; 
subscriber . cancel ( ) ; subscriber . downstream . onComplete ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; 
setSubscription ( s ) ; 
super . cancel ( ) ; receiver . cancel ( ) ; 
receiver . cancel ( ) ; downstream . onError ( t ) ; 
again ( 0 ) ; 
if ( s instanceof ConditionalSubscriber ) s . onSubscribe ( new ArrayConditionalSubscription < > ( ( ConditionalSubscriber < ? super T > ) s , array ) ) ; else s . onSubscribe ( new ArraySubscription < > ( s , array ) ) ; 
int i = index ; T [ ] arr = array ; if ( i == arr . length ) return null ; index = i + 1 ; return Objects . requireNonNull ( arr [ i ] , "array element is null" ) ; 
return index == array . length ; 
index = array . length ; 
cancelled = true ; 
T [ ] arr = array ; int f = arr . length ; Subscriber < ? super T > a = downstream ; for ( int i = index ; i != f ; i ++ ) if ( cancelled ) return ; T t = arr [ i ] ; if ( t == null ) a . onError ( new NullPointerException ( "The element at index " + i + " is null" ) ) ; return ; else a . onNext ( t ) ; if ( cancelled ) return ; a . onComplete ( ) ; 
T [ ] arr = array ; int f = arr . length ; ConditionalSubscriber < ? super T > a = downstream ; for ( int i = index ; i != f ; i ++ ) if ( cancelled ) return ; T t = arr [ i ] ; if ( t == null ) a . onError ( new NullPointerException ( "The element at index " + i + " is null" ) ) ; return ; else a . tryOnNext ( t ) ; if ( cancelled ) return ; a . onComplete ( ) ; 
if ( skip == size ) source . subscribe ( new WindowExactSubscriber < > ( s , size , bufferSize ) ) ; else if ( skip > size ) source . subscribe ( new WindowSkipSubscriber < > ( s , size , skip , bufferSize ) ) ; else source . subscribe ( new WindowOverlapSubscriber < > ( s , size , skip , bufferSize ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
Processor < T , T > w = window ; if ( w != null ) window = null ; w . onError ( t ) ; downstream . onError ( t ) ; 
Processor < T , T > w = window ; if ( w != null ) window = null ; w . onComplete ( ) ; downstream . onComplete ( ) ; 
if ( once . compareAndSet ( false , true ) ) run ( ) ; 
if ( decrementAndGet ( ) == 0 ) upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
Processor < T , T > w = window ; if ( w != null ) window = null ; w . onError ( t ) ; downstream . onError ( t ) ; 
Processor < T , T > w = window ; if ( w != null ) window = null ; w . onComplete ( ) ; downstream . onComplete ( ) ; 
if ( once . compareAndSet ( false , true ) ) run ( ) ; 
if ( decrementAndGet ( ) == 0 ) upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
for ( Processor < T , T > w : windows ) w . onError ( t ) ; windows . clear ( ) ; error = t ; done = true ; drain ( ) ; 
for ( Processor < T , T > w : windows ) w . onComplete ( ) ; windows . clear ( ) ; done = true ; drain ( ) ; 
if ( wip . getAndIncrement ( ) != 0 ) return ; final Subscriber < ? super Flowable < T > > a = downstream ; final SpscLinkedArrayQueue < UnicastProcessor < T > > q = queue ; int missed = 1 ; outer : for ( ; ; ) if ( cancelled ) UnicastProcessor < T > up = null ; while ( ( up = q . poll ( ) ) != null ) up . onComplete ( ) ; else long r = requested . get ( ) ; long e = 0 ; while ( e != r ) boolean d = done ; UnicastProcessor < T > t = q . poll ( ) ; boolean empty = t == null ; if ( cancelled ) continue outer ; if ( checkTerminated ( d , empty , a , q ) ) return ; if ( empty ) break ; FlowableWindowSubscribeIntercept < T > intercept = new FlowableWindowSubscribeIntercept < > ( t ) ; a . onNext ( intercept ) ; if ( intercept . tryAbandon ( ) ) t . onComplete ( ) ; e ++ ; if ( e == r ) if ( cancelled ) continue ; if ( checkTerminated ( done , q . isEmpty ( ) , a , q ) ) return ; if ( e != 0L && r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
cancelled = true ; if ( once . compareAndSet ( false , true ) ) run ( ) ; drain ( ) ; 
if ( decrementAndGet ( ) == 0 ) upstream . cancel ( ) ; 
source . subscribe ( new ElementAtSubscriber < > ( s , index , defaultValue , errorOnFewer ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; T v = defaultValue ; if ( v == null ) if ( errorOnFewer ) downstream . onError ( new NoSuchElementException ( ) ) ; else downstream . onComplete ( ) ; else complete ( v ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
source . subscribe ( new FlatMapMaybeSubscriber < > ( s , mapper , delayErrors , maxConcurrency ) ) ; 
source . subscribe ( new TakeWhileSubscriber < > ( s , predicate ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
D resource ; try resource = resourceSupplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; Publisher < ? extends T > source ; try source = Objects . requireNonNull ( sourceSupplier . apply ( resource ) , "The sourceSupplier returned a null Publisher" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; try disposer . accept ( resource ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( new CompositeException ( e , ex ) , s ) ; return ; EmptySubscription . error ( e , s ) ; return ; UsingSubscriber < T , D > us = new UsingSubscriber < > ( s , resource , disposer , eager ) ; source . subscribe ( us ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( eager ) Throwable innerError = null ; if ( compareAndSet ( false , true ) ) try disposer . accept ( resource ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; innerError = e ; if ( innerError != null ) downstream . onError ( new CompositeException ( t , innerError ) ) ; else downstream . onError ( t ) ; else downstream . onError ( t ) ; disposeResource ( ) ; 
if ( eager ) if ( compareAndSet ( false , true ) ) try disposer . accept ( resource ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; downstream . onComplete ( ) ; else downstream . onComplete ( ) ; disposeResource ( ) ; 
if ( eager ) disposeResource ( ) ; upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; else upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; disposeResource ( ) ; 
if ( compareAndSet ( false , true ) ) try disposer . accept ( resource ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
source . subscribe ( new OnErrorReturnSubscriber < > ( s , valueSupplier ) ) ; 
T v ; try v = Objects . requireNonNull ( valueSupplier . apply ( t ) , "The valueSupplier returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( t , ex ) ) ; return ; complete ( v ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new IgnoreElementsSubscriber < > ( t ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableIgnoreElements < > ( source ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
upstream = SubscriptionHelper . CANCELLED ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
source . subscribe ( new ReduceSubscriber < > ( s , reducer ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( upstream == SubscriptionHelper . CANCELLED ) RxJavaPlugins . onError ( t ) ; return ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
if ( upstream == SubscriptionHelper . CANCELLED ) return ; upstream = SubscriptionHelper . CANCELLED ; T v = value ; if ( v != null ) complete ( v ) ; else downstream . onComplete ( ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
U u ; try u = Objects . requireNonNull ( initialSupplier . get ( ) , "The initial value supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; source . subscribe ( new CollectSubscriber < > ( s , u , collector ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; complete ( u ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
source . subscribe ( new MaterializeSubscriber < > ( s ) ) ; 
complete ( Notification . createOnError ( t ) ) ; 
complete ( Notification . createOnComplete ( ) ) ; 
if ( n . isOnError ( ) ) RxJavaPlugins . onError ( n . getError ( ) ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( false ) ; s . onSubscribe ( sa ) ; RetryBiSubscriber < T > rs = new RetryBiSubscriber < > ( s , predicate , sa , source ) ; rs . subscribeNext ( ) ; 
sa . setSubscription ( s ) ; 
boolean b ; try b = predicate . test ( ++ retries , t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; if ( ! b ) downstream . onError ( t ) ; return ; subscribeNext ( ) ; 
downstream . onComplete ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; for ( ; ; ) if ( sa . isCancelled ( ) ) return ; long p = produced ; if ( p != 0L ) produced = 0L ; sa . produced ( p ) ; source . subscribe ( this ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
JoinSubscription < TLeft , TRight , TLeftEnd , TRightEnd , R > parent = new JoinSubscription < > ( s , leftEnd , rightEnd , resultSelector ) ; s . onSubscribe ( parent ) ; LeftRightSubscriber left = new LeftRightSubscriber ( parent , true ) ; parent . disposables . add ( left ) ; LeftRightSubscriber right = new LeftRightSubscriber ( parent , false ) ; parent . disposables . add ( right ) ; source . subscribe ( left ) ; other . subscribe ( right ) ; 
if ( cancelled ) return ; cancelled = true ; cancelAll ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
disposables . dispose ( ) ; 
Throwable ex = ExceptionHelper . terminate ( error ) ; lefts . clear ( ) ; rights . clear ( ) ; a . onError ( ex ) ; 
Exceptions . throwIfFatal ( exc ) ; ExceptionHelper . addThrowable ( error , exc ) ; q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; SpscLinkedArrayQueue < Object > q = queue ; Subscriber < ? super R > a = downstream ; for ( ; ; ) for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; Throwable ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; boolean d = active . get ( ) == 0 ; Integer mode = ( Integer ) q . poll ( ) ; boolean empty = mode == null ; if ( d && empty ) lefts . clear ( ) ; rights . clear ( ) ; disposables . dispose ( ) ; a . onComplete ( ) ; return ; if ( empty ) break ; Object val = q . poll ( ) ; if ( mode == LEFT_VALUE ) @ SuppressWarnings ( "unchecked" ) TLeft left = ( TLeft ) val ; int idx = leftIndex ++ ; lefts . put ( idx , left ) ; Publisher < TLeftEnd > p ; try p = Objects . requireNonNull ( leftEnd . apply ( left ) , "The leftEnd returned a null Publisher" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; LeftRightEndSubscriber end = new LeftRightEndSubscriber ( this , true , idx ) ; disposables . add ( end ) ; p . subscribe ( end ) ; ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; long r = requested . get ( ) ; long e = 0L ; for ( TRight right : rights . values ( ) ) R w ; try w = Objects . requireNonNull ( resultSelector . apply ( left , right ) , "The resultSelector returned a null value" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; if ( e != r ) a . onNext ( w ) ; e ++ ; else ExceptionHelper . addThrowable ( error , new MissingBackpressureException ( "Could not emit value due to lack of requests" ) ) ; q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; else if ( mode == RIGHT_VALUE ) @ SuppressWarnings ( "unchecked" ) TRight right = ( TRight ) val ; int idx = rightIndex ++ ; rights . put ( idx , right ) ; Publisher < TRightEnd > p ; try p = Objects . requireNonNull ( rightEnd . apply ( right ) , "The rightEnd returned a null Publisher" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; LeftRightEndSubscriber end = new LeftRightEndSubscriber ( this , false , idx ) ; disposables . add ( end ) ; p . subscribe ( end ) ; ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; long r = requested . get ( ) ; long e = 0L ; for ( TLeft left : lefts . values ( ) ) R w ; try w = Objects . requireNonNull ( resultSelector . apply ( left , right ) , "The resultSelector returned a null value" ) ; catch ( Throwable exc ) fail ( exc , a , q ) ; return ; if ( e != r ) a . onNext ( w ) ; e ++ ; else ExceptionHelper . addThrowable ( error , new MissingBackpressureException ( "Could not emit value due to lack of requests" ) ) ; q . clear ( ) ; cancelAll ( ) ; errorAll ( a ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; else if ( mode == LEFT_CLOSE ) LeftRightEndSubscriber end = ( LeftRightEndSubscriber ) val ; lefts . remove ( end . index ) ; disposables . remove ( end ) ; else LeftRightEndSubscriber end = ( LeftRightEndSubscriber ) val ; rights . remove ( end . index ) ; disposables . remove ( end ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( ExceptionHelper . addThrowable ( error , ex ) ) active . decrementAndGet ( ) ; drain ( ) ; else RxJavaPlugins . onError ( ex ) ; 
if ( ExceptionHelper . addThrowable ( error , ex ) ) drain ( ) ; else RxJavaPlugins . onError ( ex ) ; 
source . subscribe ( new BackpressureBufferSubscriber < > ( s , bufferSize , unbounded , delayError , onOverflow ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
error = t ; done = true ; if ( outputFused ) downstream . onError ( t ) ; else drain ( ) ; 
done = true ; if ( outputFused ) downstream . onComplete ( ) ; else drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . cancel ( ) ; if ( ! outputFused && getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; final SimplePlainQueue < T > q = queue ; final Subscriber < ? super T > a = downstream ; for ( ; ; ) if ( checkTerminated ( done , q . isEmpty ( ) , a ) ) return ; long r = requested . get ( ) ; long e = 0L ; while ( e != r ) boolean d = done ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a ) ) return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == r ) boolean d = done ; boolean empty = q . isEmpty ( ) ; if ( checkTerminated ( d , empty , a ) ) return ; if ( e != 0L ) if ( r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
return queue . poll ( ) ; 
queue . clear ( ) ; 
return queue . isEmpty ( ) ; 
source . subscribe ( new ConcatMapEagerDelayErrorSubscriber < > ( s , mapper , maxConcurrency , prefetch , errorMode ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( maxConcurrency == Integer . MAX_VALUE ? Long . MAX_VALUE : maxConcurrency ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( cancelled ) return ; cancelled = true ; upstream . cancel ( ) ; errors . tryTerminateAndReport ( ) ; drainAndCancel ( ) ; 
if ( getAndIncrement ( ) == 0 ) do cancelAll ( ) ; while ( decrementAndGet ( ) != 0 ) ; 
InnerQueuedSubscriber < R > inner = current ; current = null ; if ( inner != null ) inner . cancel ( ) ; while ( ( inner = subscribers . poll ( ) ) != null ) inner . cancel ( ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) inner . setDone ( ) ; if ( errorMode != ErrorMode . END ) upstream . cancel ( ) ; drain ( ) ; 
inner . setDone ( ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; InnerQueuedSubscriber < R > inner = current ; Subscriber < ? super R > a = downstream ; ErrorMode em = errorMode ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; if ( inner == null ) if ( em != ErrorMode . END ) Throwable ex = errors . get ( ) ; if ( ex != null ) cancelAll ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean outerDone = done ; inner = subscribers . poll ( ) ; if ( outerDone && inner == null ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( inner != null ) current = inner ; boolean continueNextSource = false ; if ( inner != null ) SimpleQueue < R > q = inner . queue ( ) ; if ( q != null ) while ( e != r ) if ( cancelled ) cancelAll ( ) ; return ; if ( em == ErrorMode . IMMEDIATE ) Throwable ex = errors . get ( ) ; if ( ex != null ) current = null ; inner . cancel ( ) ; cancelAll ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = inner . isDone ( ) ; R v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; current = null ; inner . cancel ( ) ; cancelAll ( ) ; a . onError ( ex ) ; return ; boolean empty = v == null ; if ( d && empty ) inner = null ; current = null ; upstream . request ( 1 ) ; continueNextSource = true ; break ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; inner . request ( 1L ) ; if ( e == r ) if ( cancelled ) cancelAll ( ) ; return ; if ( em == ErrorMode . IMMEDIATE ) Throwable ex = errors . get ( ) ; if ( ex != null ) current = null ; inner . cancel ( ) ; cancelAll ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = inner . isDone ( ) ; boolean empty = q . isEmpty ( ) ; if ( d && empty ) inner = null ; current = null ; upstream . request ( 1 ) ; continueNextSource = true ; if ( e != 0L && r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; if ( continueNextSource ) continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
source . subscribe ( new TakeSubscriber < > ( s , n ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) if ( remaining == 0L ) s . cancel ( ) ; EmptySubscription . complete ( downstream ) ; else this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( remaining > 0L ) remaining = 0L ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( remaining > 0L ) remaining = 0L ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
source . subscribe ( new OnBackpressureBufferStrategySubscriber < > ( s , onOverflow , strategy , bufferSize ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
cancelled = true ; upstream . cancel ( ) ; if ( getAndIncrement ( ) == 0 ) clear ( deque ) ; 
synchronized ( dq ) dq . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Deque < T > dq = deque ; Subscriber < ? super T > a = downstream ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) if ( cancelled ) clear ( dq ) ; return ; boolean d = done ; T v ; synchronized ( dq ) v = dq . poll ( ) ; boolean empty = v == null ; if ( d ) Throwable ex = error ; if ( ex != null ) clear ( dq ) ; a . onError ( ex ) ; return ; if ( empty ) a . onComplete ( ) ; return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == r ) if ( cancelled ) clear ( dq ) ; return ; boolean d = done ; boolean empty ; synchronized ( dq ) empty = dq . isEmpty ( ) ; if ( d ) Throwable ex = error ; if ( ex != null ) clear ( dq ) ; a . onError ( ex ) ; return ; if ( empty ) a . onComplete ( ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
return source ; 
MergeWithSubscriber < T > parent = new MergeWithSubscriber < > ( subscriber ) ; subscriber . onSubscribe ( parent ) ; source . subscribe ( parent ) ; other . subscribe ( parent . otherObserver ) ; 
SubscriptionHelper . deferredSetOnce ( mainSubscription , requested , s ) ; 
DisposableHelper . dispose ( otherObserver ) ; HalfSerializer . onError ( downstream , ex , this , errors ) ; 
mainDone = true ; if ( otherDone ) HalfSerializer . onComplete ( downstream , this , errors ) ; 
SubscriptionHelper . cancel ( mainSubscription ) ; DisposableHelper . dispose ( otherObserver ) ; errors . tryTerminateAndReport ( ) ; 
SubscriptionHelper . cancel ( mainSubscription ) ; HalfSerializer . onError ( downstream , ex , this , errors ) ; 
otherDone = true ; if ( mainDone ) HalfSerializer . onComplete ( downstream , this , errors ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . otherError ( e ) ; 
parent . otherComplete ( ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( false ) ; s . onSubscribe ( sa ) ; RepeatSubscriber < T > rs = new RepeatSubscriber < > ( s , count != Long . MAX_VALUE ? count - 1 : Long . MAX_VALUE , sa , source ) ; rs . subscribeNext ( ) ; 
sa . setSubscription ( s ) ; 
downstream . onError ( t ) ; 
long r = remaining ; if ( r != Long . MAX_VALUE ) remaining = r - 1 ; if ( r != 0L ) subscribeNext ( ) ; else downstream . onComplete ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; for ( ; ; ) if ( sa . isCancelled ( ) ) return ; long p = produced ; if ( p != 0L ) produced = 0L ; sa . produced ( p ) ; source . subscribe ( this ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
MulticastProcessor < T > mp = new MulticastProcessor < > ( prefetch , delayError ) ; Publisher < ? extends R > other ; try other = Objects . requireNonNull ( selector . apply ( mp ) , "selector returned a null Publisher" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; OutputCanceller < R > out = new OutputCanceller < > ( s , mp ) ; other . subscribe ( out ) ; source . subscribe ( mp ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; processor . dispose ( ) ; 
downstream . onComplete ( ) ; processor . dispose ( ) ; 
upstream . cancel ( ) ; processor . dispose ( ) ; 
if ( SubscriptionHelper . setOnce ( this . upstream , s ) ) if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY ) ; if ( m == QueueSubscription . SYNC ) sourceMode = m ; queue = qs ; done = true ; drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) sourceMode = m ; queue = qs ; QueueDrainHelper . request ( s , prefetch ) ; return ; queue = QueueDrainHelper . createQueue ( prefetch ) ; QueueDrainHelper . request ( s , prefetch ) ; 
if ( ! done ) SubscriptionHelper . cancel ( upstream ) ; if ( wip . getAndIncrement ( ) == 0 ) SimpleQueue < T > q = queue ; if ( q != null ) q . clear ( ) ; 
return upstream . get ( ) == SubscriptionHelper . CANCELLED ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; drain ( ) ; 
if ( ! done ) done = true ; drain ( ) ; 
MulticastSubscription < T > ms = new MulticastSubscription < > ( s , this ) ; s . onSubscribe ( ms ) ; if ( add ( ms ) ) if ( ms . isCancelled ( ) ) remove ( ms ) ; return ; drain ( ) ; else Throwable ex = error ; if ( ex != null ) s . onError ( ex ) ; else s . onComplete ( ) ; 
if ( wip . getAndIncrement ( ) != 0 ) return ; int missed = 1 ; SimpleQueue < T > q = queue ; int upstreamConsumed = consumed ; int localLimit = limit ; boolean canRequest = sourceMode != QueueSubscription . SYNC ; AtomicReference < MulticastSubscription < T > [ ] > subs = subscribers ; MulticastSubscription < T > [ ] array = subs . get ( ) ; outer : for ( ; ; ) int n = array . length ; if ( q != null && n != 0 ) long r = Long . MAX_VALUE ; for ( MulticastSubscription < T > ms : array ) long u = ms . get ( ) - ms . emitted ; if ( u != Long . MIN_VALUE ) if ( r > u ) r = u ; else n -- ; if ( n == 0 ) r = 0 ; while ( r != 0 ) if ( isDisposed ( ) ) q . clear ( ) ; return ; boolean d = done ; if ( d && ! delayError ) Throwable ex = error ; if ( ex != null ) errorAll ( ex ) ; return ; T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; SubscriptionHelper . cancel ( upstream ) ; errorAll ( ex ) ; return ; boolean empty = v == null ; if ( d && empty ) Throwable ex = error ; if ( ex != null ) errorAll ( ex ) ; else completeAll ( ) ; return ; if ( empty ) break ; boolean subscribersChange = false ; for ( MulticastSubscription < T > ms : array ) long msr = ms . get ( ) ; if ( msr != Long . MIN_VALUE ) if ( msr != Long . MAX_VALUE ) ms . emitted ++ ; ms . downstream . onNext ( v ) ; else subscribersChange = true ; r -- ; if ( canRequest && ++ upstreamConsumed == localLimit ) upstreamConsumed = 0 ; upstream . get ( ) . request ( localLimit ) ; MulticastSubscription < T > [ ] freshArray = subs . get ( ) ; if ( subscribersChange || freshArray != array ) array = freshArray ; continue outer ; if ( r == 0 ) if ( isDisposed ( ) ) q . clear ( ) ; return ; boolean d = done ; if ( d && ! delayError ) Throwable ex = error ; if ( ex != null ) errorAll ( ex ) ; return ; if ( d && q . isEmpty ( ) ) Throwable ex = error ; if ( ex != null ) errorAll ( ex ) ; else completeAll ( ) ; return ; consumed = upstreamConsumed ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; if ( q == null ) q = queue ; array = subs . get ( ) ; 
for ( MulticastSubscription < T > ms : subscribers . getAndSet ( TERMINATED ) ) if ( ms . get ( ) != Long . MIN_VALUE ) ms . downstream . onError ( ex ) ; 
for ( MulticastSubscription < T > ms : subscribers . getAndSet ( TERMINATED ) ) if ( ms . get ( ) != Long . MIN_VALUE ) ms . downstream . onComplete ( ) ; 
if ( getAndSet ( Long . MIN_VALUE ) != Long . MIN_VALUE ) parent . remove ( this ) ; parent . drain ( ) ; 
return get ( ) == Long . MIN_VALUE ; 
if ( source instanceof Supplier ) T t ; try t = ( ( Supplier < T > ) source ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; if ( t == null ) EmptySubscription . complete ( subscriber ) ; return true ; Publisher < ? extends R > r ; try r = Objects . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; if ( r instanceof Supplier ) R u ; try u = ( ( Supplier < R > ) r ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; if ( u == null ) EmptySubscription . complete ( subscriber ) ; return true ; subscriber . onSubscribe ( new ScalarSubscription < > ( subscriber , u ) ) ; else r . subscribe ( subscriber ) ; return true ; return false ; 
Publisher < ? extends R > other ; try other = Objects . requireNonNull ( mapper . apply ( value ) , "The mapper returned a null Publisher" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; if ( other instanceof Supplier ) R u ; try u = ( ( Supplier < R > ) other ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; if ( u == null ) EmptySubscription . complete ( s ) ; return ; s . onSubscribe ( new ScalarSubscription < > ( s , u ) ) ; else other . subscribe ( s ) ; 
source . subscribe ( new UnsubscribeSubscriber < > ( s , scheduler ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( get ( ) ) RxJavaPlugins . onError ( t ) ; return ; downstream . onError ( t ) ; 
if ( ! get ( ) ) downstream . onComplete ( ) ; 
if ( compareAndSet ( false , true ) ) scheduler . scheduleDirect ( new Cancellation ( ) ) ; 
upstream . cancel ( ) ; 
Iterator < ? extends T > it ; try it = source . iterator ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; subscribe ( s , it ) ; 
boolean hasNext ; try hasNext = it . hasNext ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; if ( ! hasNext ) EmptySubscription . complete ( s ) ; return ; if ( s instanceof ConditionalSubscriber ) s . onSubscribe ( new IteratorConditionalSubscription < T > ( ( ConditionalSubscriber < ? super T > ) s , it ) ) ; else s . onSubscribe ( new IteratorSubscription < T > ( s , it ) ) ; 
if ( iterator == null ) return null ; if ( ! once ) once = true ; else if ( ! iterator . hasNext ( ) ) return null ; return Objects . requireNonNull ( iterator . next ( ) , "Iterator.next() returned a null value" ) ; 
Iterator < ? extends T > it = this . iterator ; if ( it != null ) if ( ! once || it . hasNext ( ) ) return false ; clear ( ) ; return true ; 
iterator = null ; 
cancelled = true ; 
Iterator < ? extends T > it = this . iterator ; Subscriber < ? super T > a = downstream ; for ( ; ; ) if ( cancelled ) return ; T t ; try t = it . next ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( cancelled ) return ; if ( t == null ) a . onError ( new NullPointerException ( "Iterator.next() returned a null value" ) ) ; return ; else a . onNext ( t ) ; if ( cancelled ) return ; boolean b ; try b = it . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( ! b ) if ( ! cancelled ) a . onComplete ( ) ; return ; 
Iterator < ? extends T > it = this . iterator ; ConditionalSubscriber < ? super T > a = downstream ; for ( ; ; ) if ( cancelled ) return ; T t ; try t = it . next ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( cancelled ) return ; if ( t == null ) a . onError ( new NullPointerException ( "Iterator.next() returned a null value" ) ) ; return ; else a . tryOnNext ( t ) ; if ( cancelled ) return ; boolean b ; try b = it . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( ! b ) if ( ! cancelled ) a . onComplete ( ) ; return ; 
MainSubscriber < T > parent = new MainSubscriber < > ( child , main ) ; child . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; 
main . subscribe ( this ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
SubscriptionHelper . cancel ( other ) ; SubscriptionHelper . cancel ( upstream ) ; 
SubscriptionHelper . deferredSetOnce ( upstream , this , s ) ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) s . request ( Long . MAX_VALUE ) ; 
Subscription s = get ( ) ; if ( s != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; s . cancel ( ) ; next ( ) ; 
Subscription s = get ( ) ; if ( s != SubscriptionHelper . CANCELLED ) downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
Subscription s = get ( ) ; if ( s != SubscriptionHelper . CANCELLED ) next ( ) ; 
BaseEmitter < T > emitter ; switch ( backpressure ) case MISSING : emitter = new MissingEmitter < > ( t ) ; break ; case ERROR : emitter = new ErrorAsyncEmitter < > ( t ) ; break ; case DROP : emitter = new DropAsyncEmitter < > ( t ) ; break ; case LATEST : emitter = new LatestAsyncEmitter < > ( t ) ; break ; default : emitter = new BufferAsyncEmitter < > ( t , bufferSize ( ) ) ; break ; t . onSubscribe ( emitter ) ; try source . subscribe ( emitter ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; emitter . onError ( ex ) ; 
if ( ! tryOnError ( t ) ) RxJavaPlugins . onError ( t ) ; 
if ( emitter . isCancelled ( ) || done ) return false ; if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; if ( errors . tryAddThrowable ( t ) ) done = true ; drain ( ) ; return true ; return false ; 
if ( emitter . isCancelled ( ) || done ) return ; done = true ; drain ( ) ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
BaseEmitter < T > e = emitter ; SimplePlainQueue < T > q = queue ; AtomicThrowable errors = this . errors ; int missed = 1 ; for ( ; ; ) for ( ; ; ) if ( e . isCancelled ( ) ) q . clear ( ) ; return ; if ( errors . get ( ) != null ) q . clear ( ) ; errors . tryTerminateConsumer ( e ) ; return ; boolean d = done ; T v = q . poll ( ) ; boolean empty = v == null ; if ( d && empty ) e . onComplete ( ) ; return ; if ( empty ) break ; e . onNext ( v ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
emitter . setDisposable ( d ) ; 
emitter . setCancellable ( c ) ; 
return emitter . requested ( ) ; 
return emitter . isCancelled ( ) ; 
return this ; 
return emitter . toString ( ) ; 
completeDownstream ( ) ; 
if ( isCancelled ( ) ) return ; try downstream . onComplete ( ) ; finally serial . dispose ( ) ; 
if ( e == null ) e = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; if ( ! signalError ( e ) ) RxJavaPlugins . onError ( e ) ; 
if ( e == null ) e = ExceptionHelper . createNullPointerException ( "tryOnError called with a null Throwable." ) ; return signalError ( e ) ; 
return errorDownstream ( e ) ; 
if ( isCancelled ( ) ) return false ; try downstream . onError ( e ) ; finally serial . dispose ( ) ; return true ; 
serial . dispose ( ) ; onUnsubscribed ( ) ; 
$EMPTY$
return serial . isDisposed ( ) ; 
$EMPTY$
serial . update ( d ) ; 
setDisposable ( new CancellableDisposable ( c ) ) ; 
return get ( ) ; 
return new SerializedEmitter < > ( this ) ; 
return String . format ( "%s{%s}" , getClass ( ) . getSimpleName ( ) , super . toString ( ) ) ; 
$EMPTY$
onError ( new MissingBackpressureException ( "create: could not emit value due to lack of requests" ) ) ; 
if ( done || isCancelled ( ) ) return false ; error = e ; done = true ; drain ( ) ; return true ; 
done = true ; drain ( ) ; 
drain ( ) ; 
if ( wip . getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( wip . getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final Subscriber < ? super T > a = downstream ; final SpscLinkedArrayQueue < T > q = queue ; for ( ; ; ) long r = get ( ) ; long e = 0L ; while ( e != r ) if ( isCancelled ( ) ) q . clear ( ) ; return ; boolean d = done ; T o = q . poll ( ) ; boolean empty = o == null ; if ( d && empty ) Throwable ex = error ; if ( ex != null ) errorDownstream ( ex ) ; else completeDownstream ( ) ; return ; if ( empty ) break ; a . onNext ( o ) ; e ++ ; if ( e == r ) if ( isCancelled ( ) ) q . clear ( ) ; return ; boolean d = done ; boolean empty = q . isEmpty ( ) ; if ( d && empty ) Throwable ex = error ; if ( ex != null ) errorDownstream ( ex ) ; else completeDownstream ( ) ; return ; if ( e != 0 ) BackpressureHelper . produced ( this , e ) ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( done || isCancelled ( ) ) return false ; error = e ; done = true ; drain ( ) ; return true ; 
done = true ; drain ( ) ; 
drain ( ) ; 
if ( wip . getAndIncrement ( ) == 0 ) queue . lazySet ( null ) ; 
if ( wip . getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final Subscriber < ? super T > a = downstream ; final AtomicReference < T > q = queue ; for ( ; ; ) long r = get ( ) ; long e = 0L ; while ( e != r ) if ( isCancelled ( ) ) q . lazySet ( null ) ; return ; boolean d = done ; T o = q . getAndSet ( null ) ; boolean empty = o == null ; if ( d && empty ) Throwable ex = error ; if ( ex != null ) errorDownstream ( ex ) ; else completeDownstream ( ) ; return ; if ( empty ) break ; a . onNext ( o ) ; e ++ ; if ( e == r ) if ( isCancelled ( ) ) q . lazySet ( null ) ; return ; boolean d = done ; boolean empty = q . get ( ) == null ; if ( d && empty ) Throwable ex = error ; if ( ex != null ) errorDownstream ( ex ) ; else completeDownstream ( ) ; return ; if ( e != 0 ) BackpressureHelper . produced ( this , e ) ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
source . subscribe ( new CountSubscriber ( s ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
count ++ ; 
downstream . onError ( t ) ; 
complete ( count ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
if ( size == skip ) source . subscribe ( new PublisherBufferExactSubscriber < > ( s , size , bufferSupplier ) ) ; else if ( skip > size ) source . subscribe ( new PublisherBufferSkipSubscriber < > ( s , size , skip , bufferSupplier ) ) ; else source . subscribe ( new PublisherBufferOverlappingSubscriber < > ( s , size , skip , bufferSupplier ) ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; buffer = null ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; C b = buffer ; buffer = null ; if ( b != null ) downstream . onNext ( b ) ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; buffer = null ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; C b = buffer ; buffer = null ; if ( b != null ) downstream . onNext ( b ) ; downstream . onComplete ( ) ; 
return cancelled ; 
cancelled = true ; upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; buffers . clear ( ) ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; long p = produced ; if ( p != 0L ) BackpressureHelper . produced ( this , p ) ; QueueDrainHelper . postComplete ( downstream , buffers , this , this ) ; 
if ( other == null ) TimeoutSubscriber < T > parent = new TimeoutSubscriber < > ( s , itemTimeoutIndicator ) ; s . onSubscribe ( parent ) ; parent . startFirstTimeout ( firstTimeoutIndicator ) ; source . subscribe ( parent ) ; else TimeoutFallbackSubscriber < T > parent = new TimeoutFallbackSubscriber < > ( s , itemTimeoutIndicator , other ) ; s . onSubscribe ( parent ) ; parent . startFirstTimeout ( firstTimeoutIndicator ) ; source . subscribe ( parent ) ; 
SubscriptionHelper . deferredSetOnce ( upstream , requested , s ) ; 
if ( firstTimeoutIndicator != null ) TimeoutConsumer consumer = new TimeoutConsumer ( 0L , this ) ; if ( task . replace ( consumer ) ) firstTimeoutIndicator . subscribe ( consumer ) ; 
if ( getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onComplete ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; task . dispose ( ) ; 
if ( SubscriptionHelper . setOnce ( this . upstream , s ) ) setSubscription ( s ) ; 
if ( firstTimeoutIndicator != null ) TimeoutConsumer consumer = new TimeoutConsumer ( 0L , this ) ; if ( task . replace ( consumer ) ) firstTimeoutIndicator . subscribe ( consumer ) ; 
if ( index . getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onError ( t ) ; task . dispose ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( index . getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onComplete ( ) ; task . dispose ( ) ; 
super . cancel ( ) ; task . dispose ( ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
Subscription upstream = get ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) upstream . cancel ( ) ; lazySet ( SubscriptionHelper . CANCELLED ) ; parent . onTimeout ( idx ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; parent . onTimeoutError ( idx , t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; parent . onTimeout ( idx ) ; 
SubscriptionHelper . cancel ( this ) ; 
return this . get ( ) == SubscriptionHelper . CANCELLED ; 
MergeWithObserver < T > parent = new MergeWithObserver < > ( subscriber ) ; subscriber . onSubscribe ( parent ) ; source . subscribe ( parent ) ; other . subscribe ( parent . otherObserver ) ; 
SubscriptionHelper . setOnce ( mainSubscription , s , prefetch ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) DisposableHelper . dispose ( otherObserver ) ; drain ( ) ; 
mainDone = true ; drain ( ) ; 
cancelled = true ; SubscriptionHelper . cancel ( mainSubscription ) ; DisposableHelper . dispose ( otherObserver ) ; errors . tryTerminateAndReport ( ) ; if ( getAndIncrement ( ) == 0 ) queue = null ; singleItem = null ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) SubscriptionHelper . cancel ( mainSubscription ) ; drain ( ) ; 
SimplePlainQueue < T > q = queue ; if ( q == null ) q = new SpscArrayQueue < > ( bufferSize ( ) ) ; queue = q ; return q ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
Subscriber < ? super T > actual = this . downstream ; int missed = 1 ; long e = emitted ; int c = consumed ; int lim = limit ; for ( ; ; ) long r = requested . get ( ) ; while ( e != r ) if ( cancelled ) singleItem = null ; queue = null ; return ; if ( errors . get ( ) != null ) singleItem = null ; queue = null ; errors . tryTerminateConsumer ( downstream ) ; return ; int os = otherState ; if ( os == OTHER_STATE_HAS_VALUE ) T v = singleItem ; singleItem = null ; otherState = OTHER_STATE_CONSUMED_OR_EMPTY ; os = OTHER_STATE_CONSUMED_OR_EMPTY ; actual . onNext ( v ) ; e ++ ; continue ; boolean d = mainDone ; SimplePlainQueue < T > q = queue ; T v = q != null ? q . poll ( ) : null ; boolean empty = v == null ; if ( d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY ) queue = null ; actual . onComplete ( ) ; return ; if ( empty ) break ; actual . onNext ( v ) ; e ++ ; if ( ++ c == lim ) c = 0 ; mainSubscription . get ( ) . request ( lim ) ; if ( e == r ) if ( cancelled ) singleItem = null ; queue = null ; return ; if ( errors . get ( ) != null ) singleItem = null ; queue = null ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = mainDone ; SimplePlainQueue < T > q = queue ; boolean empty = q == null || q . isEmpty ( ) ; if ( d && empty && otherState == 2 ) queue = null ; actual . onComplete ( ) ; return ; emitted = e ; consumed = c ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . otherError ( e ) ; 
source . subscribe ( new FlatMapCompletableMainSubscriber < > ( subscriber , mapper , delayErrors , maxConcurrency ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; int m = maxConcurrency ; if ( m == Integer . MAX_VALUE ) s . request ( Long . MAX_VALUE ) ; else s . request ( m ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) if ( delayErrors ) if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; else if ( maxConcurrency != Integer . MAX_VALUE ) upstream . request ( 1 ) ; else cancelled = true ; upstream . cancel ( ) ; set . dispose ( ) ; errors . tryTerminateConsumer ( downstream ) ; 
if ( decrementAndGet ( ) == 0 ) errors . tryTerminateConsumer ( downstream ) ; else if ( maxConcurrency != Integer . MAX_VALUE ) upstream . request ( 1 ) ; 
cancelled = true ; upstream . cancel ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
return null ; 
return true ; 
$EMPTY$
DisposableHelper . setOnce ( this , d ) ; 
innerComplete ( this ) ; 
innerError ( this , e ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
WindowBoundaryMainSubscriber < T , B > parent = new WindowBoundaryMainSubscriber < > ( subscriber , capacityHint ) ; subscriber . onSubscribe ( parent ) ; parent . innerNext ( ) ; other . subscribe ( parent . boundarySubscriber ) ; source . subscribe ( parent ) ; 
SubscriptionHelper . setOnce ( upstream , s , Long . MAX_VALUE ) ; 
boundarySubscriber . dispose ( ) ; if ( errors . tryAddThrowableOrReport ( e ) ) done = true ; drain ( ) ; 
boundarySubscriber . dispose ( ) ; done = true ; drain ( ) ; 
if ( stopWindows . compareAndSet ( false , true ) ) boundarySubscriber . dispose ( ) ; if ( windows . decrementAndGet ( ) == 0 ) SubscriptionHelper . cancel ( upstream ) ; 
if ( windows . decrementAndGet ( ) == 0 ) SubscriptionHelper . cancel ( upstream ) ; 
queue . offer ( NEXT_WINDOW ) ; drain ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; if ( errors . tryAddThrowableOrReport ( e ) ) done = true ; drain ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; done = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super Flowable < T > > downstream = this . downstream ; MpscLinkedQueue < Object > queue = this . queue ; AtomicThrowable errors = this . errors ; long emitted = this . emitted ; for ( ; ; ) for ( ; ; ) if ( windows . get ( ) == 0 ) queue . clear ( ) ; window = null ; return ; UnicastProcessor < T > w = window ; boolean d = done ; if ( d && errors . get ( ) != null ) queue . clear ( ) ; Throwable ex = errors . terminate ( ) ; if ( w != null ) window = null ; w . onError ( ex ) ; downstream . onError ( ex ) ; return ; Object v = queue . poll ( ) ; boolean empty = v == null ; if ( d && empty ) Throwable ex = errors . terminate ( ) ; if ( ex == null ) if ( w != null ) window = null ; w . onComplete ( ) ; downstream . onComplete ( ) ; else if ( w != null ) window = null ; w . onError ( ex ) ; downstream . onError ( ex ) ; return ; if ( empty ) break ; if ( v != NEXT_WINDOW ) w . onNext ( ( T ) v ) ; continue ; if ( w != null ) window = null ; w . onComplete ( ) ; if ( ! stopWindows . get ( ) ) w = UnicastProcessor . create ( capacityHint , this ) ; window = w ; windows . getAndIncrement ( ) ; if ( emitted != requested . get ( ) ) emitted ++ ; FlowableWindowSubscribeIntercept < T > intercept = new FlowableWindowSubscribeIntercept < > ( w ) ; downstream . onNext ( intercept ) ; if ( intercept . tryAbandon ( ) ) w . onComplete ( ) ; else SubscriptionHelper . cancel ( upstream ) ; boundarySubscriber . dispose ( ) ; errors . tryAddThrowableOrReport ( new MissingBackpressureException ( "Could not deliver a window due to lack of requests" ) ) ; done = true ; this . emitted = emitted ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; parent . innerError ( t ) ; 
if ( done ) return ; done = true ; parent . innerComplete ( ) ; 
TimerSubscriber ios = new TimerSubscriber ( s ) ; s . onSubscribe ( ios ) ; Disposable d = scheduler . scheduleDirect ( ios , delay , unit ) ; ios . setResource ( d ) ; 
DisposableHelper . dispose ( this ) ; 
if ( get ( ) != DisposableHelper . DISPOSED ) if ( requested ) downstream . onNext ( 0L ) ; lazySet ( EmptyDisposable . INSTANCE ) ; downstream . onComplete ( ) ; else lazySet ( EmptyDisposable . INSTANCE ) ; downstream . onError ( new MissingBackpressureException ( "Can't deliver value due to lack of requests" ) ) ; 
DisposableHelper . trySet ( this , d ) ; 
ConcatArraySubscriber < T > parent = new ConcatArraySubscriber < > ( sources , delayError , s ) ; s . onSubscribe ( parent ) ; parent . onComplete ( ) ; 
setSubscription ( s ) ; 
if ( delayError ) List < Throwable > list = errors ; if ( list == null ) list = new ArrayList < > ( sources . length - index + 1 ) ; errors = list ; list . add ( t ) ; onComplete ( ) ; else downstream . onError ( t ) ; 
if ( wip . getAndIncrement ( ) == 0 ) Publisher < ? extends T > [ ] sources = this . sources ; int n = sources . length ; int i = index ; for ( ; ; ) if ( i == n ) List < Throwable > list = errors ; if ( list != null ) if ( list . size ( ) == 1 ) downstream . onError ( list . get ( 0 ) ) ; else downstream . onError ( new CompositeException ( list ) ) ; else downstream . onComplete ( ) ; return ; Publisher < ? extends T > p = sources [ i ] ; if ( p == null ) Throwable ex = new NullPointerException ( "A Publisher entry is null" ) ; if ( delayError ) List < Throwable > list = errors ; if ( list == null ) list = new ArrayList < > ( n - i + 1 ) ; errors = list ; list . add ( ex ) ; i ++ ; continue ; else downstream . onError ( ex ) ; return ; else long r = produced ; if ( r != 0L ) produced = 0L ; produced ( r ) ; p . subscribe ( this ) ; index = ++ i ; if ( wip . decrementAndGet ( ) == 0 ) break ; 
this . source . subscribe ( new BackpressureErrorSubscriber < > ( s ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
return new MulticastFlowable < > ( connectableFactory , selector ) ; 
return create ( source , DEFAULT_UNBOUNDED_FACTORY ) ; 
final AtomicReference < ReplaySubscriber < T > > curr = new AtomicReference < > ( ) ; Publisher < T > onSubscribe = new ReplayPublisher < > ( curr , bufferFactory ) ; return RxJavaPlugins . onAssembly ( new FlowableReplay < > ( onSubscribe , source , curr , bufferFactory ) ) ; 
return source ; 
onSubscribe . subscribe ( s ) ; 
ReplaySubscriber < T > conn = current . get ( ) ; if ( conn != null && conn . isDisposed ( ) ) current . compareAndSet ( conn , null ) ; 
boolean doConnect ; ReplaySubscriber < T > ps ; for ( ; ; ) ps = current . get ( ) ; if ( ps == null || ps . isDisposed ( ) ) ReplayBuffer < T > buf ; try buf = bufferFactory . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; ReplaySubscriber < T > u = new ReplaySubscriber < > ( buf , current ) ; if ( ! current . compareAndSet ( ps , u ) ) continue ; ps = u ; doConnect = ! ps . shouldConnect . get ( ) && ps . shouldConnect . compareAndSet ( false , true ) ; break ; try connection . accept ( ps ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( doConnect ) ps . shouldConnect . compareAndSet ( true , false ) ; Exceptions . throwIfFatal ( ex ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; if ( doConnect ) source . subscribe ( ps ) ; 
return subscribers . get ( ) == TERMINATED ; 
subscribers . set ( TERMINATED ) ; current . compareAndSet ( ReplaySubscriber . this , null ) ; SubscriptionHelper . cancel ( this ) ; 
if ( SubscriptionHelper . setOnce ( this , p ) ) manageRequests ( ) ; for ( InnerSubscription < T > rp : subscribers . get ( ) ) buffer . replay ( rp ) ; 
if ( ! done ) done = true ; buffer . error ( e ) ; for ( InnerSubscription < T > rp : subscribers . getAndSet ( TERMINATED ) ) buffer . replay ( rp ) ; else RxJavaPlugins . onError ( e ) ; 
if ( ! done ) done = true ; buffer . complete ( ) ; for ( InnerSubscription < T > rp : subscribers . getAndSet ( TERMINATED ) ) buffer . replay ( rp ) ; 
AtomicInteger m = management ; if ( m . getAndIncrement ( ) != 0 ) return ; int missed = 1 ; for ( ; ; ) if ( isDisposed ( ) ) return ; Subscription p = get ( ) ; if ( p != null ) long alreadyRequested = requestedFromUpstream ; long downstreamMaxRequest = alreadyRequested ; for ( InnerSubscription < T > rp : subscribers . get ( ) ) downstreamMaxRequest = Math . max ( downstreamMaxRequest , rp . totalRequested . get ( ) ) ; long diff = downstreamMaxRequest - alreadyRequested ; if ( diff != 0L ) requestedFromUpstream = downstreamMaxRequest ; p . request ( diff ) ; missed = m . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
return get ( ) == CANCELLED ; 
dispose ( ) ; 
if ( getAndSet ( CANCELLED ) != CANCELLED ) parent . remove ( this ) ; parent . manageRequests ( ) ; index = null ; 
return ( U ) index ; 
add ( NotificationLite . error ( e ) ) ; size ++ ; 
add ( NotificationLite . complete ( ) ) ; size ++ ; 
Node head = get ( ) ; Node next = head . get ( ) ; if ( next == null ) throw new IllegalStateException ( "Empty list!" ) ; size -- ; setFirst ( next ) ; 
Object o = enterTransform ( NotificationLite . error ( e ) , true ) ; Node n = new Node ( o , ++ index ) ; addLast ( n ) ; truncateFinal ( ) ; 
Object o = enterTransform ( NotificationLite . complete ( ) , true ) ; Node n = new Node ( o , ++ index ) ; addLast ( n ) ; truncateFinal ( ) ; 
Node head = get ( ) ; if ( head . value != null ) Node n = new Node ( null , 0L ) ; n . lazySet ( head . get ( ) ) ; set ( n ) ; 
return value ; 
trimHead ( ) ; 
Node n = getHead ( ) ; for ( ; ; ) Node next = n . get ( ) ; if ( next != null ) Object o = next . value ; Object v = leaveTransform ( o ) ; if ( NotificationLite . isComplete ( v ) || NotificationLite . isError ( v ) ) break ; output . add ( NotificationLite . < T > getValue ( v ) ) ; n = next ; else break ; 
return tail . value != null && NotificationLite . isError ( leaveTransform ( tail . value ) ) ; 
return tail . value != null && NotificationLite . isComplete ( leaveTransform ( tail . value ) ) ; 
return get ( ) ; 
if ( size > limit ) removeFirst ( ) ; 
return ( ( Timed < ? > ) value ) . value ( ) ; 
long timeLimit = scheduler . now ( unit ) - maxAge ; Node prev = get ( ) ; Node next = prev . get ( ) ; int e = 0 ; for ( ; ; ) if ( size > 1 ) if ( size > limit ) e ++ ; size -- ; prev = next ; next = next . get ( ) ; else Timed < ? > v = ( Timed < ? > ) next . value ; if ( v . time ( ) <= timeLimit ) e ++ ; size -- ; prev = next ; next = next . get ( ) ; else break ; else break ; if ( e != 0 ) setFirst ( prev ) ; 
long timeLimit = scheduler . now ( unit ) - maxAge ; Node prev = get ( ) ; Node next = prev . get ( ) ; int e = 0 ; for ( ; ; ) if ( size > 1 ) Timed < ? > v = ( Timed < ? > ) next . value ; if ( v . time ( ) <= timeLimit ) e ++ ; size -- ; prev = next ; next = next . get ( ) ; else break ; else break ; if ( e != 0 ) setFirst ( prev ) ; 
long timeLimit = scheduler . now ( unit ) - maxAge ; Node prev = get ( ) ; Node next = prev . get ( ) ; for ( ; ; ) if ( next == null ) break ; Timed < ? > v = ( Timed < ? > ) next . value ; if ( NotificationLite . isComplete ( v . value ( ) ) || NotificationLite . isError ( v . value ( ) ) ) break ; if ( v . time ( ) <= timeLimit ) prev = next ; next = next . get ( ) ; else break ; return prev ; 
ConnectableFlowable < U > cf ; try cf = ExceptionHelper . nullCheck ( connectableFactory . get ( ) , "The connectableFactory returned a null ConnectableFlowable." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , child ) ; return ; Publisher < R > observable ; try observable = ExceptionHelper . nullCheck ( selector . apply ( cf ) , "The selector returned a null Publisher." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , child ) ; return ; final SubscriberResourceWrapper < R > srw = new SubscriberResourceWrapper < > ( child ) ; observable . subscribe ( srw ) ; cf . connect ( new DisposableConsumer ( srw ) ) ; 
srw . setResource ( r ) ; 
return new SizeBoundReplayBuffer < > ( bufferSize , eagerTruncate ) ; 
return new SizeAndTimeBoundReplayBuffer < > ( bufferSize , maxAge , unit , scheduler , eagerTruncate ) ; 
for ( ; ; ) ReplaySubscriber < T > r = curr . get ( ) ; if ( r == null ) ReplayBuffer < T > buf ; try buf = bufferFactory . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , child ) ; return ; ReplaySubscriber < T > u = new ReplaySubscriber < > ( buf , curr ) ; if ( ! curr . compareAndSet ( null , u ) ) continue ; r = u ; InnerSubscription < T > inner = new InnerSubscription < > ( r , child ) ; child . onSubscribe ( inner ) ; r . add ( inner ) ; if ( inner . isDisposed ( ) ) r . remove ( inner ) ; return ; r . manageRequests ( ) ; r . buffer . replay ( inner ) ; break ; 
return new UnboundedReplayBuffer < > ( 16 ) ; 
source . subscribe ( new AllSubscriber < > ( observer , predicate ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableAll < > ( source , predicate ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onSuccess ( true ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
source . subscribe ( new FlatMapSingleSubscriber < > ( s , mapper , delayErrors , maxConcurrency ) ) ; 
s . onSubscribe ( new ScalarSubscription < > ( s , value ) ) ; 
return value ; 
CancellableQueueFuseable < T > qs = new CancellableQueueFuseable < > ( ) ; subscriber . onSubscribe ( qs ) ; if ( ! qs . isDisposed ( ) ) try run . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! qs . isDisposed ( ) ) subscriber . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! qs . isDisposed ( ) ) subscriber . onComplete ( ) ; 
run . run ( ) ; return null ; 
U coll ; try coll = ExceptionHelper . nullCheck ( collectionSupplier . get ( ) , "The collectionSupplier returned a null Collection." ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; source . subscribe ( new ToListSubscriber < > ( observer , coll ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableToList < > ( source , collectionSupplier ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
value = null ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
upstream = SubscriptionHelper . CANCELLED ; downstream . onSuccess ( value ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
if ( s instanceof ConditionalSubscriber ) source . subscribe ( new DoOnEachConditionalSubscriber < > ( ( ConditionalSubscriber < ? super T > ) s , onNext , onError , onComplete , onAfterTerminate ) ) ; else source . subscribe ( new DoOnEachSubscriber < > ( s , onNext , onError , onComplete , onAfterTerminate ) ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; boolean relay = true ; try onError . accept ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; relay = false ; if ( relay ) downstream . onError ( t ) ; try onAfterTerminate . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
if ( done ) return ; try onComplete . run ( ) ; catch ( Throwable e ) fail ( e ) ; return ; done = true ; downstream . onComplete ( ) ; try onAfterTerminate . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
T v ; try v = qs . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; try onError . accept ( ex ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; throw new CompositeException ( ex , exc ) ; throw ExceptionHelper . < Exception > throwIfThrowable ( ex ) ; if ( v != null ) try try onNext . accept ( v ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; try onError . accept ( ex ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; throw new CompositeException ( ex , exc ) ; throw ExceptionHelper . < Exception > throwIfThrowable ( ex ) ; finally onAfterTerminate . run ( ) ; else if ( sourceMode == SYNC ) onComplete . run ( ) ; onAfterTerminate . run ( ) ; return v ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; boolean relay = true ; try onError . accept ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; relay = false ; if ( relay ) downstream . onError ( t ) ; try onAfterTerminate . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
if ( done ) return ; try onComplete . run ( ) ; catch ( Throwable e ) fail ( e ) ; return ; done = true ; downstream . onComplete ( ) ; try onAfterTerminate . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
T v ; try v = qs . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; try onError . accept ( ex ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; throw new CompositeException ( ex , exc ) ; throw ExceptionHelper . < Exception > throwIfThrowable ( ex ) ; if ( v != null ) try try onNext . accept ( v ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; try onError . accept ( ex ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; throw new CompositeException ( ex , exc ) ; throw ExceptionHelper . < Exception > throwIfThrowable ( ex ) ; finally onAfterTerminate . run ( ) ; else if ( sourceMode == SYNC ) onComplete . run ( ) ; onAfterTerminate . run ( ) ; return v ; 
EmptySubscription . complete ( s ) ; 
return null ; 
source . subscribe ( new LastSubscriber < > ( observer , defaultItem ) ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
upstream = SubscriptionHelper . CANCELLED ; item = null ; downstream . onError ( t ) ; 
upstream = SubscriptionHelper . CANCELLED ; T v = item ; if ( v != null ) item = null ; downstream . onSuccess ( v ) ; else v = defaultItem ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onError ( new NoSuchElementException ( ) ) ; 
source . subscribe ( new SingleElementSubscriber < > ( observer , defaultValue ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableSingle < > ( source , defaultValue , true ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; T v = value ; value = null ; if ( v == null ) v = defaultValue ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onError ( new NoSuchElementException ( ) ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
source . subscribe ( new WindowBoundaryMainSubscriber < > ( s , open , closingIndicator , bufferSize ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; open . subscribe ( startSubscriber ) ; s . request ( Long . MAX_VALUE ) ; 
startSubscriber . cancel ( ) ; resources . dispose ( ) ; if ( error . tryAddThrowableOrReport ( t ) ) upstreamDone = true ; drain ( ) ; 
startSubscriber . cancel ( ) ; resources . dispose ( ) ; upstreamDone = true ; drain ( ) ; 
if ( downstreamCancelled . compareAndSet ( false , true ) ) if ( windowCount . decrementAndGet ( ) == 0 ) upstream . cancel ( ) ; startSubscriber . cancel ( ) ; resources . dispose ( ) ; error . tryTerminateAndReport ( ) ; upstreamCanceled = true ; drain ( ) ; else startSubscriber . cancel ( ) ; 
if ( windowCount . decrementAndGet ( ) == 0 ) upstream . cancel ( ) ; startSubscriber . cancel ( ) ; resources . dispose ( ) ; error . tryTerminateAndReport ( ) ; upstreamCanceled = true ; drain ( ) ; 
upstream . cancel ( ) ; resources . dispose ( ) ; if ( error . tryAddThrowableOrReport ( t ) ) upstreamDone = true ; drain ( ) ; 
openDone = true ; drain ( ) ; 
upstream . cancel ( ) ; startSubscriber . cancel ( ) ; resources . dispose ( ) ; if ( error . tryAddThrowableOrReport ( t ) ) upstreamDone = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final Subscriber < ? super Flowable < T > > downstream = this . downstream ; final SimplePlainQueue < Object > queue = this . queue ; final List < UnicastProcessor < T > > windows = this . windows ; for ( ; ; ) if ( upstreamCanceled ) queue . clear ( ) ; windows . clear ( ) ; else boolean isDone = upstreamDone ; Object o = queue . poll ( ) ; boolean isEmpty = o == null ; if ( isDone ) if ( isEmpty || error . get ( ) != null ) terminateDownstream ( downstream ) ; upstreamCanceled = true ; continue ; if ( ! isEmpty ) if ( o instanceof WindowStartItem ) if ( ! downstreamCancelled . get ( ) ) long emitted = this . emitted ; if ( requested . get ( ) != emitted ) this . emitted = ++ emitted ; @ SuppressWarnings ( "unchecked" ) B startItem = ( ( WindowStartItem < B > ) o ) . item ; Publisher < V > endSource ; try endSource = Objects . requireNonNull ( closingIndicator . apply ( startItem ) , "The closingIndicator returned a null Publisher" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; startSubscriber . cancel ( ) ; resources . dispose ( ) ; Exceptions . throwIfFatal ( ex ) ; error . tryAddThrowableOrReport ( ex ) ; upstreamDone = true ; continue ; windowCount . getAndIncrement ( ) ; UnicastProcessor < T > newWindow = UnicastProcessor . create ( bufferSize , this ) ; WindowEndSubscriberIntercept < T , V > endSubscriber = new WindowEndSubscriberIntercept < > ( this , newWindow ) ; downstream . onNext ( endSubscriber ) ; if ( endSubscriber . tryAbandon ( ) ) newWindow . onComplete ( ) ; else windows . add ( newWindow ) ; resources . add ( endSubscriber ) ; endSource . subscribe ( endSubscriber ) ; else upstream . cancel ( ) ; startSubscriber . cancel ( ) ; resources . dispose ( ) ; error . tryAddThrowableOrReport ( new MissingBackpressureException ( FlowableWindowTimed . missingBackpressureMessage ( emitted ) ) ) ; upstreamDone = true ; else if ( o instanceof WindowEndSubscriberIntercept ) @ SuppressWarnings ( "unchecked" ) UnicastProcessor < T > w = ( ( WindowEndSubscriberIntercept < T , V > ) o ) . window ; windows . remove ( w ) ; resources . delete ( ( Disposable ) o ) ; w . onComplete ( ) ; else @ SuppressWarnings ( "unchecked" ) T item = ( T ) o ; for ( UnicastProcessor < T > w : windows ) w . onNext ( item ) ; continue ; else if ( openDone && windows . size ( ) == 0 ) upstream . cancel ( ) ; startSubscriber . cancel ( ) ; resources . dispose ( ) ; terminateDownstream ( downstream ) ; upstreamCanceled = true ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
Throwable ex = error . terminate ( ) ; if ( ex == null ) for ( UnicastProcessor < T > w : windows ) w . onComplete ( ) ; downstream . onComplete ( ) ; else if ( ex != ExceptionHelper . TERMINATED ) for ( UnicastProcessor < T > w : windows ) w . onError ( ex ) ; downstream . onError ( ex ) ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) s . request ( Long . MAX_VALUE ) ; 
parent . openError ( t ) ; 
parent . openComplete ( ) ; 
SubscriptionHelper . cancel ( this ) ; 
if ( SubscriptionHelper . setOnce ( upstream , s ) ) s . request ( Long . MAX_VALUE ) ; 
if ( isDisposed ( ) ) RxJavaPlugins . onError ( t ) ; else parent . closeError ( t ) ; 
parent . close ( this ) ; 
SubscriptionHelper . cancel ( upstream ) ; 
return upstream . get ( ) == SubscriptionHelper . CANCELLED ; 
window . subscribe ( s ) ; once . set ( true ) ; 
return ! once . get ( ) && once . compareAndSet ( false , true ) ; 
CancellableQueueFuseable < T > qs = new CancellableQueueFuseable < > ( ) ; subscriber . onSubscribe ( qs ) ; if ( ! qs . isDisposed ( ) ) try action . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! qs . isDisposed ( ) ) subscriber . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! qs . isDisposed ( ) ) subscriber . onComplete ( ) ; 
action . run ( ) ; return null ; 
Publisher < ? > [ ] others = otherArray ; int n = 0 ; if ( others == null ) others = new Publisher [ 8 ] ; try for ( Publisher < ? > p : otherIterable ) if ( n == others . length ) others = Arrays . copyOf ( others , n + ( n > > 1 ) ) ; others [ n ++ ] = p ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; else n = others . length ; if ( n == 0 ) new FlowableMap < > ( source , new SingletonArrayFunc ( ) ) . subscribeActual ( s ) ; return ; WithLatestFromSubscriber < T , R > parent = new WithLatestFromSubscriber < > ( s , combiner , n ) ; s . onSubscribe ( parent ) ; parent . subscribe ( others , n ) ; source . subscribe ( parent ) ; 
SubscriptionHelper . deferredSetOnce ( this . upstream , requested , s ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; cancelAllBut ( - 1 ) ; HalfSerializer . onError ( downstream , t , this , error ) ; 
if ( ! done ) done = true ; cancelAllBut ( - 1 ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
SubscriptionHelper . cancel ( upstream ) ; for ( WithLatestInnerSubscriber s : subscribers ) s . dispose ( ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
if ( ! hasValue ) hasValue = true ; parent . innerNext ( index , t ) ; 
parent . innerError ( index , t ) ; 
parent . innerComplete ( index , hasValue ) ; 
SubscriptionHelper . cancel ( this ) ; 
source . subscribe ( new SingleElementSubscriber < > ( s , defaultValue , failOnEmpty ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; T v = value ; value = null ; if ( v == null ) v = defaultValue ; if ( v == null ) if ( failOnEmpty ) downstream . onError ( new NoSuchElementException ( ) ) ; else downstream . onComplete ( ) ; else complete ( v ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
EqualCoordinator < T > parent = new EqualCoordinator < > ( observer , prefetch , comparer ) ; observer . onSubscribe ( parent ) ; parent . subscribe ( first , second ) ; 
return RxJavaPlugins . onAssembly ( new FlowableSequenceEqual < > ( first , second , comparer , prefetch ) ) ; 
source1 . subscribe ( first ) ; source2 . subscribe ( second ) ; 
first . cancel ( ) ; second . cancel ( ) ; errors . tryTerminateAndReport ( ) ; if ( getAndIncrement ( ) == 0 ) first . clear ( ) ; second . clear ( ) ; 
return first . get ( ) == SubscriptionHelper . CANCELLED ; 
first . cancel ( ) ; first . clear ( ) ; second . cancel ( ) ; second . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; for ( ; ; ) SimpleQueue < T > q1 = first . queue ; SimpleQueue < T > q2 = second . queue ; if ( q1 != null && q2 != null ) for ( ; ; ) if ( isDisposed ( ) ) first . clear ( ) ; second . clear ( ) ; return ; Throwable ex = errors . get ( ) ; if ( ex != null ) cancelAndClear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean d1 = first . done ; T a = v1 ; if ( a == null ) try a = q1 . poll ( ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; cancelAndClear ( ) ; errors . tryAddThrowableOrReport ( exc ) ; errors . tryTerminateConsumer ( downstream ) ; return ; v1 = a ; boolean e1 = a == null ; boolean d2 = second . done ; T b = v2 ; if ( b == null ) try b = q2 . poll ( ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; cancelAndClear ( ) ; errors . tryAddThrowableOrReport ( exc ) ; errors . tryTerminateConsumer ( downstream ) ; return ; v2 = b ; boolean e2 = b == null ; if ( d1 && d2 && e1 && e2 ) downstream . onSuccess ( true ) ; return ; if ( ( d1 && d2 ) && ( e1 != e2 ) ) cancelAndClear ( ) ; downstream . onSuccess ( false ) ; return ; if ( e1 || e2 ) break ; boolean c ; try c = comparer . test ( a , b ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; cancelAndClear ( ) ; errors . tryAddThrowableOrReport ( exc ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( ! c ) cancelAndClear ( ) ; downstream . onSuccess ( false ) ; return ; v1 = null ; v2 = null ; first . request ( ) ; second . request ( ) ; else if ( isDisposed ( ) ) first . clear ( ) ; second . clear ( ) ; return ; Throwable ex = errors . get ( ) ; if ( ex != null ) cancelAndClear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( errors . tryAddThrowableOrReport ( t ) ) drain ( ) ; 
source . subscribe ( new AnySubscriber < > ( observer , predicate ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableAny < > ( source , predicate ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
if ( ! done ) done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onSuccess ( false ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
if ( source instanceof Supplier ) T v ; try v = ( ( Supplier < T > ) source ) . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; if ( v == null ) EmptySubscription . complete ( s ) ; return ; Iterator < ? extends R > it ; try Iterable < ? extends R > iterable = mapper . apply ( v ) ; it = iterable . iterator ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; FlowableFromIterable . subscribe ( s , it ) ; return ; source . subscribe ( new FlattenIterableSubscriber < > ( s , mapper , prefetch ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( ANY ) ; if ( m == SYNC ) fusionMode = m ; this . queue = qs ; done = true ; downstream . onSubscribe ( this ) ; return ; if ( m == ASYNC ) fusionMode = m ; this . queue = qs ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; 
if ( ! done && ExceptionHelper . addThrowable ( error , t ) ) done = true ; drain ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( done ) return ; done = true ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . cancel ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; final Subscriber < ? super R > a = downstream ; final SimpleQueue < T > q = queue ; final boolean replenish = fusionMode != SYNC ; int missed = 1 ; Iterator < ? extends R > it = current ; for ( ; ; ) if ( it == null ) boolean d = done ; T t ; try t = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; ExceptionHelper . addThrowable ( error , ex ) ; ex = ExceptionHelper . terminate ( error ) ; current = null ; q . clear ( ) ; a . onError ( ex ) ; return ; boolean empty = t == null ; if ( checkTerminated ( d , empty , a , q ) ) return ; if ( t != null ) Iterable < ? extends R > iterable ; boolean b ; try iterable = mapper . apply ( t ) ; it = iterable . iterator ( ) ; b = it . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . cancel ( ) ; ExceptionHelper . addThrowable ( error , ex ) ; ex = ExceptionHelper . terminate ( error ) ; a . onError ( ex ) ; return ; if ( ! b ) it = null ; consumedOne ( replenish ) ; continue ; current = it ; if ( it != null ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) if ( checkTerminated ( done , false , a , q ) ) return ; R v ; try v = Objects . requireNonNull ( it . next ( ) , "The iterator returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; current = null ; upstream . cancel ( ) ; ExceptionHelper . addThrowable ( error , ex ) ; ex = ExceptionHelper . terminate ( error ) ; a . onError ( ex ) ; return ; a . onNext ( v ) ; if ( checkTerminated ( done , false , a , q ) ) return ; e ++ ; boolean b ; try b = it . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; current = null ; upstream . cancel ( ) ; ExceptionHelper . addThrowable ( error , ex ) ; ex = ExceptionHelper . terminate ( error ) ; a . onError ( ex ) ; return ; if ( ! b ) consumedOne ( replenish ) ; it = null ; current = null ; break ; if ( e == r ) boolean d = done ; boolean empty = q . isEmpty ( ) && it == null ; if ( checkTerminated ( d , empty , a , q ) ) return ; if ( e != 0L ) if ( r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; if ( it == null ) continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
current = null ; queue . clear ( ) ; 
return current == null && queue . isEmpty ( ) ; 
Iterator < ? extends R > it = current ; for ( ; ; ) if ( it == null ) T v = queue . poll ( ) ; if ( v == null ) return null ; it = mapper . apply ( v ) . iterator ( ) ; if ( ! it . hasNext ( ) ) it = null ; continue ; current = it ; R r = Objects . requireNonNull ( it . next ( ) , "The iterator returned a null value" ) ; if ( ! it . hasNext ( ) ) current = null ; return r ; 
Scheduler . Worker w = scheduler . createWorker ( ) ; final SubscribeOnSubscriber < T > sos = new SubscribeOnSubscriber < > ( s , w , source , nonScheduledRequests ) ; s . onSubscribe ( sos ) ; w . schedule ( sos ) ; 
lazySet ( Thread . currentThread ( ) ) ; Publisher < T > src = source ; source = null ; src . subscribe ( this ) ; 
if ( SubscriptionHelper . setOnce ( this . upstream , s ) ) long r = requested . getAndSet ( 0L ) ; if ( r != 0L ) requestUpstream ( r , s ) ; 
downstream . onError ( t ) ; worker . dispose ( ) ; 
downstream . onComplete ( ) ; worker . dispose ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; worker . dispose ( ) ; 
upstream . request ( n ) ; 
R r ; try r = Objects . requireNonNull ( seedSupplier . get ( ) , "The seed supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; source . subscribe ( new ScanSeedSubscriber < > ( s , accumulator , r , bufferSize ( ) ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( prefetch - 1 ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; drain ( ) ; 
if ( done ) return ; done = true ; drain ( ) ; 
cancelled = true ; upstream . cancel ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super R > a = downstream ; SimplePlainQueue < R > q = queue ; int lim = limit ; int c = consumed ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) if ( cancelled ) q . clear ( ) ; return ; boolean d = done ; if ( d ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; return ; R v = q . poll ( ) ; boolean empty = v == null ; if ( d && empty ) a . onComplete ( ) ; return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( ++ c == lim ) c = 0 ; upstream . request ( lim ) ; if ( e == r ) if ( done ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; return ; if ( q . isEmpty ( ) ) a . onComplete ( ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; consumed = c ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
Publisher < ? extends T > [ ] sources = array ; int count ; if ( sources == null ) count = 0 ; sources = new Publisher [ 8 ] ; try for ( Publisher < ? extends T > p : iterable ) if ( count == sources . length ) Publisher < ? extends T > [ ] b = new Publisher [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = Objects . requireNonNull ( p , "The Iterator returned a null Publisher" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; else count = sources . length ; if ( count == 0 ) EmptySubscription . complete ( s ) ; return ; if ( count == 1 ) sources [ 0 ] . subscribe ( new MapSubscriber < > ( s , new SingletonArrayFunc ( ) ) ) ; return ; CombineLatestCoordinator < T , R > coordinator = new CombineLatestCoordinator < > ( s , combiner , count , bufferSize , delayErrors ) ; s . onSubscribe ( coordinator ) ; coordinator . subscribe ( sources , count ) ; 
cancelled = true ; cancelAll ( ) ; drain ( ) ; 
final Subscriber < ? super R > a = downstream ; final SpscLinkedArrayQueue < Object > q = queue ; int missed = 1 ; for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; Throwable ex = error . get ( ) ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; return ; boolean d = done ; boolean empty = q . isEmpty ( ) ; if ( ! empty ) a . onNext ( null ) ; if ( d && empty ) a . onComplete ( ) ; return ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
final Subscriber < ? super R > a = downstream ; final SpscLinkedArrayQueue < Object > q = queue ; int missed = 1 ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) boolean d = done ; Object v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , q ) ) return ; if ( empty ) break ; T [ ] va = ( T [ ] ) q . poll ( ) ; R w ; try w = Objects . requireNonNull ( combiner . apply ( va ) , "The combiner returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelAll ( ) ; ExceptionHelper . addThrowable ( error , ex ) ; ex = ExceptionHelper . terminate ( error ) ; a . onError ( ex ) ; return ; a . onNext ( w ) ; ( ( CombineLatestInnerSubscriber < T > ) v ) . requestOne ( ) ; e ++ ; if ( e == r ) if ( checkTerminated ( done , q . isEmpty ( ) , a , q ) ) return ; if ( e != 0L && r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( getAndIncrement ( ) != 0 ) return ; if ( outputFused ) drainOutput ( ) ; else drainAsync ( ) ; 
for ( CombineLatestInnerSubscriber < T > inner : subscribers ) inner . cancel ( ) ; 
Object e = queue . poll ( ) ; if ( e == null ) return null ; T [ ] a = ( T [ ] ) queue . poll ( ) ; R r = Objects . requireNonNull ( combiner . apply ( a ) , "The combiner returned a null value" ) ; ( ( CombineLatestInnerSubscriber < T > ) e ) . requestOne ( ) ; return r ; 
queue . clear ( ) ; 
return queue . isEmpty ( ) ; 
SubscriptionHelper . setOnce ( this , s , prefetch ) ; 
parent . innerError ( index , t ) ; 
parent . innerComplete ( index ) ; 
SubscriptionHelper . cancel ( this ) ; 
int p = produced + 1 ; if ( p == limit ) produced = 0 ; get ( ) . request ( p ) ; else produced = p ; 
if ( FlowableScalarXMap . tryScalarXMapSubscribe ( source , s , mapper ) ) return ; source . subscribe ( new SwitchMapSubscriber < > ( s , mapper , bufferSize , delayErrors ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( ! done && errors . tryAddThrowable ( t ) ) if ( ! delayErrors ) disposeInner ( ) ; done = true ; drain ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( done ) return ; done = true ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . cancel ( ) ; disposeInner ( ) ; errors . tryTerminateAndReport ( ) ; 
SwitchMapInnerSubscriber < T , R > a = active . getAndSet ( ( SwitchMapInnerSubscriber < T , R > ) CANCELLED ) ; if ( a != CANCELLED && a != null ) a . cancel ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; final Subscriber < ? super R > a = downstream ; int missing = 1 ; for ( ; ; ) if ( cancelled ) return ; if ( done ) if ( delayErrors ) if ( active . get ( ) == null ) errors . tryTerminateConsumer ( a ) ; return ; else Throwable err = errors . get ( ) ; if ( err != null ) disposeInner ( ) ; errors . tryTerminateConsumer ( a ) ; return ; else if ( active . get ( ) == null ) a . onComplete ( ) ; return ; SwitchMapInnerSubscriber < T , R > inner = active . get ( ) ; SimpleQueue < R > q = inner != null ? inner . queue : null ; if ( q != null ) long r = requested . get ( ) ; long e = 0L ; boolean retry = false ; while ( e != r ) if ( cancelled ) return ; boolean d = inner . done ; R v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; inner . cancel ( ) ; errors . tryAddThrowableOrReport ( ex ) ; d = true ; v = null ; boolean empty = v == null ; if ( inner != active . get ( ) ) retry = true ; break ; if ( d ) if ( ! delayErrors ) Throwable err = errors . get ( ) ; if ( err != null ) errors . tryTerminateConsumer ( a ) ; return ; else if ( empty ) active . compareAndSet ( inner , null ) ; retry = true ; break ; else if ( empty ) active . compareAndSet ( inner , null ) ; retry = true ; break ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == r ) if ( inner . done ) if ( ! delayErrors ) Throwable err = errors . get ( ) ; if ( err != null ) disposeInner ( ) ; errors . tryTerminateConsumer ( a ) ; return ; else if ( q . isEmpty ( ) ) active . compareAndSet ( inner , null ) ; continue ; else if ( q . isEmpty ( ) ) active . compareAndSet ( inner , null ) ; continue ; if ( e != 0L ) if ( ! cancelled ) if ( r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; inner . request ( e ) ; if ( retry ) continue ; missing = addAndGet ( - missing ) ; if ( missing == 0 ) break ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < R > qs = ( QueueSubscription < R > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY | QueueSubscription . BOUNDARY ) ; if ( m == QueueSubscription . SYNC ) fusionMode = m ; queue = qs ; done = true ; parent . drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) fusionMode = m ; queue = qs ; s . request ( bufferSize ) ; return ; queue = new SpscArrayQueue < > ( bufferSize ) ; s . request ( bufferSize ) ; 
SwitchMapSubscriber < T , R > p = parent ; if ( index == p . unique && p . errors . tryAddThrowable ( t ) ) if ( ! p . delayErrors ) p . upstream . cancel ( ) ; p . done = true ; done = true ; p . drain ( ) ; else RxJavaPlugins . onError ( t ) ; 
SwitchMapSubscriber < T , R > p = parent ; if ( index == p . unique ) done = true ; p . drain ( ) ; 
SubscriptionHelper . cancel ( this ) ; 
Publisher < ? extends T > pub ; try pub = Objects . requireNonNull ( supplier . get ( ) , "The publisher supplied is null" ) ; catch ( Throwable t ) Exceptions . throwIfFatal ( t ) ; EmptySubscription . error ( t , s ) ; return ; pub . subscribe ( s ) ; 
source . subscribe ( new DetachSubscriber < > ( s ) ) ; 
Subscription s = this . upstream ; this . upstream = EmptyComponent . INSTANCE ; this . downstream = EmptyComponent . asSubscriber ( ) ; s . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
Subscriber < ? super T > a = downstream ; this . upstream = EmptyComponent . INSTANCE ; this . downstream = EmptyComponent . asSubscriber ( ) ; a . onError ( t ) ; 
Subscriber < ? super T > a = downstream ; this . upstream = EmptyComponent . INSTANCE ; this . downstream = EmptyComponent . asSubscriber ( ) ; a . onComplete ( ) ; 
Publisher < ? extends T > [ ] sources = this . sources ; int count = 0 ; if ( sources == null ) sources = new Publisher [ 8 ] ; try for ( Publisher < ? extends T > p : sourcesIterable ) if ( p == null ) EmptySubscription . error ( new NullPointerException ( "One of the sources is null" ) , s ) ; return ; if ( count == sources . length ) Publisher < ? extends T > [ ] b = new Publisher [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = p ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; else count = sources . length ; if ( count == 0 ) EmptySubscription . complete ( s ) ; return ; else if ( count == 1 ) sources [ 0 ] . subscribe ( s ) ; return ; AmbCoordinator < T > ac = new AmbCoordinator < > ( s , count ) ; ac . subscribe ( sources ) ; 
if ( winner . get ( ) != - 1 ) winner . lazySet ( - 1 ) ; for ( AmbInnerSubscriber < T > a : subscribers ) a . cancel ( ) ; 
SubscriptionHelper . deferredSetOnce ( this , missedRequested , s ) ; 
if ( won ) downstream . onError ( t ) ; else if ( parent . win ( index ) ) won = true ; downstream . onError ( t ) ; else get ( ) . cancel ( ) ; RxJavaPlugins . onError ( t ) ; 
if ( won ) downstream . onComplete ( ) ; else if ( parent . win ( index ) ) won = true ; downstream . onComplete ( ) ; else get ( ) . cancel ( ) ; 
SubscriptionHelper . cancel ( this ) ; 
Subscriber < ? super T > downstream ; if ( delayError ) downstream = t ; else downstream = new SerializedSubscriber < > ( t ) ; Scheduler . Worker w = scheduler . createWorker ( ) ; source . subscribe ( new DelaySubscriber < > ( downstream , delay , unit , w , delayError ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
w . schedule ( new OnError ( t ) , delayError ? delay : 0 , unit ) ; 
w . schedule ( new OnComplete ( ) , delay , unit ) ; 
upstream . cancel ( ) ; w . dispose ( ) ; 
downstream . onNext ( t ) ; 
try downstream . onError ( t ) ; finally w . dispose ( ) ; 
try downstream . onComplete ( ) ; finally w . dispose ( ) ; 
if ( s instanceof ConditionalSubscriber ) source . subscribe ( new DoAfterConditionalSubscriber < > ( ( ConditionalSubscriber < ? super T > ) s , onAfterNext ) ) ; else source . subscribe ( new DoAfterSubscriber < > ( s , onAfterNext ) ) ; 
T v = qs . poll ( ) ; if ( v != null ) onAfterNext . accept ( v ) ; return v ; 
T v = qs . poll ( ) ; if ( v != null ) onAfterNext . accept ( v ) ; return v ; 
S state ; try state = stateSupplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptySubscription . error ( e , s ) ; return ; s . onSubscribe ( new GeneratorSubscription < > ( s , generator , disposeState , state ) ) ; 
if ( ! cancelled ) cancelled = true ; if ( BackpressureHelper . add ( this , 1 ) == 0 ) S s = state ; state = null ; dispose ( s ) ; 
if ( terminate ) RxJavaPlugins . onError ( t ) ; else if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; terminate = true ; downstream . onError ( t ) ; 
if ( ! terminate ) terminate = true ; downstream . onComplete ( ) ; 
source . subscribe ( new TakeLastSubscriber < > ( s , count ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
downstream . onError ( t ) ; 
done = true ; drain ( ) ; 
cancelled = true ; upstream . cancel ( ) ; 
if ( wip . getAndIncrement ( ) == 0 ) Subscriber < ? super T > a = downstream ; long r = requested . get ( ) ; do if ( cancelled ) return ; if ( done ) long e = 0L ; while ( e != r ) if ( cancelled ) return ; T v = poll ( ) ; if ( v == null ) a . onComplete ( ) ; return ; a . onNext ( v ) ; e ++ ; if ( isEmpty ( ) ) a . onComplete ( ) ; return ; if ( e != 0L ) r = BackpressureHelper . produced ( requested , e ) ; while ( wip . decrementAndGet ( ) != 0 ) ; 
BufferBoundarySubscriber < T , U , Open , Close > parent = new BufferBoundarySubscriber < > ( s , bufferOpen , bufferClose , bufferSupplier ) ; s . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
if ( SubscriptionHelper . setOnce ( this . upstream , s ) ) BufferOpenSubscriber < Open > open = new BufferOpenSubscriber < > ( this ) ; subscribers . add ( open ) ; bufferOpen . subscribe ( open ) ; s . request ( Long . MAX_VALUE ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) subscribers . dispose ( ) ; synchronized ( this ) buffers = null ; done = true ; drain ( ) ; 
subscribers . dispose ( ) ; synchronized ( this ) Map < Long , C > bufs = buffers ; if ( bufs == null ) return ; for ( C b : bufs . values ( ) ) queue . offer ( b ) ; buffers = null ; done = true ; drain ( ) ; 
if ( SubscriptionHelper . cancel ( upstream ) ) cancelled = true ; subscribers . dispose ( ) ; synchronized ( this ) buffers = null ; if ( getAndIncrement ( ) != 0 ) queue . clear ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; subscribers . delete ( subscriber ) ; onError ( ex ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; long e = emitted ; Subscriber < ? super C > a = downstream ; SpscLinkedArrayQueue < C > q = queue ; for ( ; ; ) long r = requested . get ( ) ; while ( e != r ) if ( cancelled ) q . clear ( ) ; return ; boolean d = done ; if ( d && errors . get ( ) != null ) q . clear ( ) ; errors . tryTerminateConsumer ( a ) ; return ; C v = q . poll ( ) ; boolean empty = v == null ; if ( d && empty ) a . onComplete ( ) ; return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == r ) if ( cancelled ) q . clear ( ) ; return ; if ( done ) if ( errors . get ( ) != null ) q . clear ( ) ; errors . tryTerminateConsumer ( a ) ; return ; else if ( q . isEmpty ( ) ) a . onComplete ( ) ; return ; emitted = e ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
lazySet ( SubscriptionHelper . CANCELLED ) ; parent . boundaryError ( this , t ) ; 
lazySet ( SubscriptionHelper . CANCELLED ) ; parent . openComplete ( this ) ; 
SubscriptionHelper . cancel ( this ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
Subscription s = get ( ) ; if ( s != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; s . cancel ( ) ; parent . close ( this , index ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; parent . boundaryError ( this , t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( get ( ) != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; parent . close ( this , index ) ; 
SubscriptionHelper . cancel ( this ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
Collection < ? super K > collection ; try collection = ExceptionHelper . nullCheck ( collectionSupplier . get ( ) , "The collectionSupplier returned a null Collection." ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return ; source . subscribe ( new DistinctSubscriber < > ( subscriber , keySelector , collection ) ) ; 
if ( done ) RxJavaPlugins . onError ( e ) ; else done = true ; collection . clear ( ) ; downstream . onError ( e ) ; 
if ( ! done ) done = true ; collection . clear ( ) ; downstream . onComplete ( ) ; 
for ( ; ; ) T v = qs . poll ( ) ; if ( v == null || collection . add ( Objects . requireNonNull ( keySelector . apply ( v ) , "The keySelector returned a null key" ) ) ) return v ; else if ( sourceMode == QueueFuseable . ASYNC ) upstream . request ( 1 ) ; 
collection . clear ( ) ; super . clear ( ) ; 
source . subscribe ( new MapNotificationSubscriber < > ( s , onNextMapper , onErrorMapper , onCompleteSupplier ) ) ; 
R p ; try p = Objects . requireNonNull ( onErrorMapper . apply ( t ) , "The onError publisher returned is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; complete ( p ) ; 
R p ; try p = Objects . requireNonNull ( onCompleteSupplier . get ( ) , "The onComplete publisher returned is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; complete ( p ) ; 
MergeWithObserver < T > parent = new MergeWithObserver < > ( subscriber ) ; subscriber . onSubscribe ( parent ) ; source . subscribe ( parent ) ; other . subscribe ( parent . otherObserver ) ; 
SubscriptionHelper . setOnce ( mainSubscription , s , prefetch ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) DisposableHelper . dispose ( otherObserver ) ; drain ( ) ; 
mainDone = true ; drain ( ) ; 
cancelled = true ; SubscriptionHelper . cancel ( mainSubscription ) ; DisposableHelper . dispose ( otherObserver ) ; errors . tryTerminateAndReport ( ) ; if ( getAndIncrement ( ) == 0 ) queue = null ; singleItem = null ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) SubscriptionHelper . cancel ( mainSubscription ) ; drain ( ) ; 
otherState = OTHER_STATE_CONSUMED_OR_EMPTY ; drain ( ) ; 
SimplePlainQueue < T > q = queue ; if ( q == null ) q = new SpscArrayQueue < > ( bufferSize ( ) ) ; queue = q ; return q ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
Subscriber < ? super T > actual = this . downstream ; int missed = 1 ; long e = emitted ; int c = consumed ; int lim = limit ; for ( ; ; ) long r = requested . get ( ) ; while ( e != r ) if ( cancelled ) singleItem = null ; queue = null ; return ; if ( errors . get ( ) != null ) singleItem = null ; queue = null ; errors . tryTerminateConsumer ( downstream ) ; return ; int os = otherState ; if ( os == OTHER_STATE_HAS_VALUE ) T v = singleItem ; singleItem = null ; otherState = OTHER_STATE_CONSUMED_OR_EMPTY ; os = OTHER_STATE_CONSUMED_OR_EMPTY ; actual . onNext ( v ) ; e ++ ; continue ; boolean d = mainDone ; SimplePlainQueue < T > q = queue ; T v = q != null ? q . poll ( ) : null ; boolean empty = v == null ; if ( d && empty && os == OTHER_STATE_CONSUMED_OR_EMPTY ) queue = null ; actual . onComplete ( ) ; return ; if ( empty ) break ; actual . onNext ( v ) ; e ++ ; if ( ++ c == lim ) c = 0 ; mainSubscription . get ( ) . request ( lim ) ; if ( e == r ) if ( cancelled ) singleItem = null ; queue = null ; return ; if ( errors . get ( ) != null ) singleItem = null ; queue = null ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = mainDone ; SimplePlainQueue < T > q = queue ; boolean empty = q == null || q . isEmpty ( ) ; if ( d && empty && otherState == 2 ) queue = null ; actual . onComplete ( ) ; return ; emitted = e ; consumed = c ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . otherError ( e ) ; 
parent . otherComplete ( ) ; 
source . subscribe ( new ElementAtSubscriber < > ( observer , index ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableElementAt < > ( source , index , null , false ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( index + 1 ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
upstream = SubscriptionHelper . CANCELLED ; if ( ! done ) done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
source . subscribe ( new TakeLastTimedSubscriber < > ( s , count , time , unit , scheduler , bufferSize , delayError ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( delayError ) trim ( scheduler . now ( unit ) , queue ) ; error = t ; done = true ; drain ( ) ; 
trim ( scheduler . now ( unit ) , queue ) ; done = true ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . cancel ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final Subscriber < ? super T > a = downstream ; final SpscLinkedArrayQueue < Object > q = queue ; final boolean delayError = this . delayError ; for ( ; ; ) if ( done ) boolean empty = q . isEmpty ( ) ; if ( checkTerminated ( empty , a , delayError ) ) return ; long r = requested . get ( ) ; long e = 0L ; for ( ; ; ) Object ts = q . peek ( ) ; empty = ts == null ; if ( checkTerminated ( empty , a , delayError ) ) return ; if ( r == e ) break ; q . poll ( ) ; @ SuppressWarnings ( "unchecked" ) T o = ( T ) q . poll ( ) ; a . onNext ( o ) ; e ++ ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
source . subscribe ( new HideSubscriber < > ( s ) ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
Publisher < ? extends T > [ ] sources = this . sources ; int count = 0 ; if ( sources == null ) sources = new Publisher [ 8 ] ; for ( Publisher < ? extends T > p : sourcesIterable ) if ( count == sources . length ) Publisher < ? extends T > [ ] b = new Publisher [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = p ; else count = sources . length ; if ( count == 0 ) EmptySubscription . complete ( s ) ; return ; ZipCoordinator < T , R > coordinator = new ZipCoordinator < > ( s , zipper , count , bufferSize , delayError ) ; s . onSubscribe ( coordinator ) ; coordinator . subscribe ( sources , count ) ; 
if ( ! cancelled ) cancelled = true ; cancelAll ( ) ; 
for ( ZipSubscriber < T , R > s : subscribers ) s . cancel ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; final Subscriber < ? super R > a = downstream ; final ZipSubscriber < T , R > [ ] qs = subscribers ; final int n = qs . length ; Object [ ] values = current ; int missed = 1 ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( r != e ) if ( cancelled ) return ; if ( ! delayErrors && errors . get ( ) != null ) cancelAll ( ) ; errors . tryTerminateConsumer ( a ) ; return ; boolean empty = false ; for ( int j = 0 ; j < n ; j ++ ) ZipSubscriber < T , R > inner = qs [ j ] ; if ( values [ j ] == null ) boolean d = inner . done ; SimpleQueue < T > q = inner . queue ; T v = null ; try v = q != null ? q . poll ( ) : null ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; errors . tryAddThrowableOrReport ( ex ) ; if ( ! delayErrors ) cancelAll ( ) ; errors . tryTerminateConsumer ( a ) ; return ; d = true ; boolean sourceEmpty = v == null ; if ( d && sourceEmpty ) cancelAll ( ) ; errors . tryTerminateConsumer ( a ) ; return ; if ( ! sourceEmpty ) values [ j ] = v ; else empty = true ; if ( empty ) break ; R v ; try v = Objects . requireNonNull ( zipper . apply ( values . clone ( ) ) , "The zipper returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; cancelAll ( ) ; errors . tryAddThrowableOrReport ( ex ) ; errors . tryTerminateConsumer ( a ) ; return ; a . onNext ( v ) ; e ++ ; Arrays . fill ( values , null ) ; if ( r == e ) if ( cancelled ) return ; if ( ! delayErrors && errors . get ( ) != null ) cancelAll ( ) ; errors . tryTerminateConsumer ( a ) ; return ; for ( int j = 0 ; j < n ; j ++ ) ZipSubscriber < T , R > inner = qs [ j ] ; if ( values [ j ] == null ) boolean d = inner . done ; SimpleQueue < T > q = inner . queue ; T v = null ; try v = q != null ? q . poll ( ) : null ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; errors . tryAddThrowableOrReport ( ex ) ; if ( ! delayErrors ) cancelAll ( ) ; errors . tryTerminateConsumer ( a ) ; return ; d = true ; boolean empty = v == null ; if ( d && empty ) cancelAll ( ) ; errors . tryTerminateConsumer ( a ) ; return ; if ( ! empty ) values [ j ] = v ; if ( e != 0L ) for ( ZipSubscriber < T , R > inner : qs ) inner . request ( e ) ; if ( r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) if ( s instanceof QueueSubscription ) QueueSubscription < T > f = ( QueueSubscription < T > ) s ; int m = f . requestFusion ( QueueSubscription . ANY | QueueSubscription . BOUNDARY ) ; if ( m == QueueSubscription . SYNC ) sourceMode = m ; queue = f ; done = true ; parent . drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) sourceMode = m ; queue = f ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; s . request ( prefetch ) ; 
parent . error ( this , t ) ; 
done = true ; parent . drain ( ) ; 
SubscriptionHelper . cancel ( this ) ; 
if ( s instanceof ConditionalSubscriber ) s . onSubscribe ( new RangeConditionalSubscription ( ( ConditionalSubscriber < ? super Integer > ) s , start , end ) ) ; else s . onSubscribe ( new RangeSubscription ( s , start , end ) ) ; 
int i = index ; if ( i == end ) return null ; index = i + 1 ; return i ; 
return index == end ; 
index = end ; 
cancelled = true ; 
int f = end ; Subscriber < ? super Integer > a = downstream ; for ( int i = index ; i != f ; i ++ ) if ( cancelled ) return ; a . onNext ( i ) ; if ( cancelled ) return ; a . onComplete ( ) ; 
int f = end ; ConditionalSubscriber < ? super Integer > a = downstream ; for ( int i = index ; i != f ; i ++ ) if ( cancelled ) return ; a . tryOnNext ( i ) ; if ( cancelled ) return ; a . onComplete ( ) ; 
source . subscribe ( new SubscriptionLambdaSubscriber < > ( s , onSubscribe , onRequest , onCancel ) ) ; 
try onSubscribe . accept ( s ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; s . cancel ( ) ; this . upstream = SubscriptionHelper . CANCELLED ; EmptySubscription . error ( e , downstream ) ; return ; if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( upstream != SubscriptionHelper . CANCELLED ) downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( upstream != SubscriptionHelper . CANCELLED ) downstream . onComplete ( ) ; 
Subscription s = upstream ; if ( s != SubscriptionHelper . CANCELLED ) upstream = SubscriptionHelper . CANCELLED ; try onCancel . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; s . cancel ( ) ; 
if ( other == null ) TimeoutSubscriber < T > parent = new TimeoutSubscriber < > ( s , timeout , unit , scheduler . createWorker ( ) ) ; s . onSubscribe ( parent ) ; parent . startTimeout ( 0L ) ; source . subscribe ( parent ) ; else TimeoutFallbackSubscriber < T > parent = new TimeoutFallbackSubscriber < > ( s , timeout , unit , scheduler . createWorker ( ) , other ) ; s . onSubscribe ( parent ) ; parent . startTimeout ( 0L ) ; source . subscribe ( parent ) ; 
SubscriptionHelper . deferredSetOnce ( upstream , requested , s ) ; 
if ( getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onError ( t ) ; worker . dispose ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onComplete ( ) ; worker . dispose ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; worker . dispose ( ) ; 
parent . onTimeout ( idx ) ; 
if ( SubscriptionHelper . setOnce ( upstream , s ) ) setSubscription ( s ) ; 
if ( index . getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onError ( t ) ; worker . dispose ( ) ; else RxJavaPlugins . onError ( t ) ; 
if ( index . getAndSet ( Long . MAX_VALUE ) != Long . MAX_VALUE ) task . dispose ( ) ; downstream . onComplete ( ) ; worker . dispose ( ) ; 
super . cancel ( ) ; worker . dispose ( ) ; 
arbiter . setSubscription ( s ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
if ( FlowableScalarXMap . tryScalarXMapSubscribe ( source , s , mapper ) ) return ; source . subscribe ( subscribe ( s , mapper , delayErrors , maxConcurrency , bufferSize ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; if ( ! cancelled ) if ( maxConcurrency == Integer . MAX_VALUE ) s . request ( Long . MAX_VALUE ) ; else s . request ( maxConcurrency ) ; 
SimplePlainQueue < U > q = queue ; if ( q == null ) if ( maxConcurrency == Integer . MAX_VALUE ) q = new SpscLinkedArrayQueue < > ( bufferSize ) ; else q = new SpscArrayQueue < > ( maxConcurrency ) ; queue = q ; return q ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; if ( errors . tryAddThrowableOrReport ( t ) ) done = true ; if ( ! delayErrors ) for ( InnerSubscriber < ? , ? > a : subscribers . getAndSet ( CANCELLED ) ) a . dispose ( ) ; drain ( ) ; 
if ( done ) return ; done = true ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; upstream . cancel ( ) ; disposeAll ( ) ; if ( getAndIncrement ( ) == 0 ) SimpleQueue < U > q = queue ; if ( q != null ) q . clear ( ) ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
final Subscriber < ? super U > child = this . downstream ; int missed = 1 ; for ( ; ; ) if ( checkTerminate ( ) ) return ; SimplePlainQueue < U > svq = queue ; long r = requested . get ( ) ; boolean unbounded = r == Long . MAX_VALUE ; long replenishMain = 0 ; if ( svq != null ) long scalarEmission = 0 ; U o = null ; while ( r != 0L ) o = svq . poll ( ) ; if ( checkTerminate ( ) ) return ; if ( o == null ) break ; child . onNext ( o ) ; replenishMain ++ ; scalarEmission ++ ; r -- ; if ( scalarEmission != 0L ) if ( unbounded ) r = Long . MAX_VALUE ; else r = requested . addAndGet ( - scalarEmission ) ; boolean d = done ; svq = queue ; InnerSubscriber < ? , ? > [ ] inner = subscribers . get ( ) ; int n = inner . length ; if ( d && ( svq == null || svq . isEmpty ( ) ) && n == 0 ) errors . tryTerminateConsumer ( downstream ) ; return ; boolean innerCompleted = false ; if ( n != 0 ) long startId = lastId ; int index = lastIndex ; if ( n <= index || inner [ index ] . id != startId ) if ( n <= index ) index = 0 ; int j = index ; for ( int i = 0 ; i < n ; i ++ ) if ( inner [ j ] . id == startId ) break ; j ++ ; if ( j == n ) j = 0 ; index = j ; lastIndex = j ; lastId = inner [ j ] . id ; int j = index ; sourceLoop : for ( int i = 0 ; i < n ; i ++ ) if ( checkTerminate ( ) ) return ; @ SuppressWarnings ( "unchecked" ) InnerSubscriber < T , U > is = ( InnerSubscriber < T , U > ) inner [ j ] ; U o = null ; for ( ; ; ) SimpleQueue < U > q = is . queue ; if ( q == null ) break ; long produced = 0 ; while ( r != 0L ) if ( checkTerminate ( ) ) return ; try o = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; is . dispose ( ) ; errors . tryAddThrowableOrReport ( ex ) ; if ( ! delayErrors ) upstream . cancel ( ) ; if ( checkTerminate ( ) ) return ; removeInner ( is ) ; innerCompleted = true ; i ++ ; continue sourceLoop ; if ( o == null ) break ; child . onNext ( o ) ; r -- ; produced ++ ; if ( produced != 0L ) if ( ! unbounded ) r = requested . addAndGet ( - produced ) ; else r = Long . MAX_VALUE ; is . requestMore ( produced ) ; if ( r == 0 || o == null ) break ; boolean innerDone = is . done ; SimpleQueue < U > innerQueue = is . queue ; if ( innerDone && ( innerQueue == null || innerQueue . isEmpty ( ) ) ) removeInner ( is ) ; if ( checkTerminate ( ) ) return ; replenishMain ++ ; innerCompleted = true ; if ( r == 0L ) break ; j ++ ; if ( j == n ) j = 0 ; lastIndex = j ; lastId = inner [ j ] . id ; if ( replenishMain != 0L && ! cancelled ) upstream . request ( replenishMain ) ; if ( innerCompleted ) continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( cancelled ) clearScalarQueue ( ) ; return true ; if ( ! delayErrors && errors . get ( ) != null ) clearScalarQueue ( ) ; errors . tryTerminateConsumer ( downstream ) ; return true ; return false ; 
SimpleQueue < U > q = queue ; if ( q != null ) q . clear ( ) ; 
InnerSubscriber < ? , ? > [ ] a = subscribers . getAndSet ( CANCELLED ) ; if ( a != CANCELLED ) for ( InnerSubscriber < ? , ? > inner : a ) inner . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( SubscriptionHelper . setOnce ( this , s ) ) if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < U > qs = ( QueueSubscription < U > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY | QueueSubscription . BOUNDARY ) ; if ( m == QueueSubscription . SYNC ) fusionMode = m ; queue = qs ; done = true ; parent . drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) fusionMode = m ; queue = qs ; s . request ( bufferSize ) ; 
lazySet ( SubscriptionHelper . CANCELLED ) ; parent . innerError ( this , t ) ; 
done = true ; parent . drain ( ) ; 
SubscriptionHelper . cancel ( this ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
return source ; 
PublishConnection < T > conn ; boolean doConnect = false ; for ( ; ; ) conn = current . get ( ) ; if ( conn == null || conn . isDisposed ( ) ) PublishConnection < T > fresh = new PublishConnection < > ( current , bufferSize ) ; if ( ! current . compareAndSet ( conn , fresh ) ) continue ; conn = fresh ; doConnect = ! conn . connect . get ( ) && conn . connect . compareAndSet ( false , true ) ; break ; try connection . accept ( conn ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; if ( doConnect ) source . subscribe ( conn ) ; 
PublishConnection < T > conn ; for ( ; ; ) conn = current . get ( ) ; if ( conn == null ) PublishConnection < T > fresh = new PublishConnection < > ( current , bufferSize ) ; if ( ! current . compareAndSet ( conn , fresh ) ) continue ; conn = fresh ; break ; InnerSubscription < T > inner = new InnerSubscription < > ( s , conn ) ; s . onSubscribe ( inner ) ; if ( conn . add ( inner ) ) if ( inner . isCancelled ( ) ) conn . remove ( inner ) ; else conn . drain ( ) ; return ; Throwable ex = conn . error ; if ( ex != null ) inner . downstream . onError ( ex ) ; else inner . downstream . onComplete ( ) ; 
PublishConnection < T > conn = current . get ( ) ; if ( conn != null && conn . isDisposed ( ) ) current . compareAndSet ( conn , null ) ; 
subscribers . getAndSet ( TERMINATED ) ; current . compareAndSet ( this , null ) ; SubscriptionHelper . cancel ( upstream ) ; 
return subscribers . get ( ) == TERMINATED ; 
if ( SubscriptionHelper . setOnce ( this . upstream , s ) ) if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY | QueueSubscription . BOUNDARY ) ; if ( m == QueueSubscription . SYNC ) sourceMode = m ; queue = qs ; done = true ; drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) sourceMode = m ; queue = qs ; s . request ( bufferSize ) ; return ; queue = new SpscArrayQueue < > ( bufferSize ) ; s . request ( bufferSize ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; else error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; SimpleQueue < T > queue = this . queue ; int consumed = this . consumed ; int limit = this . bufferSize - ( this . bufferSize > > 2 ) ; boolean async = this . sourceMode != QueueSubscription . SYNC ; outer : for ( ; ; ) if ( queue != null ) long minDemand = Long . MAX_VALUE ; boolean hasDemand = false ; InnerSubscription < T > [ ] consumers = subscribers . get ( ) ; for ( InnerSubscription < T > inner : consumers ) long request = inner . get ( ) ; if ( request != Long . MIN_VALUE ) hasDemand = true ; minDemand = Math . min ( request - inner . emitted , minDemand ) ; if ( ! hasDemand ) minDemand = 0L ; while ( minDemand != 0L ) boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; upstream . get ( ) . cancel ( ) ; queue . clear ( ) ; done = true ; signalError ( ex ) ; return ; boolean empty = v == null ; if ( checkTerminated ( d , empty ) ) return ; if ( empty ) break ; for ( InnerSubscription < T > inner : consumers ) if ( ! inner . isCancelled ( ) ) inner . downstream . onNext ( v ) ; inner . emitted ++ ; if ( async && ++ consumed == limit ) consumed = 0 ; upstream . get ( ) . request ( limit ) ; minDemand -- ; if ( consumers != subscribers . get ( ) ) continue outer ; if ( checkTerminated ( done , queue . isEmpty ( ) ) ) return ; this . consumed = consumed ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; if ( queue == null ) queue = this . queue ; 
for ( InnerSubscription < T > inner : subscribers . getAndSet ( TERMINATED ) ) if ( ! inner . isCancelled ( ) ) inner . downstream . onError ( ex ) ; 
if ( getAndSet ( Long . MIN_VALUE ) != Long . MIN_VALUE ) parent . remove ( this ) ; parent . drain ( ) ; 
return get ( ) == Long . MIN_VALUE ; 
if ( timespan == timeskip ) if ( maxSize == Long . MAX_VALUE ) source . subscribe ( new WindowExactUnboundedSubscriber < > ( downstream , timespan , unit , scheduler , bufferSize ) ) ; return ; source . subscribe ( new WindowExactBoundedSubscriber < > ( downstream , timespan , unit , scheduler , bufferSize , maxSize , restartTimerOnMaxSize ) ) ; return ; source . subscribe ( new WindowSkipSubscriber < > ( downstream , timespan , timeskip , unit , scheduler . createWorker ( ) , bufferSize ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; createFirstWindow ( ) ; 
error = t ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
if ( downstreamCancelled . compareAndSet ( false , true ) ) windowDone ( ) ; 
if ( windowCount . decrementAndGet ( ) == 0 ) cleanupResources ( ) ; upstream . cancel ( ) ; upstreamCancelled = true ; drain ( ) ; 
if ( ! downstreamCancelled . get ( ) ) if ( requested . get ( ) != 0L ) windowCount . getAndIncrement ( ) ; window = UnicastProcessor . create ( bufferSize , windowRunnable ) ; emitted = 1 ; FlowableWindowSubscribeIntercept < T > intercept = new FlowableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; timer . replace ( scheduler . schedulePeriodicallyDirect ( this , timespan , timespan , unit ) ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; upstream . request ( Long . MAX_VALUE ) ; else upstream . cancel ( ) ; downstream . onError ( new MissingBackpressureException ( missingBackpressureMessage ( emitted ) ) ) ; cleanupResources ( ) ; upstreamCancelled = true ; 
queue . offer ( NEXT_WINDOW ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; final SimplePlainQueue < Object > queue = this . queue ; final Subscriber < ? super Flowable < T > > downstream = this . downstream ; UnicastProcessor < T > window = this . window ; int missed = 1 ; for ( ; ; ) if ( upstreamCancelled ) queue . clear ( ) ; window = null ; this . window = null ; else boolean isDone = done ; Object o = queue . poll ( ) ; boolean isEmpty = o == null ; if ( isDone && isEmpty ) Throwable ex = error ; if ( ex != null ) if ( window != null ) window . onError ( ex ) ; downstream . onError ( ex ) ; else if ( window != null ) window . onComplete ( ) ; downstream . onComplete ( ) ; cleanupResources ( ) ; upstreamCancelled = true ; continue ; else if ( ! isEmpty ) if ( o == NEXT_WINDOW ) if ( window != null ) window . onComplete ( ) ; window = null ; this . window = null ; if ( downstreamCancelled . get ( ) ) timer . dispose ( ) ; else if ( requested . get ( ) == emitted ) upstream . cancel ( ) ; cleanupResources ( ) ; upstreamCancelled = true ; downstream . onError ( new MissingBackpressureException ( missingBackpressureMessage ( emitted ) ) ) ; else emitted ++ ; windowCount . getAndIncrement ( ) ; window = UnicastProcessor . create ( bufferSize , windowRunnable ) ; this . window = window ; FlowableWindowSubscribeIntercept < T > intercept = new FlowableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; else if ( window != null ) @ SuppressWarnings ( "unchecked" ) T item = ( T ) o ; window . onNext ( item ) ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
timer . dispose ( ) ; 
windowDone ( ) ; 
if ( ! downstreamCancelled . get ( ) ) if ( requested . get ( ) != 0L ) emitted = 1 ; windowCount . getAndIncrement ( ) ; window = UnicastProcessor . create ( bufferSize , this ) ; FlowableWindowSubscribeIntercept < T > intercept = new FlowableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; Runnable boundaryTask = new WindowBoundaryRunnable ( this , 1L ) ; if ( restartTimerOnMaxSize ) timer . replace ( worker . schedulePeriodically ( boundaryTask , timespan , timespan , unit ) ) ; else timer . replace ( scheduler . schedulePeriodicallyDirect ( boundaryTask , timespan , timespan , unit ) ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; upstream . request ( Long . MAX_VALUE ) ; else upstream . cancel ( ) ; downstream . onError ( new MissingBackpressureException ( missingBackpressureMessage ( emitted ) ) ) ; cleanupResources ( ) ; upstreamCancelled = true ; 
windowDone ( ) ; 
timer . dispose ( ) ; Worker w = worker ; if ( w != null ) w . dispose ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final SimplePlainQueue < Object > queue = this . queue ; final Subscriber < ? super Flowable < T > > downstream = this . downstream ; UnicastProcessor < T > window = this . window ; for ( ; ; ) if ( upstreamCancelled ) queue . clear ( ) ; window = null ; this . window = null ; else boolean isDone = done ; Object o = queue . poll ( ) ; boolean isEmpty = o == null ; if ( isDone && isEmpty ) Throwable ex = error ; if ( ex != null ) if ( window != null ) window . onError ( ex ) ; downstream . onError ( ex ) ; else if ( window != null ) window . onComplete ( ) ; downstream . onComplete ( ) ; cleanupResources ( ) ; upstreamCancelled = true ; continue ; else if ( ! isEmpty ) if ( o instanceof WindowBoundaryRunnable ) WindowBoundaryRunnable boundary = ( WindowBoundaryRunnable ) o ; if ( boundary . index == emitted || ! restartTimerOnMaxSize ) this . count = 0 ; window = createNewWindow ( window ) ; else if ( window != null ) @ SuppressWarnings ( "unchecked" ) T item = ( T ) o ; window . onNext ( item ) ; long count = this . count + 1 ; if ( count == maxSize ) this . count = 0 ; window = createNewWindow ( window ) ; else this . count = count ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( window != null ) window . onComplete ( ) ; window = null ; if ( downstreamCancelled . get ( ) ) cleanupResources ( ) ; else long emitted = this . emitted ; if ( requested . get ( ) == emitted ) upstream . cancel ( ) ; cleanupResources ( ) ; upstreamCancelled = true ; downstream . onError ( new MissingBackpressureException ( missingBackpressureMessage ( emitted ) ) ) ; else this . emitted = ++ emitted ; windowCount . getAndIncrement ( ) ; window = UnicastProcessor . create ( bufferSize , this ) ; this . window = window ; FlowableWindowSubscribeIntercept < T > intercept = new FlowableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; if ( restartTimerOnMaxSize ) timer . update ( worker . schedulePeriodically ( new WindowBoundaryRunnable ( this , emitted ) , timespan , timespan , unit ) ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; return window ; 
parent . boundary ( this ) ; 
if ( ! downstreamCancelled . get ( ) ) if ( requested . get ( ) != 0L ) emitted = 1 ; windowCount . getAndIncrement ( ) ; UnicastProcessor < T > window = UnicastProcessor . create ( bufferSize , this ) ; windows . add ( window ) ; FlowableWindowSubscribeIntercept < T > intercept = new FlowableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; worker . schedule ( new WindowBoundaryRunnable ( this , false ) , timespan , unit ) ; worker . schedulePeriodically ( new WindowBoundaryRunnable ( this , true ) , timeskip , timeskip , unit ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; windows . remove ( window ) ; upstream . request ( Long . MAX_VALUE ) ; else upstream . cancel ( ) ; downstream . onError ( new MissingBackpressureException ( missingBackpressureMessage ( emitted ) ) ) ; cleanupResources ( ) ; upstreamCancelled = true ; 
worker . dispose ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final SimplePlainQueue < Object > queue = this . queue ; final Subscriber < ? super Flowable < T > > downstream = this . downstream ; final List < UnicastProcessor < T > > windows = this . windows ; for ( ; ; ) if ( upstreamCancelled ) queue . clear ( ) ; windows . clear ( ) ; else boolean isDone = done ; Object o = queue . poll ( ) ; boolean isEmpty = o == null ; if ( isDone && isEmpty ) Throwable ex = error ; if ( ex != null ) for ( UnicastProcessor < T > window : windows ) window . onError ( ex ) ; downstream . onError ( ex ) ; else for ( UnicastProcessor < T > window : windows ) window . onComplete ( ) ; downstream . onComplete ( ) ; cleanupResources ( ) ; upstreamCancelled = true ; continue ; else if ( ! isEmpty ) if ( o == WINDOW_OPEN ) if ( ! downstreamCancelled . get ( ) ) long emitted = this . emitted ; if ( requested . get ( ) != emitted ) this . emitted = ++ emitted ; windowCount . getAndIncrement ( ) ; UnicastProcessor < T > window = UnicastProcessor . create ( bufferSize , this ) ; windows . add ( window ) ; FlowableWindowSubscribeIntercept < T > intercept = new FlowableWindowSubscribeIntercept < > ( window ) ; downstream . onNext ( intercept ) ; worker . schedule ( new WindowBoundaryRunnable ( this , false ) , timespan , unit ) ; if ( intercept . tryAbandon ( ) ) window . onComplete ( ) ; else upstream . cancel ( ) ; Throwable ex = new MissingBackpressureException ( missingBackpressureMessage ( emitted ) ) ; for ( UnicastProcessor < T > window : windows ) window . onError ( ex ) ; downstream . onError ( ex ) ; cleanupResources ( ) ; upstreamCancelled = true ; continue ; else if ( o == WINDOW_CLOSE ) if ( ! windows . isEmpty ( ) ) windows . remove ( 0 ) . onComplete ( ) ; else @ SuppressWarnings ( "unchecked" ) T item = ( T ) o ; for ( UnicastProcessor < T > window : windows ) window . onNext ( item ) ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
windowDone ( ) ; 
parent . boundary ( isOpen ) ; 
final Map < Object , GroupedUnicast < K , V > > groups ; final Queue < GroupedUnicast < K , V > > evictedGroups ; try if ( mapFactory == null ) evictedGroups = null ; groups = new ConcurrentHashMap < > ( ) ; else evictedGroups = new ConcurrentLinkedQueue < > ( ) ; Consumer < Object > evictionAction = ( Consumer ) new EvictionAction < > ( evictedGroups ) ; groups = ( Map ) mapFactory . apply ( evictionAction ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; s . onSubscribe ( EmptyComponent . INSTANCE ) ; s . onError ( e ) ; return ; GroupBySubscriber < T , K , V > subscriber = new GroupBySubscriber < > ( s , keySelector , valueSelector , bufferSize , delayError , groups , evictedGroups ) ; source . subscribe ( subscriber ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( bufferSize ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; for ( GroupedUnicast < K , V > g : groups . values ( ) ) g . onError ( t ) ; groups . clear ( ) ; completeEvictions ( ) ; downstream . onError ( t ) ; 
if ( ! done ) for ( GroupedUnicast < K , V > g : groups . values ( ) ) g . onComplete ( ) ; groups . clear ( ) ; completeEvictions ( ) ; done = true ; downstream . onComplete ( ) ; 
if ( cancelled . compareAndSet ( false , true ) ) completeEvictions ( ) ; if ( groupCount . decrementAndGet ( ) == 0 ) upstream . cancel ( ) ; 
if ( evictedGroups != null ) int count = 0 ; GroupedUnicast < K , V > evictedGroup ; while ( ( evictedGroup = evictedGroups . poll ( ) ) != null ) if ( evictedGroup . state . tryComplete ( ) ) count ++ ; if ( count != 0 ) groupCount . addAndGet ( - count ) ; 
state . subscribe ( s ) ; 
state . onError ( e ) ; 
state . onComplete ( ) ; 
if ( cancelled . compareAndSet ( false , true ) ) cancelParent ( ) ; drain ( ) ; 
for ( ; ; ) int s = once . get ( ) ; if ( ( s & HAS_SUBSCRIBER ) != 0 ) break ; int u = s | HAS_SUBSCRIBER ; if ( once . compareAndSet ( s , u ) ) subscriber . onSubscribe ( this ) ; actual . lazySet ( subscriber ) ; if ( cancelled . get ( ) ) actual . lazySet ( null ) ; else drain ( ) ; return ; EmptySubscription . error ( new IllegalStateException ( "Only one Subscriber allowed!" ) , subscriber ) ; 
error = e ; done = true ; drain ( ) ; 
done = true ; drain ( ) ; 
boolean canEvict = evictOnce . compareAndSet ( false , true ) ; done = true ; drain ( ) ; return canEvict ; 
if ( ( once . get ( ) & ABANDONED ) == 0 ) if ( evictOnce . compareAndSet ( false , true ) ) parent . cancel ( key ) ; 
return once . get ( ) == FRESH && once . compareAndSet ( FRESH , ABANDONED ) ; 
if ( getAndIncrement ( ) != 0 ) return ; if ( outputFused ) drainFused ( ) ; else drainNormal ( ) ; 
int missed = 1 ; final SpscLinkedArrayQueue < T > q = this . queue ; Subscriber < ? super T > a = this . actual . get ( ) ; for ( ; ; ) if ( a != null ) if ( cancelled . get ( ) ) return ; boolean d = done ; if ( d && ! delayError ) Throwable ex = error ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; return ; a . onNext ( null ) ; if ( d ) Throwable ex = error ; if ( ex != null ) a . onError ( ex ) ; else a . onComplete ( ) ; return ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) return ; if ( a == null ) a = this . actual . get ( ) ; 
int missed = 1 ; final SpscLinkedArrayQueue < T > q = queue ; final boolean delayError = this . delayError ; Subscriber < ? super T > a = actual . get ( ) ; final AtomicBoolean cancelled = this . cancelled ; outer : for ( ; ; ) if ( cancelled . get ( ) ) cleanupQueue ( 0 , false ) ; else if ( a != null ) long r = requested . get ( ) ; long e = 0 ; while ( e != r ) boolean d = done ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , e , ! empty ) ) continue outer ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == r && checkTerminated ( done , q . isEmpty ( ) , a , delayError , e , false ) ) continue outer ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; requestParent ( e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; if ( a == null ) a = actual . get ( ) ; 
int p = produced ; if ( p != 0 ) produced = 0 ; requestParent ( p ) ; 
T v = queue . poll ( ) ; if ( v != null ) produced ++ ; return v ; tryReplenish ( ) ; return null ; 
if ( queue . isEmpty ( ) ) tryReplenish ( ) ; return true ; tryReplenish ( ) ; return false ; 
SpscLinkedArrayQueue < T > q = queue ; while ( q . poll ( ) != null ) produced ++ ; tryReplenish ( ) ; 
U u ; try u = Objects . requireNonNull ( initialSupplier . get ( ) , "The initialSupplier returned a null value" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; source . subscribe ( new CollectSubscriber < > ( observer , u , collector ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableCollect < > ( source , initialSupplier , collector ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onSuccess ( u ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
if ( s instanceof ConditionalSubscriber ) ConditionalSubscriber < ? super T > cs = ( ConditionalSubscriber < ? super T > ) s ; source . subscribe ( new DistinctUntilChangedConditionalSubscriber < > ( cs , keySelector , comparer ) ) ; else source . subscribe ( new DistinctUntilChangedSubscriber < > ( s , keySelector , comparer ) ) ; 
for ( ; ; ) T v = qs . poll ( ) ; if ( v == null ) return null ; K key = keySelector . apply ( v ) ; if ( ! hasValue ) hasValue = true ; last = key ; return v ; if ( ! comparer . test ( last , key ) ) last = key ; return v ; last = key ; if ( sourceMode != SYNC ) upstream . request ( 1 ) ; 
for ( ; ; ) T v = qs . poll ( ) ; if ( v == null ) return null ; K key = keySelector . apply ( v ) ; if ( ! hasValue ) hasValue = true ; last = key ; return v ; if ( ! comparer . test ( last , key ) ) last = key ; return v ; last = key ; if ( sourceMode != SYNC ) upstream . request ( 1 ) ; 
LatestSubscriberIterator < T > lio = new LatestSubscriberIterator < > ( ) ; Flowable . < T > fromPublisher ( source ) . materialize ( ) . subscribe ( lio ) ; return lio ; 
boolean wasNotAvailable = value . getAndSet ( args ) == null ; if ( wasNotAvailable ) notify . release ( ) ; 
RxJavaPlugins . onError ( e ) ; 
$EMPTY$
if ( iteratorNotification != null && iteratorNotification . isOnError ( ) ) throw ExceptionHelper . wrapOrThrow ( iteratorNotification . getError ( ) ) ; if ( iteratorNotification == null || iteratorNotification . isOnNext ( ) ) if ( iteratorNotification == null ) try BlockingHelper . verifyNonBlocking ( ) ; notify . acquire ( ) ; catch ( InterruptedException ex ) dispose ( ) ; iteratorNotification = Notification . createOnError ( ex ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; Notification < T > n = value . getAndSet ( null ) ; iteratorNotification = n ; if ( n . isOnError ( ) ) throw ExceptionHelper . wrapOrThrow ( n . getError ( ) ) ; return iteratorNotification . isOnNext ( ) ; 
if ( hasNext ( ) ) if ( iteratorNotification . isOnNext ( ) ) T v = iteratorNotification . getValue ( ) ; iteratorNotification = null ; return v ; throw new NoSuchElementException ( ) ; 
throw new UnsupportedOperationException ( "Read-only iterator." ) ; 
BlockingFlowableIterator < T > it = new BlockingFlowableIterator < > ( bufferSize ) ; source . subscribe ( it ) ; return it ; 
for ( ; ; ) if ( isDisposed ( ) ) Throwable e = error ; if ( e != null ) throw ExceptionHelper . wrapOrThrow ( e ) ; return false ; boolean d = done ; boolean empty = queue . isEmpty ( ) ; if ( d ) Throwable e = error ; if ( e != null ) throw ExceptionHelper . wrapOrThrow ( e ) ; else if ( empty ) return false ; if ( empty ) BlockingHelper . verifyNonBlocking ( ) ; lock . lock ( ) ; try while ( ! done && queue . isEmpty ( ) && ! isDisposed ( ) ) condition . await ( ) ; catch ( InterruptedException ex ) run ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; finally lock . unlock ( ) ; else return true ; 
if ( hasNext ( ) ) T v = queue . poll ( ) ; long p = produced + 1 ; if ( p == limit ) produced = 0 ; get ( ) . request ( p ) ; else produced = p ; return v ; throw new NoSuchElementException ( ) ; 
SubscriptionHelper . setOnce ( this , s , batchSize ) ; 
error = t ; done = true ; signalConsumer ( ) ; 
done = true ; signalConsumer ( ) ; 
lock . lock ( ) ; try condition . signalAll ( ) ; finally lock . unlock ( ) ; 
SubscriptionHelper . cancel ( this ) ; signalConsumer ( ) ; 
throw new UnsupportedOperationException ( "remove" ) ; 
SubscriptionHelper . cancel ( this ) ; signalConsumer ( ) ; 
return get ( ) == SubscriptionHelper . CANCELLED ; 
source . subscribe ( new SkipLastSubscriber < > ( s , skip ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; 
downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
if ( s instanceof ConditionalSubscriber ) s . onSubscribe ( new RangeConditionalSubscription ( ( ConditionalSubscriber < ? super Long > ) s , start , end ) ) ; else s . onSubscribe ( new RangeSubscription ( s , start , end ) ) ; 
long i = index ; if ( i == end ) return null ; index = i + 1 ; return i ; 
return index == end ; 
index = end ; 
cancelled = true ; 
long f = end ; Subscriber < ? super Long > a = downstream ; for ( long i = index ; i != f ; i ++ ) if ( cancelled ) return ; a . onNext ( i ) ; if ( cancelled ) return ; a . onComplete ( ) ; 
long f = end ; ConditionalSubscriber < ? super Long > a = downstream ; for ( long i = index ; i != f ; i ++ ) if ( cancelled ) return ; a . tryOnNext ( i ) ; if ( cancelled ) return ; a . onComplete ( ) ; 
NextSubscriber < T > nextSubscriber = new NextSubscriber < > ( ) ; return new NextIterator < > ( source , nextSubscriber ) ; 
if ( error != null ) throw ExceptionHelper . wrapOrThrow ( error ) ; if ( ! hasNext ) return false ; return ! isNextConsumed || moveToNext ( ) ; 
try if ( ! started ) started = true ; subscriber . setWaiting ( ) ; Flowable . < T > fromPublisher ( items ) . materialize ( ) . subscribe ( subscriber ) ; Notification < T > nextNotification = subscriber . takeNext ( ) ; if ( nextNotification . isOnNext ( ) ) isNextConsumed = false ; next = nextNotification . getValue ( ) ; return true ; hasNext = false ; if ( nextNotification . isOnComplete ( ) ) return false ; error = nextNotification . getError ( ) ; throw ExceptionHelper . wrapOrThrow ( error ) ; catch ( InterruptedException e ) subscriber . dispose ( ) ; error = e ; throw ExceptionHelper . wrapOrThrow ( e ) ; 
if ( error != null ) throw ExceptionHelper . wrapOrThrow ( error ) ; if ( hasNext ( ) ) isNextConsumed = true ; return next ; else throw new NoSuchElementException ( "No more elements" ) ; 
throw new UnsupportedOperationException ( "Read only iterator" ) ; 
$EMPTY$
RxJavaPlugins . onError ( e ) ; 
if ( waiting . getAndSet ( 0 ) == 1 || ! args . isOnNext ( ) ) Notification < T > toOffer = args ; while ( ! buf . offer ( toOffer ) ) Notification < T > concurrentItem = buf . poll ( ) ; if ( concurrentItem != null && ! concurrentItem . isOnNext ( ) ) toOffer = concurrentItem ; 
setWaiting ( ) ; BlockingHelper . verifyNonBlocking ( ) ; return buf . take ( ) ; 
waiting . set ( 1 ) ; 
if ( s instanceof ConditionalSubscriber ) source . subscribe ( new FilterConditionalSubscriber < > ( ( ConditionalSubscriber < ? super T > ) s , predicate ) ) ; else source . subscribe ( new FilterSubscriber < > ( s , predicate ) ) ; 
QueueSubscription < T > qs = this . qs ; Predicate < ? super T > f = filter ; for ( ; ; ) T t = qs . poll ( ) ; if ( t == null ) return null ; if ( f . test ( t ) ) return t ; if ( sourceMode == ASYNC ) qs . request ( 1 ) ; 
QueueSubscription < T > qs = this . qs ; Predicate < ? super T > f = filter ; for ( ; ; ) T t = qs . poll ( ) ; if ( t == null ) return null ; if ( f . test ( t ) ) return t ; if ( sourceMode == ASYNC ) qs . request ( 1 ) ; 
source . subscribe ( new SingleElementSubscriber < > ( observer ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableSingle < > ( source , null , false ) ) ; 
