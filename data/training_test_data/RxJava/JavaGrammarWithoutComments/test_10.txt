if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; T v = value ; value = null ; if ( v == null ) downstream . onComplete ( ) ; else downstream . onSuccess ( v ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
source . subscribe ( new DebounceTimedSubscriber < > ( new SerializedSubscriber < > ( s ) , timeout , unit , scheduler . createWorker ( ) ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
gate = false ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; worker . dispose ( ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; worker . dispose ( ) ; 
upstream . cancel ( ) ; worker . dispose ( ) ; 
IntervalSubscriber is = new IntervalSubscriber ( s ) ; s . onSubscribe ( is ) ; Scheduler sch = scheduler ; if ( sch instanceof TrampolineScheduler ) Worker worker = sch . createWorker ( ) ; is . setResource ( worker ) ; worker . schedulePeriodically ( is , initialDelay , period , unit ) ; else Disposable d = sch . schedulePeriodicallyDirect ( is , initialDelay , period , unit ) ; is . setResource ( d ) ; 
DisposableHelper . dispose ( resource ) ; 
if ( resource . get ( ) != DisposableHelper . DISPOSED ) long r = get ( ) ; if ( r != 0L ) downstream . onNext ( count ++ ) ; BackpressureHelper . produced ( this , 1 ) ; else downstream . onError ( new MissingBackpressureException ( "Can't deliver value " + count + " due to lack of requests" ) ) ; DisposableHelper . dispose ( resource ) ; 
DisposableHelper . setOnce ( resource , d ) ; 
window . subscribe ( s ) ; once . set ( true ) ; 
return ! once . get ( ) && once . compareAndSet ( false , true ) ; 
source . subscribe ( new DematerializeSubscriber < > ( subscriber , selector ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
TakeUntilMainSubscriber < T > parent = new TakeUntilMainSubscriber < > ( child ) ; child . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; source . subscribe ( parent ) ; 
SubscriptionHelper . deferredSetOnce ( this . upstream , requested , s ) ; 
SubscriptionHelper . cancel ( other ) ; HalfSerializer . onError ( downstream , t , this , error ) ; 
SubscriptionHelper . cancel ( other ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
SubscriptionHelper . cancel ( upstream ) ; SubscriptionHelper . cancel ( other ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
SubscriptionHelper . cancel ( this ) ; onComplete ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; HalfSerializer . onError ( downstream , t , TakeUntilMainSubscriber . this , error ) ; 
SubscriptionHelper . cancel ( upstream ) ; HalfSerializer . onComplete ( downstream , TakeUntilMainSubscriber . this , error ) ; 
source . subscribe ( new AllSubscriber < > ( s , predicate ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; complete ( true ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
if ( FlowableScalarXMap . tryScalarXMapSubscribe ( source , s , mapper ) ) return ; source . subscribe ( subscribe ( s , mapper , prefetch , errorMode ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > f = ( QueueSubscription < T > ) s ; int m = f . requestFusion ( QueueSubscription . ANY | QueueSubscription . BOUNDARY ) ; if ( m == QueueSubscription . SYNC ) sourceMode = m ; queue = f ; done = true ; subscribeActual ( ) ; drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) sourceMode = m ; queue = f ; subscribeActual ( ) ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; subscribeActual ( ) ; s . request ( prefetch ) ; 
done = true ; drain ( ) ; 
active = false ; drain ( ) ; 
downstream . onSubscribe ( this ) ; 
inner . cancel ( ) ; HalfSerializer . onError ( downstream , t , this , errors ) ; 
upstream . cancel ( ) ; HalfSerializer . onError ( downstream , e , this , errors ) ; 
if ( ! cancelled ) cancelled = true ; inner . cancel ( ) ; upstream . cancel ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( wip . getAndIncrement ( ) == 0 ) for ( ; ; ) if ( cancelled ) return ; if ( ! active ) boolean d = done ; T v ; try v = queue . poll ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean empty = v == null ; if ( d && empty ) downstream . onComplete ( ) ; return ; if ( ! empty ) Publisher < ? extends R > p ; try p = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null Publisher" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( sourceMode != QueueSubscription . SYNC ) int c = consumed + 1 ; if ( c == limit ) consumed = 0 ; upstream . request ( c ) ; else consumed = c ; if ( p instanceof Supplier ) @ SuppressWarnings ( "unchecked" ) Supplier < R > supplier = ( Supplier < R > ) p ; R vr ; try vr = supplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( vr == null ) continue ; if ( inner . isUnbounded ( ) ) if ( ! HalfSerializer . onNext ( downstream , vr , this , errors ) ) return ; continue ; else active = true ; inner . setSubscription ( new SimpleScalarSubscription < > ( vr , inner ) ) ; else active = true ; p . subscribe ( inner ) ; if ( wip . decrementAndGet ( ) == 0 ) break ; 
$EMPTY$
downstream . onSubscribe ( this ) ; 
if ( errors . tryAddThrowableOrReport ( t ) ) done = true ; drain ( ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) if ( ! veryEnd ) upstream . cancel ( ) ; done = true ; active = false ; drain ( ) ; 
if ( ! cancelled ) cancelled = true ; inner . cancel ( ) ; upstream . cancel ( ) ; errors . tryTerminateAndReport ( ) ; 
if ( getAndIncrement ( ) == 0 ) for ( ; ; ) if ( cancelled ) return ; if ( ! active ) boolean d = done ; if ( d && ! veryEnd ) Throwable ex = errors . get ( ) ; if ( ex != null ) errors . tryTerminateConsumer ( downstream ) ; return ; T v ; try v = queue . poll ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( downstream ) ; return ; if ( ! empty ) Publisher < ? extends R > p ; try p = Objects . requireNonNull ( mapper . apply ( v ) , "The mapper returned a null Publisher" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; upstream . cancel ( ) ; errors . tryAddThrowableOrReport ( e ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( sourceMode != QueueSubscription . SYNC ) int c = consumed + 1 ; if ( c == limit ) consumed = 0 ; upstream . request ( c ) ; else consumed = c ; if ( p instanceof Supplier ) @ SuppressWarnings ( "unchecked" ) Supplier < R > supplier = ( Supplier < R > ) p ; R vr ; try vr = supplier . get ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; errors . tryAddThrowableOrReport ( e ) ; if ( ! veryEnd ) upstream . cancel ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; vr = null ; if ( vr == null ) continue ; if ( inner . isUnbounded ( ) ) downstream . onNext ( vr ) ; continue ; else active = true ; inner . setSubscription ( new SimpleScalarSubscription < > ( vr , inner ) ) ; else active = true ; p . subscribe ( inner ) ; if ( decrementAndGet ( ) == 0 ) break ; 
setSubscription ( s ) ; 
long p = produced ; if ( p != 0L ) produced = 0L ; produced ( p ) ; parent . innerError ( t ) ; 
long p = produced ; if ( p != 0L ) produced = 0L ; produced ( p ) ; parent . innerComplete ( ) ; 
source . subscribe ( new MapSubscriber < T , U > ( s , mapper ) ) ; 
source . subscribe ( new DebounceSubscriber < > ( new SerializedSubscriber < > ( s ) , debounceSelector ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
DisposableHelper . dispose ( debouncer ) ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; Disposable d = debouncer . get ( ) ; if ( ! DisposableHelper . isDisposed ( d ) ) @ SuppressWarnings ( "unchecked" ) DebounceInnerSubscriber < T , U > dis = ( DebounceInnerSubscriber < T , U > ) d ; if ( dis != null ) dis . emit ( ) ; DisposableHelper . dispose ( debouncer ) ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; DisposableHelper . dispose ( debouncer ) ; 
if ( once . compareAndSet ( false , true ) ) parent . emit ( index , value ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; parent . onError ( t ) ; 
if ( done ) return ; done = true ; emit ( ) ; 
s . onSubscribe ( EmptySubscription . INSTANCE ) ; 
source . subscribe ( new FlatMapSingleSubscriber < > ( s , mapper , delayErrors , maxConcurrency ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; int m = maxConcurrency ; if ( m == Integer . MAX_VALUE ) s . request ( Long . MAX_VALUE ) ; else s . request ( maxConcurrency ) ; 
active . decrementAndGet ( ) ; if ( errors . tryAddThrowableOrReport ( t ) ) if ( ! delayErrors ) set . dispose ( ) ; drain ( ) ; 
active . decrementAndGet ( ) ; drain ( ) ; 
cancelled = true ; upstream . cancel ( ) ; set . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
SpscLinkedArrayQueue < R > current = queue . get ( ) ; if ( current != null ) return current ; current = new SpscLinkedArrayQueue < > ( Flowable . bufferSize ( ) ) ; if ( queue . compareAndSet ( null , current ) ) return current ; return queue . get ( ) ; 
if ( getAndIncrement ( ) == 0 ) drainLoop ( ) ; 
SpscLinkedArrayQueue < R > q = queue . get ( ) ; if ( q != null ) q . clear ( ) ; 
int missed = 1 ; Subscriber < ? super R > a = downstream ; AtomicInteger n = active ; AtomicReference < SpscLinkedArrayQueue < R > > qr = queue ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( e != r ) if ( cancelled ) clear ( ) ; return ; if ( ! delayErrors ) Throwable ex = errors . get ( ) ; if ( ex != null ) clear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; boolean d = n . get ( ) == 0 ; SpscLinkedArrayQueue < R > q = qr . get ( ) ; R v = q != null ? q . poll ( ) : null ; boolean empty = v == null ; if ( d && empty ) errors . tryTerminateConsumer ( a ) ; return ; if ( empty ) break ; a . onNext ( v ) ; e ++ ; if ( e == r ) if ( cancelled ) clear ( ) ; return ; if ( ! delayErrors ) Throwable ex = errors . get ( ) ; if ( ex != null ) clear ( ) ; errors . tryTerminateConsumer ( a ) ; return ; boolean d = n . get ( ) == 0 ; SpscLinkedArrayQueue < R > q = qr . get ( ) ; boolean empty = q == null || q . isEmpty ( ) ; if ( d && empty ) errors . tryTerminateConsumer ( a ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; if ( maxConcurrency != Integer . MAX_VALUE ) upstream . request ( e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
DisposableHelper . setOnce ( this , d ) ; 
innerError ( this , e ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . dispose ( this ) ; 
source . subscribe ( new CountSubscriber ( observer ) ) ; 
return RxJavaPlugins . onAssembly ( new FlowableCount < > ( source ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
count ++ ; 
upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( t ) ; 
upstream = SubscriptionHelper . CANCELLED ; downstream . onSuccess ( count ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
source . subscribe ( new BufferExactBoundarySubscriber < > ( new SerializedSubscriber < > ( s ) , bufferSupplier , boundary ) ) ; 
if ( ! SubscriptionHelper . validate ( this . upstream , s ) ) return ; this . upstream = s ; U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The buffer supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; cancelled = true ; s . cancel ( ) ; EmptySubscription . error ( e , downstream ) ; return ; buffer = b ; BufferBoundarySubscriber < T , U , B > bs = new BufferBoundarySubscriber < > ( this ) ; other = bs ; downstream . onSubscribe ( this ) ; if ( ! cancelled ) s . request ( Long . MAX_VALUE ) ; boundary . subscribe ( bs ) ; 
cancel ( ) ; downstream . onError ( t ) ; 
U b ; synchronized ( this ) b = buffer ; if ( b == null ) return ; buffer = null ; queue . offer ( b ) ; done = true ; if ( enter ( ) ) QueueDrainHelper . drainMaxLoop ( queue , downstream , false , this , this ) ; 
if ( ! cancelled ) cancelled = true ; other . dispose ( ) ; upstream . cancel ( ) ; if ( enter ( ) ) queue . clear ( ) ; 
U next ; try next = Objects . requireNonNull ( bufferSupplier . get ( ) , "The buffer supplied is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; cancel ( ) ; downstream . onError ( e ) ; return ; U b ; synchronized ( this ) b = buffer ; if ( b == null ) return ; buffer = next ; fastPathEmitMax ( b , false , this ) ; 
cancel ( ) ; 
return cancelled ; 
parent . onError ( t ) ; 
parent . onComplete ( ) ; 
source . subscribe ( new ConcatWithSubscriber < > ( s , other ) ) ; 
if ( SubscriptionHelper . validate ( upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( t ) ; 
if ( inCompletable ) downstream . onComplete ( ) ; else inCompletable = true ; upstream = SubscriptionHelper . CANCELLED ; CompletableSource cs = other ; other = null ; cs . subscribe ( this ) ; 
upstream . cancel ( ) ; DisposableHelper . dispose ( this ) ; 
DeferredScalarSubscription < T > deferred = new DeferredScalarSubscription < > ( s ) ; s . onSubscribe ( deferred ) ; T v ; try v = unit != null ? future . get ( timeout , unit ) : future . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! deferred . isCancelled ( ) ) s . onError ( ex ) ; return ; if ( v == null ) s . onError ( ExceptionHelper . createNullPointerException ( "The future returned a null value." ) ) ; else deferred . complete ( v ) ; 
source . subscribe ( new BackpressureReduceSubscriber < > ( s , reducer ) ) ; 
source . subscribe ( new ConcatMapEagerDelayErrorSubscriber < > ( s , mapper , maxConcurrency , prefetch , errorMode ) ) ; 
SkipUntilMainSubscriber < T > parent = new SkipUntilMainSubscriber < > ( child ) ; child . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; source . subscribe ( parent ) ; 
SubscriptionHelper . deferredSetOnce ( this . upstream , requested , s ) ; 
SubscriptionHelper . cancel ( other ) ; HalfSerializer . onError ( downstream , t , SkipUntilMainSubscriber . this , error ) ; 
SubscriptionHelper . cancel ( other ) ; HalfSerializer . onComplete ( downstream , this , error ) ; 
SubscriptionHelper . cancel ( upstream ) ; SubscriptionHelper . cancel ( other ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
gate = true ; get ( ) . cancel ( ) ; 
SubscriptionHelper . cancel ( upstream ) ; HalfSerializer . onError ( downstream , t , SkipUntilMainSubscriber . this , error ) ; 
gate = true ; 
CacheSubscription < T > consumer = new CacheSubscription < > ( t , this ) ; t . onSubscribe ( consumer ) ; add ( consumer ) ; if ( ! once . get ( ) && once . compareAndSet ( false , true ) ) source . subscribe ( this ) ; else replay ( consumer ) ; 
return once . get ( ) ; 
return subscribers . get ( ) . length != 0 ; 
return size ; 
s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; for ( CacheSubscription < T > consumer : subscribers . getAndSet ( TERMINATED ) ) replay ( consumer ) ; 
done = true ; for ( CacheSubscription < T > consumer : subscribers . getAndSet ( TERMINATED ) ) replay ( consumer ) ; 
if ( requested . getAndSet ( Long . MIN_VALUE ) != Long . MIN_VALUE ) parent . remove ( this ) ; 
source . subscribe ( new ScanSubscriber < > ( s , accumulator ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
OnErrorNextSubscriber < T > parent = new OnErrorNextSubscriber < > ( s , nextSupplier ) ; s . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
setSubscription ( s ) ; 
if ( once ) if ( done ) RxJavaPlugins . onError ( t ) ; return ; downstream . onError ( t ) ; return ; once = true ; Publisher < ? extends T > p ; try p = Objects . requireNonNull ( nextSupplier . apply ( t ) , "The nextSupplier returned a null Publisher" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; long mainProduced = produced ; if ( mainProduced != 0L ) produced ( mainProduced ) ; p . subscribe ( this ) ; 
if ( done ) return ; done = true ; once = true ; downstream . onComplete ( ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( false ) ; s . onSubscribe ( sa ) ; RetrySubscriber < T > rs = new RetrySubscriber < > ( s , count , predicate , sa , source ) ; rs . subscribeNext ( ) ; 
sa . setSubscription ( s ) ; 
long r = remaining ; if ( r != Long . MAX_VALUE ) remaining = r - 1 ; if ( r == 0 ) downstream . onError ( t ) ; else boolean b ; try b = predicate . test ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( new CompositeException ( t , e ) ) ; return ; if ( ! b ) downstream . onError ( t ) ; return ; subscribeNext ( ) ; 
downstream . onComplete ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; for ( ; ; ) if ( sa . isCancelled ( ) ) return ; long p = produced ; if ( p != 0L ) produced = 0L ; sa . produced ( p ) ; source . subscribe ( this ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( timespan == timeskip && maxSize == Integer . MAX_VALUE ) source . subscribe ( new BufferExactUnboundedSubscriber < > ( new SerializedSubscriber < > ( s ) , bufferSupplier , timespan , unit , scheduler ) ) ; return ; Scheduler . Worker w = scheduler . createWorker ( ) ; if ( timespan == timeskip ) source . subscribe ( new BufferExactBoundedSubscriber < > ( new SerializedSubscriber < > ( s ) , bufferSupplier , timespan , unit , maxSize , restartTimerOnMaxSize , w ) ) ; return ; source . subscribe ( new BufferSkipBoundedSubscriber < > ( new SerializedSubscriber < > ( s ) , bufferSupplier , timespan , timeskip , unit , w ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The supplied buffer is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; cancel ( ) ; EmptySubscription . error ( e , downstream ) ; return ; buffer = b ; downstream . onSubscribe ( this ) ; if ( ! cancelled ) s . request ( Long . MAX_VALUE ) ; Disposable d = scheduler . schedulePeriodicallyDirect ( this , timespan , timespan , unit ) ; if ( ! timer . compareAndSet ( null , d ) ) d . dispose ( ) ; 
DisposableHelper . dispose ( timer ) ; synchronized ( this ) buffer = null ; downstream . onError ( t ) ; 
DisposableHelper . dispose ( timer ) ; U b ; synchronized ( this ) b = buffer ; if ( b == null ) return ; buffer = null ; queue . offer ( b ) ; done = true ; if ( enter ( ) ) QueueDrainHelper . drainMaxLoop ( queue , downstream , false , null , this ) ; 
cancelled = true ; upstream . cancel ( ) ; DisposableHelper . dispose ( timer ) ; 
U next ; try next = Objects . requireNonNull ( bufferSupplier . get ( ) , "The supplied buffer is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; cancel ( ) ; downstream . onError ( e ) ; return ; U current ; synchronized ( this ) current = buffer ; if ( current == null ) return ; buffer = next ; fastPathEmitMax ( current , false , this ) ; 
cancel ( ) ; 
return timer . get ( ) == DisposableHelper . DISPOSED ; 
if ( ! SubscriptionHelper . validate ( this . upstream , s ) ) return ; this . upstream = s ; final U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The supplied buffer is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; w . dispose ( ) ; s . cancel ( ) ; EmptySubscription . error ( e , downstream ) ; return ; buffers . add ( b ) ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; w . schedulePeriodically ( this , timeskip , timeskip , unit ) ; w . schedule ( new RemoveFromBuffer ( b ) , timespan , unit ) ; 
done = true ; w . dispose ( ) ; clear ( ) ; downstream . onError ( t ) ; 
List < U > bs ; synchronized ( this ) bs = new ArrayList < > ( buffers ) ; buffers . clear ( ) ; for ( U b : bs ) queue . offer ( b ) ; done = true ; if ( enter ( ) ) QueueDrainHelper . drainMaxLoop ( queue , downstream , false , w , this ) ; 
cancelled = true ; upstream . cancel ( ) ; w . dispose ( ) ; clear ( ) ; 
synchronized ( this ) buffers . clear ( ) ; 
if ( cancelled ) return ; final U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The supplied buffer is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; cancel ( ) ; downstream . onError ( e ) ; return ; synchronized ( this ) if ( cancelled ) return ; buffers . add ( b ) ; w . schedule ( new RemoveFromBuffer ( b ) , timespan , unit ) ; 
synchronized ( BufferSkipBoundedSubscriber . this ) buffers . remove ( buffer ) ; fastPathOrderedEmitMax ( buffer , false , w ) ; 
if ( ! SubscriptionHelper . validate ( this . upstream , s ) ) return ; this . upstream = s ; U b ; try b = Objects . requireNonNull ( bufferSupplier . get ( ) , "The supplied buffer is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; w . dispose ( ) ; s . cancel ( ) ; EmptySubscription . error ( e , downstream ) ; return ; buffer = b ; downstream . onSubscribe ( this ) ; timer = w . schedulePeriodically ( this , timespan , timespan , unit ) ; s . request ( Long . MAX_VALUE ) ; 
synchronized ( this ) buffer = null ; downstream . onError ( t ) ; w . dispose ( ) ; 
U b ; synchronized ( this ) b = buffer ; buffer = null ; if ( b != null ) queue . offer ( b ) ; done = true ; if ( enter ( ) ) QueueDrainHelper . drainMaxLoop ( queue , downstream , false , this , this ) ; w . dispose ( ) ; 
if ( ! cancelled ) cancelled = true ; dispose ( ) ; 
synchronized ( this ) buffer = null ; upstream . cancel ( ) ; w . dispose ( ) ; 
return w . isDisposed ( ) ; 
U next ; try next = Objects . requireNonNull ( bufferSupplier . get ( ) , "The supplied buffer is null" ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; cancel ( ) ; downstream . onError ( e ) ; return ; U current ; synchronized ( this ) current = buffer ; if ( current == null || producerIndex != consumerIndex ) return ; buffer = next ; fastPathOrderedEmitMax ( current , false , this ) ; 
RefConnection conn ; boolean connect = false ; synchronized ( this ) conn = connection ; if ( conn == null ) conn = new RefConnection ( this ) ; connection = conn ; long c = conn . subscriberCount ; if ( c == 0L && conn . timer != null ) conn . timer . dispose ( ) ; conn . subscriberCount = c + 1 ; if ( ! conn . connected && c + 1 == n ) connect = true ; conn . connected = true ; source . subscribe ( new RefCountSubscriber < > ( s , this , conn ) ) ; if ( connect ) source . connect ( conn ) ; 
parent . timeout ( this ) ; 
DisposableHelper . replace ( this , t ) ; synchronized ( parent ) if ( disconnectedEarly ) parent . source . reset ( ) ; 
if ( compareAndSet ( false , true ) ) parent . terminated ( connection ) ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( compareAndSet ( false , true ) ) parent . terminated ( connection ) ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; if ( compareAndSet ( false , true ) ) parent . cancel ( connection ) ; 
if ( SubscriptionHelper . validate ( upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
DeferredScalarSubscription < T > deferred = new DeferredScalarSubscription < > ( s ) ; s . onSubscribe ( deferred ) ; T t ; try t = Objects . requireNonNull ( supplier . get ( ) , "The supplier returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( deferred . isCancelled ( ) ) RxJavaPlugins . onError ( ex ) ; else s . onError ( ex ) ; return ; deferred . complete ( t ) ; 
return Objects . requireNonNull ( supplier . get ( ) , "The supplier returned a null value" ) ; 
SubscriptionArbiter sa = new SubscriptionArbiter ( false ) ; s . onSubscribe ( sa ) ; RepeatSubscriber < T > rs = new RepeatSubscriber < > ( s , until , sa , source ) ; rs . subscribeNext ( ) ; 
sa . setSubscription ( s ) ; 
downstream . onError ( t ) ; 
boolean b ; try b = stop . getAsBoolean ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; downstream . onError ( e ) ; return ; if ( b ) downstream . onComplete ( ) ; else subscribeNext ( ) ; 
if ( getAndIncrement ( ) == 0 ) int missed = 1 ; for ( ; ; ) if ( sa . isCancelled ( ) ) return ; long p = produced ; if ( p != 0L ) produced = 0L ; sa . produced ( p ) ; source . subscribe ( this ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
try Subscriber < ? super T > st = operator . apply ( s ) ; if ( st == null ) throw new NullPointerException ( "Operator " + operator + " returned a null Subscriber" ) ; source . subscribe ( st ) ; catch ( NullPointerException e ) throw e ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; NullPointerException npe = new NullPointerException ( "Actually not, but can't throw other exceptions due to RS" ) ; npe . initCause ( e ) ; throw npe ; 
source . subscribe ( new ElementAtSubscriber < > ( observer , index ) ) ; 
source . subscribe ( new OnErrorCompleteSubscriber < > ( observer , predicate ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
boolean b ; try b = predicate . test ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; if ( b ) downstream . onComplete ( ) ; else downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
source . subscribe ( new ConcatWithSubscriber < > ( s , other ) ) ; 
DisposableHelper . setOnce ( otherDisposable , d ) ; 
downstream . onError ( t ) ; 
upstream = SubscriptionHelper . CANCELLED ; SingleSource < ? extends T > ss = other ; other = null ; ss . subscribe ( this ) ; 
super . cancel ( ) ; DisposableHelper . dispose ( otherDisposable ) ; 
SerializedSubscriber < T > serial = new SerializedSubscriber < > ( s ) ; if ( emitLast ) source . subscribe ( new SampleMainEmitLast < > ( serial , other ) ) ; else source . subscribe ( new SampleMainNoLast < > ( serial , other ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; if ( other . get ( ) == null ) sampler . subscribe ( new SamplerSubscriber < > ( this ) ) ; s . request ( Long . MAX_VALUE ) ; 
SubscriptionHelper . cancel ( other ) ; downstream . onError ( t ) ; 
SubscriptionHelper . cancel ( other ) ; completion ( ) ; 
SubscriptionHelper . setOnce ( other , o , Long . MAX_VALUE ) ; 
SubscriptionHelper . cancel ( other ) ; upstream . cancel ( ) ; 
upstream . cancel ( ) ; downstream . onError ( e ) ; 
upstream . cancel ( ) ; completion ( ) ; 
T value = getAndSet ( null ) ; if ( value != null ) long r = requested . get ( ) ; if ( r != 0L ) downstream . onNext ( value ) ; BackpressureHelper . produced ( requested , 1 ) ; else cancel ( ) ; downstream . onError ( new MissingBackpressureException ( "Couldn't emit value due to lack of requests!" ) ) ; 
parent . setOther ( s ) ; 
parent . run ( ) ; 
parent . error ( t ) ; 
parent . complete ( ) ; 
downstream . onComplete ( ) ; 
emit ( ) ; 
done = true ; if ( wip . getAndIncrement ( ) == 0 ) emit ( ) ; downstream . onComplete ( ) ; 
if ( wip . getAndIncrement ( ) == 0 ) do boolean d = done ; emit ( ) ; if ( d ) downstream . onComplete ( ) ; return ; while ( wip . decrementAndGet ( ) != 0 ) ; 
source . subscribe ( new DebounceTimedSubscriber < > ( new SerializedSubscriber < > ( s ) , timeout , unit , scheduler . createWorker ( ) ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; Disposable d = timer ; if ( d != null ) d . dispose ( ) ; downstream . onError ( t ) ; worker . dispose ( ) ; 
if ( done ) return ; done = true ; Disposable d = timer ; if ( d != null ) d . dispose ( ) ; @ SuppressWarnings ( "unchecked" ) DebounceEmitter < T > de = ( DebounceEmitter < T > ) d ; if ( de != null ) de . emit ( ) ; downstream . onComplete ( ) ; worker . dispose ( ) ; 
upstream . cancel ( ) ; worker . dispose ( ) ; 
emit ( ) ; 
if ( once . compareAndSet ( false , true ) ) parent . emit ( idx , value , this ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
DisposableHelper . replace ( this , d ) ; 
source . subscribe ( new ReduceSeedObserver < > ( observer , reducer , seed ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( value != null ) value = null ; upstream = SubscriptionHelper . CANCELLED ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
R v = value ; if ( v != null ) value = null ; upstream = SubscriptionHelper . CANCELLED ; downstream . onSuccess ( v ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
TimerDisposable parent = new TimerDisposable ( observer ) ; observer . onSubscribe ( parent ) ; parent . setFuture ( scheduler . scheduleDirect ( parent , delay , unit ) ) ; 
downstream . onSuccess ( 0L ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( this , d ) ; 
source . subscribe ( new DelayMaybeObserver < > ( observer , delay , unit , scheduler , delayError ) ) ; 
Throwable ex = error ; if ( ex != null ) downstream . onError ( ex ) ; else T v = value ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onComplete ( ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
this . error = e ; schedule ( delayError ? delay : 0 ) ; 
schedule ( delay ) ; 
MaybeSource < ? extends T > [ ] sources = this . sources ; int n = sources . length ; if ( n == 1 ) sources [ 0 ] . subscribe ( new MaybeMap . MapMaybeObserver < > ( observer , new SingletonArrayFunc ( ) ) ) ; return ; ZipCoordinator < T , R > parent = new ZipCoordinator < > ( observer , n , zipper ) ; observer . onSubscribe ( parent ) ; for ( int i = 0 ; i < n ; i ++ ) if ( parent . isDisposed ( ) ) return ; MaybeSource < ? extends T > source = sources [ i ] ; if ( source == null ) parent . innerError ( new NullPointerException ( "One of the sources is null" ) , i ) ; return ; source . subscribe ( parent . observers [ i ] ) ; 
return get ( ) <= 0 ; 
if ( getAndSet ( 0 ) > 0 ) for ( ZipMaybeObserver < ? > d : observers ) d . dispose ( ) ; values = null ; 
DisposableHelper . dispose ( this ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . innerError ( e , index ) ; 
parent . innerComplete ( index ) ; 
other . subscribe ( new OtherSubscriber < > ( observer , source ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; main . downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( upstream != SubscriptionHelper . CANCELLED ) upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; subscribeNext ( ) ; 
if ( upstream != SubscriptionHelper . CANCELLED ) upstream = SubscriptionHelper . CANCELLED ; main . downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( upstream != SubscriptionHelper . CANCELLED ) upstream = SubscriptionHelper . CANCELLED ; subscribeNext ( ) ; 
MaybeSource < T > src = source ; source = null ; src . subscribe ( main ) ; 
return DisposableHelper . isDisposed ( main . get ( ) ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; DisposableHelper . dispose ( main ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
SubscribeOnMaybeObserver < T > parent = new SubscribeOnMaybeObserver < > ( observer ) ; observer . onSubscribe ( parent ) ; parent . task . replace ( scheduler . scheduleDirect ( new SubscribeTask < > ( parent , source ) ) ) ; 
source . subscribe ( observer ) ; 
DisposableHelper . dispose ( this ) ; task . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
return source ; 
source . subscribe ( new MaybeToFlowableSubscriber < > ( s ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
super . cancel ( ) ; upstream . dispose ( ) ; 
source . subscribe ( new MaybePeekObserver < > ( observer , this ) ) ; 
try parent . onDisposeCall . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) try parent . onSubscribeCall . accept ( d ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; d . dispose ( ) ; this . upstream = DisposableHelper . DISPOSED ; EmptyDisposable . error ( ex , downstream ) ; return ; this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( this . upstream == DisposableHelper . DISPOSED ) RxJavaPlugins . onError ( e ) ; return ; onErrorInner ( e ) ; 
try parent . onErrorCall . accept ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; this . upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; onAfterTerminate ( ) ; 
if ( this . upstream == DisposableHelper . DISPOSED ) return ; try parent . onCompleteCall . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; onErrorInner ( ex ) ; return ; this . upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; onAfterTerminate ( ) ; 
try parent . onAfterTerminate . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( ! d . isDisposed ( ) ) T v ; try if ( timeout <= 0L ) v = future . get ( ) ; else v = future . get ( timeout , unit ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ex instanceof ExecutionException ) ex = ex . getCause ( ) ; Exceptions . throwIfFatal ( ex ) ; if ( ! d . isDisposed ( ) ) observer . onError ( ex ) ; return ; if ( ! d . isDisposed ( ) ) if ( v == null ) observer . onComplete ( ) ; else observer . onSuccess ( v ) ; 
other . subscribe ( new OtherObserver < > ( observer , source ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new DelayWithMainObserver < > ( this , downstream ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( parent , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new IgnoreMaybeObserver < > ( observer ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; 
return upstream . isDisposed ( ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
source . subscribe ( new SwitchIfEmptyMaybeObserver < > ( observer , other ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
Disposable d = get ( ) ; if ( d != DisposableHelper . DISPOSED ) if ( compareAndSet ( d , null ) ) other . subscribe ( new OtherMaybeObserver < T > ( downstream , this ) ) ; 
DisposableHelper . setOnce ( parent , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new IgnoreMaybeObserver < > ( observer ) ) ; 
return RxJavaPlugins . onAssembly ( new MaybeIgnoreElement < > ( source ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; 
return upstream . isDisposed ( ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
MaybeObserver < ? super T > lifted ; try lifted = Objects . requireNonNull ( operator . apply ( observer ) , "The operator returned a null MaybeObserver" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( lifted ) ; 
EqualCoordinator < T > parent = new EqualCoordinator < > ( observer , isEqual ) ; observer . onSubscribe ( parent ) ; parent . subscribe ( source1 , source2 ) ; 
source1 . subscribe ( observer1 ) ; source2 . subscribe ( observer2 ) ; 
observer1 . dispose ( ) ; observer2 . dispose ( ) ; 
return DisposableHelper . isDisposed ( observer1 . get ( ) ) ; 
if ( decrementAndGet ( ) == 0 ) Object o1 = observer1 . value ; Object o2 = observer2 . value ; if ( o1 != null && o2 != null ) boolean b ; try b = isEqual . test ( ( T ) o1 , ( T ) o2 ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; downstream . onSuccess ( b ) ; else downstream . onSuccess ( o1 == null && o2 == null ) ; 
DisposableHelper . dispose ( this ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . error ( this , e ) ; 
parent . done ( ) ; 
CacheDisposable < T > parent = new CacheDisposable < > ( observer , this ) ; observer . onSubscribe ( parent ) ; if ( add ( parent ) ) if ( parent . isDisposed ( ) ) remove ( parent ) ; return ; else if ( ! parent . isDisposed ( ) ) Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else T v = value ; if ( v != null ) observer . onSuccess ( v ) ; else observer . onComplete ( ) ; return ; MaybeSource < T > src = source . getAndSet ( null ) ; if ( src != null ) src . subscribe ( this ) ; 
$EMPTY$
this . error = e ; for ( CacheDisposable < T > inner : observers . getAndSet ( TERMINATED ) ) if ( ! inner . isDisposed ( ) ) inner . downstream . onError ( e ) ; 
for ( CacheDisposable < T > inner : observers . getAndSet ( TERMINATED ) ) if ( ! inner . isDisposed ( ) ) inner . downstream . onComplete ( ) ; 
MaybeCache < T > mc = getAndSet ( null ) ; if ( mc != null ) mc . remove ( this ) ; 
return get ( ) == null ; 
source . subscribe ( new OnErrorCompleteMultiObserver < > ( observer , predicate ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
boolean b ; try b = predicate . test ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; if ( b ) downstream . onComplete ( ) ; else downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
return source ; 
return RxJavaPlugins . onAssembly ( new MaybeIsEmpty < > ( source ) ) ; 
source . subscribe ( new IsEmptyMaybeObserver < > ( observer ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onSuccess ( true ) ; 
return source ; 
source . subscribe ( new SwitchIfEmptyMaybeObserver < > ( observer , other ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
Disposable d = get ( ) ; if ( d != DisposableHelper . DISPOSED ) if ( compareAndSet ( d , null ) ) other . subscribe ( new OtherSingleObserver < T > ( downstream , this ) ) ; 
DisposableHelper . setOnce ( parent , d ) ; 
downstream . onError ( e ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( ! d . isDisposed ( ) ) try action . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! d . isDisposed ( ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! d . isDisposed ( ) ) observer . onComplete ( ) ; 
action . run ( ) ; return null ; 
source . subscribe ( new FilterMaybeObserver < > ( observer , predicate ) ) ; 
Disposable d = this . upstream ; this . upstream = DisposableHelper . DISPOSED ; d . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new DoFinallyObserver < > ( observer , onFinally ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( t ) ; runFinally ( ) ; 
downstream . onComplete ( ) ; runFinally ( ) ; 
upstream . dispose ( ) ; runFinally ( ) ; 
return upstream . isDisposed ( ) ; 
if ( compareAndSet ( 0 , 1 ) ) try onFinally . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
return source ; 
source . subscribe ( new ContainsMaybeObserver ( observer , value ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onSuccess ( Objects . equals ( value , this . value ) ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onSuccess ( false ) ; 
MaybeSource < ? extends T > [ ] maybes = sources ; int n = maybes . length ; SimpleQueueWithConsumerIndex < Object > queue ; if ( n <= bufferSize ( ) ) queue = new MpscFillOnceSimpleQueue < > ( n ) ; else queue = new ClqSimpleQueue < > ( ) ; MergeMaybeObserver < T > parent = new MergeMaybeObserver < > ( s , n , queue ) ; s . onSubscribe ( parent ) ; AtomicThrowable e = parent . errors ; for ( MaybeSource < ? extends T > source : maybes ) if ( parent . isCancelled ( ) || e . get ( ) != null ) return ; source . subscribe ( parent ) ; 
for ( ; ; ) Object o = queue . poll ( ) ; if ( o != NotificationLite . COMPLETE ) return ( T ) o ; 
return queue . isEmpty ( ) ; 
queue . clear ( ) ; 
if ( ! cancelled ) cancelled = true ; set . dispose ( ) ; if ( getAndIncrement ( ) == 0 ) queue . clear ( ) ; 
set . add ( d ) ; 
if ( errors . tryAddThrowableOrReport ( e ) ) set . dispose ( ) ; queue . offer ( NotificationLite . COMPLETE ) ; drain ( ) ; 
queue . offer ( NotificationLite . COMPLETE ) ; drain ( ) ; 
return cancelled ; 
int missed = 1 ; Subscriber < ? super T > a = downstream ; SimpleQueueWithConsumerIndex < Object > q = queue ; long e = consumed ; for ( ; ; ) long r = requested . get ( ) ; while ( e != r ) if ( cancelled ) q . clear ( ) ; return ; Throwable ex = errors . get ( ) ; if ( ex != null ) q . clear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; if ( q . consumerIndex ( ) == sourceCount ) a . onComplete ( ) ; return ; Object v = q . poll ( ) ; if ( v == null ) break ; if ( v != NotificationLite . COMPLETE ) a . onNext ( ( T ) v ) ; e ++ ; if ( e == r ) Throwable ex = errors . get ( ) ; if ( ex != null ) q . clear ( ) ; errors . tryTerminateConsumer ( downstream ) ; return ; while ( q . peek ( ) == NotificationLite . COMPLETE ) q . drop ( ) ; if ( q . consumerIndex ( ) == sourceCount ) a . onComplete ( ) ; return ; consumed = e ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
int missed = 1 ; Subscriber < ? super T > a = downstream ; SimpleQueueWithConsumerIndex < Object > q = queue ; for ( ; ; ) if ( cancelled ) q . clear ( ) ; return ; Throwable ex = errors . get ( ) ; if ( ex != null ) q . clear ( ) ; a . onError ( ex ) ; return ; boolean d = q . producerIndex ( ) == sourceCount ; if ( ! q . isEmpty ( ) ) a . onNext ( null ) ; if ( d ) a . onComplete ( ) ; return ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( getAndIncrement ( ) != 0 ) return ; if ( outputFused ) drainFused ( ) ; else drainNormal ( ) ; 
int ci = consumerIndex ; if ( ci == length ( ) ) return null ; AtomicInteger pi = producerIndex ; for ( ; ; ) T v = get ( ci ) ; if ( v != null ) consumerIndex = ci + 1 ; lazySet ( ci , null ) ; return v ; if ( pi . get ( ) == ci ) return null ; 
int ci = consumerIndex ; if ( ci == length ( ) ) return null ; return get ( ci ) ; 
int ci = consumerIndex ; lazySet ( ci , null ) ; consumerIndex = ci + 1 ; 
return consumerIndex == producerIndex ( ) ; 
while ( poll ( ) != null && ! isEmpty ( ) ) 
return consumerIndex ; 
return producerIndex . get ( ) ; 
T v = super . poll ( ) ; if ( v != null ) consumerIndex ++ ; return v ; 
return consumerIndex ; 
return producerIndex . get ( ) ; 
poll ( ) ; 
source . subscribe ( new MaterializeSingleObserver < > ( observer ) ) ; 
source . subscribe ( new DoAfterObserver < > ( observer , onAfterSuccess ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
source . subscribe ( new FilterMaybeObserver < > ( observer , predicate ) ) ; 
Disposable d = this . upstream ; this . upstream = DisposableHelper . DISPOSED ; d . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
source . subscribe ( new FlatMapMaybeObserver < > ( downstream , mapper ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
DisposableHelper . replace ( parent , d ) ; 
downstream . onError ( e ) ; 
return source ; 
source . subscribe ( new ToSingleMaybeSubscriber < > ( observer , defaultValue ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; if ( defaultValue != null ) downstream . onSuccess ( defaultValue ) ; else downstream . onError ( new NoSuchElementException ( "The MaybeSource is empty" ) ) ; 
ConcatMaybeObserver < T > parent = new ConcatMaybeObserver < > ( s , sources ) ; s . onSubscribe ( parent ) ; parent . drain ( ) ; 
disposables . dispose ( ) ; errors . tryTerminateAndReport ( ) ; 
disposables . replace ( d ) ; 
current . lazySet ( NotificationLite . COMPLETE ) ; if ( errors . tryAddThrowableOrReport ( e ) ) drain ( ) ; 
current . lazySet ( NotificationLite . COMPLETE ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; AtomicReference < Object > c = current ; Subscriber < ? super T > a = downstream ; Disposable cancelled = disposables ; for ( ; ; ) if ( cancelled . isDisposed ( ) ) c . lazySet ( null ) ; return ; Object o = c . get ( ) ; if ( o != null ) boolean goNextSource ; if ( o != NotificationLite . COMPLETE ) long p = produced ; if ( p != requested . get ( ) ) produced = p + 1 ; c . lazySet ( null ) ; goNextSource = true ; a . onNext ( ( T ) o ) ; else goNextSource = false ; else goNextSource = true ; c . lazySet ( null ) ; if ( goNextSource && ! cancelled . isDisposed ( ) ) int i = index ; if ( i == sources . length ) errors . tryTerminateConsumer ( downstream ) ; return ; index = i + 1 ; sources [ i ] . subscribe ( this ) ; if ( decrementAndGet ( ) == 0 ) break ; 
source . subscribe ( new FlatMapMaybeObserver < > ( observer , onSuccessMapper , onErrorMapper , onCompleteSupplier ) ) ; 
DisposableHelper . dispose ( this ) ; upstream . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
MaybeSource < ? extends R > source ; try source = Objects . requireNonNull ( onErrorMapper . apply ( e ) , "The onErrorMapper returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; if ( ! isDisposed ( ) ) source . subscribe ( new InnerObserver ( ) ) ; 
MaybeSource < ? extends R > source ; try source = Objects . requireNonNull ( onCompleteSupplier . get ( ) , "The onCompleteSupplier returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; if ( ! isDisposed ( ) ) source . subscribe ( new InnerObserver ( ) ) ; 
DisposableHelper . setOnce ( FlatMapMaybeObserver . this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new DelayMaybeObserver < > ( observer , other ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; SubscriptionHelper . cancel ( other ) ; 
return other . get ( ) == SubscriptionHelper . CANCELLED ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; other . downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; other . error = e ; subscribeNext ( ) ; 
upstream = DisposableHelper . DISPOSED ; subscribeNext ( ) ; 
otherSource . subscribe ( other ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
Subscription s = get ( ) ; if ( s != SubscriptionHelper . CANCELLED ) lazySet ( SubscriptionHelper . CANCELLED ) ; s . cancel ( ) ; onComplete ( ) ; 
Throwable e = error ; if ( e == null ) downstream . onError ( t ) ; else downstream . onError ( new CompositeException ( e , t ) ) ; 
Throwable e = error ; if ( e != null ) downstream . onError ( e ) ; else T v = value ; if ( v != null ) downstream . onSuccess ( v ) ; else downstream . onComplete ( ) ; 
return source ; 
source . subscribe ( new FromSingleObserver < > ( observer ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
return source ; 
return source ; 
source . subscribe ( new CountMaybeObserver ( observer ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onSuccess ( 1L ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onSuccess ( 0L ) ; 
return upstream . isDisposed ( ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
D resource ; try resource = resourceSupplier . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; MaybeSource < ? extends T > source ; try source = Objects . requireNonNull ( sourceSupplier . apply ( resource ) , "The sourceSupplier returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( eager ) try resourceDisposer . accept ( resource ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; EmptyDisposable . error ( new CompositeException ( ex , exc ) , observer ) ; return ; EmptyDisposable . error ( ex , observer ) ; if ( ! eager ) try resourceDisposer . accept ( resource ) ; catch ( Throwable exc ) Exceptions . throwIfFatal ( exc ) ; RxJavaPlugins . onError ( exc ) ; return ; source . subscribe ( new UsingObserver < T , D > ( observer , resource , resourceDisposer , eager ) ) ; 
if ( eager ) disposeResource ( ) ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; else upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; disposeResource ( ) ; 
Object resource = getAndSet ( this ) ; if ( resource != this ) try disposer . accept ( ( D ) resource ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; if ( eager ) Object resource = getAndSet ( this ) ; if ( resource != this ) try disposer . accept ( ( D ) resource ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; else return ; downstream . onError ( e ) ; if ( ! eager ) disposeResource ( ) ; 
upstream = DisposableHelper . DISPOSED ; if ( eager ) Object resource = getAndSet ( this ) ; if ( resource != this ) try disposer . accept ( ( D ) resource ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; else return ; downstream . onComplete ( ) ; if ( ! eager ) disposeResource ( ) ; 
source . subscribe ( new IsEmptyMaybeObserver < > ( observer ) ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onSuccess ( true ) ; 
Iterator < ? extends MaybeSource < ? extends T > > it ; try it = Objects . requireNonNull ( sources . iterator ( ) , "The sources Iterable returned a null Iterator" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; ConcatMaybeObserver < T > parent = new ConcatMaybeObserver < > ( s , it ) ; s . onSubscribe ( parent ) ; parent . drain ( ) ; 
disposables . dispose ( ) ; 
disposables . replace ( d ) ; 
downstream . onError ( e ) ; 
current . lazySet ( NotificationLite . COMPLETE ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; AtomicReference < Object > c = current ; Subscriber < ? super T > a = downstream ; Disposable cancelled = disposables ; for ( ; ; ) if ( cancelled . isDisposed ( ) ) c . lazySet ( null ) ; return ; Object o = c . get ( ) ; if ( o != null ) boolean goNextSource ; if ( o != NotificationLite . COMPLETE ) long p = produced ; if ( p != requested . get ( ) ) produced = p + 1 ; c . lazySet ( null ) ; goNextSource = true ; a . onNext ( ( T ) o ) ; else goNextSource = false ; else goNextSource = true ; c . lazySet ( null ) ; if ( goNextSource && ! cancelled . isDisposed ( ) ) boolean b ; try b = sources . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( b ) MaybeSource < ? extends T > source ; try source = Objects . requireNonNull ( sources . next ( ) , "The source Iterator returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; source . subscribe ( this ) ; else a . onComplete ( ) ; if ( decrementAndGet ( ) == 0 ) break ; 
source . subscribe ( new FlatMapIterableObserver < > ( observer , mapper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
cancelled = true ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return cancelled ; 
it = null ; 
return it == null ; 
Iterator < ? extends R > iterator = it ; if ( iterator != null ) R v = Objects . requireNonNull ( iterator . next ( ) , "The iterator returned a null value" ) ; if ( ! iterator . hasNext ( ) ) it = null ; return v ; return null ; 
source . subscribe ( new UnsubscribeOnMaybeObserver < > ( observer , scheduler ) ) ; 
Disposable d = getAndSet ( DisposableHelper . DISPOSED ) ; if ( d != DisposableHelper . DISPOSED ) this . ds = d ; scheduler . scheduleDirect ( this ) ; 
ds . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new FlatMapIterableObserver < > ( s , mapper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
cancelled = true ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
for ( ; ; ) if ( cancelled ) return ; R v ; try v = iterator . next ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; a . onNext ( v ) ; if ( cancelled ) return ; boolean b ; try b = iterator . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( ! b ) a . onComplete ( ) ; return ; 
if ( getAndIncrement ( ) != 0 ) return ; Subscriber < ? super R > a = downstream ; Iterator < ? extends R > iterator = this . it ; if ( outputFused && iterator != null ) a . onNext ( null ) ; a . onComplete ( ) ; return ; int missed = 1 ; for ( ; ; ) if ( iterator != null ) long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) fastPath ( a , iterator ) ; return ; long e = 0L ; while ( e != r ) if ( cancelled ) return ; R v ; try v = Objects . requireNonNull ( iterator . next ( ) , "The iterator returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; a . onNext ( v ) ; if ( cancelled ) return ; e ++ ; boolean b ; try b = iterator . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; a . onError ( ex ) ; return ; if ( ! b ) a . onComplete ( ) ; return ; if ( e != 0L ) BackpressureHelper . produced ( requested , e ) ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; if ( iterator == null ) iterator = it ; 
it = null ; 
return it == null ; 
Iterator < ? extends R > iterator = it ; if ( iterator != null ) R v = Objects . requireNonNull ( iterator . next ( ) , "The iterator returned a null value" ) ; if ( ! iterator . hasNext ( ) ) it = null ; return v ; return null ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( ! d . isDisposed ( ) ) try runnable . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! d . isDisposed ( ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! d . isDisposed ( ) ) observer . onComplete ( ) ; 
runnable . run ( ) ; return null ; 
source . subscribe ( new DetachMaybeObserver < > ( observer ) ) ; 
downstream = null ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; MaybeObserver < ? super T > a = downstream ; if ( a != null ) downstream = null ; a . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; MaybeObserver < ? super T > a = downstream ; if ( a != null ) downstream = null ; a . onComplete ( ) ; 
observer . onSubscribe ( Disposable . disposed ( ) ) ; Throwable ex ; try ex = ExceptionHelper . nullCheck ( errorSupplier . get ( ) , "Supplier returned a null Throwable." ) ; catch ( Throwable ex1 ) Exceptions . throwIfFatal ( ex1 ) ; ex = ex1 ; observer . onError ( ex ) ; 
source . subscribe ( new MapMaybeObserver < T , R > ( observer , mapper ) ) ; 
Disposable d = this . upstream ; this . upstream = DisposableHelper . DISPOSED ; d . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new HideMaybeObserver < > ( observer ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
MaybeSource < ? extends T > [ ] sources = this . sources ; int count = 0 ; if ( sources == null ) sources = new MaybeSource [ 8 ] ; try for ( MaybeSource < ? extends T > element : sourcesIterable ) if ( element == null ) EmptyDisposable . error ( new NullPointerException ( "One of the sources is null" ) , observer ) ; return ; if ( count == sources . length ) MaybeSource < ? extends T > [ ] b = new MaybeSource [ count + ( count > > 2 ) ] ; System . arraycopy ( sources , 0 , b , 0 , count ) ; sources = b ; sources [ count ++ ] = element ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; EmptyDisposable . error ( e , observer ) ; return ; else count = sources . length ; CompositeDisposable set = new CompositeDisposable ( ) ; observer . onSubscribe ( set ) ; AtomicBoolean winner = new AtomicBoolean ( ) ; for ( int i = 0 ; i < count ; i ++ ) MaybeSource < ? extends T > s = sources [ i ] ; if ( set . isDisposed ( ) ) return ; if ( s == null ) set . dispose ( ) ; NullPointerException ex = new NullPointerException ( "One of the MaybeSources is null" ) ; if ( winner . compareAndSet ( false , true ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; s . subscribe ( new AmbMaybeObserver < T > ( observer , set , winner ) ) ; if ( count == 0 ) observer . onComplete ( ) ; 
upstream = d ; set . add ( d ) ; 
if ( winner . compareAndSet ( false , true ) ) set . delete ( upstream ) ; set . dispose ( ) ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( winner . compareAndSet ( false , true ) ) set . delete ( upstream ) ; set . dispose ( ) ; downstream . onComplete ( ) ; 
observer . onSubscribe ( Disposable . disposed ( ) ) ; observer . onSuccess ( value ) ; 
return value ; 
source . subscribe ( new ObserveOnMaybeObserver < > ( observer , scheduler ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
this . error = e ; DisposableHelper . replace ( this , scheduler . scheduleDirect ( this ) ) ; 
DisposableHelper . replace ( this , scheduler . scheduleDirect ( this ) ) ; 
Throwable ex = error ; if ( ex != null ) error = null ; downstream . onError ( ex ) ; else T v = value ; if ( v != null ) value = null ; downstream . onSuccess ( v ) ; else downstream . onComplete ( ) ; 
TakeUntilMainMaybeObserver < T , U > parent = new TakeUntilMainMaybeObserver < > ( observer ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; source . subscribe ( parent ) ; 
DisposableHelper . dispose ( this ) ; DisposableHelper . dispose ( other ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
DisposableHelper . dispose ( other ) ; if ( getAndSet ( DisposableHelper . DISPOSED ) != DisposableHelper . DISPOSED ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
DisposableHelper . dispose ( other ) ; if ( getAndSet ( DisposableHelper . DISPOSED ) != DisposableHelper . DISPOSED ) downstream . onComplete ( ) ; 
if ( DisposableHelper . dispose ( this ) ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( DisposableHelper . dispose ( this ) ) downstream . onComplete ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . otherComplete ( ) ; 
parent . otherError ( e ) ; 
parent . otherComplete ( ) ; 
source . subscribe ( new OnErrorReturnMaybeObserver < > ( observer , itemSupplier ) ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
T v ; try v = Objects . requireNonNull ( itemSupplier . apply ( e ) , "The itemSupplier returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; downstream . onSuccess ( v ) ; 
downstream . onComplete ( ) ; 
TimeoutMainMaybeObserver < T , U > parent = new TimeoutMainMaybeObserver < > ( observer , fallback ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; source . subscribe ( parent ) ; 
DisposableHelper . dispose ( this ) ; SubscriptionHelper . cancel ( other ) ; TimeoutFallbackMaybeObserver < T > oo = otherObserver ; if ( oo != null ) DisposableHelper . dispose ( oo ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
SubscriptionHelper . cancel ( other ) ; if ( getAndSet ( DisposableHelper . DISPOSED ) != DisposableHelper . DISPOSED ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
SubscriptionHelper . cancel ( other ) ; if ( getAndSet ( DisposableHelper . DISPOSED ) != DisposableHelper . DISPOSED ) downstream . onComplete ( ) ; 
if ( DisposableHelper . dispose ( this ) ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( DisposableHelper . dispose ( this ) ) if ( fallback == null ) downstream . onError ( new TimeoutException ( ) ) ; else fallback . subscribe ( otherObserver ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
get ( ) . cancel ( ) ; parent . otherComplete ( ) ; 
parent . otherError ( e ) ; 
parent . otherComplete ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
EmptyDisposable . complete ( observer ) ; 
return null ; 
source . subscribe ( new DoOnEventMaybeObserver < > ( observer , onEvent ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; try onEvent . accept ( null , e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; downstream . onError ( e ) ; 
upstream = DisposableHelper . DISPOSED ; try onEvent . accept ( null , null ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; downstream . onComplete ( ) ; 
return source ; 
source . subscribe ( new FromCompletableObserver < T > ( observer ) ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; 
upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; 
source . subscribe ( new DematerializeObserver < > ( observer , selector ) ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( upstream , d ) ) upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
return source ; 
source . subscribe ( create ( observer ) ) ; 
return new MaybeToObservableObserver < > ( downstream ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
error ( e ) ; 
complete ( ) ; 
super . dispose ( ) ; upstream . dispose ( ) ; 
source . subscribe ( new MaybeLifecycleObserver < > ( observer , onSubscribe , onDispose ) ) ; 
try onSubscribe . accept ( d ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; d . dispose ( ) ; this . upstream = DisposableHelper . DISPOSED ; EmptyDisposable . error ( e , downstream ) ; return ; if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( upstream != DisposableHelper . DISPOSED ) upstream = DisposableHelper . DISPOSED ; downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( upstream != DisposableHelper . DISPOSED ) upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; 
try onDispose . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream . isDisposed ( ) ; 
observer . onSubscribe ( Disposable . disposed ( ) ) ; observer . onError ( error ) ; 
source . subscribe ( new FlatMapBiMainObserver < T , U , R > ( observer , mapper , resultSelector ) ) ; 
DisposableHelper . dispose ( inner ) ; 
return DisposableHelper . isDisposed ( inner . get ( ) ) ; 
if ( DisposableHelper . setOnce ( inner , d ) ) inner . downstream . onSubscribe ( this ) ; 
inner . downstream . onError ( e ) ; 
inner . downstream . onComplete ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
Emitter < T > parent = new Emitter < > ( observer ) ; observer . onSubscribe ( parent ) ; try source . subscribe ( parent ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; parent . onError ( ex ) ; 
if ( ! tryOnError ( t ) ) RxJavaPlugins . onError ( t ) ; 
if ( t == null ) t = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; if ( get ( ) != DisposableHelper . DISPOSED ) Disposable d = getAndSet ( DisposableHelper . DISPOSED ) ; if ( d != DisposableHelper . DISPOSED ) try downstream . onError ( t ) ; finally if ( d != null ) d . dispose ( ) ; return true ; return false ; 
if ( get ( ) != DisposableHelper . DISPOSED ) Disposable d = getAndSet ( DisposableHelper . DISPOSED ) ; if ( d != DisposableHelper . DISPOSED ) try downstream . onComplete ( ) ; finally if ( d != null ) d . dispose ( ) ; 
DisposableHelper . set ( this , d ) ; 
setDisposable ( new CancellableDisposable ( c ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
return String . format ( "%s{%s}" , getClass ( ) . getSimpleName ( ) , super . toString ( ) ) ; 
ConcatMaybeObserver < T > parent = new ConcatMaybeObserver < > ( s , sources ) ; s . onSubscribe ( parent ) ; parent . drain ( ) ; 
disposables . dispose ( ) ; 
disposables . replace ( d ) ; 
downstream . onError ( e ) ; 
current . lazySet ( NotificationLite . COMPLETE ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; AtomicReference < Object > c = current ; Subscriber < ? super T > a = downstream ; Disposable cancelled = disposables ; for ( ; ; ) if ( cancelled . isDisposed ( ) ) c . lazySet ( null ) ; return ; Object o = c . get ( ) ; if ( o != null ) boolean goNextSource ; if ( o != NotificationLite . COMPLETE ) long p = produced ; if ( p != requested . get ( ) ) produced = p + 1 ; c . lazySet ( null ) ; goNextSource = true ; a . onNext ( ( T ) o ) ; else goNextSource = false ; else goNextSource = true ; c . lazySet ( null ) ; if ( goNextSource && ! cancelled . isDisposed ( ) ) int i = index ; if ( i == sources . length ) a . onComplete ( ) ; return ; index = i + 1 ; sources [ i ] . subscribe ( this ) ; if ( decrementAndGet ( ) == 0 ) break ; 
source . subscribe ( observer ) ; 
return ( Function ) INSTANCE ; 
return new MaybeToFlowable < > ( t ) ; 
source . subscribe ( new FlatMapMaybeObserver < > ( observer , mapper ) ) ; 
DisposableHelper . dispose ( this ) ; upstream . dispose ( ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
DisposableHelper . setOnce ( FlatMapMaybeObserver . this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
source . subscribe ( new TimeIntervalMaybeObserver < > ( observer , unit , scheduler , start ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
FlatMapCompletableObserver < T > parent = new FlatMapCompletableObserver < > ( observer , mapper ) ; observer . onSubscribe ( parent ) ; source . subscribe ( parent ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . replace ( this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
TimeoutMainMaybeObserver < T , U > parent = new TimeoutMainMaybeObserver < > ( observer , fallback ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; source . subscribe ( parent ) ; 
DisposableHelper . dispose ( this ) ; DisposableHelper . dispose ( other ) ; TimeoutFallbackMaybeObserver < T > oo = otherObserver ; if ( oo != null ) DisposableHelper . dispose ( oo ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
DisposableHelper . dispose ( other ) ; if ( getAndSet ( DisposableHelper . DISPOSED ) != DisposableHelper . DISPOSED ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
DisposableHelper . dispose ( other ) ; if ( getAndSet ( DisposableHelper . DISPOSED ) != DisposableHelper . DISPOSED ) downstream . onComplete ( ) ; 
if ( DisposableHelper . dispose ( this ) ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( DisposableHelper . dispose ( this ) ) if ( fallback == null ) downstream . onError ( new TimeoutException ( ) ) ; else fallback . subscribe ( otherObserver ) ; 
DisposableHelper . setOnce ( this , d ) ; 
parent . otherComplete ( ) ; 
parent . otherError ( e ) ; 
parent . otherComplete ( ) ; 
DisposableHelper . setOnce ( this , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
observer . onSubscribe ( EmptyDisposable . NEVER ) ; 
source . subscribe ( new OnErrorNextMaybeObserver < > ( observer , resumeFunction ) ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) downstream . onSubscribe ( this ) ; 
MaybeSource < ? extends T > m ; try m = Objects . requireNonNull ( resumeFunction . apply ( e ) , "The resumeFunction returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( new CompositeException ( e , ex ) ) ; return ; DisposableHelper . replace ( this , null ) ; m . subscribe ( new NextMaybeObserver < T > ( downstream , this ) ) ; 
downstream . onComplete ( ) ; 
DisposableHelper . setOnce ( this . upstream , d ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
@ SuppressWarnings ( "unchecked" ) MaybeSource < ? extends T > [ ] a = new MaybeSource [ 8 ] ; int n = 0 ; try for ( MaybeSource < ? extends T > source : sources ) if ( source == null ) EmptyDisposable . error ( new NullPointerException ( "One of the sources is null" ) , observer ) ; return ; if ( n == a . length ) a = Arrays . copyOf ( a , n + ( n > > 2 ) ) ; a [ n ++ ] = source ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; if ( n == 0 ) EmptyDisposable . complete ( observer ) ; return ; if ( n == 1 ) a [ 0 ] . subscribe ( new MaybeMap . MapMaybeObserver < > ( observer , new SingletonArrayFunc ( ) ) ) ; return ; ZipCoordinator < T , R > parent = new ZipCoordinator < > ( observer , n , zipper ) ; observer . onSubscribe ( parent ) ; for ( int i = 0 ; i < n ; i ++ ) if ( parent . isDisposed ( ) ) return ; a [ i ] . subscribe ( parent . observers [ i ] ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
lazySet ( DisposableHelper . DISPOSED ) ; try onError . accept ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( e , ex ) ) ; 
lazySet ( DisposableHelper . DISPOSED ) ; try onComplete . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
return onError != Functions . ON_ERROR_MISSING ; 
MaybeSource < ? extends T > source ; try source = Objects . requireNonNull ( maybeSupplier . get ( ) , "The maybeSupplier returned a null MaybeSource" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( observer ) ; 
TakeUntilMainMaybeObserver < T , U > parent = new TakeUntilMainMaybeObserver < > ( observer ) ; observer . onSubscribe ( parent ) ; other . subscribe ( parent . other ) ; source . subscribe ( parent ) ; 
DisposableHelper . dispose ( this ) ; SubscriptionHelper . cancel ( other ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
SubscriptionHelper . cancel ( other ) ; if ( getAndSet ( DisposableHelper . DISPOSED ) != DisposableHelper . DISPOSED ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
SubscriptionHelper . cancel ( other ) ; if ( getAndSet ( DisposableHelper . DISPOSED ) != DisposableHelper . DISPOSED ) downstream . onComplete ( ) ; 
if ( DisposableHelper . dispose ( this ) ) downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( DisposableHelper . dispose ( this ) ) downstream . onComplete ( ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
SubscriptionHelper . cancel ( this ) ; parent . otherComplete ( ) ; 
parent . otherError ( e ) ; 
parent . otherComplete ( ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( ! d . isDisposed ( ) ) T v ; try v = supplier . get ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! d . isDisposed ( ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! d . isDisposed ( ) ) if ( v == null ) observer . onComplete ( ) ; else observer . onSuccess ( v ) ; 
return supplier . get ( ) ; 
source . subscribe ( new DoOnTerminate ( observer ) ) ; 
downstream . onSubscribe ( d ) ; 
try onTerminate . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; e = new CompositeException ( e , ex ) ; downstream . onError ( e ) ; 
try onTerminate . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; downstream . onComplete ( ) ; 
Disposable d = Disposable . empty ( ) ; observer . onSubscribe ( d ) ; if ( ! d . isDisposed ( ) ) T v ; try v = callable . call ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( ! d . isDisposed ( ) ) observer . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; return ; if ( ! d . isDisposed ( ) ) if ( v == null ) observer . onComplete ( ) ; else observer . onSuccess ( v ) ; 
return callable . call ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; if ( d instanceof QueueDisposable ) this . qd = ( QueueDisposable < T > ) d ; if ( beforeDownstream ( ) ) downstream . onSubscribe ( this ) ; afterDownstream ( ) ; 
return true ; 
$EMPTY$
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
Exceptions . throwIfFatal ( t ) ; upstream . dispose ( ) ; onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
return qd . isEmpty ( ) ; 
qd . clear ( ) ; 
DisposableHelper . replace ( parent , d ) ; 
downstream . onError ( e ) ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
return getCount ( ) == 0 ; 
if ( getCount ( ) != 0 ) BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; if ( isCancelled ( ) ) throw new CancellationException ( ) ; Throwable ex = error ; if ( ex != null ) throw new ExecutionException ( ex ) ; return value ; 
DisposableHelper . setOnce ( this . upstream , d ) ; 
for ( ; ; ) Disposable a = upstream . get ( ) ; if ( a == DisposableHelper . DISPOSED ) RxJavaPlugins . onError ( t ) ; return ; error = t ; if ( upstream . compareAndSet ( a , this ) ) countDown ( ) ; return ; 
Disposable a = upstream . get ( ) ; if ( a == DisposableHelper . DISPOSED ) return ; upstream . compareAndSet ( a , this ) ; countDown ( ) ; 
$EMPTY$
return isDone ( ) ; 
try downstream . onSubscribe ( d ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; onSubscribeFailed = true ; d . dispose ( ) ; RxJavaPlugins . onError ( ex ) ; 
if ( onSubscribeFailed ) RxJavaPlugins . onError ( e ) ; else try downstream . onError ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( e , ex ) ) ; 
if ( ! onSubscribeFailed ) try downstream . onComplete ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
try downstream . onSubscribe ( d ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; onSubscribeFailed = true ; d . dispose ( ) ; RxJavaPlugins . onError ( ex ) ; 
if ( onSubscribeFailed ) RxJavaPlugins . onError ( e ) ; else try downstream . onError ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( e , ex ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
queue . offer ( NotificationLite . error ( t ) ) ; 
queue . offer ( NotificationLite . complete ( ) ) ; 
if ( DisposableHelper . dispose ( this ) ) queue . offer ( TERMINATED ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
try onSubscribe . accept ( d ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; d . dispose ( ) ; this . upstream = DisposableHelper . DISPOSED ; EmptyDisposable . error ( e , downstream ) ; return ; if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( upstream != DisposableHelper . DISPOSED ) upstream = DisposableHelper . DISPOSED ; downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( upstream != DisposableHelper . DISPOSED ) upstream = DisposableHelper . DISPOSED ; downstream . onComplete ( ) ; 
Disposable d = upstream ; if ( d != DisposableHelper . DISPOSED ) upstream = DisposableHelper . DISPOSED ; try onDispose . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; d . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( value == null ) error = t ; countDown ( ) ; 
if ( DisposableHelper . setOnce ( this , d ) ) try onSubscribe . accept ( this ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; d . dispose ( ) ; onError ( ex ) ; 
if ( ! isDisposed ( ) ) lazySet ( DisposableHelper . DISPOSED ) ; try onError . accept ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , e ) ) ; else RxJavaPlugins . onError ( t ) ; 
if ( ! isDisposed ( ) ) lazySet ( DisposableHelper . DISPOSED ) ; try onComplete . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
return onError != Functions . ON_ERROR_MISSING ; 
if ( DisposableHelper . setOnce ( this , d ) ) if ( d instanceof QueueDisposable ) @ SuppressWarnings ( "unchecked" ) QueueDisposable < T > qd = ( QueueDisposable < T > ) d ; int m = qd . requestFusion ( QueueDisposable . ANY ) ; if ( m == QueueSubscription . SYNC ) fusionMode = m ; queue = qd ; done = true ; parent . innerComplete ( this ) ; return ; if ( m == QueueDisposable . ASYNC ) fusionMode = m ; queue = qd ; return ; queue = QueueDrainHelper . createQueue ( - prefetch ) ; 
parent . innerError ( this , t ) ; 
parent . innerComplete ( this ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
return done ; 
this . done = true ; 
return queue ; 
this . upstream = d ; if ( cancelled ) d . dispose ( ) ; 
countDown ( ) ; 
cancelled = true ; Disposable d = this . upstream ; if ( d != null ) d . dispose ( ) ; 
return cancelled ; 
if ( getCount ( ) != 0 ) try BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; catch ( InterruptedException ex ) dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; Throwable e = error ; if ( e != null ) throw ExceptionHelper . wrapOrThrow ( e ) ; return value ; 
if ( get ( ) != DisposableHelper . DISPOSED ) lazySet ( DisposableHelper . DISPOSED ) ; try onError . accept ( t ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( new CompositeException ( t , e ) ) ; else RxJavaPlugins . onError ( t ) ; removeSelf ( ) ; 
if ( get ( ) != DisposableHelper . DISPOSED ) lazySet ( DisposableHelper . DISPOSED ) ; try onComplete . run ( ) ; catch ( Throwable e ) Exceptions . throwIfFatal ( e ) ; RxJavaPlugins . onError ( e ) ; removeSelf ( ) ; 
DisposableHelper . dispose ( this ) ; removeSelf ( ) ; 
DisposableContainer c = composite . getAndSet ( null ) ; if ( c != null ) c . delete ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
return onError != Functions . ON_ERROR_MISSING ; 
try onComplete . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; lazySet ( DisposableHelper . DISPOSED ) ; 
try onError . accept ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; lazySet ( DisposableHelper . DISPOSED ) ; 
DisposableHelper . setOnce ( this , d ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
return onError != Functions . ON_ERROR_MISSING ; 
lazySet ( DisposableHelper . DISPOSED ) ; try onError . accept ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( e , ex ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
return onError != Functions . ON_ERROR_MISSING ; 
return DisposableHelper . isDisposed ( upstream . get ( ) ) ; 
return getCount ( ) == 0 ; 
if ( getCount ( ) != 0 ) BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; if ( isCancelled ( ) ) throw new CancellationException ( ) ; Throwable ex = error ; if ( ex != null ) throw new ExecutionException ( ex ) ; return value ; 
DisposableHelper . setOnce ( this . upstream , d ) ; 
if ( error == null ) Disposable a = upstream . get ( ) ; if ( a != this && a != DisposableHelper . DISPOSED && upstream . compareAndSet ( a , this ) ) error = t ; countDown ( ) ; return ; RxJavaPlugins . onError ( t ) ; 
if ( value == null ) onError ( new NoSuchElementException ( "The source is empty" ) ) ; return ; Disposable a = upstream . get ( ) ; if ( a == this || a == DisposableHelper . DISPOSED ) return ; if ( upstream . compareAndSet ( a , this ) ) countDown ( ) ; 
$EMPTY$
return isDone ( ) ; 
return cancelled ; 
return done ; 
return wip . getAndIncrement ( ) == 0 ; 
return error ; 
DisposableHelper . setOnce ( this , d ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; try onError . accept ( t ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( t , ex ) ) ; 
if ( done ) return ; done = true ; try onComplete . run ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( this . get ( ) ) ; 
upstream . dispose ( ) ; countDown ( ) ; 
return upstream . isDisposed ( ) ; 
DisposableHelper . setOnce ( upstream , d ) ; 
this . error = e ; upstream . lazySet ( Disposable . disposed ( ) ) ; countDown ( ) ; 
upstream . lazySet ( Disposable . disposed ( ) ) ; countDown ( ) ; 
if ( getCount ( ) != 0 ) try BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; catch ( InterruptedException ex ) dispose ( ) ; observer . onError ( ex ) ; return ; if ( isDisposed ( ) ) return ; Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else observer . onComplete ( ) ; 
if ( getCount ( ) != 0 ) try BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; catch ( InterruptedException ex ) dispose ( ) ; observer . onError ( ex ) ; return ; if ( isDisposed ( ) ) return ; Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else observer . onSuccess ( value ) ; 
if ( getCount ( ) != 0 ) try BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; catch ( InterruptedException ex ) dispose ( ) ; observer . onError ( ex ) ; return ; if ( isDisposed ( ) ) return ; Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else T v = value ; if ( v == null ) observer . onComplete ( ) ; else observer . onSuccess ( v ) ; 
try downstream . onSubscribe ( d ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; onSubscribeFailed = true ; d . dispose ( ) ; RxJavaPlugins . onError ( ex ) ; 
if ( onSubscribeFailed ) RxJavaPlugins . onError ( e ) ; else try downstream . onError ( e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( e , ex ) ) ; 
if ( ! onSubscribeFailed ) try downstream . onComplete ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
value = null ; error ( t ) ; 
R v = value ; if ( v != null ) value = null ; complete ( v ) ; else complete ( ) ; 
super . dispose ( ) ; upstream . dispose ( ) ; 
value = null ; error = t ; countDown ( ) ; 
int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) RxJavaPlugins . onError ( t ) ; return ; lazySet ( TERMINATED ) ; downstream . onError ( t ) ; 
int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) return ; lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; 
if ( get ( ) == FUSED_READY ) T v = value ; value = null ; lazySet ( FUSED_CONSUMED ) ; return v ; return null ; 
return get ( ) != FUSED_READY ; 
lazySet ( FUSED_CONSUMED ) ; value = null ; 
set ( DISPOSED ) ; value = null ; 
return getAndSet ( DISPOSED ) != DISPOSED ; 
return get ( ) == DISPOSED ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
lazySet ( DisposableHelper . DISPOSED ) ; 
lazySet ( DisposableHelper . DISPOSED ) ; RxJavaPlugins . onError ( new OnErrorNotImplementedException ( e ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
return false ; 
cancelled = true ; Disposable d = this . upstream ; if ( d != null ) d . dispose ( ) ; 
this . upstream = d ; if ( cancelled ) d . dispose ( ) ; 
error = e ; countDown ( ) ; 
countDown ( ) ; 
if ( getCount ( ) != 0 ) try BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; catch ( InterruptedException ex ) dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; Throwable ex = error ; if ( ex != null ) throw ExceptionHelper . wrapOrThrow ( ex ) ; return value ; 
try if ( getCount ( ) != 0 ) try BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; catch ( InterruptedException ex ) dispose ( ) ; onError . accept ( ex ) ; return ; Throwable ex = error ; if ( ex != null ) onError . accept ( ex ) ; return ; T v = value ; if ( v != null ) onSuccess . accept ( v ) ; else onComplete . run ( ) ; catch ( Throwable t ) Exceptions . throwIfFatal ( t ) ; RxJavaPlugins . onError ( t ) ; 
try lazySet ( DisposableHelper . DISPOSED ) ; onCallback . accept ( null , e ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( new CompositeException ( e , ex ) ) ; 
DisposableHelper . setOnce ( this , d ) ; 
DisposableHelper . dispose ( this ) ; 
return get ( ) == DisposableHelper . DISPOSED ; 
Collections . sort ( t , comparator ) ; return t ; 
return "NotificationLite.Error[" + e + "]" ; 
return e . hashCode ( ) ; 
if ( obj instanceof ErrorNotification ) ErrorNotification n = ( ErrorNotification ) obj ; return Objects . equals ( e , n . e ) ; return false ; 
return "NotificationLite.Subscription[" + upstream + "]" ; 
return "NotificationLite.Disposable[" + upstream + "]" ; 
return COMPLETE ; 
return new ErrorNotification ( e ) ; 
return new SubscriptionNotification ( s ) ; 
return new DisposableNotification ( d ) ; 
return o == COMPLETE ; 
return o instanceof ErrorNotification ; 
return o instanceof SubscriptionNotification ; 
return o instanceof DisposableNotification ; 
return ( T ) o ; 
return ( ( ErrorNotification ) o ) . e ; 
return ( ( SubscriptionNotification ) o ) . upstream ; 
return ( ( DisposableNotification ) o ) . upstream ; 
if ( o == COMPLETE ) s . onComplete ( ) ; return true ; else if ( o instanceof ErrorNotification ) s . onError ( ( ( ErrorNotification ) o ) . e ) ; return true ; s . onNext ( ( T ) o ) ; return false ; 
if ( o == COMPLETE ) observer . onComplete ( ) ; return true ; else if ( o instanceof ErrorNotification ) observer . onError ( ( ( ErrorNotification ) o ) . e ) ; return true ; observer . onNext ( ( T ) o ) ; return false ; 
if ( o == COMPLETE ) s . onComplete ( ) ; return true ; else if ( o instanceof ErrorNotification ) s . onError ( ( ( ErrorNotification ) o ) . e ) ; return true ; else if ( o instanceof SubscriptionNotification ) s . onSubscribe ( ( ( SubscriptionNotification ) o ) . upstream ) ; return false ; s . onNext ( ( T ) o ) ; return false ; 
if ( o == COMPLETE ) observer . onComplete ( ) ; return true ; else if ( o instanceof ErrorNotification ) observer . onError ( ( ( ErrorNotification ) o ) . e ) ; return true ; else if ( o instanceof DisposableNotification ) observer . onSubscribe ( ( ( DisposableNotification ) o ) . upstream ) ; return false ; observer . onNext ( ( T ) o ) ; return false ; 
return "NotificationLite.Complete" ; 
int n = a . size ( ) + b . size ( ) ; if ( n == 0 ) return new ArrayList < > ( ) ; List < T > both = new ArrayList < > ( n ) ; Iterator < T > at = a . iterator ( ) ; Iterator < T > bt = b . iterator ( ) ; T s1 = at . hasNext ( ) ? at . next ( ) : null ; T s2 = bt . hasNext ( ) ? bt . next ( ) : null ; while ( s1 != null && s2 != null ) if ( comparator . compare ( s1 , s2 ) < 0 ) both . add ( s1 ) ; s1 = at . hasNext ( ) ? at . next ( ) : null ; else both . add ( s2 ) ; s2 = bt . hasNext ( ) ? bt . next ( ) : null ; if ( s1 != null ) both . add ( s1 ) ; while ( at . hasNext ( ) ) both . add ( at . next ( ) ) ; else both . add ( s2 ) ; while ( bt . hasNext ( ) ) both . add ( bt . next ( ) ) ; return both ; 
if ( error instanceof Error ) throw ( Error ) error ; if ( error instanceof RuntimeException ) return ( RuntimeException ) error ; return new RuntimeException ( error ) ; 
for ( ; ; ) Throwable current = field . get ( ) ; if ( current == TERMINATED ) return false ; Throwable update ; if ( current == null ) update = exception ; else update = new CompositeException ( current , exception ) ; if ( field . compareAndSet ( current , update ) ) return true ; 
Throwable current = field . get ( ) ; if ( current != TERMINATED ) current = field . getAndSet ( TERMINATED ) ; return current ; 
List < Throwable > list = new ArrayList < > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) deque . offerFirst ( exceptions . get ( i ) ) ; else list . add ( e ) ; return list ; 
if ( e instanceof Exception ) return ( Exception ) e ; throw ( E ) e ; 
return this ; 
return prefix + " Null values are generally not allowed in 3.x operators and sources." ; 
return new NullPointerException ( nullWarning ( prefix ) ) ; 
T [ ] a = keys ; int i = a . length ; int newCap = i << 1 ; int m = newCap - 1 ; T [ ] b = ( T [ ] ) new Object [ newCap ] ; for ( int j = size ; j -- != 0 ; ) while ( a [ -- i ] == null ) int pos = mix ( a [ i ] . hashCode ( ) ) & m ; if ( b [ pos ] != null ) for ( ; ; ) pos = ( pos + 1 ) & m ; if ( b [ pos ] == null ) break ; b [ pos ] = a [ i ] ; this . mask = m ; this . maxSize = ( int ) ( newCap * loadFactor ) ; this . keys = b ; 
return keys ; 
return size ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) if ( wip . getAndIncrement ( ) == 0 ) errors . tryTerminateConsumer ( subscriber ) ; 
if ( wip . getAndIncrement ( ) == 0 ) errors . tryTerminateConsumer ( subscriber ) ; 
if ( errors . tryAddThrowableOrReport ( ex ) ) if ( wip . getAndIncrement ( ) == 0 ) errors . tryTerminateConsumer ( observer ) ; 
if ( wip . getAndIncrement ( ) == 0 ) errors . tryTerminateConsumer ( observer ) ; 
error = e ; countDown ( ) ; 
countDown ( ) ; 
return get ( ) ; 
return get ( ) == 0 ; 
return list . contains ( o ) ; 
return list . iterator ( ) ; 
return list . toArray ( ) ; 
boolean b = list . remove ( o ) ; lazySet ( list . size ( ) ) ; return b ; 
return list . containsAll ( c ) ; 
boolean b = list . addAll ( c ) ; lazySet ( list . size ( ) ) ; return b ; 
boolean b = list . removeAll ( c ) ; lazySet ( list . size ( ) ) ; return b ; 
boolean b = list . retainAll ( c ) ; lazySet ( list . size ( ) ) ; return b ; 
list . clear ( ) ; lazySet ( 0 ) ; 
return list . indexOf ( o ) ; 
return list . lastIndexOf ( o ) ; 
return list . listIterator ( ) ; 
if ( obj instanceof VolatileSizeArrayList ) return list . equals ( ( ( VolatileSizeArrayList < ? > ) obj ) . list ) ; return list . equals ( obj ) ; 
return list . hashCode ( ) ; 
return list . toString ( ) ; 
return ( Supplier ) INSTANCE ; 
return new HashMap < > ( ) ; 
Object [ ] a = head ; final int c = capacity ; while ( a != null ) for ( int i = 0 ; i < c ; i ++ ) Object o = a [ i ] ; if ( o == null ) break ; if ( NotificationLite . acceptFull ( o , subscriber ) ) return true ; a = ( Object [ ] ) a [ c ] ; return false ; 
Object [ ] a = head ; final int c = capacity ; while ( a != null ) for ( int i = 0 ; i < c ; i ++ ) Object o = a [ i ] ; if ( o == null ) break ; if ( NotificationLite . acceptFull ( o , observer ) ) return true ; a = ( Object [ ] ) a [ c ] ; return false ; 
this . disposable = t ; 
if ( size == 0 ) head = new Object [ capacityHint + 1 ] ; tail = head ; head [ 0 ] = o ; indexInTail = 1 ; size = 1 ; else if ( indexInTail == capacityHint ) Object [ ] t = new Object [ capacityHint + 1 ] ; t [ 0 ] = o ; tail [ capacityHint ] = t ; tail = t ; indexInTail = 1 ; size ++ ; else tail [ indexInTail ] = o ; indexInTail ++ ; size ++ ; 
return head ; 
return size ; 
final int cap = capacityHint ; final int s = size ; final List < Object > list = new ArrayList < > ( s + 1 ) ; Object [ ] h = head ( ) ; int j = 0 ; int k = 0 ; while ( j < s ) list . add ( h [ k ] ) ; j ++ ; if ( ++ k == cap ) k = 0 ; h = ( Object [ ] ) h [ cap ] ; return list . toString ( ) ; 
return ( BiFunction ) INSTANCE ; 
t1 . add ( t2 ) ; return t1 ; 
return ( Subscriber < T > ) INSTANCE ; 
return ( Observer < T > ) INSTANCE ; 
$EMPTY$
return true ; 
$EMPTY$
d . dispose ( ) ; 
s . cancel ( ) ; 
$EMPTY$
RxJavaPlugins . onError ( t ) ; 
$EMPTY$
$EMPTY$
return ExceptionHelper . addThrowable ( this , t ) ; 
if ( tryAddThrowable ( t ) ) return true ; RxJavaPlugins . onError ( t ) ; return false ; 
return ExceptionHelper . terminate ( this ) ; 
return get ( ) == ExceptionHelper . TERMINATED ; 
Throwable ex = terminate ( ) ; if ( ex != null && ex != ExceptionHelper . TERMINATED ) RxJavaPlugins . onError ( ex ) ; 
Throwable ex = terminate ( ) ; if ( ex == null ) consumer . onComplete ( ) ; else if ( ex != ExceptionHelper . TERMINATED ) consumer . onError ( ex ) ; 
Throwable ex = terminate ( ) ; if ( ex == null ) consumer . onComplete ( ) ; else if ( ex != ExceptionHelper . TERMINATED ) consumer . onError ( ex ) ; 
Throwable ex = terminate ( ) ; if ( ex == null ) consumer . onComplete ( ) ; else if ( ex != ExceptionHelper . TERMINATED ) consumer . onError ( ex ) ; 
Throwable ex = terminate ( ) ; if ( ex != null && ex != ExceptionHelper . TERMINATED ) consumer . onError ( ex ) ; 
Throwable ex = terminate ( ) ; if ( ex == null ) consumer . onComplete ( ) ; else if ( ex != ExceptionHelper . TERMINATED ) consumer . onError ( ex ) ; 
Throwable ex = terminate ( ) ; if ( ex == null ) consumer . onComplete ( ) ; else if ( ex != ExceptionHelper . TERMINATED ) consumer . onError ( ex ) ; 
Objects . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) reportDoubleSubscription ( observer ) ; return false ; return true ; 
Objects . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) reportDoubleSubscription ( observer ) ; return false ; return true ; 
Objects . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) reportDoubleSubscription ( subscriber ) ; return false ; return true ; 
Objects . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) reportDoubleSubscription ( subscriber ) ; return false ; return true ; 
return "It is not allowed to subscribe with a(n) " + consumer + " multiple times. " + "Please create a fresh instance of " + consumer + " and subscribe that to the target source instead." ; 
RxJavaPlugins . onError ( new ProtocolViolationException ( composeMessage ( consumer . getName ( ) ) ) ) ; 
if ( latch . getCount ( ) == 0 ) return ; try verifyNonBlocking ( ) ; latch . await ( ) ; catch ( InterruptedException e ) subscription . dispose ( ) ; Thread . currentThread ( ) . interrupt ( ) ; throw new IllegalStateException ( "Interrupted while waiting for subscription to complete." , e ) ; 
if ( RxJavaPlugins . isFailOnNonBlockingScheduler ( ) && ( Thread . currentThread ( ) instanceof NonBlockingThread || RxJavaPlugins . onBeforeBlocking ( ) ) ) throw new IllegalStateException ( "Attempt to block on a Scheduler " + Thread . currentThread ( ) . getName ( ) + " that doesn't support blocking operators as they may lead to deadlock" ) ; 
return ( Supplier ) INSTANCE ; 
return ( Function ) INSTANCE ; 
return new ArrayList < > ( ) ; 
return new ArrayList < > ( ) ; 
try return cancelled . getAsBoolean ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; return true ; 
if ( queue . isEmpty ( ) ) actual . onComplete ( ) ; return ; if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) return ; for ( ; ; ) long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) return ; long u = r | COMPLETED_MASK ; if ( state . compareAndSet ( r , u ) ) if ( r != 0L ) postCompleteDrain ( u , actual , queue , state , isCancelled ) ; return ; 
return new Array2Func < > ( f ) ; 
return new Array3Func < > ( f ) ; 
return new Array4Func < > ( f ) ; 
return new Array5Func < > ( f ) ; 
return new Array6Func < > ( f ) ; 
return new Array7Func < > ( f ) ; 
return new Array8Func < > ( f ) ; 
return new Array9Func < > ( f ) ; 
return ( Function < T , T > ) IDENTITY ; 
return ( Consumer < T > ) EMPTY_CONSUMER ; 
return ( Predicate < T > ) ALWAYS_TRUE ; 
return ( Predicate < T > ) ALWAYS_FALSE ; 
return ( Supplier < T > ) NULL_SUPPLIER ; 
future . get ( ) ; 
return new FutureAction ( future ) ; 
return value ; 
return value ; 
return new CastToClass < > ( target ) ; 
return new ArrayList < > ( capacity ) ; 
return new HashSet < > ( ) ; 
return ( Supplier ) HashSetSupplier . INSTANCE ; 
onNotification . accept ( Notification . createOnError ( v ) ) ; 
onNotification . accept ( Notification . createOnComplete ( ) ) ; 
return new NotificationOnNext < > ( onNotification ) ; 
return new NotificationOnError < > ( onNotification ) ; 
return new NotificationOnComplete < > ( onNotification ) ; 
return new ActionConsumer < > ( action ) ; 
return new ClassFilter < > ( clazz ) ; 
return new BooleanSupplierPredicateReverse < > ( supplier ) ; 
return new TimestampFunction < > ( unit , scheduler ) ; 
return new ToMapKeySelector < > ( keySelector ) ; 
return new ToMapKeyValueSelector < > ( valueSelector , keySelector ) ; 
return new ToMultimapKeyValueSelector < > ( collectionFactory , valueSelector , keySelector ) ; 
return ( ( Comparable < Object > ) o1 ) . compareTo ( o2 ) ; 
return ( Comparator < T > ) NaturalComparator . INSTANCE ; 
Collections . sort ( v , comparator ) ; return v ; 
return new ListSorter < > ( comparator ) ; 
return v ; 
return "IdentityFunction" ; 
$EMPTY$
return "EmptyRunnable" ; 
$EMPTY$
return "EmptyAction" ; 
$EMPTY$
return "EmptyConsumer" ; 
RxJavaPlugins . onError ( error ) ; 
RxJavaPlugins . onError ( new OnErrorNotImplementedException ( error ) ) ; 
return true ; 
return false ; 
return null ; 
t . request ( Long . MAX_VALUE ) ; 
s . request ( bufferSize ) ; 
return ( BiPredicate < T , T > ) EQUALS ; 
return Objects . equals ( o1 , o2 ) ; 
if ( ! isDone ( ) ) T v = value ; clear ( ) ; if ( v != null ) complete ( v ) ; else if ( hasDefault ) complete ( defaultItem ) ; else completeExceptionally ( new NoSuchElementException ( ) ) ; 
s . request ( Long . MAX_VALUE ) ; 
BiConsumerAtomicReference < T > whenReference = new BiConsumerAtomicReference < > ( ) ; CompletionStageHandler < T > handler = new CompletionStageHandler < > ( observer , whenReference ) ; whenReference . lazySet ( handler ) ; observer . onSubscribe ( handler ) ; stage . whenComplete ( whenReference ) ; 
super . dispose ( ) ; whenReference . set ( null ) ; 
if ( ! isDone ( ) ) clear ( ) ; if ( hasDefault ) complete ( defaultItem ) ; else completeExceptionally ( new NoSuchElementException ( ) ) ; 
s . request ( 1 ) ; 
return new ObservableCollectWithCollector < > ( source , collector ) ; 
A container ; BiConsumer < A , ? super T > accumulator ; Function < A , R > finisher ; try container = collector . supplier ( ) . get ( ) ; accumulator = collector . accumulator ( ) ; finisher = collector . finisher ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( new CollectorSingleObserver < > ( observer , container , accumulator , finisher ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; else done = true ; upstream = DisposableHelper . DISPOSED ; this . container = null ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; upstream = DisposableHelper . DISPOSED ; A container = this . container ; this . container = null ; R result ; try result = Objects . requireNonNull ( finisher . apply ( container ) , "The finisher returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; downstream . onSuccess ( result ) ; 
upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; 
return upstream == DisposableHelper . DISPOSED ; 
source . subscribe ( new MapOptionalMaybeObserver < > ( observer , mapper ) ) ; 
Disposable d = this . upstream ; this . upstream = DisposableHelper . DISPOSED ; d . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
BiConsumerAtomicReference < T > whenReference = new BiConsumerAtomicReference < > ( ) ; CompletionStageHandler < T > handler = new CompletionStageHandler < > ( observer , whenReference ) ; whenReference . lazySet ( handler ) ; observer . onSubscribe ( handler ) ; stage . whenComplete ( whenReference ) ; 
whenReference . set ( null ) ; 
return whenReference . get ( ) == null ; 
if ( source instanceof Supplier ) Stream < ? extends R > stream = null ; try @ SuppressWarnings ( "unchecked" ) T t = ( ( Supplier < T > ) source ) . get ( ) ; if ( t != null ) stream = Objects . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Stream" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; if ( stream != null ) FlowableFromStream . subscribeStream ( s , stream ) ; else EmptySubscription . complete ( s ) ; else source . subscribe ( subscribe ( s , mapper , prefetch ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( QueueFuseable . ANY | QueueFuseable . BOUNDARY ) ; if ( m == QueueFuseable . SYNC ) sourceMode = m ; queue = qs ; upstreamDone = true ; downstream . onSubscribe ( this ) ; return ; else if ( m == QueueFuseable . ASYNC ) sourceMode = m ; queue = qs ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; return ; queue = new SpscArrayQueue < > ( prefetch ) ; downstream . onSubscribe ( this ) ; s . request ( prefetch ) ; 
if ( error . compareAndSet ( null , t ) ) upstreamDone = true ; drain ( ) ; else RxJavaPlugins . onError ( t ) ; 
upstreamDone = true ; drain ( ) ; 
cancelled = true ; upstream . cancel ( ) ; drain ( ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; final Subscriber < ? super R > downstream = this . downstream ; final SimpleQueue < T > queue = this . queue ; final AtomicThrowable error = this . error ; Iterator < ? extends R > iterator = this . currentIterator ; long requested = this . requested . get ( ) ; long emitted = this . emitted ; final int limit = prefetch - ( prefetch > > 2 ) ; boolean canRequest = sourceMode != QueueFuseable . SYNC ; for ( ; ; ) if ( cancelled ) queue . clear ( ) ; clearCurrentSuppressCloseError ( ) ; else boolean isDone = upstreamDone ; if ( error . get ( ) != null ) downstream . onError ( error . get ( ) ) ; cancelled = true ; continue ; if ( iterator == null ) T t ; try t = queue . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; trySignalError ( downstream , ex ) ; continue ; boolean isEmpty = t == null ; if ( isDone && isEmpty ) downstream . onComplete ( ) ; cancelled = true ; else if ( ! isEmpty ) if ( canRequest && ++ consumed == limit ) consumed = 0 ; upstream . request ( limit ) ; Stream < ? extends R > stream ; try stream = Objects . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Stream" ) ; iterator = stream . iterator ( ) ; if ( iterator . hasNext ( ) ) currentIterator = iterator ; currentCloseable = stream ; else iterator = null ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; trySignalError ( downstream , ex ) ; continue ; if ( iterator != null && emitted != requested ) R item ; try item = Objects . requireNonNull ( iterator . next ( ) , "The Stream.Iterator returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; trySignalError ( downstream , ex ) ; continue ; if ( ! cancelled ) downstream . onNext ( item ) ; emitted ++ ; if ( ! cancelled ) try if ( ! iterator . hasNext ( ) ) iterator = null ; clearCurrentRethrowCloseError ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; trySignalError ( downstream , ex ) ; continue ; this . emitted = emitted ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) break ; requested = this . requested . get ( ) ; 
currentIterator = null ; AutoCloseable ac = currentCloseable ; currentCloseable = null ; if ( ac != null ) ac . close ( ) ; 
try clearCurrentRethrowCloseError ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
if ( error . compareAndSet ( null , ex ) ) upstream . cancel ( ) ; cancelled = true ; downstream . onError ( ex ) ; else RxJavaPlugins . onError ( ex ) ; 
source . subscribe ( new MapOptionalObserver < > ( observer , mapper ) ) ; 
for ( ; ; ) T item = qd . poll ( ) ; if ( item == null ) return null ; Optional < ? extends R > result = Objects . requireNonNull ( mapper . apply ( item ) , "The mapper returned a null Optional" ) ; if ( result . isPresent ( ) ) return result . get ( ) ; 
DisposableHelper . setOnce ( upstream , d ) ; 
clear ( ) ; if ( ! completeExceptionally ( t ) ) RxJavaPlugins . onError ( t ) ; 
if ( hasDefault ) complete ( defaultItem ) ; else completeExceptionally ( new NoSuchElementException ( "The source was empty" ) ) ; 
DisposableHelper . dispose ( upstream ) ; 
upstream . lazySet ( DisposableHelper . DISPOSED ) ; 
cancelUpstream ( ) ; return super . completeExceptionally ( ex ) ; 
BiConsumerAtomicReference < Object > whenReference = new BiConsumerAtomicReference < > ( ) ; CompletionStageHandler < Object > handler = new CompletionStageHandler < > ( observer , whenReference ) ; whenReference . lazySet ( handler ) ; observer . onSubscribe ( handler ) ; stage . whenComplete ( whenReference ) ; 
whenReference . set ( null ) ; 
return whenReference . get ( ) == null ; 
return new FlowableCollectWithCollector < > ( source , collector ) ; 
A container ; BiConsumer < A , ? super T > accumulator ; Function < A , R > finisher ; try container = collector . supplier ( ) . get ( ) ; accumulator = collector . accumulator ( ) ; finisher = collector . finisher ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( new CollectorSingleObserver < > ( observer , container , accumulator , finisher ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; else done = true ; upstream = SubscriptionHelper . CANCELLED ; this . container = null ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; A container = this . container ; this . container = null ; R result ; try result = Objects . requireNonNull ( finisher . apply ( container ) , "The finisher returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; downstream . onSuccess ( result ) ; 
upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; 
return upstream == SubscriptionHelper . CANCELLED ; 
DisposableHelper . setOnce ( upstream , d ) ; 
clear ( ) ; if ( ! completeExceptionally ( t ) ) RxJavaPlugins . onError ( t ) ; 
DisposableHelper . dispose ( upstream ) ; 
value = null ; upstream . lazySet ( DisposableHelper . DISPOSED ) ; 
disposeUpstream ( ) ; return super . completeExceptionally ( ex ) ; 
subscribeStream ( s , stream ) ; 
Iterator < T > iterator ; try iterator = stream . iterator ( ) ; if ( ! iterator . hasNext ( ) ) EmptySubscription . complete ( s ) ; closeSafely ( stream ) ; return ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; closeSafely ( stream ) ; return ; if ( s instanceof ConditionalSubscriber ) s . onSubscribe ( new StreamConditionalSubscription < > ( ( ConditionalSubscriber < ? super T > ) s , iterator , stream ) ) ; else s . onSubscribe ( new StreamSubscription < > ( s , iterator , stream ) ) ; 
try c . close ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
cancelled = true ; request ( 1L ) ; 
if ( iterator == null ) return null ; if ( ! once ) once = true ; else if ( ! iterator . hasNext ( ) ) clear ( ) ; return null ; return Objects . requireNonNull ( iterator . next ( ) , "The Stream's Iterator.next() returned a null value" ) ; 
Iterator < T > it = iterator ; if ( it != null ) if ( ! once || it . hasNext ( ) ) return false ; clear ( ) ; return true ; 
iterator = null ; AutoCloseable c = closeable ; closeable = null ; if ( c != null ) closeSafely ( c ) ; 
ParallelCollectorSubscriber < T , A , R > parent ; try parent = new ParallelCollectorSubscriber < > ( s , source . parallelism ( ) , collector ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; s . onSubscribe ( parent ) ; source . subscribe ( parent . subscribers ) ; 
for ( ParallelCollectorInnerSubscriber < T , A , R > inner : subscribers ) inner . cancel ( ) ; 
if ( error . compareAndSet ( null , ex ) ) cancel ( ) ; downstream . onError ( ex ) ; else if ( ex != error . get ( ) ) RxJavaPlugins . onError ( ex ) ; 
SubscriptionHelper . setOnce ( this , s , Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; container = null ; done = true ; parent . innerError ( t ) ; 
if ( ! done ) A v = container ; container = null ; done = true ; parent . innerComplete ( v , combiner ) ; 
SubscriptionHelper . cancel ( this ) ; 
for ( ; ; ) int acquired = get ( ) ; if ( acquired >= 2 ) return - 1 ; if ( compareAndSet ( acquired , acquired + 1 ) ) return acquired ; 
return releaseIndex . incrementAndGet ( ) == 2 ; 
subscribeStream ( observer , stream ) ; 
Iterator < T > iterator ; try iterator = stream . iterator ( ) ; if ( ! iterator . hasNext ( ) ) EmptyDisposable . complete ( observer ) ; closeSafely ( stream ) ; return ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; closeSafely ( stream ) ; return ; StreamDisposable < T > disposable = new StreamDisposable < > ( observer , iterator , stream ) ; observer . onSubscribe ( disposable ) ; disposable . run ( ) ; 
try c . close ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
disposed = true ; run ( ) ; 
return disposed ; 
if ( iterator == null ) return null ; if ( ! once ) once = true ; else if ( ! iterator . hasNext ( ) ) clear ( ) ; return null ; return Objects . requireNonNull ( iterator . next ( ) , "The Stream's Iterator.next() returned a null value" ) ; 
Iterator < T > it = iterator ; if ( it != null ) if ( ! once || it . hasNext ( ) ) return false ; clear ( ) ; return true ; 
iterator = null ; AutoCloseable c = closeable ; closeable = null ; if ( c != null ) closeSafely ( c ) ; 
if ( outputFused ) return ; Iterator < T > iterator = this . iterator ; Observer < ? super T > downstream = this . downstream ; for ( ; ; ) if ( disposed ) clear ( ) ; break ; T next ; try next = Objects . requireNonNull ( iterator . next ( ) , "The Stream's Iterator.next returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; disposed = true ; continue ; if ( disposed ) continue ; downstream . onNext ( next ) ; if ( disposed ) continue ; try if ( iterator . hasNext ( ) ) continue ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; disposed = true ; continue ; downstream . onComplete ( ) ; disposed = true ; 
if ( s instanceof ConditionalSubscriber ) source . subscribe ( new MapOptionalConditionalSubscriber < > ( ( ConditionalSubscriber < ? super R > ) s , mapper ) ) ; else source . subscribe ( new MapOptionalSubscriber < > ( s , mapper ) ) ; 
for ( ; ; ) T item = qs . poll ( ) ; if ( item == null ) return null ; Optional < ? extends R > result = Objects . requireNonNull ( mapper . apply ( item ) , "The mapper returned a null Optional" ) ; if ( result . isPresent ( ) ) return result . get ( ) ; if ( sourceMode == ASYNC ) qs . request ( 1 ) ; 
for ( ; ; ) T item = qs . poll ( ) ; if ( item == null ) return null ; Optional < ? extends R > result = Objects . requireNonNull ( mapper . apply ( item ) , "The mapper returned a null Optional" ) ; if ( result . isPresent ( ) ) return result . get ( ) ; if ( sourceMode == ASYNC ) qs . request ( 1 ) ; 
source . subscribe ( new MapOptionalSingleObserver < > ( observer , mapper ) ) ; 
Disposable d = this . upstream ; this . upstream = DisposableHelper . DISPOSED ; d . dispose ( ) ; 
return upstream . isDisposed ( ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
BiConsumerAtomicReference < T > whenReference = new BiConsumerAtomicReference < > ( ) ; CompletionStageHandler < T > handler = new CompletionStageHandler < > ( s , whenReference ) ; whenReference . lazySet ( handler ) ; s . onSubscribe ( handler ) ; stage . whenComplete ( whenReference ) ; 
super . cancel ( ) ; whenReference . set ( null ) ; 
return source . parallelism ( ) ; 
if ( ! isDone ( ) ) T v = value ; clear ( ) ; if ( v != null ) complete ( v ) ; else if ( hasDefault ) complete ( defaultItem ) ; else completeExceptionally ( new NoSuchElementException ( ) ) ; 
s . request ( 2 ) ; 
if ( SubscriptionHelper . setOnce ( upstream , s ) ) afterSubscribe ( s ) ; 
clear ( ) ; if ( ! completeExceptionally ( t ) ) RxJavaPlugins . onError ( t ) ; 
SubscriptionHelper . cancel ( upstream ) ; 
value = null ; upstream . lazySet ( SubscriptionHelper . CANCELLED ) ; 
cancelUpstream ( ) ; return super . completeExceptionally ( ex ) ; 
A container ; BiConsumer < A , ? super T > accumulator ; Function < A , R > finisher ; try container = collector . supplier ( ) . get ( ) ; accumulator = collector . accumulator ( ) ; finisher = collector . finisher ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; source . subscribe ( new CollectorObserver < > ( observer , container , accumulator , finisher ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; else done = true ; upstream = DisposableHelper . DISPOSED ; this . container = null ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; upstream = DisposableHelper . DISPOSED ; A container = this . container ; this . container = null ; R result ; try result = Objects . requireNonNull ( finisher . apply ( container ) , "The finisher returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; complete ( result ) ; 
super . dispose ( ) ; upstream . dispose ( ) ; 
source . subscribe ( new FlattenStreamMultiObserver < > ( s , mapper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
disposed = true ; upstream . dispose ( ) ; if ( ! outputFused ) drain ( ) ; 
return disposed ; 
Iterator < ? extends R > it = iterator ; if ( it != null ) if ( once ) if ( ! it . hasNext ( ) ) clear ( ) ; return null ; else once = true ; return it . next ( ) ; return null ; 
Iterator < ? extends R > it = iterator ; if ( it != null ) if ( ! once ) return false ; if ( it . hasNext ( ) ) return false ; clear ( ) ; return true ; 
iterator = null ; AutoCloseable close = this . close ; this . close = null ; close ( close ) ; 
try if ( c != null ) c . close ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Observer < ? super R > downstream = this . downstream ; Iterator < ? extends R > it = iterator ; for ( ; ; ) if ( disposed ) clear ( ) ; else if ( outputFused ) downstream . onNext ( null ) ; downstream . onComplete ( ) ; else R item ; try item = it . next ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; disposed = true ; continue ; if ( disposed ) continue ; downstream . onNext ( item ) ; if ( disposed ) continue ; boolean has ; try has = it . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; disposed = true ; continue ; if ( disposed ) continue ; if ( ! has ) downstream . onComplete ( ) ; disposed = true ; continue ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) return ; 
return source . parallelism ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
A container ; BiConsumer < A , ? super T > accumulator ; Function < A , R > finisher ; try container = collector . supplier ( ) . get ( ) ; accumulator = collector . accumulator ( ) ; finisher = collector . finisher ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , s ) ; return ; source . subscribe ( new CollectorSubscriber < > ( s , container , accumulator , finisher ) ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; s . request ( Long . MAX_VALUE ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; else done = true ; upstream = SubscriptionHelper . CANCELLED ; this . container = null ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; upstream = SubscriptionHelper . CANCELLED ; A container = this . container ; this . container = null ; R result ; try result = Objects . requireNonNull ( finisher . apply ( container ) , "The finisher returned a null value" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; return ; complete ( result ) ; 
super . cancel ( ) ; upstream . cancel ( ) ; 
source . subscribe ( new FlattenStreamMultiObserver < > ( s , mapper ) ) ; 
BiConsumerAtomicReference < T > whenReference = new BiConsumerAtomicReference < > ( ) ; CompletionStageHandler < T > handler = new CompletionStageHandler < > ( observer , whenReference ) ; whenReference . lazySet ( handler ) ; observer . onSubscribe ( handler ) ; stage . whenComplete ( whenReference ) ; 
whenReference . set ( null ) ; 
return whenReference . get ( ) == null ; 
source . subscribe ( new FlattenStreamMultiObserver < > ( s , mapper ) ) ; 
if ( source instanceof Supplier ) Stream < ? extends R > stream = null ; try @ SuppressWarnings ( "unchecked" ) T t = ( ( Supplier < T > ) source ) . get ( ) ; if ( t != null ) stream = Objects . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Stream" ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return ; if ( stream != null ) ObservableFromStream . subscribeStream ( observer , stream ) ; else EmptyDisposable . complete ( observer ) ; else source . subscribe ( new FlatMapStreamObserver < > ( observer , mapper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( e ) ; else done = true ; downstream . onError ( e ) ; 
if ( ! done ) done = true ; downstream . onComplete ( ) ; 
disposed = true ; upstream . dispose ( ) ; 
return disposed ; 
return source . parallelism ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
upstream . cancel ( ) ; 
if ( SubscriptionHelper . validate ( this . upstream , s ) ) this . upstream = s ; downstream . onSubscribe ( this ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; downstream . onError ( t ) ; 
if ( done ) return ; done = true ; downstream . onComplete ( ) ; 
source . subscribe ( new FlattenStreamMultiObserver < > ( s , mapper ) ) ; 
if ( DisposableHelper . validate ( this . upstream , d ) ) this . upstream = d ; downstream . onSubscribe ( this ) ; 
downstream . onError ( e ) ; 
downstream . onComplete ( ) ; 
cancelled = true ; upstream . dispose ( ) ; if ( ! outputFused ) drain ( ) ; 
Iterator < ? extends R > it = iterator ; if ( it != null ) if ( once ) if ( ! it . hasNext ( ) ) clear ( ) ; return null ; else once = true ; return it . next ( ) ; return null ; 
Iterator < ? extends R > it = iterator ; if ( it != null ) if ( ! once ) return false ; if ( it . hasNext ( ) ) return false ; clear ( ) ; return true ; 
iterator = null ; AutoCloseable close = this . close ; this . close = null ; close ( close ) ; 
try if ( c != null ) c . close ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
if ( getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super R > downstream = this . downstream ; long emitted = this . emitted ; long requested = this . requested . get ( ) ; Iterator < ? extends R > it = iterator ; for ( ; ; ) if ( cancelled ) clear ( ) ; else if ( outputFused ) if ( it != null ) downstream . onNext ( null ) ; downstream . onComplete ( ) ; else if ( it != null && emitted != requested ) R item ; try item = it . next ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; cancelled = true ; continue ; if ( cancelled ) continue ; downstream . onNext ( item ) ; emitted ++ ; if ( cancelled ) continue ; boolean has ; try has = it . hasNext ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; downstream . onError ( ex ) ; cancelled = true ; continue ; if ( cancelled ) continue ; if ( ! has ) downstream . onComplete ( ) ; cancelled = true ; continue ; this . emitted = emitted ; missed = addAndGet ( - missed ) ; if ( missed == 0 ) return ; requested = this . requested . get ( ) ; if ( it == null ) it = iterator ; 
if ( ! isDone ( ) ) clear ( ) ; if ( hasDefault ) complete ( defaultItem ) ; else completeExceptionally ( new NoSuchElementException ( ) ) ; 
if ( ! isDone ( ) ) T v = value ; clear ( ) ; if ( v != null ) complete ( v ) ; else if ( hasDefault ) complete ( defaultItem ) ; else completeExceptionally ( new NoSuchElementException ( ) ) ; 
if ( ! isDone ( ) ) T v = value ; clear ( ) ; if ( v != null ) complete ( v ) ; else if ( hasDefault ) complete ( defaultItem ) ; else completeExceptionally ( new NoSuchElementException ( ) ) ; 
$EMPTY$
return this == INSTANCE ; 
observer . onSubscribe ( INSTANCE ) ; observer . onComplete ( ) ; 
observer . onSubscribe ( INSTANCE ) ; observer . onComplete ( ) ; 
observer . onSubscribe ( INSTANCE ) ; observer . onError ( e ) ; 
observer . onSubscribe ( INSTANCE ) ; observer . onComplete ( ) ; 
observer . onSubscribe ( INSTANCE ) ; observer . onError ( e ) ; 
observer . onSubscribe ( INSTANCE ) ; observer . onError ( e ) ; 
observer . onSubscribe ( INSTANCE ) ; observer . onError ( e ) ; 
throw new UnsupportedOperationException ( "Should not be called!" ) ; 
throw new UnsupportedOperationException ( "Should not be called!" ) ; 
return null ; 
return true ; 
$EMPTY$
return d == DISPOSED ; 
for ( ; ; ) Disposable current = field . get ( ) ; if ( current == DISPOSED ) if ( d != null ) d . dispose ( ) ; return false ; if ( field . compareAndSet ( current , d ) ) if ( current != null ) current . dispose ( ) ; return true ; 
Objects . requireNonNull ( d , "d is null" ) ; if ( ! field . compareAndSet ( null , d ) ) d . dispose ( ) ; if ( field . get ( ) != DISPOSED ) reportDisposableSet ( ) ; return false ; return true ; 
for ( ; ; ) Disposable current = field . get ( ) ; if ( current == DISPOSED ) if ( d != null ) d . dispose ( ) ; return false ; if ( field . compareAndSet ( current , d ) ) return true ; 
Disposable current = field . get ( ) ; Disposable d = DISPOSED ; if ( current != d ) current = field . getAndSet ( d ) ; if ( current != d ) if ( current != null ) current . dispose ( ) ; return true ; return false ; 
if ( next == null ) RxJavaPlugins . onError ( new NullPointerException ( "next is null" ) ) ; return false ; if ( current != null ) next . dispose ( ) ; reportDisposableSet ( ) ; return false ; return true ; 
RxJavaPlugins . onError ( new ProtocolViolationException ( "Disposable already set!" ) ) ; 
if ( ! field . compareAndSet ( null , d ) ) if ( field . get ( ) == DISPOSED ) d . dispose ( ) ; return false ; return true ; 
$EMPTY$
return true ; 
if ( disposed ) return ; List < Disposable > set ; synchronized ( this ) if ( disposed ) return ; disposed = true ; set = resources ; resources = null ; dispose ( set ) ; 
return disposed ; 
Objects . requireNonNull ( d , "d is null" ) ; if ( ! disposed ) synchronized ( this ) if ( ! disposed ) List < Disposable > set = resources ; if ( set == null ) set = new LinkedList < > ( ) ; resources = set ; set . add ( d ) ; return true ; d . dispose ( ) ; return false ; 
if ( delete ( d ) ) d . dispose ( ) ; return true ; return false ; 
Objects . requireNonNull ( d , "Disposable item is null" ) ; if ( disposed ) return false ; synchronized ( this ) if ( disposed ) return false ; List < Disposable > set = resources ; if ( set == null || ! set . remove ( d ) ) return false ; return true ; 
if ( disposed ) return ; List < Disposable > set ; synchronized ( this ) if ( disposed ) return ; set = resources ; resources = null ; dispose ( set ) ; 
if ( set == null ) return ; List < Throwable > errors = null ; for ( Disposable o : set ) try o . dispose ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( errors == null ) errors = new ArrayList < > ( ) ; errors . add ( ex ) ; if ( errors != null ) if ( errors . size ( ) == 1 ) throw ExceptionHelper . wrapOrThrow ( errors . get ( 0 ) ) ; throw new CompositeException ( errors ) ; 
return DisposableHelper . set ( this , next ) ; 
return DisposableHelper . replace ( this , next ) ; 
DisposableHelper . dispose ( this ) ; 
return DisposableHelper . isDisposed ( get ( ) ) ; 
if ( get ( 0 ) != DisposableHelper . DISPOSED ) int s = length ( ) ; for ( int i = 0 ; i < s ; i ++ ) Disposable o = get ( i ) ; if ( o != DisposableHelper . DISPOSED ) o = getAndSet ( i , DisposableHelper . DISPOSED ) ; if ( o != DisposableHelper . DISPOSED && o != null ) o . dispose ( ) ; 
return get ( 0 ) == DisposableHelper . DISPOSED ; 
return get ( ) == null ; 
if ( get ( ) != null ) Cancellable c = getAndSet ( null ) ; if ( c != null ) try c . cancel ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; RxJavaPlugins . onError ( ex ) ; 
return null ; 
return true ; 
$EMPTY$
$EMPTY$
$EMPTY$
return false ; 
disposed = true ; 
disposed = true ; 
return disposed ; 
return from ( source , Runtime . getRuntime ( ) . availableProcessors ( ) , Flowable . bufferSize ( ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelMap < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; Objects . requireNonNull ( errorHandler , "errorHandler is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelMapTry < > ( this , mapper , errorHandler ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; Objects . requireNonNull ( errorHandler , "errorHandler is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelMapTry < > ( this , mapper , errorHandler ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelFilter < > ( this , predicate ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; Objects . requireNonNull ( errorHandler , "errorHandler is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelFilterTry < > ( this , predicate , errorHandler ) ) ; 
Objects . requireNonNull ( predicate , "predicate is null" ) ; Objects . requireNonNull ( errorHandler , "errorHandler is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelFilterTry < > ( this , predicate , errorHandler ) ) ; 
return runOn ( scheduler , Flowable . bufferSize ( ) ) ; 
Objects . requireNonNull ( reducer , "reducer is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelReduceFull < > ( this , reducer ) ) ; 
Objects . requireNonNull ( initialSupplier , "initialSupplier is null" ) ; Objects . requireNonNull ( reducer , "reducer is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelReduce < > ( this , initialSupplier , reducer ) ) ; 
return sequential ( Flowable . bufferSize ( ) ) ; 
return sequentialDelayError ( Flowable . bufferSize ( ) ) ; 
return sorted ( comparator , 16 ) ; 
return toSortedList ( comparator , 16 ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelPeek < > ( this , onNext , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . emptyConsumer ( ) , Functions . EMPTY_LONG_CONSUMER , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( errorHandler , "errorHandler is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelDoOnNextTry < > ( this , onNext , errorHandler ) ) ; 
Objects . requireNonNull ( onNext , "onNext is null" ) ; Objects . requireNonNull ( errorHandler , "errorHandler is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelDoOnNextTry < > ( this , onNext , errorHandler ) ) ; 
Objects . requireNonNull ( onAfterNext , "onAfterNext is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelPeek < > ( this , Functions . emptyConsumer ( ) , onAfterNext , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . emptyConsumer ( ) , Functions . EMPTY_LONG_CONSUMER , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onError , "onError is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelPeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , onError , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . emptyConsumer ( ) , Functions . EMPTY_LONG_CONSUMER , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onComplete , "onComplete is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelPeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , onComplete , Functions . EMPTY_ACTION , Functions . emptyConsumer ( ) , Functions . EMPTY_LONG_CONSUMER , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onAfterTerminate , "onAfterTerminate is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelPeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , onAfterTerminate , Functions . emptyConsumer ( ) , Functions . EMPTY_LONG_CONSUMER , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onSubscribe , "onSubscribe is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelPeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , onSubscribe , Functions . EMPTY_LONG_CONSUMER , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onRequest , "onRequest is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelPeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . emptyConsumer ( ) , onRequest , Functions . EMPTY_ACTION ) ) ; 
Objects . requireNonNull ( onCancel , "onCancel is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelPeek < > ( this , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . emptyConsumer ( ) , Functions . EMPTY_ACTION , Functions . EMPTY_ACTION , Functions . emptyConsumer ( ) , Functions . EMPTY_LONG_CONSUMER , onCancel ) ) ; 
Objects . requireNonNull ( collectionSupplier , "collectionSupplier is null" ) ; Objects . requireNonNull ( collector , "collector is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelCollect < > ( this , collectionSupplier , collector ) ) ; 
return Objects . requireNonNull ( converter , "converter is null" ) . apply ( this ) ; 
return RxJavaPlugins . onAssembly ( Objects . requireNonNull ( composer , "composer is null" ) . apply ( this ) ) ; 
return flatMap ( mapper , false , Flowable . bufferSize ( ) , Flowable . bufferSize ( ) ) ; 
return concatMap ( mapper , 2 ) ; 
return flatMapIterable ( mapper , Flowable . bufferSize ( ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelMapOptional < > ( this , mapper ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; Objects . requireNonNull ( errorHandler , "errorHandler is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelMapTryOptional < > ( this , mapper , errorHandler ) ) ; 
Objects . requireNonNull ( mapper , "mapper is null" ) ; Objects . requireNonNull ( errorHandler , "errorHandler is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelMapTryOptional < > ( this , mapper , errorHandler ) ) ; 
return flatMapStream ( mapper , Flowable . bufferSize ( ) ) ; 
Objects . requireNonNull ( collector , "collector is null" ) ; return RxJavaPlugins . onAssembly ( new ParallelCollector < > ( this , collector ) ) ; 
return this ; 
ConnectConsumer cc = new ConnectConsumer ( ) ; connect ( cc ) ; return cc . disposable ; 
return RxJavaPlugins . onAssembly ( new ObservableRefCount < > ( this ) ) ; 
return autoConnect ( 1 ) ; 
return key ; 
T value = get ( ) ; if ( value != null ) value = getAndSet ( null ) ; if ( value != null ) onDisposed ( value ) ; 
return get ( ) == null ; 
try value . run ( ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
return "ActionDisposable(disposed=" + isDisposed ( ) + ", " + get ( ) + ")" ; 
try value . close ( ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
return "AutoCloseableDisposable(disposed=" + isDisposed ( ) + ", " + get ( ) + ")" ; 
return DisposableHelper . set ( resource , next ) ; 
return DisposableHelper . replace ( resource , next ) ; 
Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) return Disposable . disposed ( ) ; return d ; 
DisposableHelper . dispose ( resource ) ; 
return DisposableHelper . isDisposed ( resource . get ( ) ) ; 
if ( disposed ) return ; OpenHashSet < Disposable > set ; synchronized ( this ) if ( disposed ) return ; disposed = true ; set = resources ; resources = null ; dispose ( set ) ; 
return disposed ; 
Objects . requireNonNull ( disposable , "disposable is null" ) ; if ( ! disposed ) synchronized ( this ) if ( ! disposed ) OpenHashSet < Disposable > set = resources ; if ( set == null ) set = new OpenHashSet < > ( ) ; resources = set ; set . add ( disposable ) ; return true ; disposable . dispose ( ) ; return false ; 
if ( delete ( disposable ) ) disposable . dispose ( ) ; return true ; return false ; 
Objects . requireNonNull ( disposable , "disposable is null" ) ; if ( disposed ) return false ; synchronized ( this ) if ( disposed ) return false ; OpenHashSet < Disposable > set = resources ; if ( set == null || ! set . remove ( disposable ) ) return false ; return true ; 
if ( disposed ) return ; OpenHashSet < Disposable > set ; synchronized ( this ) if ( disposed ) return ; set = resources ; resources = null ; dispose ( set ) ; 
if ( disposed ) return 0 ; synchronized ( this ) if ( disposed ) return 0 ; OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; 
if ( set == null ) return ; List < Throwable > errors = null ; Object [ ] array = set . keys ( ) ; for ( Object o : array ) if ( o instanceof Disposable ) try ( ( Disposable ) o ) . dispose ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; if ( errors == null ) errors = new ArrayList < > ( ) ; errors . add ( ex ) ; if ( errors != null ) if ( errors . size ( ) == 1 ) throw ExceptionHelper . wrapOrThrow ( errors . get ( 0 ) ) ; throw new CompositeException ( errors ) ; 
Objects . requireNonNull ( run , "run is null" ) ; return new RunnableDisposable ( run ) ; 
Objects . requireNonNull ( action , "action is null" ) ; return new ActionDisposable ( action ) ; 
Objects . requireNonNull ( future , "future is null" ) ; return fromFuture ( future , true ) ; 
Objects . requireNonNull ( subscription , "subscription is null" ) ; return new SubscriptionDisposable ( subscription ) ; 
Objects . requireNonNull ( autoCloseable , "autoCloseable is null" ) ; return new AutoCloseableDisposable ( autoCloseable ) ; 
Objects . requireNonNull ( disposable , "disposable is null" ) ; return disposable :: dispose ; 
return fromRunnable ( Functions . EMPTY_RUNNABLE ) ; 
return EmptyDisposable . INSTANCE ; 
value . cancel ( ) ; 
value . run ( ) ; 
return "RunnableDisposable(disposed=" + isDisposed ( ) + ", " + get ( ) + ")" ; 
Future < ? > f = get ( ) ; return f == null || f . isDone ( ) ; 
Future < ? > f = getAndSet ( null ) ; if ( f != null ) f . cancel ( allowInterrupt ) ; 
lockdown = true ; 
return lockdown ; 
return failNonBlockingScheduler ; 
return onComputationHandler ; 
return errorHandler ; 
return onInitComputationHandler ; 
return onInitIoHandler ; 
return onInitNewThreadHandler ; 
return onInitSingleHandler ; 
return onIoHandler ; 
return onNewThreadHandler ; 
return onScheduleHandler ; 
return onSingleHandler ; 
Objects . requireNonNull ( defaultScheduler , "Scheduler Supplier can't be null" ) ; Function < ? super Supplier < Scheduler > , ? extends Scheduler > f = onInitComputationHandler ; if ( f == null ) return callRequireNonNull ( defaultScheduler ) ; return applyRequireNonNull ( f , defaultScheduler ) ; 
Objects . requireNonNull ( defaultScheduler , "Scheduler Supplier can't be null" ) ; Function < ? super Supplier < Scheduler > , ? extends Scheduler > f = onInitIoHandler ; if ( f == null ) return callRequireNonNull ( defaultScheduler ) ; return applyRequireNonNull ( f , defaultScheduler ) ; 
Objects . requireNonNull ( defaultScheduler , "Scheduler Supplier can't be null" ) ; Function < ? super Supplier < Scheduler > , ? extends Scheduler > f = onInitNewThreadHandler ; if ( f == null ) return callRequireNonNull ( defaultScheduler ) ; return applyRequireNonNull ( f , defaultScheduler ) ; 
Objects . requireNonNull ( defaultScheduler , "Scheduler Supplier can't be null" ) ; Function < ? super Supplier < Scheduler > , ? extends Scheduler > f = onInitSingleHandler ; if ( f == null ) return callRequireNonNull ( defaultScheduler ) ; return applyRequireNonNull ( f , defaultScheduler ) ; 
Function < ? super Scheduler , ? extends Scheduler > f = onComputationHandler ; if ( f == null ) return defaultScheduler ; return apply ( f , defaultScheduler ) ; 
Consumer < ? super Throwable > f = errorHandler ; if ( error == null ) error = ExceptionHelper . createNullPointerException ( "onError called with a null Throwable." ) ; else if ( ! isBug ( error ) ) error = new UndeliverableException ( error ) ; if ( f != null ) try f . accept ( error ) ; return ; catch ( Throwable e ) e . printStackTrace ( ) ; uncaught ( e ) ; error . printStackTrace ( ) ; uncaught ( error ) ; 
if ( error instanceof OnErrorNotImplementedException ) return true ; if ( error instanceof MissingBackpressureException ) return true ; if ( error instanceof IllegalStateException ) return true ; if ( error instanceof NullPointerException ) return true ; if ( error instanceof IllegalArgumentException ) return true ; if ( error instanceof CompositeException ) return true ; return false ; 
Thread currentThread = Thread . currentThread ( ) ; UncaughtExceptionHandler handler = currentThread . getUncaughtExceptionHandler ( ) ; handler . uncaughtException ( currentThread , error ) ; 
Function < ? super Scheduler , ? extends Scheduler > f = onIoHandler ; if ( f == null ) return defaultScheduler ; return apply ( f , defaultScheduler ) ; 
Function < ? super Scheduler , ? extends Scheduler > f = onNewThreadHandler ; if ( f == null ) return defaultScheduler ; return apply ( f , defaultScheduler ) ; 
Objects . requireNonNull ( run , "run is null" ) ; Function < ? super Runnable , ? extends Runnable > f = onScheduleHandler ; if ( f == null ) return run ; return apply ( f , run ) ; 
Function < ? super Scheduler , ? extends Scheduler > f = onSingleHandler ; if ( f == null ) return defaultScheduler ; return apply ( f , defaultScheduler ) ; 
setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setOnParallelSubscribe ( null ) ; setFailOnNonBlockingScheduler ( false ) ; setOnBeforeBlocking ( null ) ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onComputationHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; errorHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onInitComputationHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onInitIoHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onInitNewThreadHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onInitSingleHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onIoHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onNewThreadHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onScheduleHandler = handler ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onSingleHandler = handler ; 
lockdown = false ; 
return onCompletableAssembly ; 
return onCompletableSubscribe ; 
return onFlowableAssembly ; 
return onConnectableFlowableAssembly ; 
return onFlowableSubscribe ; 
return onMaybeSubscribe ; 
return onMaybeAssembly ; 
return onSingleAssembly ; 
return onSingleSubscribe ; 
return onObservableAssembly ; 
return onConnectableObservableAssembly ; 
return onObservableSubscribe ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onCompletableAssembly = onCompletableAssembly ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onCompletableSubscribe = onCompletableSubscribe ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onFlowableAssembly = onFlowableAssembly ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onMaybeAssembly = onMaybeAssembly ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onConnectableFlowableAssembly = onConnectableFlowableAssembly ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onFlowableSubscribe = onFlowableSubscribe ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onMaybeSubscribe = onMaybeSubscribe ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onObservableAssembly = onObservableAssembly ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onConnectableObservableAssembly = onConnectableObservableAssembly ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onObservableSubscribe = onObservableSubscribe ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onSingleAssembly = onSingleAssembly ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; RxJavaPlugins . onSingleSubscribe = onSingleSubscribe ; 
BiFunction < ? super Flowable , @ NonNull ? super Subscriber , @ NonNull ? extends Subscriber > f = onFlowableSubscribe ; if ( f != null ) return apply ( f , source , subscriber ) ; return subscriber ; 
BiFunction < ? super Observable , @ NonNull ? super Observer , @ NonNull ? extends Observer > f = onObservableSubscribe ; if ( f != null ) return apply ( f , source , observer ) ; return observer ; 
BiFunction < ? super Single , @ NonNull ? super SingleObserver , @ NonNull ? extends SingleObserver > f = onSingleSubscribe ; if ( f != null ) return apply ( f , source , observer ) ; return observer ; 
BiFunction < ? super Completable , @ NonNull ? super CompletableObserver , @ NonNull ? extends CompletableObserver > f = onCompletableSubscribe ; if ( f != null ) return apply ( f , source , observer ) ; return observer ; 
BiFunction < ? super Maybe , @ NonNull ? super MaybeObserver , @ NonNull ? extends MaybeObserver > f = onMaybeSubscribe ; if ( f != null ) return apply ( f , source , observer ) ; return observer ; 
Function < ? super Maybe , ? extends Maybe > f = onMaybeAssembly ; if ( f != null ) return apply ( f , source ) ; return source ; 
Function < ? super Flowable , ? extends Flowable > f = onFlowableAssembly ; if ( f != null ) return apply ( f , source ) ; return source ; 
Function < ? super ConnectableFlowable , ? extends ConnectableFlowable > f = onConnectableFlowableAssembly ; if ( f != null ) return apply ( f , source ) ; return source ; 
Function < ? super Observable , ? extends Observable > f = onObservableAssembly ; if ( f != null ) return apply ( f , source ) ; return source ; 
Function < ? super ConnectableObservable , ? extends ConnectableObservable > f = onConnectableObservableAssembly ; if ( f != null ) return apply ( f , source ) ; return source ; 
Function < ? super Single , ? extends Single > f = onSingleAssembly ; if ( f != null ) return apply ( f , source ) ; return source ; 
Function < ? super Completable , ? extends Completable > f = onCompletableAssembly ; if ( f != null ) return apply ( f , source ) ; return source ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onParallelAssembly = handler ; 
return onParallelAssembly ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onParallelSubscribe = handler ; 
return onParallelSubscribe ; 
Function < ? super ParallelFlowable , ? extends ParallelFlowable > f = onParallelAssembly ; if ( f != null ) return apply ( f , source ) ; return source ; 
BooleanSupplier f = onBeforeBlocking ; if ( f != null ) try return f . getAsBoolean ( ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; return false ; 
if ( lockdown ) throw new IllegalStateException ( "Plugins can't be changed anymore" ) ; onBeforeBlocking = handler ; 
return onBeforeBlocking ; 
return new ComputationScheduler ( Objects . requireNonNull ( threadFactory , "threadFactory is null" ) ) ; 
return new IoScheduler ( Objects . requireNonNull ( threadFactory , "threadFactory is null" ) ) ; 
return new NewThreadScheduler ( Objects . requireNonNull ( threadFactory , "threadFactory is null" ) ) ; 
return new SingleScheduler ( Objects . requireNonNull ( threadFactory , "threadFactory is null" ) ) ; 
try return Objects . requireNonNull ( s . get ( ) , "Scheduler Supplier result can't be null" ) ; catch ( Throwable ex ) throw ExceptionHelper . wrapOrThrow ( ex ) ; 
return Objects . requireNonNull ( apply ( f , s ) , "Scheduler Supplier result can't be null" ) ; 
actual . subscribe ( s ) ; 
boolean cancel ; if ( ! done ) synchronized ( this ) if ( done ) cancel = true ; else if ( emitting ) AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( 4 ) ; queue = q ; q . add ( NotificationLite . subscription ( s ) ) ; return ; emitting = true ; cancel = false ; else cancel = true ; if ( cancel ) s . cancel ( ) ; else actual . onSubscribe ( s ) ; emitLoop ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; boolean reportError ; synchronized ( this ) if ( done ) reportError = true ; else done = true ; if ( emitting ) AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( 4 ) ; queue = q ; q . setFirst ( NotificationLite . error ( t ) ) ; return ; reportError = false ; emitting = true ; if ( reportError ) RxJavaPlugins . onError ( t ) ; return ; actual . onError ( t ) ; 
if ( done ) return ; synchronized ( this ) if ( done ) return ; done = true ; if ( emitting ) AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( 4 ) ; queue = q ; q . add ( NotificationLite . complete ( ) ) ; return ; emitting = true ; actual . onComplete ( ) ; 
for ( ; ; ) AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) q = queue ; if ( q == null ) emitting = false ; return ; queue = null ; q . accept ( actual ) ; 
return actual . hasSubscribers ( ) ; 
return actual . hasThrowable ( ) ; 
return actual . getThrowable ( ) ; 
return actual . hasComplete ( ) ; 
return new BehaviorProcessor < > ( ) ; 
BehaviorSubscription < T > bs = new BehaviorSubscription < > ( s , this ) ; s . onSubscribe ( bs ) ; if ( add ( bs ) ) if ( bs . cancelled ) remove ( bs ) ; else bs . emitFirst ( ) ; else Throwable ex = terminalEvent . get ( ) ; if ( ex == ExceptionHelper . TERMINATED ) s . onComplete ( ) ; else s . onError ( ex ) ; 
if ( terminalEvent . get ( ) != null ) s . cancel ( ) ; return ; s . request ( Long . MAX_VALUE ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( ! terminalEvent . compareAndSet ( null , t ) ) RxJavaPlugins . onError ( t ) ; return ; Object o = NotificationLite . error ( t ) ; for ( BehaviorSubscription < T > bs : terminate ( o ) ) bs . emitNext ( o , index ) ; 
if ( ! terminalEvent . compareAndSet ( null , ExceptionHelper . TERMINATED ) ) return ; Object o = NotificationLite . complete ( ) ; for ( BehaviorSubscription < T > bs : terminate ( o ) ) bs . emitNext ( o , index ) ; 
return subscribers . get ( ) . length != 0 ; 
return subscribers . get ( ) . length ; 
Object o = value . get ( ) ; if ( NotificationLite . isError ( o ) ) return NotificationLite . getError ( o ) ; return null ; 
Object o = value . get ( ) ; if ( NotificationLite . isComplete ( o ) || NotificationLite . isError ( o ) ) return null ; return NotificationLite . getValue ( o ) ; 
Object o = value . get ( ) ; return NotificationLite . isComplete ( o ) ; 
Object o = value . get ( ) ; return NotificationLite . isError ( o ) ; 
Object o = value . get ( ) ; return o != null && ! NotificationLite . isComplete ( o ) && ! NotificationLite . isError ( o ) ; 
setCurrent ( terminalValue ) ; return subscribers . getAndSet ( TERMINATED ) ; 
Lock wl = writeLock ; wl . lock ( ) ; index ++ ; value . lazySet ( o ) ; wl . unlock ( ) ; 
if ( ! cancelled ) cancelled = true ; state . remove ( this ) ; 
if ( cancelled ) return ; Object o ; synchronized ( this ) if ( cancelled ) return ; if ( next ) return ; BehaviorProcessor < T > s = state ; Lock readLock = s . readLock ; readLock . lock ( ) ; index = s . index ; o = s . value . get ( ) ; readLock . unlock ( ) ; emitting = o != null ; next = true ; if ( o != null ) if ( test ( o ) ) return ; emitLoop ( ) ; 
if ( cancelled ) return true ; if ( NotificationLite . isComplete ( o ) ) downstream . onComplete ( ) ; return true ; else if ( NotificationLite . isError ( o ) ) downstream . onError ( NotificationLite . getError ( o ) ) ; return true ; long r = get ( ) ; if ( r != 0L ) downstream . onNext ( NotificationLite . < T > getValue ( o ) ) ; if ( r != Long . MAX_VALUE ) decrementAndGet ( ) ; return false ; cancel ( ) ; downstream . onError ( new MissingBackpressureException ( "Could not deliver value due to lack of requests" ) ) ; return true ; 
for ( ; ; ) if ( cancelled ) return ; AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) q = queue ; if ( q == null ) emitting = false ; return ; queue = null ; q . forEachWhile ( this ) ; 
return get ( ) == 0L ; 
return new UnicastProcessor < > ( bufferSize ( ) , null , true ) ; 
Runnable r = onTerminate . getAndSet ( null ) ; if ( r != null ) r . run ( ) ; 
int missed = 1 ; final SpscLinkedArrayQueue < T > q = queue ; final boolean failFast = ! delayError ; for ( ; ; ) long r = requested . get ( ) ; long e = 0L ; while ( r != e ) boolean d = done ; T t = q . poll ( ) ; boolean empty = t == null ; if ( checkTerminated ( failFast , d , empty , a , q ) ) return ; if ( empty ) break ; a . onNext ( t ) ; e ++ ; if ( r == e && checkTerminated ( failFast , done , q . isEmpty ( ) , a , q ) ) return ; if ( e != 0 && r != Long . MAX_VALUE ) requested . addAndGet ( - e ) ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
int missed = 1 ; final SpscLinkedArrayQueue < T > q = queue ; final boolean failFast = ! delayError ; for ( ; ; ) if ( cancelled ) downstream . lazySet ( null ) ; return ; boolean d = done ; if ( failFast && d && error != null ) q . clear ( ) ; downstream . lazySet ( null ) ; a . onError ( error ) ; return ; a . onNext ( null ) ; if ( d ) downstream . lazySet ( null ) ; Throwable ex = error ; if ( ex != null ) a . onError ( ex ) ; else a . onComplete ( ) ; return ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( wip . getAndIncrement ( ) != 0 ) return ; int missed = 1 ; Subscriber < ? super T > a = downstream . get ( ) ; for ( ; ; ) if ( a != null ) if ( enableOperatorFusion ) drainFused ( a ) ; else drainRegular ( a ) ; return ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; a = downstream . get ( ) ; 
if ( done || cancelled ) s . cancel ( ) ; else s . request ( Long . MAX_VALUE ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( done || cancelled ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; doTerminate ( ) ; drain ( ) ; 
if ( done || cancelled ) return ; done = true ; doTerminate ( ) ; drain ( ) ; 
if ( ! once . get ( ) && once . compareAndSet ( false , true ) ) s . onSubscribe ( wip ) ; downstream . set ( s ) ; if ( cancelled ) downstream . lazySet ( null ) ; else drain ( ) ; else EmptySubscription . error ( new IllegalStateException ( "This processor allows only a single Subscriber" ) , s ) ; 
return queue . poll ( ) ; 
return queue . isEmpty ( ) ; 
queue . clear ( ) ; 
if ( cancelled ) return ; cancelled = true ; doTerminate ( ) ; downstream . lazySet ( null ) ; if ( wip . getAndIncrement ( ) == 0 ) downstream . lazySet ( null ) ; if ( ! enableOperatorFusion ) queue . clear ( ) ; 
return downstream . get ( ) != null ; 
if ( done ) return error ; return null ; 
return done && error == null ; 
return done && error != null ; 
if ( this instanceof SerializedProcessor ) return this ; return new SerializedProcessor < > ( this ) ; 
return new AsyncProcessor < > ( ) ; 
if ( subscribers . get ( ) == TERMINATED ) s . cancel ( ) ; return ; s . request ( Long . MAX_VALUE ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( subscribers . get ( ) == TERMINATED ) RxJavaPlugins . onError ( t ) ; return ; value = null ; error = t ; for ( AsyncSubscription < T > as : subscribers . getAndSet ( TERMINATED ) ) as . onError ( t ) ; 
if ( subscribers . get ( ) == TERMINATED ) return ; T v = value ; AsyncSubscription < T > [ ] array = subscribers . getAndSet ( TERMINATED ) ; if ( v == null ) for ( AsyncSubscription < T > as : array ) as . onComplete ( ) ; else for ( AsyncSubscription < T > as : array ) as . complete ( v ) ; 
return subscribers . get ( ) . length != 0 ; 
return subscribers . get ( ) == TERMINATED && error != null ; 
return subscribers . get ( ) == TERMINATED && error == null ; 
return subscribers . get ( ) == TERMINATED ? error : null ; 
AsyncSubscription < T > as = new AsyncSubscription < > ( s , this ) ; s . onSubscribe ( as ) ; if ( add ( as ) ) if ( as . isCancelled ( ) ) remove ( as ) ; else Throwable ex = error ; if ( ex != null ) s . onError ( ex ) ; else T v = value ; if ( v != null ) as . complete ( v ) ; else as . onComplete ( ) ; 
return subscribers . get ( ) == TERMINATED && value != null ; 
return subscribers . get ( ) == TERMINATED ? value : null ; 
if ( super . tryCancel ( ) ) parent . remove ( this ) ; 
if ( ! isCancelled ( ) ) downstream . onComplete ( ) ; 
if ( isCancelled ( ) ) RxJavaPlugins . onError ( t ) ; else downstream . onError ( t ) ; 
return new PublishProcessor < > ( ) ; 
PublishSubscription < T > ps = new PublishSubscription < > ( t , this ) ; t . onSubscribe ( ps ) ; if ( add ( ps ) ) if ( ps . isCancelled ( ) ) remove ( ps ) ; else Throwable ex = error ; if ( ex != null ) t . onError ( ex ) ; else t . onComplete ( ) ; 
if ( subscribers . get ( ) == TERMINATED ) s . cancel ( ) ; return ; s . request ( Long . MAX_VALUE ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( subscribers . get ( ) == TERMINATED ) RxJavaPlugins . onError ( t ) ; return ; error = t ; for ( PublishSubscription < T > s : subscribers . getAndSet ( TERMINATED ) ) s . onError ( t ) ; 
if ( subscribers . get ( ) == TERMINATED ) return ; for ( PublishSubscription < T > s : subscribers . getAndSet ( TERMINATED ) ) s . onComplete ( ) ; 
return subscribers . get ( ) . length != 0 ; 
if ( subscribers . get ( ) == TERMINATED ) return error ; return null ; 
return subscribers . get ( ) == TERMINATED && error != null ; 
return subscribers . get ( ) == TERMINATED && error == null ; 
if ( get ( ) != Long . MIN_VALUE ) downstream . onError ( t ) ; else RxJavaPlugins . onError ( t ) ; 
if ( get ( ) != Long . MIN_VALUE ) downstream . onComplete ( ) ; 
if ( getAndSet ( Long . MIN_VALUE ) != Long . MIN_VALUE ) parent . remove ( this ) ; 
return get ( ) == Long . MIN_VALUE ; 
return get ( ) == 0L ; 
return new ReplayProcessor < > ( new UnboundedReplayBuffer < > ( 16 ) ) ; 
return new ReplayProcessor < > ( new SizeBoundReplayBuffer < > ( Integer . MAX_VALUE ) ) ; 
ReplaySubscription < T > rs = new ReplaySubscription < > ( s , this ) ; s . onSubscribe ( rs ) ; if ( add ( rs ) ) if ( rs . cancelled ) remove ( rs ) ; return ; buffer . replay ( rs ) ; 
if ( done ) s . cancel ( ) ; return ; s . request ( Long . MAX_VALUE ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; ReplayBuffer < T > b = buffer ; b . error ( t ) ; for ( ReplaySubscription < T > rs : subscribers . getAndSet ( TERMINATED ) ) b . replay ( rs ) ; 
if ( done ) return ; done = true ; ReplayBuffer < T > b = buffer ; b . complete ( ) ; for ( ReplaySubscription < T > rs : subscribers . getAndSet ( TERMINATED ) ) b . replay ( rs ) ; 
return subscribers . get ( ) . length != 0 ; 
return subscribers . get ( ) . length ; 
ReplayBuffer < T > b = buffer ; if ( b . isDone ( ) ) return b . getError ( ) ; return null ; 
buffer . trimHead ( ) ; 
return buffer . getValue ( ) ; 
@ SuppressWarnings ( "unchecked" ) T [ ] a = ( T [ ] ) EMPTY_ARRAY ; T [ ] b = getValues ( a ) ; if ( b == EMPTY_ARRAY ) return new Object [ 0 ] ; return b ; 
ReplayBuffer < T > b = buffer ; return b . isDone ( ) && b . getError ( ) == null ; 
ReplayBuffer < T > b = buffer ; return b . isDone ( ) && b . getError ( ) != null ; 
return buffer . size ( ) != 0 ; 
return buffer . size ( ) ; 
if ( ! cancelled ) cancelled = true ; state . remove ( this ) ; 
error = ex ; done = true ; 
done = true ; 
$EMPTY$
int s = size ; if ( s == 0 ) return null ; return buffer . get ( s - 1 ) ; 
return size ; 
return done ; 
return error ; 
if ( size > maxSize ) size -- ; Node < T > h = head ; head = h . get ( ) ; 
error = ex ; trimHead ( ) ; done = true ; 
trimHead ( ) ; done = true ; 
if ( head . value != null ) Node < T > n = new Node < > ( null ) ; n . lazySet ( head . get ( ) ) ; head = n ; 
return done ; 
return error ; 
Node < T > h = head ; for ( ; ; ) Node < T > n = h . get ( ) ; if ( n == null ) return h . value ; h = n ; 
int s = 0 ; Node < T > h = head ; while ( s != Integer . MAX_VALUE ) Node < T > next = h . get ( ) ; if ( next == null ) break ; s ++ ; h = next ; return s ; 
if ( size > maxSize ) size -- ; TimedNode < T > h = head ; head = h . get ( ) ; long limit = scheduler . now ( unit ) - maxAge ; TimedNode < T > h = head ; for ( ; ; ) if ( size <= 1 ) head = h ; break ; TimedNode < T > next = h . get ( ) ; if ( next . time > limit ) head = h ; break ; h = next ; size -- ; 
long limit = scheduler . now ( unit ) - maxAge ; TimedNode < T > h = head ; for ( ; ; ) TimedNode < T > next = h . get ( ) ; if ( next == null ) if ( h . value != null ) head = new TimedNode < > ( null , 0L ) ; else head = h ; break ; if ( next . time > limit ) if ( h . value != null ) TimedNode < T > n = new TimedNode < > ( null , 0L ) ; n . lazySet ( h . get ( ) ) ; head = n ; else head = h ; break ; h = next ; 
if ( head . value != null ) TimedNode < T > n = new TimedNode < > ( null , 0L ) ; n . lazySet ( head . get ( ) ) ; head = n ; 
trimFinal ( ) ; error = ex ; done = true ; 
trimFinal ( ) ; done = true ; 
TimedNode < T > h = head ; for ( ; ; ) TimedNode < T > next = h . get ( ) ; if ( next == null ) break ; h = next ; long limit = scheduler . now ( unit ) - maxAge ; if ( h . time < limit ) return null ; return h . value ; 
TimedNode < T > index = head ; long limit = scheduler . now ( unit ) - maxAge ; TimedNode < T > next = index . get ( ) ; while ( next != null ) long ts = next . time ; if ( ts > limit ) break ; index = next ; next = index . get ( ) ; return index ; 
return size ( getHead ( ) ) ; 
return error ; 
return done ; 
return new MulticastProcessor < > ( bufferSize ( ) , false ) ; 
if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) queue = new SpscArrayQueue < > ( bufferSize ) ; 
if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) queue = new SpscLinkedArrayQueue < > ( bufferSize ) ; 
if ( SubscriptionHelper . setOnce ( upstream , s ) ) if ( s instanceof QueueSubscription ) @ SuppressWarnings ( "unchecked" ) QueueSubscription < T > qs = ( QueueSubscription < T > ) s ; int m = qs . requestFusion ( QueueSubscription . ANY ) ; if ( m == QueueSubscription . SYNC ) fusionMode = m ; queue = qs ; done = true ; drain ( ) ; return ; if ( m == QueueSubscription . ASYNC ) fusionMode = m ; queue = qs ; s . request ( bufferSize ) ; return ; queue = new SpscArrayQueue < > ( bufferSize ) ; s . request ( bufferSize ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( ! done ) error = t ; done = true ; drain ( ) ; return ; RxJavaPlugins . onError ( t ) ; 
done = true ; drain ( ) ; 
return subscribers . get ( ) . length != 0 ; 
return done && error != null ; 
return done && error == null ; 
return done ? error : null ; 
MulticastSubscription < T > ms = new MulticastSubscription < > ( s , this ) ; s . onSubscribe ( ms ) ; if ( add ( ms ) ) if ( ms . get ( ) == Long . MIN_VALUE ) remove ( ms ) ; else drain ( ) ; else if ( done ) Throwable ex = error ; if ( ex != null ) s . onError ( ex ) ; return ; s . onComplete ( ) ; 
if ( wip . getAndIncrement ( ) != 0 ) return ; int missed = 1 ; AtomicReference < MulticastSubscription < T > [ ] > subs = subscribers ; int c = consumed ; int lim = limit ; int fm = fusionMode ; outer : for ( ; ; ) SimpleQueue < T > q = queue ; if ( q != null ) MulticastSubscription < T > [ ] as = subs . get ( ) ; int n = as . length ; if ( n != 0 ) long r = - 1L ; for ( MulticastSubscription < T > a : as ) long ra = a . get ( ) ; if ( ra >= 0L ) if ( r == - 1L ) r = ra - a . emitted ; else r = Math . min ( r , ra - a . emitted ) ; while ( r > 0L ) MulticastSubscription < T > [ ] bs = subs . get ( ) ; if ( bs == TERMINATED ) q . clear ( ) ; return ; if ( as != bs ) continue outer ; boolean d = done ; T v ; try v = q . poll ( ) ; catch ( Throwable ex ) Exceptions . throwIfFatal ( ex ) ; SubscriptionHelper . cancel ( upstream ) ; d = true ; v = null ; error = ex ; done = true ; boolean empty = v == null ; if ( d && empty ) Throwable ex = error ; if ( ex != null ) for ( MulticastSubscription < T > inner : subs . getAndSet ( TERMINATED ) ) inner . onError ( ex ) ; else for ( MulticastSubscription < T > inner : subs . getAndSet ( TERMINATED ) ) inner . onComplete ( ) ; return ; if ( empty ) break ; for ( MulticastSubscription < T > inner : as ) inner . onNext ( v ) ; r -- ; if ( fm != QueueSubscription . SYNC ) if ( ++ c == lim ) c = 0 ; upstream . get ( ) . request ( lim ) ; if ( r == 0 ) MulticastSubscription < T > [ ] bs = subs . get ( ) ; if ( bs == TERMINATED ) q . clear ( ) ; return ; if ( as != bs ) continue ; if ( done && q . isEmpty ( ) ) Throwable ex = error ; if ( ex != null ) for ( MulticastSubscription < T > inner : subs . getAndSet ( TERMINATED ) ) inner . onError ( ex ) ; else for ( MulticastSubscription < T > inner : subs . getAndSet ( TERMINATED ) ) inner . onComplete ( ) ; return ; consumed = c ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
if ( getAndSet ( Long . MIN_VALUE ) != Long . MIN_VALUE ) parent . remove ( this ) ; 
if ( get ( ) != Long . MIN_VALUE ) downstream . onError ( t ) ; 
if ( get ( ) != Long . MIN_VALUE ) downstream . onComplete ( ) ; 
return new BehaviorSubject < > ( null ) ; 
BehaviorDisposable < T > bs = new BehaviorDisposable < > ( observer , this ) ; observer . onSubscribe ( bs ) ; if ( add ( bs ) ) if ( bs . cancelled ) remove ( bs ) ; else bs . emitFirst ( ) ; else Throwable ex = terminalEvent . get ( ) ; if ( ex == ExceptionHelper . TERMINATED ) observer . onComplete ( ) ; else observer . onError ( ex ) ; 
if ( terminalEvent . get ( ) != null ) d . dispose ( ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( ! terminalEvent . compareAndSet ( null , t ) ) RxJavaPlugins . onError ( t ) ; return ; Object o = NotificationLite . error ( t ) ; for ( BehaviorDisposable < T > bs : terminate ( o ) ) bs . emitNext ( o , index ) ; 
if ( ! terminalEvent . compareAndSet ( null , ExceptionHelper . TERMINATED ) ) return ; Object o = NotificationLite . complete ( ) ; for ( BehaviorDisposable < T > bs : terminate ( o ) ) bs . emitNext ( o , index ) ; 
return observers . get ( ) . length != 0 ; 
return observers . get ( ) . length ; 
Object o = value . get ( ) ; if ( NotificationLite . isError ( o ) ) return NotificationLite . getError ( o ) ; return null ; 
Object o = value . get ( ) ; if ( NotificationLite . isComplete ( o ) || NotificationLite . isError ( o ) ) return null ; return NotificationLite . getValue ( o ) ; 
Object o = value . get ( ) ; return NotificationLite . isComplete ( o ) ; 
Object o = value . get ( ) ; return NotificationLite . isError ( o ) ; 
Object o = value . get ( ) ; return o != null && ! NotificationLite . isComplete ( o ) && ! NotificationLite . isError ( o ) ; 
setCurrent ( terminalValue ) ; return observers . getAndSet ( TERMINATED ) ; 
writeLock . lock ( ) ; index ++ ; value . lazySet ( o ) ; writeLock . unlock ( ) ; 
if ( ! cancelled ) cancelled = true ; state . remove ( this ) ; 
return cancelled ; 
if ( cancelled ) return ; Object o ; synchronized ( this ) if ( cancelled ) return ; if ( next ) return ; BehaviorSubject < T > s = state ; Lock lock = s . readLock ; lock . lock ( ) ; index = s . index ; o = s . value . get ( ) ; lock . unlock ( ) ; emitting = o != null ; next = true ; if ( o != null ) if ( test ( o ) ) return ; emitLoop ( ) ; 
return cancelled || NotificationLite . accept ( o , downstream ) ; 
for ( ; ; ) if ( cancelled ) return ; AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) q = queue ; if ( q == null ) emitting = false ; return ; queue = null ; q . forEachWhile ( this ) ; 
if ( this instanceof SerializedSubject ) return this ; return new SerializedSubject < > ( this ) ; 
return new SingleSubject < > ( ) ; 
if ( observers . get ( ) == TERMINATED ) d . dispose ( ) ; 
ExceptionHelper . nullCheck ( e , "onError called with a null Throwable." ) ; if ( once . compareAndSet ( false , true ) ) this . error = e ; for ( SingleDisposable < T > md : observers . getAndSet ( TERMINATED ) ) md . downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
SingleDisposable < T > md = new SingleDisposable < > ( observer , this ) ; observer . onSubscribe ( md ) ; if ( add ( md ) ) if ( md . isDisposed ( ) ) remove ( md ) ; else Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else observer . onSuccess ( value ) ; 
if ( observers . get ( ) == TERMINATED ) return value ; return null ; 
return observers . get ( ) == TERMINATED && value != null ; 
if ( observers . get ( ) == TERMINATED ) return error ; return null ; 
return observers . get ( ) == TERMINATED && error != null ; 
return observers . get ( ) . length != 0 ; 
return observers . get ( ) . length ; 
SingleSubject < T > parent = getAndSet ( null ) ; if ( parent != null ) parent . remove ( this ) ; 
return get ( ) == null ; 
return new PublishSubject < > ( ) ; 
PublishDisposable < T > ps = new PublishDisposable < > ( t , this ) ; t . onSubscribe ( ps ) ; if ( add ( ps ) ) if ( ps . isDisposed ( ) ) remove ( ps ) ; else Throwable ex = error ; if ( ex != null ) t . onError ( ex ) ; else t . onComplete ( ) ; 
if ( subscribers . get ( ) == TERMINATED ) d . dispose ( ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( subscribers . get ( ) == TERMINATED ) RxJavaPlugins . onError ( t ) ; return ; error = t ; for ( PublishDisposable < T > pd : subscribers . getAndSet ( TERMINATED ) ) pd . onError ( t ) ; 
if ( subscribers . get ( ) == TERMINATED ) return ; for ( PublishDisposable < T > pd : subscribers . getAndSet ( TERMINATED ) ) pd . onComplete ( ) ; 
return subscribers . get ( ) . length != 0 ; 
if ( subscribers . get ( ) == TERMINATED ) return error ; return null ; 
return subscribers . get ( ) == TERMINATED && error != null ; 
return subscribers . get ( ) == TERMINATED && error == null ; 
if ( get ( ) ) RxJavaPlugins . onError ( t ) ; else downstream . onError ( t ) ; 
if ( ! get ( ) ) downstream . onComplete ( ) ; 
if ( compareAndSet ( false , true ) ) parent . remove ( this ) ; 
return get ( ) ; 
actual . subscribe ( observer ) ; 
boolean cancel ; if ( ! done ) synchronized ( this ) if ( done ) cancel = true ; else if ( emitting ) AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( 4 ) ; queue = q ; q . add ( NotificationLite . disposable ( d ) ) ; return ; emitting = true ; cancel = false ; else cancel = true ; if ( cancel ) d . dispose ( ) ; else actual . onSubscribe ( d ) ; emitLoop ( ) ; 
if ( done ) RxJavaPlugins . onError ( t ) ; return ; boolean reportError ; synchronized ( this ) if ( done ) reportError = true ; else done = true ; if ( emitting ) AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( 4 ) ; queue = q ; q . setFirst ( NotificationLite . error ( t ) ) ; return ; reportError = false ; emitting = true ; if ( reportError ) RxJavaPlugins . onError ( t ) ; return ; actual . onError ( t ) ; 
if ( done ) return ; synchronized ( this ) if ( done ) return ; done = true ; if ( emitting ) AppendOnlyLinkedArrayList < Object > q = queue ; if ( q == null ) q = new AppendOnlyLinkedArrayList < > ( 4 ) ; queue = q ; q . add ( NotificationLite . complete ( ) ) ; return ; emitting = true ; actual . onComplete ( ) ; 
for ( ; ; ) AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) q = queue ; if ( q == null ) emitting = false ; return ; queue = null ; q . forEachWhile ( this ) ; 
return NotificationLite . acceptFull ( o , actual ) ; 
return actual . hasObservers ( ) ; 
return actual . hasThrowable ( ) ; 
return actual . getThrowable ( ) ; 
return actual . hasComplete ( ) ; 
return new ReplaySubject < > ( new UnboundedReplayBuffer < > ( 16 ) ) ; 
return new ReplaySubject < > ( new SizeBoundReplayBuffer < > ( Integer . MAX_VALUE ) ) ; 
ReplayDisposable < T > rs = new ReplayDisposable < > ( observer , this ) ; observer . onSubscribe ( rs ) ; if ( add ( rs ) ) if ( rs . cancelled ) remove ( rs ) ; return ; buffer . replay ( rs ) ; 
if ( done ) d . dispose ( ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( done ) RxJavaPlugins . onError ( t ) ; return ; done = true ; Object o = NotificationLite . error ( t ) ; ReplayBuffer < T > b = buffer ; b . addFinal ( o ) ; for ( ReplayDisposable < T > rs : terminate ( o ) ) b . replay ( rs ) ; 
if ( done ) return ; done = true ; Object o = NotificationLite . complete ( ) ; ReplayBuffer < T > b = buffer ; b . addFinal ( o ) ; for ( ReplayDisposable < T > rs : terminate ( o ) ) b . replay ( rs ) ; 
return observers . get ( ) . length != 0 ; 
return observers . get ( ) . length ; 
Object o = buffer . get ( ) ; if ( NotificationLite . isError ( o ) ) return NotificationLite . getError ( o ) ; return null ; 
return buffer . getValue ( ) ; 
buffer . trimHead ( ) ; 
@ SuppressWarnings ( "unchecked" ) T [ ] a = ( T [ ] ) EMPTY_ARRAY ; T [ ] b = getValues ( a ) ; if ( b == EMPTY_ARRAY ) return new Object [ 0 ] ; return b ; 
Object o = buffer . get ( ) ; return NotificationLite . isComplete ( o ) ; 
Object o = buffer . get ( ) ; return NotificationLite . isError ( o ) ; 
return buffer . size ( ) != 0 ; 
return buffer . size ( ) ; 
buffer . compareAndSet ( null , terminalValue ) ; return observers . getAndSet ( TERMINATED ) ; 
if ( ! cancelled ) cancelled = true ; state . remove ( this ) ; 
return cancelled ; 
buffer . add ( notificationLite ) ; trimHead ( ) ; size ++ ; done = true ; 
$EMPTY$
int s = size ; if ( s != 0 ) List < Object > b = buffer ; Object o = b . get ( s - 1 ) ; if ( NotificationLite . isComplete ( o ) || NotificationLite . isError ( o ) ) if ( s == 1 ) return null ; return ( T ) b . get ( s - 2 ) ; return ( T ) o ; return null ; 
int s = size ; if ( s != 0 ) Object o = buffer . get ( s - 1 ) ; if ( NotificationLite . isComplete ( o ) || NotificationLite . isError ( o ) ) return s - 1 ; return s ; return 0 ; 
if ( size > maxSize ) size -- ; Node < Object > h = head ; head = h . get ( ) ; 
Node < Object > n = new Node < > ( notificationLite ) ; Node < Object > t = tail ; tail = n ; size ++ ; t . lazySet ( n ) ; trimHead ( ) ; done = true ; 
Node < Object > h = head ; if ( h . value != null ) Node < Object > n = new Node < > ( null ) ; n . lazySet ( h . get ( ) ) ; head = n ; 
Node < Object > prev = null ; Node < Object > h = head ; for ( ; ; ) Node < Object > next = h . get ( ) ; if ( next == null ) break ; prev = h ; h = next ; Object v = h . value ; if ( v == null ) return null ; if ( NotificationLite . isComplete ( v ) || NotificationLite . isError ( v ) ) return ( T ) prev . value ; return ( T ) v ; 
int s = 0 ; Node < Object > h = head ; while ( s != Integer . MAX_VALUE ) Node < Object > next = h . get ( ) ; if ( next == null ) Object o = h . value ; if ( NotificationLite . isComplete ( o ) || NotificationLite . isError ( o ) ) s -- ; break ; s ++ ; h = next ; return s ; 
if ( size > maxSize ) size -- ; TimedNode < Object > h = head ; head = h . get ( ) ; long limit = scheduler . now ( unit ) - maxAge ; TimedNode < Object > h = head ; for ( ; ; ) if ( size <= 1 ) head = h ; break ; TimedNode < Object > next = h . get ( ) ; if ( next . time > limit ) head = h ; break ; h = next ; size -- ; 
long limit = scheduler . now ( unit ) - maxAge ; TimedNode < Object > h = head ; for ( ; ; ) TimedNode < Object > next = h . get ( ) ; if ( next . get ( ) == null ) if ( h . value != null ) TimedNode < Object > lasth = new TimedNode < > ( null , 0L ) ; lasth . lazySet ( h . get ( ) ) ; head = lasth ; else head = h ; break ; if ( next . time > limit ) if ( h . value != null ) TimedNode < Object > lasth = new TimedNode < > ( null , 0L ) ; lasth . lazySet ( h . get ( ) ) ; head = lasth ; else head = h ; break ; h = next ; 
TimedNode < Object > n = new TimedNode < > ( notificationLite , Long . MAX_VALUE ) ; TimedNode < Object > t = tail ; tail = n ; size ++ ; t . lazySet ( n ) ; trimFinal ( ) ; done = true ; 
TimedNode < Object > h = head ; if ( h . value != null ) TimedNode < Object > n = new TimedNode < > ( null , 0 ) ; n . lazySet ( h . get ( ) ) ; head = n ; 
TimedNode < Object > prev = null ; TimedNode < Object > h = head ; for ( ; ; ) TimedNode < Object > next = h . get ( ) ; if ( next == null ) break ; prev = h ; h = next ; long limit = scheduler . now ( unit ) - maxAge ; if ( h . time < limit ) return null ; Object v = h . value ; if ( v == null ) return null ; if ( NotificationLite . isComplete ( v ) || NotificationLite . isError ( v ) ) return ( T ) prev . value ; return ( T ) v ; 
TimedNode < Object > index = head ; long limit = scheduler . now ( unit ) - maxAge ; TimedNode < Object > next = index . get ( ) ; while ( next != null ) long ts = next . time ; if ( ts > limit ) break ; index = next ; next = index . get ( ) ; return index ; 
return size ( getHead ( ) ) ; 
return new AsyncSubject < > ( ) ; 
if ( subscribers . get ( ) == TERMINATED ) d . dispose ( ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( subscribers . get ( ) == TERMINATED ) RxJavaPlugins . onError ( t ) ; return ; value = null ; error = t ; for ( AsyncDisposable < T > as : subscribers . getAndSet ( TERMINATED ) ) as . onError ( t ) ; 
if ( subscribers . get ( ) == TERMINATED ) return ; T v = value ; AsyncDisposable < T > [ ] array = subscribers . getAndSet ( TERMINATED ) ; if ( v == null ) for ( AsyncDisposable < T > as : array ) as . onComplete ( ) ; else for ( AsyncDisposable < T > as : array ) as . complete ( v ) ; 
return subscribers . get ( ) . length != 0 ; 
return subscribers . get ( ) == TERMINATED && error != null ; 
return subscribers . get ( ) == TERMINATED && error == null ; 
return subscribers . get ( ) == TERMINATED ? error : null ; 
AsyncDisposable < T > as = new AsyncDisposable < > ( observer , this ) ; observer . onSubscribe ( as ) ; if ( add ( as ) ) if ( as . isDisposed ( ) ) remove ( as ) ; else Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else T v = value ; if ( v != null ) as . complete ( v ) ; else as . onComplete ( ) ; 
return subscribers . get ( ) == TERMINATED && value != null ; 
return subscribers . get ( ) == TERMINATED ? value : null ; 
if ( super . tryDispose ( ) ) parent . remove ( this ) ; 
if ( ! isDisposed ( ) ) downstream . onComplete ( ) ; 
if ( isDisposed ( ) ) RxJavaPlugins . onError ( t ) ; else downstream . onError ( t ) ; 
return new MaybeSubject < > ( ) ; 
if ( observers . get ( ) == TERMINATED ) d . dispose ( ) ; 
ExceptionHelper . nullCheck ( e , "onError called with a null Throwable." ) ; if ( once . compareAndSet ( false , true ) ) this . error = e ; for ( MaybeDisposable < T > md : observers . getAndSet ( TERMINATED ) ) md . downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( once . compareAndSet ( false , true ) ) for ( MaybeDisposable < T > md : observers . getAndSet ( TERMINATED ) ) md . downstream . onComplete ( ) ; 
MaybeDisposable < T > md = new MaybeDisposable < > ( observer , this ) ; observer . onSubscribe ( md ) ; if ( add ( md ) ) if ( md . isDisposed ( ) ) remove ( md ) ; else Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else T v = value ; if ( v == null ) observer . onComplete ( ) ; else observer . onSuccess ( v ) ; 
if ( observers . get ( ) == TERMINATED ) return value ; return null ; 
return observers . get ( ) == TERMINATED && value != null ; 
if ( observers . get ( ) == TERMINATED ) return error ; return null ; 
return observers . get ( ) == TERMINATED && error != null ; 
return observers . get ( ) == TERMINATED && value == null && error == null ; 
return observers . get ( ) . length != 0 ; 
return observers . get ( ) . length ; 
MaybeSubject < T > parent = getAndSet ( null ) ; if ( parent != null ) parent . remove ( this ) ; 
return get ( ) == null ; 
return new UnicastSubject < > ( bufferSize ( ) , null , true ) ; 
if ( ! once . get ( ) && once . compareAndSet ( false , true ) ) observer . onSubscribe ( wip ) ; downstream . lazySet ( observer ) ; if ( disposed ) downstream . lazySet ( null ) ; return ; drain ( ) ; else EmptyDisposable . error ( new IllegalStateException ( "Only a single observer allowed." ) , observer ) ; 
Runnable r = onTerminate . get ( ) ; if ( r != null && onTerminate . compareAndSet ( r , null ) ) r . run ( ) ; 
if ( done || disposed ) d . dispose ( ) ; 
ExceptionHelper . nullCheck ( t , "onError called with a null Throwable." ) ; if ( done || disposed ) RxJavaPlugins . onError ( t ) ; return ; error = t ; done = true ; doTerminate ( ) ; drain ( ) ; 
if ( done || disposed ) return ; done = true ; doTerminate ( ) ; drain ( ) ; 
int missed = 1 ; SimpleQueue < T > q = queue ; boolean failFast = ! this . delayError ; boolean canBeError = true ; for ( ; ; ) for ( ; ; ) if ( disposed ) downstream . lazySet ( null ) ; q . clear ( ) ; return ; boolean d = this . done ; T v = queue . poll ( ) ; boolean empty = v == null ; if ( d ) if ( failFast && canBeError ) if ( failedFast ( q , a ) ) return ; else canBeError = false ; if ( empty ) errorOrComplete ( a ) ; return ; if ( empty ) break ; a . onNext ( v ) ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
int missed = 1 ; final SpscLinkedArrayQueue < T > q = queue ; final boolean failFast = ! delayError ; for ( ; ; ) if ( disposed ) downstream . lazySet ( null ) ; return ; boolean d = done ; if ( failFast && d ) if ( failedFast ( q , a ) ) return ; a . onNext ( null ) ; if ( d ) errorOrComplete ( a ) ; return ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; 
downstream . lazySet ( null ) ; Throwable ex = error ; if ( ex != null ) a . onError ( ex ) ; else a . onComplete ( ) ; 
Throwable ex = error ; if ( ex != null ) downstream . lazySet ( null ) ; q . clear ( ) ; a . onError ( ex ) ; return true ; else return false ; 
if ( wip . getAndIncrement ( ) != 0 ) return ; Observer < ? super T > a = downstream . get ( ) ; int missed = 1 ; for ( ; ; ) if ( a != null ) if ( enableOperatorFusion ) drainFused ( a ) ; else drainNormal ( a ) ; return ; missed = wip . addAndGet ( - missed ) ; if ( missed == 0 ) break ; a = downstream . get ( ) ; 
return downstream . get ( ) != null ; 
if ( done ) return error ; return null ; 
return done && error != null ; 
return done && error == null ; 
return queue . poll ( ) ; 
return queue . isEmpty ( ) ; 
queue . clear ( ) ; 
if ( ! disposed ) disposed = true ; doTerminate ( ) ; downstream . lazySet ( null ) ; if ( wip . getAndIncrement ( ) == 0 ) downstream . lazySet ( null ) ; if ( ! enableOperatorFusion ) queue . clear ( ) ; 
return disposed ; 
return new CompletableSubject ( ) ; 
if ( observers . get ( ) == TERMINATED ) d . dispose ( ) ; 
ExceptionHelper . nullCheck ( e , "onError called with a null Throwable." ) ; if ( once . compareAndSet ( false , true ) ) this . error = e ; for ( CompletableDisposable md : observers . getAndSet ( TERMINATED ) ) md . downstream . onError ( e ) ; else RxJavaPlugins . onError ( e ) ; 
if ( once . compareAndSet ( false , true ) ) for ( CompletableDisposable md : observers . getAndSet ( TERMINATED ) ) md . downstream . onComplete ( ) ; 
CompletableDisposable md = new CompletableDisposable ( observer , this ) ; observer . onSubscribe ( md ) ; if ( add ( md ) ) if ( md . isDisposed ( ) ) remove ( md ) ; else Throwable ex = error ; if ( ex != null ) observer . onError ( ex ) ; else observer . onComplete ( ) ; 
if ( observers . get ( ) == TERMINATED ) return error ; return null ; 
return observers . get ( ) == TERMINATED && error != null ; 
return observers . get ( ) == TERMINATED && error == null ; 
return observers . get ( ) . length != 0 ; 
return observers . get ( ) . length ; 
CompletableSubject parent = getAndSet ( null ) ; if ( parent != null ) parent . remove ( this ) ; 
return get ( ) == null ; 
bh . consume ( value ) ; countDown ( ) ; 
$EMPTY$
s . request ( Long . MAX_VALUE ) ; 
bh . consume ( t ) ; 
t . printStackTrace ( ) ; countDown ( ) ; 
bh . consume ( true ) ; countDown ( ) ; 
Integer [ ] array = new Integer [ times ] ; flowable = Flowable . fromArray ( array ) . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; observable = Observable . fromArray ( array ) . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; 
flowable . subscribe ( new PerfConsumer ( bh ) ) ; 
observable . subscribe ( new PerfConsumer ( bh ) ) ; 
unbounded = PublishProcessor . create ( ) ; unbounded . subscribe ( new PerfConsumer ( bh ) ) ; bounded = PublishProcessor . create ( ) ; bounded . subscribe ( new PerfBoundedSubscriber ( bh , 1000 * 1000 ) ) ; subject = PublishSubject . create ( ) ; subject . subscribe ( new PerfConsumer ( bh ) ) ; 
unbounded . onNext ( 1 ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) unbounded . onNext ( 1 ) ; 
for ( int i = 0 ; i < 1000000 ; i ++ ) unbounded . onNext ( 1 ) ; 
bounded . onNext ( 1 ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) bounded . onNext ( 1 ) ; 
for ( int i = 0 ; i < 1000000 ; i ++ ) bounded . onNext ( 1 ) ; 
subject . onNext ( 1 ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) subject . onNext ( 1 ) ; 
for ( int i = 0 ; i < 1000000 ; i ++ ) subject . onNext ( 1 ) ; 
range = Flowable . range ( 1 , times ) ; rangeFlatMapJust = range . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; rangeFlatMap = range . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . range ( v , 2 ) ; ) ; rangeObservable = Observable . range ( 1 , times ) ; rangeObservableFlatMapJust = rangeObservable . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; rangeObservableFlatMap = rangeObservable . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . range ( v , 2 ) ; ) ; values = range . toList ( ) . blockingGet ( ) ; 
range . subscribe ( new PerfSubscriber ( bh ) ) ; 
rangeObservable . subscribe ( new PerfObserver ( bh ) ) ; 
rangeFlatMap . subscribe ( new PerfSubscriber ( bh ) ) ; 
rangeObservableFlatMap . subscribe ( new PerfObserver ( bh ) ) ; 
rangeFlatMapJust . subscribe ( new PerfSubscriber ( bh ) ) ; 
rangeObservableFlatMapJust . subscribe ( new PerfObserver ( bh ) ) ; 
int d = 1000000 / count ; Integer [ ] mainArray = new Integer [ count ] ; Integer [ ] innerArray = new Integer [ d ] ; Arrays . fill ( mainArray , 777 ) ; Arrays . fill ( innerArray , 777 ) ; Observable < Integer > outer = Observable . fromArray ( mainArray ) ; final Observable < Integer > inner = Observable . fromArray ( innerArray ) ; source = outer . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer t ) return inner ; ) ; 
source . subscribe ( new PerfObserver ( bh ) ) ; 
Integer [ ] array = new Integer [ items ] ; Arrays . fill ( array , 777 ) ; flatMapCompletable = Flowable . fromArray ( array ) . flatMapCompletable ( Functions . justFunction ( Completable . complete ( ) ) , false , maxConcurrency ) ; flatMap = Flowable . fromArray ( array ) . flatMap ( Functions . justFunction ( Completable . complete ( ) . toFlowable ( ) ) , false , maxConcurrency ) ; 
return flatMap . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flatMapCompletable . subscribeWith ( new PerfConsumer ( bh ) ) ; 
flowable = Flowable . just ( 1 ) ; observable = Observable . just ( 1 ) ; single = Single . just ( 1 ) ; maybe = Maybe . just ( 1 ) ; completable = Completable . complete ( ) ; 
return flowable . blockingFirst ( ) ; 
return flowable . blockingLast ( ) ; 
return observable . blockingLast ( ) ; 
return observable . blockingFirst ( ) ; 
return single . blockingGet ( ) ; 
return maybe . blockingGet ( ) ; 
completable . blockingAwait ( ) ; 
Integer [ ] array = new Integer [ count ] ; Arrays . fill ( array , 777 ) ; source = Flowable . fromArray ( array ) ; 
source . subscribe ( new InternalConsumer ( bh , cpu ) ) ; 
source . subscribe ( new ExternalConsumer ( bh , cpu ) ) ; 
bh . consume ( t ) ; Blackhole . consumeCPU ( cycles ) ; 
bh . consume ( t ) ; 
bh . consume ( true ) ; 
s . request ( Long . MAX_VALUE ) ; 
bh . consume ( t ) ; Blackhole . consumeCPU ( cycles ) ; 
bh . consume ( t ) ; 
bh . consume ( true ) ; 
s . request ( Long . MAX_VALUE ) ; 
$EMPTY$
bh . consume ( value ) ; 
e . printStackTrace ( ) ; cdl . countDown ( ) ; 
cdl . countDown ( ) ; 
bpRange = Flowable . range ( 1 , times ) ; nbpRange = Observable . range ( 1 , times ) ; bpRangeMapJust = bpRange . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; nbpRangeMapJust = nbpRange . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; bpRangeMapRange = bpRange . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . range ( v , 2 ) ; ) ; nbpRangeMapRange = nbpRange . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . range ( v , 2 ) ; ) ; singleJust = Single . just ( 1 ) ; singleJustMapJust = singleJust . flatMap ( new Function < Integer , Single < Integer > > ( ) @ Override public Single < Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; 
bpRange . subscribe ( new PerfSubscriber ( bh ) ) ; 
bpRangeMapJust . subscribe ( new PerfSubscriber ( bh ) ) ; 
bpRangeMapRange . subscribe ( new PerfSubscriber ( bh ) ) ; 
nbpRange . subscribe ( new PerfObserver ( bh ) ) ; 
nbpRangeMapJust . subscribe ( new PerfObserver ( bh ) ) ; 
nbpRangeMapRange . subscribe ( new PerfObserver ( bh ) ) ; 
singleJust . subscribe ( new LatchedSingleObserver < > ( bh ) ) ; 
singleJustMapJust . subscribe ( new LatchedSingleObserver < > ( bh ) ) ; 
return size ; 
Blackhole . consumeCPU ( work ) ; 
Integer [ ] array = new Integer [ items ] ; Arrays . fill ( array , 777 ) ; flatMapCompletable = Flowable . fromArray ( array ) . flatMapCompletable ( Functions . justFunction ( Completable . fromAction ( this ) . subscribeOn ( Schedulers . computation ( ) ) ) , false , maxConcurrency ) ; flatMap = Flowable . fromArray ( array ) . flatMap ( Functions . justFunction ( Completable . fromAction ( this ) . subscribeOn ( Schedulers . computation ( ) ) . toFlowable ( ) ) , false , maxConcurrency ) ; 
return flatMap . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( items ) ; 
return flatMapCompletable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( items ) ; 
Integer [ ] array = new Integer [ times ] ; Arrays . fill ( array , 777 ) ; final Iterable < Integer > singletonList = Collections . singletonList ( 1 ) ; flowable = Flowable . fromArray ( array ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return singletonList ; ) ; observable = Observable . fromArray ( array ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return singletonList ; ) ; 
flowable . subscribe ( new PerfConsumer ( bh ) ) ; 
observable . subscribe ( new PerfConsumer ( bh ) ) ; 
Integer [ ] array = new Integer [ times ] ; Arrays . fill ( array , 777 ) ; flowable = Flowable . fromArray ( array ) ; observable = Observable . fromArray ( array ) ; 
return flowable . blockingFirst ( ) ; 
return flowable . blockingLast ( ) ; 
return observable . blockingLast ( ) ; 
return observable . blockingFirst ( ) ; 
final Integer [ ] array = new Integer [ times ] ; Arrays . fill ( array , 777 ) ; final List < Integer > list = Arrays . asList ( array ) ; final Flowable < Integer > arrayFlowable = Flowable . fromArray ( array ) ; final Flowable < Integer > arrayFlowableHide = Flowable . fromArray ( array ) . hide ( ) ; final Flowable < Integer > listFlowable = Flowable . fromIterable ( list ) ; final Observable < Integer > arrayObservable = Observable . fromArray ( array ) ; final Observable < Integer > arrayObservableHide = Observable . fromArray ( array ) . hide ( ) ; final Observable < Integer > listObservable = Observable . fromIterable ( list ) ; singleFlatMapPublisher = Single . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return arrayFlowable ; ) ; singleFlatMapHidePublisher = Single . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return arrayFlowableHide ; ) ; singleFlattenAsPublisher = Single . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < ? extends Integer > > ( ) @ Override public Iterable < ? extends Integer > apply ( Integer v ) return list ; ) ; maybeFlatMapPublisher = Maybe . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return arrayFlowable ; ) ; maybeFlatMapHidePublisher = Maybe . just ( 1 ) . flatMapPublisher ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return arrayFlowableHide ; ) ; maybeFlattenAsPublisher = Maybe . just ( 1 ) . flattenAsFlowable ( new Function < Integer , Iterable < ? extends Integer > > ( ) @ Override public Iterable < ? extends Integer > apply ( Integer v ) return list ; ) ; completableFlatMapPublisher = Completable . complete ( ) . andThen ( listFlowable ) ; completableFlattenAsPublisher = Completable . complete ( ) . andThen ( arrayFlowable ) ; singleFlatMapObservable = Single . just ( 1 ) . flatMapObservable ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return arrayObservable ; ) ; singleFlatMapHideObservable = Single . just ( 1 ) . flatMapObservable ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return arrayObservableHide ; ) ; singleFlattenAsObservable = Single . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < ? extends Integer > > ( ) @ Override public Iterable < ? extends Integer > apply ( Integer v ) return list ; ) ; maybeFlatMapObservable = Maybe . just ( 1 ) . flatMapObservable ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return arrayObservable ; ) ; maybeFlatMapHideObservable = Maybe . just ( 1 ) . flatMapObservable ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return arrayObservableHide ; ) ; maybeFlattenAsObservable = Maybe . just ( 1 ) . flattenAsObservable ( new Function < Integer , Iterable < ? extends Integer > > ( ) @ Override public Iterable < ? extends Integer > apply ( Integer v ) return list ; ) ; completableFlatMapObservable = Completable . complete ( ) . andThen ( listObservable ) ; completableFlattenAsObservable = Completable . complete ( ) . andThen ( arrayObservable ) ; 
singleFlatMapPublisher . subscribe ( new PerfConsumer ( bh ) ) ; 
singleFlatMapHidePublisher . subscribe ( new PerfConsumer ( bh ) ) ; 
singleFlattenAsPublisher . subscribe ( new PerfConsumer ( bh ) ) ; 
maybeFlatMapPublisher . subscribe ( new PerfConsumer ( bh ) ) ; 
maybeFlatMapHidePublisher . subscribe ( new PerfConsumer ( bh ) ) ; 
maybeFlattenAsPublisher . subscribe ( new PerfConsumer ( bh ) ) ; 
completableFlatMapPublisher . subscribe ( new PerfConsumer ( bh ) ) ; 
completableFlattenAsPublisher . subscribe ( new PerfConsumer ( bh ) ) ; 
singleFlatMapObservable . subscribe ( new PerfConsumer ( bh ) ) ; 
singleFlatMapHideObservable . subscribe ( new PerfConsumer ( bh ) ) ; 
singleFlattenAsObservable . subscribe ( new PerfConsumer ( bh ) ) ; 
maybeFlatMapObservable . subscribe ( new PerfConsumer ( bh ) ) ; 
maybeFlatMapHideObservable . subscribe ( new PerfConsumer ( bh ) ) ; 
maybeFlattenAsObservable . subscribe ( new PerfConsumer ( bh ) ) ; 
completableFlatMapObservable . subscribe ( new PerfConsumer ( bh ) ) ; 
completableFlattenAsObservable . subscribe ( new PerfConsumer ( bh ) ) ; 
range = Flowable . range ( 1 , times ) ; rangeAsync = range . observeOn ( Schedulers . single ( ) ) ; rangeAsyncPipeline = range . subscribeOn ( new SingleScheduler ( ) ) . observeOn ( Schedulers . single ( ) ) ; 
PerfSubscriber lo = new PerfSubscriber ( bh ) ; range . subscribe ( lo ) ; return lo ; 
PerfSubscriber lo = new PerfSubscriber ( bh ) ; rangeAsync . subscribe ( lo ) ; if ( times == 1 ) while ( lo . latch . getCount ( ) != 0 ) else lo . latch . await ( ) ; 
PerfSubscriber lo = new PerfSubscriber ( bh ) ; rangeAsyncPipeline . subscribe ( lo ) ; if ( times == 1 ) while ( lo . latch . getCount ( ) != 0 ) else lo . latch . await ( ) ; 
return t1 + t2 ; 
Integer [ ] array = new Integer [ times ] ; Arrays . fill ( array , 777 ) ; obsSingle = Observable . fromArray ( array ) . reduce ( 0 , this ) ; obsMaybe = Observable . fromArray ( array ) . reduce ( this ) ; flowSingle = Flowable . fromArray ( array ) . reduce ( 0 , this ) ; flowMaybe = Flowable . fromArray ( array ) . reduce ( this ) ; 
obsSingle . subscribe ( new PerfConsumer ( bh ) ) ; 
flowSingle . subscribe ( new PerfConsumer ( bh ) ) ; 
obsMaybe . subscribe ( new PerfConsumer ( bh ) ) ; 
flowMaybe . subscribe ( new PerfConsumer ( bh ) ) ; 
Integer [ ] array = new Integer [ times ] ; Arrays . fill ( array , 777 ) ; final Iterable < Integer > list = Arrays . asList ( 1 , 2 ) ; flowable = Flowable . fromArray ( array ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return list ; ) ; observable = Observable . fromArray ( array ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return list ; ) ; 
flowable . subscribe ( new PerfConsumer ( bh ) ) ; 
observable . subscribe ( new PerfConsumer ( bh ) ) ; 
Scheduler s = Schedulers . single ( ) ; Scheduler s2 = new SingleScheduler ( ) ; Callable < Integer > c = new Callable < Integer > ( ) @ Override public Integer call ( ) return 1 ; ; subscribeOnFlowable = Flowable . fromCallable ( c ) . subscribeOn ( s ) ; observeOnFlowable = Flowable . fromCallable ( c ) . observeOn ( s ) ; pipelineFlowable = Flowable . fromCallable ( c ) . subscribeOn ( s ) . observeOn ( s2 ) ; subscribeOnObservable = Observable . fromCallable ( c ) . subscribeOn ( s ) ; observeOnObservable = Observable . fromCallable ( c ) . observeOn ( s ) ; pipelineObservable = Observable . fromCallable ( c ) . subscribeOn ( s ) . observeOn ( s2 ) ; observeOnSingle = Single . fromCallable ( c ) . observeOn ( s ) ; subscribeOnSingle = Single . fromCallable ( c ) . subscribeOn ( s ) ; pipelineSingle = Single . fromCallable ( c ) . subscribeOn ( s ) . observeOn ( s2 ) ; observeOnCompletable = Completable . fromCallable ( c ) . observeOn ( s ) ; subscribeOnCompletable = Completable . fromCallable ( c ) . subscribeOn ( s ) ; pipelineCompletable = Completable . fromCallable ( c ) . subscribeOn ( s ) . observeOn ( s2 ) ; observeOnMaybe = Maybe . fromCallable ( c ) . observeOn ( s ) ; subscribeOnMaybe = Maybe . fromCallable ( c ) . subscribeOn ( s ) ; pipelineMaybe = Maybe . fromCallable ( c ) . subscribeOn ( s ) . observeOn ( s2 ) ; 
subscribeOnFlowable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnFlowable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineFlowable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
subscribeOnObservable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnObservable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineObservable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnSingle . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
subscribeOnSingle . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineSingle . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnCompletable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
subscribeOnCompletable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineCompletable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnMaybe . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
subscribeOnMaybe . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineMaybe . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
bh . consume ( value ) ; 
$EMPTY$
s . request ( Long . MAX_VALUE ) ; 
bh . consume ( t ) ; 
t . printStackTrace ( ) ; 
bh . consume ( true ) ; 
$EMPTY$
e . printStackTrace ( ) ; cdl . countDown ( ) ; 
$EMPTY$
$EMPTY$
bh . consume ( t ) ; 
return i < size ; 
Blackhole . consumeCPU ( 10 ) ; return i ++ ; 
$EMPTY$
return new IncrementingIterator ( ) ; 
s . onSubscribe ( EmptySubscription . INSTANCE ) ; for ( int i = 0 ; i < size ; i ++ ) s . onNext ( i ) ; s . onComplete ( ) ; 
this . bh = bh ; final int size = getSize ( ) ; flowable = Flowable . range ( 0 , size ) ; firehose = Flowable . unsafeCreate ( new IncrementingPublisher ( size ) ) ; iterable = new IncrementingIterable ( size ) ; 
return new PerfSubscriber ( bh ) ; 
return new DefaultSubscriberImpl ( ) ; 
Integer [ ] array = new Integer [ times ] ; Arrays . fill ( array , 777 ) ; Integer [ ] arrayInner = new Integer [ 1000000 / times ] ; Arrays . fill ( arrayInner , 888 ) ; final Iterable < Integer > list = Arrays . asList ( arrayInner ) ; flowable = Flowable . fromArray ( array ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return list ; ) ; observable = Observable . fromArray ( array ) . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return list ; ) ; 
flowable . subscribe ( new PerfConsumer ( bh ) ) ; 
observable . subscribe ( new PerfConsumer ( bh ) ) ; 
s . request ( Long . MAX_VALUE ) ; 
latch . countDown ( ) ; 
latch . countDown ( ) ; 
bh . consume ( t ) ; 
items ++ ; 
flowable = Flowable . range ( 1 , 1000 * 1000 ) . takeUntil ( Flowable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) int c = count ; while ( items < c ) return 1 ; ) . subscribeOn ( Schedulers . single ( ) ) ) ; observable = Observable . range ( 1 , 1000 * 1000 ) . takeUntil ( Observable . fromCallable ( new Callable < Object > ( ) @ Override public Object call ( ) int c = count ; while ( items < c ) return 1 ; ) . subscribeOn ( Schedulers . single ( ) ) ) ; 
final CountDownLatch cdl = new CountDownLatch ( 1 ) ; flowable . subscribe ( this , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) cdl . countDown ( ) ; ) ; while ( cdl . getCount ( ) != 0 ) 
final CountDownLatch cdl = new CountDownLatch ( 1 ) ; observable . subscribe ( this , Functions . emptyConsumer ( ) , new Action ( ) @ Override public void run ( ) cdl . countDown ( ) ; ) ; while ( cdl . getCount ( ) != 0 ) 
bh . consume ( value ) ; 
$EMPTY$
s . request ( Long . MAX_VALUE ) ; 
bh . consume ( t ) ; 
t . printStackTrace ( ) ; 
bh . consume ( true ) ; 
s . request ( request ) ; 
countDown ( ) ; 
countDown ( ) ; 
bh . consume ( t ) ; 
Integer [ ] array = new Integer [ times ] ; Arrays . fill ( array , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( array ) ; final BiFunction < Integer , Integer , Integer > second = new BiFunction < Integer , Integer , Integer > ( ) @ Override public Integer apply ( Integer a , Integer b ) return b ; ; flowable = source . reduce ( second ) ; flowableInner = source . concatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . range ( 1 , 50 ) . reduce ( second ) . toFlowable ( ) ; ) ; Observable < Integer > sourceObs = Observable . fromArray ( array ) ; observable = sourceObs . reduce ( second ) . toObservable ( ) ; observableInner = sourceObs . concatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . range ( 1 , 50 ) . reduce ( second ) . toObservable ( ) ; ) ; 
return flowable . blockingGet ( ) ; 
return flowableInner . blockingLast ( ) ; 
return observable . blockingLast ( ) ; 
return observableInner . blockingLast ( ) ; 
this . bh = bh ; observables = new ArrayList < > ( ) ; for ( int i = 0 ; i < size ; i ++ ) observables . add ( Flowable . just ( i ) ) ; 
return new PerfSubscriber ( bh ) ; 
return size ; 
return size ; 
Integer [ ] values = new Integer [ times ] ; Arrays . fill ( values , 777 ) ; Flowable < Integer > fsource = Flowable . fromArray ( values ) ; flowFlatMapFlowable1 = fsource . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; flowFlatMapFlowable0 = fsource . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . empty ( ) ; ) ; flowFlatMapSingle1 = fsource . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; flowFlatMapMaybe1 = fsource . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; flowFlatMapMaybe0 = fsource . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; flowFlatMapCompletable0 = fsource . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) return Completable . complete ( ) ; ) ; flowFlatMapIterable1 = fsource . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Collections . singletonList ( v ) ; ) ; flowFlatMapIterable0 = fsource . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Collections . emptyList ( ) ; ) ; flowFlatMapSingle1 = fsource . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; flowFlatMapMaybe1 = fsource . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; flowFlatMapMaybe0 = fsource . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; flowFlatMapCompletable0 = fsource . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) return Completable . complete ( ) ; ) ; flowFlatMapSingleAsFlow1 = fsource . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Single . just ( v ) . toFlowable ( ) ; ) ; flowFlatMapMaybeAsFlow1 = fsource . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Maybe . just ( v ) . toFlowable ( ) ; ) ; flowFlatMapMaybeAsFlow0 = fsource . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Maybe . < Integer > empty ( ) . toFlowable ( ) ; ) ; flowFlatMapCompletableAsFlow0 = fsource . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Completable . complete ( ) . toFlowable ( ) ; ) ; flowFlatMapIterableAsFlow1 = fsource . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . fromIterable ( Collections . singletonList ( v ) ) ; ) ; flowFlatMapIterableAsFlow0 = fsource . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . fromIterable ( Collections . emptyList ( ) ) ; ) ; Observable < Integer > osource = Observable . fromArray ( values ) ; obsFlatMapObservable1 = osource . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; obsFlatMapObservable0 = osource . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . empty ( ) ; ) ; obsFlatMapSingle1 = osource . flatMapSingle ( new Function < Integer , SingleSource < Integer > > ( ) @ Override public SingleSource < Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; obsFlatMapMaybe1 = osource . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; obsFlatMapMaybe0 = osource . flatMapMaybe ( new Function < Integer , MaybeSource < Integer > > ( ) @ Override public MaybeSource < Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; obsFlatMapCompletable0 = osource . flatMapCompletable ( new Function < Integer , CompletableSource > ( ) @ Override public CompletableSource apply ( Integer v ) return Completable . complete ( ) ; ) ; obsFlatMapIterable1 = osource . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Collections . singletonList ( v ) ; ) ; obsFlatMapIterable0 = osource . flatMapIterable ( new Function < Integer , Iterable < Integer > > ( ) @ Override public Iterable < Integer > apply ( Integer v ) return Collections . emptyList ( ) ; ) ; obsFlatMapSingleAsObs1 = osource . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Single . just ( v ) . toObservable ( ) ; ) ; obsFlatMapMaybeAsObs1 = osource . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Maybe . just ( v ) . toObservable ( ) ; ) ; obsFlatMapMaybeAsObs0 = osource . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Maybe . < Integer > empty ( ) . toObservable ( ) ; ) ; obsFlatMapCompletableAsObs0 = osource . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Completable . complete ( ) . toObservable ( ) ; ) ; obsFlatMapIterableAsObs1 = osource . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . fromIterable ( Collections . singletonList ( v ) ) ; ) ; obsFlatMapIterableAsObs0 = osource . flatMap ( new Function < Integer , Observable < Integer > > ( ) @ Override public Observable < Integer > apply ( Integer v ) return Observable . fromIterable ( Collections . emptyList ( ) ) ; ) ; 
flowFlatMapIterable1 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapIterable0 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapFlowable0 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapFlowable1 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapSingle1 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapMaybe1 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapMaybe0 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapCompletable0 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapIterableAsFlow1 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapIterableAsFlow0 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapSingleAsFlow1 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapMaybeAsFlow1 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapMaybeAsFlow0 . subscribe ( new PerfConsumer ( bh ) ) ; 
flowFlatMapCompletableAsFlow0 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapIterable0 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapIterable1 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapObservable0 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapObservable1 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapSingle1 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapMaybe1 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapMaybe0 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapCompletable0 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapIterableAsObs1 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapIterableAsObs0 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapSingleAsObs1 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapMaybeAsObs1 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapMaybeAsObs0 . subscribe ( new PerfConsumer ( bh ) ) ; 
obsFlatMapCompletableAsObs0 . subscribe ( new PerfConsumer ( bh ) ) ; 
return ManagementFactory . getMemoryMXBean ( ) . getHeapMemoryUsage ( ) . getUsed ( ) ; 
this . upstream = s ; 
$EMPTY$
$EMPTY$
$EMPTY$
this . upstream = d ; 
$EMPTY$
$EMPTY$
$EMPTY$
$EMPTY$
checkMemory ( item , name , typeLib , 1000000 ) ; 
Scheduler s = Schedulers . single ( ) ; Scheduler s2 = new SingleScheduler ( ) ; subscribeOnFlowable = Flowable . just ( 1 ) . subscribeOn ( s ) ; observeOnFlowable = Flowable . just ( 1 ) . observeOn ( s ) ; pipelineFlowable = Flowable . just ( 1 ) . subscribeOn ( s ) . observeOn ( s2 ) ; subscribeOnObservable = Observable . just ( 1 ) . subscribeOn ( s ) ; observeOnObservable = Observable . just ( 1 ) . observeOn ( s ) ; pipelineObservable = Observable . just ( 1 ) . subscribeOn ( s ) . observeOn ( s2 ) ; observeOnSingle = Single . just ( 1 ) . observeOn ( s ) ; subscribeOnSingle = Single . just ( 1 ) . subscribeOn ( s ) ; pipelineSingle = Single . just ( 1 ) . subscribeOn ( s ) . observeOn ( s2 ) ; observeOnCompletable = Completable . complete ( ) . observeOn ( s ) ; subscribeOnCompletable = Completable . complete ( ) . subscribeOn ( s ) ; pipelineCompletable = Completable . complete ( ) . subscribeOn ( s ) . observeOn ( s2 ) ; observeOnMaybe = Maybe . just ( 1 ) . observeOn ( s ) ; subscribeOnMaybe = Maybe . just ( 1 ) . subscribeOn ( s ) ; pipelineMaybe = Maybe . just ( 1 ) . subscribeOn ( s ) . observeOn ( s2 ) ; 
subscribeOnFlowable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnFlowable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineFlowable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
subscribeOnObservable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnObservable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineObservable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnSingle . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
subscribeOnSingle . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineSingle . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnCompletable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
subscribeOnCompletable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineCompletable . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
observeOnMaybe . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
subscribeOnMaybe . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
pipelineMaybe . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; 
Blackhole . consumeCPU ( compute ) ; return t ; 
final int cpu = parallelism ; Integer [ ] ints = new Integer [ count ] ; Arrays . fill ( ints , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( ints ) ; flatMap = source . flatMap ( new Function < Integer , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( Integer v ) return Flowable . just ( v ) . subscribeOn ( Schedulers . computation ( ) ) . map ( ParallelPerf . this ) ; , cpu ) ; groupBy = source . groupBy ( new Function < Integer , Integer > ( ) int i ; @ Override public Integer apply ( Integer v ) return ( i ++ ) % cpu ; ) . flatMap ( new Function < GroupedFlowable < Integer , Integer > , Publisher < Integer > > ( ) @ Override public Publisher < Integer > apply ( GroupedFlowable < Integer , Integer > g ) return g . observeOn ( Schedulers . computation ( ) ) . map ( ParallelPerf . this ) ; ) ; parallel = source . parallel ( cpu ) . runOn ( Schedulers . computation ( ) ) . map ( this ) . sequential ( ) ; 
PerfAsyncConsumer consumer = new PerfAsyncConsumer ( bh ) ; f . subscribe ( consumer ) ; consumer . await ( count ) ; 
subscribe ( flatMap , bh ) ; 
subscribe ( groupBy , bh ) ; 
subscribe ( parallel , bh ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . concatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . empty ( ) ; ) ; concatMapToObservableEmpty = source . concatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Maybe . < Integer > empty ( ) . toObservable ( ) ; ) ; observableDedicated = source . concatMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return concatMapToObservableEmpty . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . concatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . empty ( ) ; ) ; observableConvert = source . concatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Completable . complete ( ) . toObservable ( ) ; ) ; observableDedicated = source . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return Completable . complete ( ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . flatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . empty ( ) ; ) ; observableConvert = source . flatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Maybe . < Integer > empty ( ) . toObservable ( ) ; ) ; observableDedicated = source . flatMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . empty ( ) ; ) ; concatMapToFlowableEmpty = source . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Maybe . < Integer > empty ( ) . toFlowable ( ) ; ) ; flowableDedicated = source . concatMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return concatMapToFlowableEmpty . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . flatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; observableConvert = source . flatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Single . just ( v ) . toObservable ( ) ; ) ; observableDedicated = source . flatMapSingle ( new Function < Integer , Single < ? extends Integer > > ( ) @ Override public Single < ? extends Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . switchMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . empty ( ) ; ) ; observableConvert = source . switchMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Maybe . < Integer > empty ( ) . toObservable ( ) ; ) ; observableDedicated = source . switchMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . flatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; observableConvert = source . flatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) . toObservable ( ) ; ) ; observableDedicated = source . flatMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; flowableConvert = source . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Single . just ( v ) . toFlowable ( ) ; ) ; flowableDedicated = source . concatMapSingle ( new Function < Integer , Single < ? extends Integer > > ( ) @ Override public Single < ? extends Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . flatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . empty ( ) ; ) ; flowableConvert = source . flatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Completable . complete ( ) . toFlowable ( ) ; ) ; flowableDedicated = source . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return Completable . complete ( ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . empty ( ) ; ) ; flowableConvert = source . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Completable . complete ( ) . toFlowable ( ) ; ) ; flowableDedicated = source . concatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return Completable . complete ( ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . flatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; flowableConvert = source . flatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Single . just ( v ) . toFlowable ( ) ; ) ; flowableDedicated = source . flatMapSingle ( new Function < Integer , Single < ? extends Integer > > ( ) @ Override public Single < ? extends Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . switchMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; observableConvert = source . switchMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Single . just ( v ) . toObservable ( ) ; ) ; observableDedicated = source . switchMapSingle ( new Function < Integer , Single < ? extends Integer > > ( ) @ Override public Single < ? extends Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . switchMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; flowableConvert = source . switchMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) . toFlowable ( ) ; ) ; flowableDedicated = source . switchMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; flowableConvert = source . concatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) . toFlowable ( ) ; ) ; flowableDedicated = source . concatMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . switchMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; observableConvert = source . switchMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) . toObservable ( ) ; ) ; observableDedicated = source . switchMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . switchMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; flowableConvert = source . switchMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Single . just ( v ) . toFlowable ( ) ; ) ; flowableDedicated = source . switchMapSingle ( new Function < Integer , Single < ? extends Integer > > ( ) @ Override public Single < ? extends Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . concatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; observableConvert = source . concatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) . toObservable ( ) ; ) ; observableDedicated = source . concatMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . switchMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . empty ( ) ; ) ; flowableConvert = source . switchMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Maybe . < Integer > empty ( ) . toFlowable ( ) ; ) ; flowableDedicated = source . switchMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . flatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . empty ( ) ; ) ; flowableConvert = source . flatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Maybe . < Integer > empty ( ) . toFlowable ( ) ; ) ; flowableDedicated = source . flatMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . empty ( ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . flatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . empty ( ) ; ) ; observableConvert = source . flatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Completable . complete ( ) . toObservable ( ) ; ) ; observableDedicated = source . flatMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return Completable . complete ( ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . switchMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . empty ( ) ; ) ; observableConvert = source . switchMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Completable . complete ( ) . toObservable ( ) ; ) ; observableDedicated = source . switchMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return Completable . complete ( ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Observable < Integer > source = Observable . fromArray ( sourceArray ) ; observablePlain = source . concatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Observable . just ( v ) ; ) ; observableConvert = source . concatMap ( new Function < Integer , Observable < ? extends Integer > > ( ) @ Override public Observable < ? extends Integer > apply ( Integer v ) return Single . just ( v ) . toObservable ( ) ; ) ; observableDedicated = source . concatMapSingle ( new Function < Integer , Single < ? extends Integer > > ( ) @ Override public Single < ? extends Integer > apply ( Integer v ) return Single . just ( v ) ; ) ; 
return observablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return observableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . flatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . just ( v ) ; ) ; flowableConvert = source . flatMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) . toFlowable ( ) ; ) ; flowableDedicated = source . flatMapMaybe ( new Function < Integer , Maybe < ? extends Integer > > ( ) @ Override public Maybe < ? extends Integer > apply ( Integer v ) return Maybe . just ( v ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
Integer [ ] sourceArray = new Integer [ count ] ; Arrays . fill ( sourceArray , 777 ) ; Flowable < Integer > source = Flowable . fromArray ( sourceArray ) ; flowablePlain = source . switchMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Flowable . empty ( ) ; ) ; flowableConvert = source . switchMap ( new Function < Integer , Publisher < ? extends Integer > > ( ) @ Override public Publisher < ? extends Integer > apply ( Integer v ) return Completable . complete ( ) . toFlowable ( ) ; ) ; flowableDedicated = source . switchMapCompletable ( new Function < Integer , Completable > ( ) @ Override public Completable apply ( Integer v ) return Completable . complete ( ) ; ) ; 
return flowablePlain . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableConvert . subscribeWith ( new PerfConsumer ( bh ) ) ; 
return flowableDedicated . subscribeWith ( new PerfConsumer ( bh ) ) ; 
